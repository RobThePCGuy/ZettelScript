/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository of this plugin.
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZettelScriptPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  cliPath: "npx zettelscript",
  useWsl: false,
  autoSync: false,
  syncInterval: 0,
  kbPath: ".narrative-project/kb",
  showNotifications: true
};
var ZettelScriptSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ZettelScript Settings" });
    new import_obsidian.Setting(containerEl).setName("CLI Path").setDesc('Path to ZettelScript CLI. Use "npx zettelscript" to run via npx.').addText(
      (text) => text.setPlaceholder("npx zettelscript").setValue(this.plugin.settings.cliPath).onChange(async (value) => {
        this.plugin.settings.cliPath = value;
        await this.plugin.saveSettings();
      })
    );
    if (import_obsidian.Platform.isWin) {
      new import_obsidian.Setting(containerEl).setName("Use WSL").setDesc("Run CLI commands through Windows Subsystem for Linux. Enable if Node.js is installed in WSL, not Windows.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.useWsl).onChange(async (value) => {
          this.plugin.settings.useWsl = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian.Setting(containerEl).setName("Knowledge Base Path").setDesc("Relative path to KB directory from vault root.").addText(
      (text) => text.setPlaceholder(".narrative-project/kb").setValue(this.plugin.settings.kbPath).onChange(async (value) => {
        this.plugin.settings.kbPath = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Auto-Sync" });
    new import_obsidian.Setting(containerEl).setName("Auto-sync on file change").setDesc("Automatically run index when files are modified.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
        this.plugin.settings.autoSync = value;
        await this.plugin.saveSettings();
        this.plugin.setupAutoSync();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync interval (minutes)").setDesc("Periodically run index. Set to 0 to disable.").addSlider(
      (slider) => slider.setLimits(0, 60, 5).setValue(this.plugin.settings.syncInterval).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.syncInterval = value;
        await this.plugin.saveSettings();
        this.plugin.setupSyncInterval();
      })
    );
    containerEl.createEl("h3", { text: "Notifications" });
    new import_obsidian.Setting(containerEl).setName("Show notifications").setDesc("Display notifications when commands complete.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showNotifications).onChange(async (value) => {
        this.plugin.settings.showNotifications = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// view.ts
var import_obsidian2 = require("obsidian");
var VIEW_TYPE_SUGGESTIONS = "zettelscript-suggestions";
var SuggestionsView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.focusBundle = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_SUGGESTIONS;
  }
  getDisplayText() {
    return "ZettelScript Suggestions";
  }
  getIcon() {
    return "links";
  }
  async onOpen() {
    this.renderEmptyState("Open a note to see suggestions");
  }
  async onClose() {
  }
  setFocusBundle(bundle) {
    this.focusBundle = bundle;
    this.render();
  }
  render() {
    const container = this.containerEl.children[1];
    container.empty();
    if (!this.focusBundle) {
      this.renderEmptyState("No focus data available");
      return;
    }
    const { suggestions, health, meta } = this.focusBundle;
    const header = container.createEl("div", { cls: "zs-header" });
    header.createEl("h4", { text: meta.scope.focusNodeTitle });
    const healthBadge = header.createEl("span", {
      cls: `zs-health-badge zs-health-${health.level}`,
      text: health.level.toUpperCase()
    });
    this.renderSection(
      container,
      "Related Notes",
      suggestions.relatedNotes,
      suggestions.relatedNotes.length,
      (note) => this.renderRelatedNote(note),
      this.getRelatedEmptyState(health)
    );
    this.renderSection(
      container,
      "Suggested Links",
      suggestions.candidateLinks,
      suggestions.candidateLinks.length,
      (link) => this.renderCandidateLink(link),
      "No link suggestions for this view."
    );
    this.renderSection(
      container,
      "Orphans",
      suggestions.orphans,
      suggestions.orphans.length,
      (orphan) => this.renderOrphan(orphan),
      "No orphans detected. Your notes are well-connected!"
    );
  }
  renderSection(container, title, items, count, renderItem, emptyMessage) {
    const section = container.createEl("div", { cls: "zs-section" });
    const sectionHeader = section.createEl("div", { cls: "zs-section-header" });
    sectionHeader.createEl("h5", { text: `${title} (${count})` });
    if (items.length === 0) {
      section.createEl("div", { cls: "zs-empty-state", text: emptyMessage });
      return;
    }
    const list = section.createEl("div", { cls: "zs-list" });
    for (const item of items) {
      const el = renderItem.call(this, item);
      list.appendChild(el);
    }
  }
  renderRelatedNote(note) {
    const row = createEl("div", { cls: "zs-row zs-related-row" });
    const info = row.createEl("div", { cls: "zs-row-info" });
    const titleEl = info.createEl("span", { cls: "zs-row-title", text: note.title });
    if (note.path) {
      titleEl.onclick = () => this.openFile(note.path);
      titleEl.addClass("zs-clickable");
    }
    const score = row.createEl("span", {
      cls: "zs-score",
      text: `${Math.round(note.score * 100)}%`
    });
    if (note.reasons.length > 0) {
      row.setAttribute("aria-label", note.reasons.join("\n"));
      row.addClass("has-tooltip");
    }
    return row;
  }
  renderCandidateLink(link) {
    const row = createEl("div", { cls: "zs-row zs-candidate-row" });
    const info = row.createEl("div", { cls: "zs-row-info" });
    const linkText = info.createEl("span", { cls: "zs-link-text" });
    linkText.createEl("span", { text: link.fromTitle, cls: "zs-from-title" });
    linkText.createEl("span", { text: " \u2192 ", cls: "zs-arrow" });
    const toSpan = linkText.createEl("span", { text: link.toTitle, cls: "zs-to-title" });
    if (link.isGhostTarget) {
      toSpan.addClass("zs-ghost");
      toSpan.setAttribute("aria-label", "Ghost node (file does not exist)");
    }
    if (link.reasons.length > 0) {
      row.setAttribute("aria-label", link.reasons.join("\n"));
    }
    const actions = row.createEl("div", { cls: "zs-actions" });
    const approveBtn = actions.createEl("button", { cls: "zs-btn zs-btn-approve" });
    (0, import_obsidian2.setIcon)(approveBtn, "check");
    approveBtn.setAttribute("aria-label", "Approve link");
    approveBtn.onclick = (e) => {
      e.stopPropagation();
      this.plugin.handleApprove(link.suggestionId);
    };
    const rejectBtn = actions.createEl("button", { cls: "zs-btn zs-btn-reject" });
    (0, import_obsidian2.setIcon)(rejectBtn, "x");
    rejectBtn.setAttribute("aria-label", "Reject link");
    rejectBtn.onclick = (e) => {
      e.stopPropagation();
      this.plugin.handleReject(link.suggestionId);
    };
    return row;
  }
  renderOrphan(orphan) {
    const row = createEl("div", { cls: "zs-row zs-orphan-row" });
    const warningIcon = row.createEl("span", { cls: "zs-warning-icon" });
    (0, import_obsidian2.setIcon)(warningIcon, "alert-triangle");
    const info = row.createEl("div", { cls: "zs-row-info" });
    const titleEl = info.createEl("span", { cls: "zs-row-title", text: orphan.title });
    if (orphan.path) {
      titleEl.onclick = () => this.openFile(orphan.path);
      titleEl.addClass("zs-clickable");
    }
    const score = row.createEl("span", {
      cls: "zs-orphan-score",
      text: `${Math.round(orphan.orphanScore * 100)}%`
    });
    if (orphan.reasons.length > 0) {
      row.setAttribute("aria-label", orphan.reasons.join("\n"));
    }
    return row;
  }
  renderEmptyState(message) {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("div", { cls: "zs-empty-state zs-centered", text: message });
  }
  getRelatedEmptyState(health) {
    if (health.embeddings.level === "fail") {
      return "Embeddings incomplete. Run: zs embed compute";
    }
    if (health.embeddings.coverageInView < 50) {
      return `Embeddings ${health.embeddings.coverageInView}% complete. Run: zs embed compute`;
    }
    return "No related notes found for this view.";
  }
  async openFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file) {
      await this.app.workspace.openLinkText(path, "", false);
    }
  }
};

// main.ts
var execFileAsync = (0, import_util.promisify)(import_child_process.execFile);
var ZettelScriptPlugin = class extends import_obsidian3.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = DEFAULT_SETTINGS;
    this.syncIntervalId = null;
    this.fileWatcherDebounce = null;
    this.focusDebounce = null;
    this.requestId = 0;
    // For stale refresh handling
    this.suggestionsView = null;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_SUGGESTIONS,
      (leaf) => {
        this.suggestionsView = new SuggestionsView(leaf, this);
        return this.suggestionsView;
      }
    );
    this.addSettingTab(new ZettelScriptSettingTab(this.app, this));
    this.registerCommands();
    this.setupAutoSync();
    this.setupSyncInterval();
    this.setupActiveFileListener();
    this.addRibbonIcon("links", "Open ZettelScript Suggestions", () => {
      this.activateSuggestionsView();
    });
    this.addCommand({
      id: "zettelscript-open-suggestions",
      name: "Open suggestions panel",
      callback: () => this.activateSuggestionsView()
    });
    this.addStatusBarItem().setText("ZS: Ready");
  }
  onunload() {
    if (this.syncIntervalId) {
      clearInterval(this.syncIntervalId);
    }
    if (this.fileWatcherDebounce) {
      clearTimeout(this.fileWatcherDebounce);
    }
    if (this.focusDebounce) {
      clearTimeout(this.focusDebounce);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateSuggestionsView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_SUGGESTIONS);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_SUGGESTIONS, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      this.refreshFocusBundle(activeFile.path);
    }
  }
  setupActiveFileListener() {
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (!leaf)
          return;
        const view = leaf.view;
        if (view.getViewType() === "markdown") {
          const file = this.app.workspace.getActiveFile();
          if (file) {
            if (this.focusDebounce) {
              clearTimeout(this.focusDebounce);
            }
            this.focusDebounce = setTimeout(() => {
              this.refreshFocusBundle(file.path);
            }, 500);
          }
        }
      })
    );
  }
  async refreshFocusBundle(filePath) {
    const localId = ++this.requestId;
    const vaultPath = this.getVaultPath();
    if (!vaultPath)
      return;
    try {
      const result = await this.execZs(["focus", filePath, "--json-stdout"]);
      if (localId === this.requestId) {
        const bundle = JSON.parse(result);
        if (this.suggestionsView) {
          this.suggestionsView.setFocusBundle(bundle);
        }
      }
    } catch (error) {
      if (localId === this.requestId) {
        console.error("ZettelScript focus error:", error);
        if (this.suggestionsView) {
          this.suggestionsView.setFocusBundle(null);
        }
      }
    }
  }
  // Direct approve execution per design Section 8.2
  async handleApprove(suggestionId) {
    if (import_obsidian3.Platform.isMobile) {
      const command = `zs approve --suggestion-id ${suggestionId}`;
      await navigator.clipboard.writeText(command);
      new import_obsidian3.Notice("Command copied to clipboard");
      return;
    }
    try {
      const result = await this.execZs(["approve", "--suggestion-id", suggestionId, "--json"]);
      const response = JSON.parse(result);
      if (response.success) {
        new import_obsidian3.Notice(`Linked to ${response.toTitle}`);
        if (response.writeback === "failed") {
          new import_obsidian3.Notice(`Writeback warning: ${response.writebackReason}`, 5e3);
        }
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          this.refreshFocusBundle(activeFile.path);
        }
      } else {
        new import_obsidian3.Notice(`Approve failed: ${response.error}`);
      }
    } catch (error) {
      const err = error;
      new import_obsidian3.Notice(`Error: ${err.message}`);
    }
  }
  // Direct reject execution per design Section 8.2
  async handleReject(suggestionId) {
    if (import_obsidian3.Platform.isMobile) {
      const command = `zs reject --suggestion-id ${suggestionId}`;
      await navigator.clipboard.writeText(command);
      new import_obsidian3.Notice("Command copied to clipboard");
      return;
    }
    try {
      const result = await this.execZs(["reject", "--suggestion-id", suggestionId, "--json"]);
      const response = JSON.parse(result);
      if (response.success) {
        new import_obsidian3.Notice(`Rejected suggestion for ${response.toTitle}`);
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          this.refreshFocusBundle(activeFile.path);
        }
      } else {
        new import_obsidian3.Notice(`Reject failed: ${response.error}`);
      }
    } catch (error) {
      const err = error;
      new import_obsidian3.Notice(`Error: ${err.message}`);
    }
  }
  buildCommand(args) {
    const cliParts = this.settings.cliPath.split(" ");
    if (this.settings.useWsl) {
      const fullCmd = [...cliParts, ...args].join(" ");
      return { command: "wsl", args: ["zsh", "-lic", fullCmd] };
    }
    return { command: cliParts[0], args: [...cliParts.slice(1), ...args] };
  }
  async execZs(args) {
    const vaultPath = this.getVaultPath();
    if (!vaultPath) {
      throw new Error("Could not determine vault path");
    }
    const { command, args: cmdArgs } = this.buildCommand(args);
    const { stdout } = await execFileAsync(command, cmdArgs, {
      cwd: vaultPath,
      timeout: 12e4,
      shell: true
    });
    return stdout;
  }
  registerCommands() {
    this.addCommand({
      id: "zettelscript-index",
      name: "Index vault",
      callback: () => this.runCommand("index")
    });
    this.addCommand({
      id: "zettelscript-discover",
      name: "Run discovery",
      callback: () => this.runCommand("discover")
    });
    this.addCommand({
      id: "zettelscript-focus",
      name: "Focus on current file",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          this.refreshFocusBundle(file.path);
          this.activateSuggestionsView();
        } else {
          new import_obsidian3.Notice("No active file");
        }
      }
    });
    this.addCommand({
      id: "zettelscript-generate-all",
      name: "Generate all notes",
      callback: () => this.runCommand("generate all")
    });
    this.addCommand({
      id: "zettelscript-generate-characters",
      name: "Generate character notes",
      callback: () => this.runCommand("generate characters")
    });
    this.addCommand({
      id: "zettelscript-generate-chapters",
      name: "Generate chapter notes",
      callback: async () => {
        const manuscriptPath = await this.promptForPath("Enter manuscript path:");
        if (manuscriptPath) {
          this.runCommand(`generate chapters -m "${manuscriptPath}"`);
        }
      }
    });
    this.addCommand({
      id: "zettelscript-generate-locations",
      name: "Generate location notes",
      callback: () => this.runCommand("generate locations")
    });
    this.addCommand({
      id: "zettelscript-generate-objects",
      name: "Generate object notes",
      callback: () => this.runCommand("generate objects")
    });
    this.addCommand({
      id: "zettelscript-generate-lore",
      name: "Generate lore notes",
      callback: () => this.runCommand("generate lore")
    });
    this.addCommand({
      id: "zettelscript-generate-timeline",
      name: "Generate timeline notes",
      callback: () => this.runCommand("generate timeline")
    });
    this.addCommand({
      id: "zettelscript-generate-arcs",
      name: "Generate arc notes",
      callback: () => this.runCommand("generate arcs")
    });
    this.addCommand({
      id: "zettelscript-inject-links",
      name: "Inject wikilinks",
      callback: () => this.runCommand("inject-links")
    });
    this.addCommand({
      id: "zettelscript-inject-links-preview",
      name: "Preview link injection",
      callback: () => this.runCommand("inject-links --preview")
    });
    this.addCommand({
      id: "zettelscript-validate",
      name: "Validate vault",
      callback: () => this.runCommand("validate")
    });
    this.addCommand({
      id: "zettelscript-embed-compute",
      name: "Compute embeddings",
      callback: () => this.runCommand("embed compute")
    });
  }
  setupAutoSync() {
    if (this.settings.autoSync) {
      this.registerEvent(
        this.app.vault.on("modify", () => {
          if (this.fileWatcherDebounce) {
            clearTimeout(this.fileWatcherDebounce);
          }
          this.fileWatcherDebounce = setTimeout(() => {
            this.runCommand("index", true);
          }, 5e3);
        })
      );
    }
  }
  setupSyncInterval() {
    if (this.syncIntervalId) {
      clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
    if (this.settings.syncInterval > 0) {
      const ms = this.settings.syncInterval * 60 * 1e3;
      this.syncIntervalId = setInterval(() => {
        this.runCommand("index", true);
      }, ms);
    }
  }
  async runCommand(command, silent = false) {
    const vaultPath = this.getVaultPath();
    if (!vaultPath) {
      if (!silent) {
        new import_obsidian3.Notice("Could not determine vault path");
      }
      return;
    }
    const statusBar = this.addStatusBarItem();
    statusBar.setText("ZS: Running...");
    try {
      const { command: cmd, args: cmdArgs } = this.buildCommand(command.split(" "));
      const { stdout, stderr } = await execFileAsync(cmd, cmdArgs, {
        cwd: vaultPath,
        timeout: 12e4,
        shell: true
      });
      statusBar.setText("ZS: Ready");
      if (this.settings.showNotifications && !silent) {
        if (stdout) {
          new import_obsidian3.Notice(`ZettelScript: ${command} completed
${this.truncate(stdout, 200)}`);
        }
      }
      if (stderr && !silent) {
        console.warn("ZettelScript stderr:", stderr);
      }
    } catch (error) {
      statusBar.setText("ZS: Error");
      if (!silent) {
        const err = error;
        new import_obsidian3.Notice(`ZettelScript error: ${err.message}`);
        console.error("ZettelScript error:", error);
      }
    }
  }
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    if ("basePath" in adapter) {
      return adapter.basePath;
    }
    return null;
  }
  truncate(str, maxLen) {
    if (str.length <= maxLen)
      return str;
    return str.slice(0, maxLen - 3) + "...";
  }
  async promptForPath(message) {
    return new Promise((resolve) => {
      const modal = new PathPromptModal(this.app, message, (result) => {
        resolve(result);
      });
      modal.open();
    });
  }
};
var PathPromptModal = class extends import_obsidian3.Modal {
  constructor(app, message, onSubmit) {
    super(app);
    this.result = "";
    this.message = message;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.message });
    const inputContainer = contentEl.createDiv();
    const input = new import_obsidian3.TextComponent(inputContainer);
    input.setPlaceholder("path/to/manuscript.md");
    input.onChange((value) => {
      this.result = value;
    });
    input.inputEl.style.width = "100%";
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitBtn = buttonContainer.createEl("button", { text: "Submit" });
    submitBtn.onclick = () => {
      this.close();
      this.onSubmit(this.result || null);
    };
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => {
      this.close();
      this.onSubmit(null);
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
