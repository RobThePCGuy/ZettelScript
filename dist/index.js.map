{"version":3,"sources":["../src/core/types/index.ts","../src/core/logger.ts","../src/core/graph/pathfinder.ts","../src/core/graph/engine.ts","../src/core/errors.ts","../src/storage/database/connection.ts","../src/storage/database/schema.ts","../src/storage/database/repositories/node-repository.ts","../src/storage/database/repositories/edge-repository.ts","../src/storage/database/repositories/version-repository.ts","../src/storage/database/repositories/chunk-repository.ts","../src/storage/database/repositories/mention-repository.ts","../src/storage/database/repositories/unresolved-link-repository.ts","../src/storage/database/repositories/constellation-repository.ts","../src/storage/database/repositories/embedding-repository.ts","../src/core/circuit-breaker.ts","../src/storage/database/repositories/wormhole-repository.ts","../src/storage/database/repositories/candidate-edge-repository.ts","../src/parser/markdown.ts","../src/parser/frontmatter.ts","../src/parser/exclusions.ts","../src/parser/wikilink.ts","../src/parser/resolver.ts","../src/indexer/pipeline.ts","../src/retrieval/expansion/graph-expander.ts","../src/retrieval/fusion/rrf.ts","../src/retrieval/context/assembler.ts"],"sourcesContent":["import { Type, Static } from '@sinclair/typebox';\nimport { createHash } from 'node:crypto';\nimport { getLogger } from '../logger.js';\n\n// ============================================================================\n// Node Types\n// ============================================================================\n\nexport const NodeTypeSchema = Type.Union([\n  Type.Literal('note'),\n  Type.Literal('scene'),\n  Type.Literal('character'),\n  Type.Literal('location'),\n  Type.Literal('object'),\n  Type.Literal('event'),\n  Type.Literal('concept'),\n  Type.Literal('moc'),\n  Type.Literal('timeline'),\n  Type.Literal('draft'),\n]);\n\nexport type NodeType = Static<typeof NodeTypeSchema>;\n\nexport const NodeSchema = Type.Object({\n  nodeId: Type.String(),\n  type: NodeTypeSchema,\n  title: Type.String(),\n  path: Type.String(),\n  createdAt: Type.String({ format: 'date-time' }),\n  updatedAt: Type.String({ format: 'date-time' }),\n  contentHash: Type.Optional(Type.String()),\n  metadata: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n  isGhost: Type.Optional(Type.Boolean()),\n});\n\nexport type Node = Static<typeof NodeSchema>;\n\n// ============================================================================\n// Edge Types\n// ============================================================================\n\nexport const EdgeTypeSchema = Type.Union([\n  Type.Literal('explicit_link'),\n  Type.Literal('backlink'),\n  Type.Literal('sequence'),\n  Type.Literal('hierarchy'),\n  Type.Literal('participation'),\n  Type.Literal('pov_visible_to'),\n  Type.Literal('causes'),\n  Type.Literal('setup_payoff'),\n  Type.Literal('semantic'),\n  Type.Literal('semantic_suggestion'), // Pending semantic wormhole (not yet accepted)\n  Type.Literal('mention'),\n  Type.Literal('alias'),\n]);\n\nexport type EdgeType = Static<typeof EdgeTypeSchema>;\n\nexport const EdgeProvenanceSchema = Type.Union([\n  Type.Literal('explicit'),\n  Type.Literal('inferred'),\n  Type.Literal('computed'),\n  Type.Literal('user_approved'),\n]);\n\nexport type EdgeProvenance = Static<typeof EdgeProvenanceSchema>;\n\nexport const EdgeSchema = Type.Object({\n  edgeId: Type.String(),\n  sourceId: Type.String(),\n  targetId: Type.String(),\n  edgeType: EdgeTypeSchema,\n  strength: Type.Optional(Type.Number({ minimum: 0, maximum: 1 })),\n  provenance: EdgeProvenanceSchema,\n  createdAt: Type.String({ format: 'date-time' }),\n  versionStart: Type.Optional(Type.String()),\n  versionEnd: Type.Optional(Type.String()),\n  attributes: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n});\n\nexport type Edge = Static<typeof EdgeSchema>;\n\n// ============================================================================\n// Version Types\n// ============================================================================\n\nexport const VersionSchema = Type.Object({\n  versionId: Type.String(),\n  nodeId: Type.String(),\n  contentHash: Type.String(),\n  parentVersionId: Type.Optional(Type.String()),\n  createdAt: Type.String({ format: 'date-time' }),\n  summary: Type.Optional(Type.String()),\n});\n\nexport type Version = Static<typeof VersionSchema>;\n\n// ============================================================================\n// Mention Types\n// ============================================================================\n\nexport const MentionStatusSchema = Type.Union([\n  Type.Literal('new'),\n  Type.Literal('approved'),\n  Type.Literal('rejected'),\n  Type.Literal('deferred'),\n]);\n\nexport type MentionStatus = Static<typeof MentionStatusSchema>;\n\nexport const MentionCandidateSchema = Type.Object({\n  candidateId: Type.String(),\n  sourceId: Type.String(),\n  targetId: Type.String(),\n  surfaceText: Type.String(),\n  spanStart: Type.Optional(Type.Integer()),\n  spanEnd: Type.Optional(Type.Integer()),\n  confidence: Type.Number({ minimum: 0, maximum: 1 }),\n  reasons: Type.Optional(Type.Array(Type.String())),\n  status: MentionStatusSchema,\n});\n\nexport type MentionCandidate = Static<typeof MentionCandidateSchema>;\n\n// ============================================================================\n// Chunk Types (for retrieval)\n// ============================================================================\n\nexport const ChunkSchema = Type.Object({\n  chunkId: Type.String(),\n  nodeId: Type.String(),\n  text: Type.String(),\n  offsetStart: Type.Integer(),\n  offsetEnd: Type.Integer(),\n  versionId: Type.String(),\n  tokenCount: Type.Optional(Type.Integer()),\n});\n\nexport type Chunk = Static<typeof ChunkSchema>;\n\n// ============================================================================\n// Proposal Types (for writeback)\n// ============================================================================\n\nexport const ProposalTypeSchema = Type.Union([\n  Type.Literal('link_addition'),\n  Type.Literal('content_edit'),\n  Type.Literal('node_creation'),\n  Type.Literal('node_deletion'),\n  Type.Literal('metadata_update'),\n]);\n\nexport type ProposalType = Static<typeof ProposalTypeSchema>;\n\nexport const ProposalStatusSchema = Type.Union([\n  Type.Literal('pending'),\n  Type.Literal('approved'),\n  Type.Literal('rejected'),\n  Type.Literal('applied'),\n]);\n\nexport type ProposalStatus = Static<typeof ProposalStatusSchema>;\n\nexport const ProposalSchema = Type.Object({\n  proposalId: Type.String(),\n  type: ProposalTypeSchema,\n  nodeId: Type.String(),\n  description: Type.String(),\n  diff: Type.Object({\n    before: Type.Optional(Type.String()),\n    after: Type.String(),\n  }),\n  status: ProposalStatusSchema,\n  createdAt: Type.String({ format: 'date-time' }),\n  appliedAt: Type.Optional(Type.String({ format: 'date-time' })),\n  metadata: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n});\n\nexport type Proposal = Static<typeof ProposalSchema>;\n\n// ============================================================================\n// Graph Metrics\n// ============================================================================\n\nexport const GraphMetricsSchema = Type.Object({\n  nodeId: Type.String(),\n  centralityPagerank: Type.Optional(Type.Number()),\n  clusterId: Type.Optional(Type.String()),\n  computedAt: Type.String({ format: 'date-time' }),\n});\n\nexport type GraphMetrics = Static<typeof GraphMetricsSchema>;\n\n// ============================================================================\n// Frontmatter Schema\n// ============================================================================\n\nexport const FrontmatterSchema = Type.Object(\n  {\n    id: Type.Optional(Type.String()),\n    title: Type.Optional(Type.String()),\n    type: Type.Optional(NodeTypeSchema),\n    aliases: Type.Optional(Type.Array(Type.String())),\n    tags: Type.Optional(Type.Array(Type.String())),\n    created: Type.Optional(Type.String()),\n    updated: Type.Optional(Type.String()),\n    // Manuscript-specific fields\n    pov: Type.Optional(Type.String()),\n    scene_order: Type.Optional(Type.Number()),\n    timeline_position: Type.Optional(Type.String()),\n    characters: Type.Optional(Type.Array(Type.String())),\n    locations: Type.Optional(Type.Array(Type.String())),\n    // Allow additional fields\n  },\n  { additionalProperties: true }\n);\n\nexport type Frontmatter = Static<typeof FrontmatterSchema>;\n\n// ============================================================================\n// Wikilink Types\n// ============================================================================\n\nexport interface WikiLink {\n  raw: string; // Original text including brackets\n  target: string; // The link target (after id: prefix if present)\n  display: string; // Display text (after | if present)\n  isIdLink: boolean; // Whether it uses id: prefix\n  start: number; // Start position in source\n  end: number; // End position in source\n}\n\nexport interface ResolvedLink extends WikiLink {\n  resolvedNodeId: string | null;\n  ambiguous: boolean;\n  candidates: string[]; // Node IDs if ambiguous\n}\n\n// ============================================================================\n// Query Types\n// ============================================================================\n\nexport interface BacklinkResult {\n  sourceNode: Node;\n  edge: Edge;\n  context?: string; // Surrounding text for context\n}\n\nexport interface NeighborResult {\n  node: Node;\n  edge: Edge;\n  direction: 'incoming' | 'outgoing';\n}\n\nexport interface TraversalResult {\n  nodeId: string;\n  depth: number;\n  score: number;\n  path: string[]; // Node IDs forming the path\n}\n\n// ============================================================================\n// Retrieval Types\n// ============================================================================\n\nexport interface RetrievalQuery {\n  text: string;\n  maxResults?: number;\n  filters?: {\n    nodeTypes?: NodeType[];\n    excludeNodeIds?: string[];\n    dateRange?: { start?: string; end?: string };\n  };\n  expansion?: {\n    maxDepth?: number;\n    budget?: number;\n    edgeTypes?: EdgeType[];\n    decayFactor?: number;\n  };\n}\n\nexport interface RetrievalResult {\n  chunks: Array<{\n    chunk: Chunk;\n    node: Node;\n    score: number;\n    matchType: 'semantic' | 'lexical' | 'graph';\n  }>;\n  context: string;\n  provenance: Array<{\n    nodeId: string;\n    path: string;\n    contribution: number;\n  }>;\n}\n\n// ============================================================================\n// Manuscript Types\n// ============================================================================\n\nexport interface SceneInfo {\n  nodeId: string;\n  sceneOrder: number;\n  timelinePosition?: string;\n  pov?: string;\n  characters: string[];\n  locations: string[];\n}\n\nexport interface CharacterKnowledge {\n  characterId: string;\n  knows: Map<string, { learnedAt: string; source: string }>;\n  present: string[]; // Scene IDs where character is present\n}\n\nexport interface ContinuityIssue {\n  type:\n    | 'pov_leakage'\n    | 'timeline_inconsistency'\n    | 'missing_setup'\n    | 'orphaned_payoff'\n    | 'character_knowledge';\n  severity: 'error' | 'warning' | 'info';\n  nodeId: string;\n  description: string;\n  suggestion?: string;\n}\n\nexport interface ImpactAnalysis {\n  directImpact: string[]; // Directly affected node IDs\n  transitiveImpact: string[]; // Indirectly affected via graph\n  povImpact: string[]; // Scenes with same POV\n  timelineImpact: string[]; // Scenes in timeline range\n  characterImpact: string[]; // Characters whose knowledge changes\n}\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\nexport type VisualizationMode = 'focus' | 'classic';\n\nexport interface ZettelScriptConfig {\n  vault: {\n    path: string;\n    excludePatterns: string[];\n  };\n  database: {\n    path: string;\n  };\n  embeddings: {\n    provider: 'openai' | 'ollama';\n    model: string;\n    dimensions: number;\n    apiKey?: string;\n    baseUrl?: string;\n  };\n  retrieval: {\n    defaultMaxResults: number;\n    semanticWeight: number;\n    lexicalWeight: number;\n    graphWeight: number;\n    rrfK: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n  manuscript: {\n    enabled: boolean;\n    validatePov: boolean;\n    validateTimeline: boolean;\n    validateSetupPayoff: boolean;\n  };\n  graph: {\n    defaultMaxDepth: number;\n    defaultBudget: number;\n    decayFactor: number;\n    scoreThreshold: number;\n  };\n  chunking: {\n    maxTokens: number;\n    overlap: number;\n    minChunkSize: number;\n  };\n  discovery: {\n    weights: {\n      locality: number;\n      centrality: number;\n      frequency: number;\n      matchQuality: number;\n    };\n    confidenceThreshold: number;\n    ambiguityPenalty: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n  cache: {\n    defaultTtlMs: number;\n    defaultMaxSize: number;\n    mentionTtlMs: number;\n    mentionMaxSize: number;\n    mocTtlMs: number;\n    mocMaxSize: number;\n  };\n  impact: {\n    timelineRange: number;\n    maxTransitiveDepth: number;\n    maxTransitiveBudget: number;\n  };\n  moc: {\n    scoreNormalizationBase: number;\n    hubScoreNormalization: number;\n    clusterScoreNormalization: number;\n    defaultHubThreshold: number;\n  };\n  versioning: {\n    driftVersionWindow: number;\n    butterflyLogDefaultEntries: number;\n  };\n  search: {\n    defaultLimit: number;\n    contextWindowChars: number;\n    diffContextLines: number;\n  };\n  llm: {\n    provider: 'openai' | 'ollama' | 'none';\n    model: string;\n    apiKey?: string;\n    baseUrl?: string;\n    maxTokens?: number;\n    temperature?: number;\n  };\n  visualization: {\n    mode: VisualizationMode;\n  };\n}\n\nexport const DEFAULT_CONFIG: ZettelScriptConfig = {\n  vault: {\n    path: '.',\n    excludePatterns: ['node_modules/**', '.git/**', '.zettelscript/**'],\n  },\n  database: {\n    path: '.zettelscript/zettelscript.db',\n  },\n  embeddings: {\n    provider: 'openai',\n    model: 'text-embedding-3-small',\n    dimensions: 1536,\n  },\n  retrieval: {\n    defaultMaxResults: 20,\n    semanticWeight: 0.5,\n    lexicalWeight: 0.3,\n    graphWeight: 0.2,\n    rrfK: 60,\n    expansionMaxDepth: 3,\n    expansionBudget: 50,\n  },\n  manuscript: {\n    enabled: false,\n    validatePov: true,\n    validateTimeline: true,\n    validateSetupPayoff: true,\n  },\n  graph: {\n    defaultMaxDepth: 3,\n    defaultBudget: 50,\n    decayFactor: 0.7,\n    scoreThreshold: 0.01,\n  },\n  chunking: {\n    maxTokens: 512,\n    overlap: 50,\n    minChunkSize: 50,\n  },\n  discovery: {\n    weights: {\n      locality: 0.3,\n      centrality: 0.2,\n      frequency: 0.2,\n      matchQuality: 0.3,\n    },\n    confidenceThreshold: 0.3,\n    ambiguityPenalty: 0.7,\n    expansionMaxDepth: 4,\n    expansionBudget: 100,\n  },\n  cache: {\n    defaultTtlMs: 300000, // 5 minutes\n    defaultMaxSize: 1000,\n    mentionTtlMs: 600000, // 10 minutes\n    mentionMaxSize: 500,\n    mocTtlMs: 300000, // 5 minutes\n    mocMaxSize: 100,\n  },\n  impact: {\n    timelineRange: 5,\n    maxTransitiveDepth: 3,\n    maxTransitiveBudget: 50,\n  },\n  moc: {\n    scoreNormalizationBase: 100,\n    hubScoreNormalization: 50,\n    clusterScoreNormalization: 20,\n    defaultHubThreshold: 5,\n  },\n  versioning: {\n    driftVersionWindow: 5,\n    butterflyLogDefaultEntries: 50,\n  },\n  search: {\n    defaultLimit: 20,\n    contextWindowChars: 50,\n    diffContextLines: 3,\n  },\n  llm: {\n    provider: 'none',\n    model: 'gpt-4',\n  },\n  visualization: {\n    mode: 'focus', // v2 default: hide Layer C edges (mentions, suggestions)\n  },\n};\n\n// ============================================================================\n// Edge Layer Classification (per DESIGN.md v2)\n// ============================================================================\n\n/**\n * Layer A: Truth edges - explicit user intent or durable structure.\n * Always rendered in both focus and classic modes.\n */\nexport const LAYER_A_EDGES: EdgeType[] = [\n  'explicit_link', // User-authored [[wikilinks]]\n  'hierarchy', // Parent/child, folder structure\n  'sequence', // Chapter/scene order (chronology_next)\n  'causes', // Causal relationships\n  'setup_payoff', // Narrative foreshadowing\n  'participation', // Character in scene\n  'pov_visible_to', // POV constraints\n];\n\n/**\n * Layer B: Semantic edges - computed similarity.\n * Rendered with visual distinction (dotted, subdued).\n */\nexport const LAYER_B_EDGES: EdgeType[] = [\n  'semantic', // Accepted wormholes (similarity > threshold)\n];\n\n/**\n * Layer C: Suggestion edges - candidates, not truth.\n * Hidden by default in focus mode, shown in classic mode.\n */\nexport const LAYER_C_EDGES: EdgeType[] = [\n  'mention', // Approved mention (co-occurrence)\n  'semantic_suggestion', // Wormhole below threshold\n  'backlink', // Computed incoming (can be noisy)\n  'alias', // Alternative name reference\n];\n\n/**\n * Edge layer classification result.\n * A = Truth, B = Semantic, C = Suggestions, unknown = unclassified\n */\nexport type EdgeLayer = 'A' | 'B' | 'C' | 'unknown';\n\n/**\n * Get the layer classification for an edge type.\n * Single source of truth for edge categorization.\n * @param edgeType The type of edge to classify\n * @returns The layer ('A', 'B', 'C', or 'unknown')\n */\nexport function getEdgeLayer(edgeType: EdgeType): EdgeLayer {\n  if (LAYER_A_EDGES.includes(edgeType)) return 'A';\n  if (LAYER_B_EDGES.includes(edgeType)) return 'B';\n  if (LAYER_C_EDGES.includes(edgeType)) return 'C';\n  return 'unknown';\n}\n\n/**\n * Determine if an edge should be rendered based on visualization mode.\n * @param edgeType The type of edge to check\n * @param mode The current visualization mode ('focus' or 'classic')\n * @returns true if the edge should be rendered\n */\nexport function shouldRenderEdge(edgeType: EdgeType, mode: VisualizationMode): boolean {\n  if (mode === 'classic') return true;\n\n  const layer = getEdgeLayer(edgeType);\n\n  if (layer === 'A' || layer === 'B') return true;\n  if (layer === 'C') return false;\n\n  // Unknown edge types: warn and hide (safe default)\n  getLogger().warn(`Unknown edge type: ${edgeType}`);\n  return false;\n}\n\n// ============================================================================\n// Candidate Edge Types (Phase 2: Suggestions)\n// ============================================================================\n\nexport const CandidateEdgeStatusSchema = Type.Union([\n  Type.Literal('suggested'),\n  Type.Literal('approved'),\n  Type.Literal('rejected'),\n]);\n\nexport type CandidateEdgeStatus = Static<typeof CandidateEdgeStatusSchema>;\n\nexport const CandidateEdgeSourceSchema = Type.Union([\n  Type.Literal('mention'),\n  Type.Literal('semantic'),\n  Type.Literal('heuristic'),\n]);\n\nexport type CandidateEdgeSource = Static<typeof CandidateEdgeSourceSchema>;\n\nexport interface CandidateEdgeSignals {\n  semantic?: number;\n  mentionCount?: number;\n  graphProximity?: number;\n}\n\nexport interface CandidateEdgeProvenance {\n  model?: string;\n  excerpt?: string;\n  createdAt?: string;\n}\n\nexport interface CandidateEdge {\n  suggestionId: string;\n  fromId: string;\n  toId: string;\n  suggestedEdgeType: EdgeType;\n  status: CandidateEdgeStatus;\n  statusChangedAt?: string;\n  signals?: CandidateEdgeSignals;\n  reasons?: string[];\n  provenance?: CandidateEdgeProvenance[];\n  createdAt: string;\n  lastComputedAt: string;\n  lastSeenAt?: string;\n  writebackStatus?: string;\n  writebackReason?: string;\n  approvedEdgeId?: string;\n}\n\n/**\n * Generate a canonical suggestionId from edge components.\n *\n * Per Phase 2 design Section 2.4:\n * - 128-bit hash (32 hex chars) from (fromId, toId, edgeType)\n * - For undirected edges, IDs are canonically ordered (smaller first)\n * - For directed edges, order is preserved\n *\n * @param fromId Source node ID\n * @param toId Target node ID\n * @param edgeType The suggested edge type\n * @param isUndirected If true, IDs are canonically ordered for deduplication\n * @returns 32-character hex string (128 bits)\n */\nexport function generateSuggestionId(\n  fromId: string,\n  toId: string,\n  edgeType: EdgeType,\n  isUndirected: boolean = true\n): string {\n  // Canonical ordering for undirected edges only\n  const [a, b] = isUndirected && fromId > toId ? [toId, fromId] : [fromId, toId];\n\n  const input = `v1|${a}|${b}|${edgeType}`;\n  return createHash('sha256').update(input).digest('hex').slice(0, 32);\n}\n\n/**\n * Check if an edge type is undirected for suggestionId generation.\n * Most edges in ZettelScript are directed, but semantic similarity is undirected.\n */\nexport function isUndirectedEdgeType(edgeType: EdgeType): boolean {\n  // Semantic edges are undirected (A similar to B = B similar to A)\n  return edgeType === 'semantic' || edgeType === 'semantic_suggestion';\n}\n","/**\n * Lightweight logger with configurable log levels\n */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  SILENT = 4,\n}\n\nexport interface LoggerOptions {\n  level?: LogLevel;\n  prefix?: string;\n}\n\n/**\n * Simple logger with log levels\n */\nexport class Logger {\n  private level: LogLevel;\n  private prefix: string;\n\n  constructor(options: LoggerOptions = {}) {\n    this.level = options.level ?? LogLevel.INFO;\n    this.prefix = options.prefix ?? '';\n  }\n\n  /**\n   * Set the log level\n   */\n  setLevel(level: LogLevel): void {\n    this.level = level;\n  }\n\n  /**\n   * Get the current log level\n   */\n  getLevel(): LogLevel {\n    return this.level;\n  }\n\n  /**\n   * Format a log message with optional prefix\n   */\n  private format(message: string): string {\n    return this.prefix ? `[${this.prefix}] ${message}` : message;\n  }\n\n  /**\n   * Log a debug message\n   */\n  debug(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.DEBUG) {\n      console.debug(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log an info message\n   */\n  info(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.INFO) {\n      console.log(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log a warning message\n   */\n  warn(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.WARN) {\n      console.warn(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log an error message\n   */\n  error(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.ERROR) {\n      console.error(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Create a child logger with a prefix\n   */\n  child(prefix: string): Logger {\n    const childPrefix = this.prefix ? `${this.prefix}:${prefix}` : prefix;\n    return new Logger({ level: this.level, prefix: childPrefix });\n  }\n}\n\n// Default logger instance\nlet defaultLogger = new Logger();\n\n/**\n * Get the default logger\n */\nexport function getLogger(): Logger {\n  return defaultLogger;\n}\n\n/**\n * Set the default logger\n */\nexport function setDefaultLogger(logger: Logger): void {\n  defaultLogger = logger;\n}\n\n/**\n * Create a new logger with the given options\n */\nexport function createLogger(options: LoggerOptions = {}): Logger {\n  return new Logger(options);\n}\n\n/**\n * Configure the default logger\n */\nexport function configureLogger(options: LoggerOptions): void {\n  if (options.level !== undefined) {\n    defaultLogger.setLevel(options.level);\n  }\n}\n","import type { Edge, EdgeType } from '../types/index.js';\n\n/**\n * Result of a path search\n */\nexport interface PathResult {\n  path: string[]; // Node IDs\n  edges: EdgeType[]; // Length = path.length - 1\n  hopCount: number;\n  score: number;\n}\n\n/**\n * Options for K-shortest paths search\n */\nexport interface KShortestPathsOptions {\n  k?: number; // Default: 3\n  edgeTypes?: EdgeType[]; // Default: explicit_link, sequence, causes, semantic\n  maxDepth?: number; // Default: 15\n  overlapThreshold?: number; // Default: 0.7 (max allowed Jaccard overlap)\n  maxCandidates?: number; // Default: 100\n  maxExtraHops?: number; // Default: 2\n}\n\n/**\n * Edge penalties for cosmetic scoring (lower = preferred)\n */\nconst EDGE_PENALTIES: Record<string, number> = {\n  explicit_link: 0,\n  sequence: 0.1,\n  causes: 0.2,\n  semantic: 0.3,\n  semantic_suggestion: 0.5,\n};\n\n/**\n * Default edge penalty for unknown types\n */\nconst DEFAULT_EDGE_PENALTY = 0.3;\n\n/**\n * Adjacency list entry\n */\ninterface AdjEntry {\n  nodeId: string;\n  edgeType: EdgeType;\n}\n\n/**\n * Build adjacency lists from edges\n */\nexport function buildAdjacencyLists(\n  edges: Edge[],\n  edgeTypes?: EdgeType[]\n): {\n  forward: Map<string, AdjEntry[]>;\n  backward: Map<string, AdjEntry[]>;\n} {\n  const forward = new Map<string, AdjEntry[]>();\n  const backward = new Map<string, AdjEntry[]>();\n  const typeSet = edgeTypes ? new Set(edgeTypes) : null;\n\n  for (const edge of edges) {\n    if (typeSet && !typeSet.has(edge.edgeType)) continue;\n\n    // Forward adjacency (source -> target)\n    if (!forward.has(edge.sourceId)) {\n      forward.set(edge.sourceId, []);\n    }\n    forward.get(edge.sourceId)!.push({\n      nodeId: edge.targetId,\n      edgeType: edge.edgeType,\n    });\n\n    // Backward adjacency (target -> source)\n    if (!backward.has(edge.targetId)) {\n      backward.set(edge.targetId, []);\n    }\n    backward.get(edge.targetId)!.push({\n      nodeId: edge.sourceId,\n      edgeType: edge.edgeType,\n    });\n  }\n\n  return { forward, backward };\n}\n\n/**\n * Bidirectional BFS to find shortest path\n *\n * Key insight: Don't stop at first meeting. Track bestDistance and continue\n * until both frontiers exceed it.\n */\nexport function bidirectionalBFS(\n  startId: string,\n  endId: string,\n  forward: Map<string, AdjEntry[]>,\n  backward: Map<string, AdjEntry[]>,\n  maxDepth: number,\n  disabledEdges?: Set<string>, // Set of \"sourceId->targetId\" strings\n  disabledNodes?: Set<string>\n): { path: string[]; edges: EdgeType[] } | null {\n  if (startId === endId) {\n    return { path: [startId], edges: [] };\n  }\n\n  // Check if start/end are disabled\n  if (disabledNodes?.has(startId) || disabledNodes?.has(endId)) {\n    return null;\n  }\n\n  // Forward search state (from start)\n  const forwardVisited = new Map<string, { parent: string | null; edgeType: EdgeType | null }>();\n  forwardVisited.set(startId, { parent: null, edgeType: null });\n  let forwardQueue: string[] = [startId];\n  let forwardDepth = 0;\n\n  // Backward search state (from end)\n  const backwardVisited = new Map<string, { parent: string | null; edgeType: EdgeType | null }>();\n  backwardVisited.set(endId, { parent: null, edgeType: null });\n  let backwardQueue: string[] = [endId];\n  let backwardDepth = 0;\n\n  let bestDistance = Infinity;\n  let meetingNode: string | null = null;\n\n  while (\n    (forwardQueue.length > 0 || backwardQueue.length > 0) &&\n    forwardDepth + backwardDepth < bestDistance\n  ) {\n    // Check depth limit\n    if (forwardDepth + backwardDepth >= maxDepth * 2) break;\n\n    // Expand the smaller frontier\n    const expandForward =\n      forwardQueue.length > 0 &&\n      (backwardQueue.length === 0 || forwardQueue.length <= backwardQueue.length);\n\n    if (expandForward && forwardQueue.length > 0) {\n      const nextQueue: string[] = [];\n      forwardDepth++;\n\n      // Can we possibly find a shorter path?\n      if (forwardDepth > bestDistance) break;\n\n      for (const nodeId of forwardQueue) {\n        const neighbors = forward.get(nodeId) || [];\n\n        for (const { nodeId: neighborId, edgeType } of neighbors) {\n          // Check if edge/node is disabled\n          if (disabledNodes?.has(neighborId)) continue;\n          const edgeKey = `${nodeId}->${neighborId}`;\n          if (disabledEdges?.has(edgeKey)) continue;\n\n          if (!forwardVisited.has(neighborId)) {\n            forwardVisited.set(neighborId, { parent: nodeId, edgeType });\n            nextQueue.push(neighborId);\n\n            // Check for meeting point\n            if (backwardVisited.has(neighborId)) {\n              const totalDist = forwardDepth + backwardDepth;\n              if (totalDist < bestDistance) {\n                bestDistance = totalDist;\n                meetingNode = neighborId;\n              }\n            }\n          }\n        }\n      }\n      forwardQueue = nextQueue;\n    } else if (backwardQueue.length > 0) {\n      const nextQueue: string[] = [];\n      backwardDepth++;\n\n      // Can we possibly find a shorter path?\n      if (backwardDepth > bestDistance) break;\n\n      for (const nodeId of backwardQueue) {\n        const neighbors = backward.get(nodeId) || [];\n\n        for (const { nodeId: neighborId, edgeType } of neighbors) {\n          // Check if edge/node is disabled\n          if (disabledNodes?.has(neighborId)) continue;\n          const edgeKey = `${neighborId}->${nodeId}`;\n          if (disabledEdges?.has(edgeKey)) continue;\n\n          if (!backwardVisited.has(neighborId)) {\n            backwardVisited.set(neighborId, { parent: nodeId, edgeType });\n            nextQueue.push(neighborId);\n\n            // Check for meeting point\n            if (forwardVisited.has(neighborId)) {\n              const totalDist = forwardDepth + backwardDepth;\n              if (totalDist < bestDistance) {\n                bestDistance = totalDist;\n                meetingNode = neighborId;\n              }\n            }\n          }\n        }\n      }\n      backwardQueue = nextQueue;\n    } else {\n      break;\n    }\n  }\n\n  if (!meetingNode) {\n    return null;\n  }\n\n  // Reconstruct path from start to meeting point\n  const pathToMeeting: string[] = [];\n  const edgesToMeeting: EdgeType[] = [];\n  let current: string | null = meetingNode;\n\n  while (current !== null) {\n    pathToMeeting.unshift(current);\n    const info = forwardVisited.get(current);\n    if (info?.edgeType) {\n      edgesToMeeting.unshift(info.edgeType);\n    }\n    current = info?.parent ?? null;\n  }\n\n  // Reconstruct path from meeting point to end\n  const pathFromMeeting: string[] = [];\n  const edgesFromMeeting: EdgeType[] = [];\n  current = backwardVisited.get(meetingNode)?.parent ?? null;\n\n  while (current !== null) {\n    pathFromMeeting.push(current);\n    const info = backwardVisited.get(current);\n    // Edge type is stored in child pointing to parent\n    const prevNode: string =\n      pathFromMeeting.length > 1 ? pathFromMeeting[pathFromMeeting.length - 2]! : meetingNode;\n    const prevInfo = backwardVisited.get(prevNode);\n    if (prevInfo?.edgeType) {\n      edgesFromMeeting.push(prevInfo.edgeType);\n    }\n    current = info?.parent ?? null;\n  }\n\n  const path = [...pathToMeeting, ...pathFromMeeting];\n  const edges = [...edgesToMeeting, ...edgesFromMeeting];\n\n  return { path, edges };\n}\n\n/**\n * Calculate Jaccard overlap between two paths\n * Optionally excludes endpoints for short paths\n */\nexport function calculateJaccardOverlap(\n  pathA: string[],\n  pathB: string[],\n  excludeEndpoints: boolean = false\n): number {\n  let nodesA = new Set(pathA);\n  let nodesB = new Set(pathB);\n\n  if (excludeEndpoints && pathA.length >= 2 && pathB.length >= 2) {\n    // Exclude first and last nodes\n    nodesA = new Set(pathA.slice(1, -1));\n    nodesB = new Set(pathB.slice(1, -1));\n  }\n\n  if (nodesA.size === 0 && nodesB.size === 0) {\n    // Both have no intermediate nodes, consider as 100% overlap\n    return 1.0;\n  }\n\n  const intersection = new Set([...nodesA].filter((x) => nodesB.has(x)));\n  const union = new Set([...nodesA, ...nodesB]);\n\n  if (union.size === 0) return 1.0;\n\n  return intersection.size / union.size;\n}\n\n/**\n * Calculate cosmetic score for a path\n * score = hopCount + sum of edge penalties\n */\nexport function calculatePathScore(edges: EdgeType[]): number {\n  const hopCount = edges.length;\n  let penalty = 0;\n\n  for (const edgeType of edges) {\n    penalty += EDGE_PENALTIES[edgeType] ?? DEFAULT_EDGE_PENALTY;\n  }\n\n  return hopCount + penalty;\n}\n\n/**\n * Check if a path is simple (no repeated nodes)\n */\nexport function isSimplePath(path: string[]): boolean {\n  const seen = new Set<string>();\n  for (const nodeId of path) {\n    if (seen.has(nodeId)) return false;\n    seen.add(nodeId);\n  }\n  return true;\n}\n\n/**\n * Yen's K-Shortest Paths algorithm with diversity filtering\n *\n * Algorithm:\n * 1. Find shortest path first\n * 2. For each spur node, temporarily remove edges to force deviation\n * 3. Find shortest path through spur node\n * 4. Add to candidate heap\n * 5. Filter by diversity (Jaccard overlap)\n */\nexport function findKShortestPaths(\n  startId: string,\n  endId: string,\n  edges: Edge[],\n  options: KShortestPathsOptions = {}\n): { paths: PathResult[]; reason: string } {\n  const {\n    k = 3,\n    edgeTypes = ['explicit_link', 'sequence', 'causes', 'semantic'] as EdgeType[],\n    maxDepth = 15,\n    overlapThreshold = 0.7,\n    maxCandidates = 100,\n    maxExtraHops = 2,\n  } = options;\n\n  // Build adjacency lists\n  const { forward, backward } = buildAdjacencyLists(edges, edgeTypes);\n\n  // Find the first (shortest) path\n  const firstResult = bidirectionalBFS(startId, endId, forward, backward, maxDepth);\n\n  if (!firstResult) {\n    return { paths: [], reason: 'no_path' };\n  }\n\n  const shortestHopCount = firstResult.path.length - 1;\n  const maxAllowedHops = shortestHopCount + maxExtraHops;\n\n  // Result paths\n  const results: PathResult[] = [\n    {\n      path: firstResult.path,\n      edges: firstResult.edges,\n      hopCount: shortestHopCount,\n      score: calculatePathScore(firstResult.edges),\n    },\n  ];\n\n  // Candidate heap: [score, path, edges]\n  // We use an array and sort as needed (small heap)\n  const candidates: Array<{ path: string[]; edges: EdgeType[]; score: number }> = [];\n  const seenPaths = new Set<string>([firstResult.path.join('|')]);\n\n  // Yen's algorithm: iterate over accepted paths\n  for (let i = 0; i < results.length && results.length < k; i++) {\n    const resultItem = results[i]!;\n    const currentPath = resultItem.path;\n\n    // For each spur node (except the last)\n    for (let spurIndex = 0; spurIndex < currentPath.length - 1; spurIndex++) {\n      const spurNode = currentPath[spurIndex]!;\n      const rootPath = currentPath.slice(0, spurIndex + 1);\n      const rootEdges = resultItem.edges.slice(0, spurIndex);\n\n      // Disable edges used by paths that share the same root\n      const disabledEdges = new Set<string>();\n      const disabledNodes = new Set<string>();\n\n      for (const result of results) {\n        if (result.path.length > spurIndex) {\n          // Check if root matches\n          const matchesRoot = rootPath.every((node, idx) => result.path[idx] === node);\n          if (matchesRoot && spurIndex < result.path.length - 1) {\n            // Disable the edge leaving the spur node in this path\n            const edgeKey = `${result.path[spurIndex]}->${result.path[spurIndex + 1]}`;\n            disabledEdges.add(edgeKey);\n          }\n        }\n      }\n\n      // Also disable nodes in root path (except spur node) to prevent cycles\n      for (let j = 0; j < rootPath.length - 1; j++) {\n        const nodeToDisable = rootPath[j];\n        if (nodeToDisable) {\n          disabledNodes.add(nodeToDisable);\n        }\n      }\n\n      // Find spur path from spurNode to end\n      const spurResult = bidirectionalBFS(\n        spurNode,\n        endId,\n        forward,\n        backward,\n        maxDepth - spurIndex,\n        disabledEdges,\n        disabledNodes\n      );\n\n      if (spurResult && spurResult.path.length > 1) {\n        // Combine root + spur (skip duplicate spur node)\n        const totalPath = [...rootPath.slice(0, -1), ...spurResult.path];\n        const totalEdges = [...rootEdges, ...spurResult.edges];\n        const pathKey = totalPath.join('|');\n\n        // Check if path is valid\n        if (\n          !seenPaths.has(pathKey) &&\n          isSimplePath(totalPath) &&\n          totalPath.length - 1 <= maxAllowedHops\n        ) {\n          seenPaths.add(pathKey);\n          candidates.push({\n            path: totalPath,\n            edges: totalEdges,\n            score: calculatePathScore(totalEdges),\n          });\n        }\n      }\n\n      // Cap candidates\n      if (candidates.length > maxCandidates) {\n        // Sort and trim\n        candidates.sort((a, b) => {\n          // Primary: hop count ascending\n          const hopDiff = a.path.length - 1 - (b.path.length - 1);\n          if (hopDiff !== 0) return hopDiff;\n          // Secondary: score ascending\n          const scoreDiff = a.score - b.score;\n          if (scoreDiff !== 0) return scoreDiff;\n          // Tertiary: lexical\n          return a.path.join('|').localeCompare(b.path.join('|'));\n        });\n        candidates.length = maxCandidates;\n      }\n    }\n\n    // Try to add the best candidate that passes diversity check\n    if (candidates.length > 0) {\n      // Sort candidates\n      candidates.sort((a, b) => {\n        const hopDiff = a.path.length - 1 - (b.path.length - 1);\n        if (hopDiff !== 0) return hopDiff;\n        const scoreDiff = a.score - b.score;\n        if (scoreDiff !== 0) return scoreDiff;\n        return a.path.join('|').localeCompare(b.path.join('|'));\n      });\n\n      // Find first candidate that passes diversity check\n      let addedIndex = -1;\n      for (let j = 0; j < candidates.length; j++) {\n        const candidate = candidates[j]!;\n\n        // Check diversity against all accepted paths\n        let tooSimilar = false;\n        for (const accepted of results) {\n          const overlap = calculateJaccardOverlap(\n            candidate.path,\n            accepted.path,\n            candidate.path.length <= 4 || accepted.path.length <= 4\n          );\n          if (overlap > overlapThreshold) {\n            tooSimilar = true;\n            break;\n          }\n        }\n\n        if (!tooSimilar) {\n          results.push({\n            path: candidate.path,\n            edges: candidate.edges,\n            hopCount: candidate.path.length - 1,\n            score: candidate.score,\n          });\n          addedIndex = j;\n          break;\n        }\n      }\n\n      // Remove added candidate\n      if (addedIndex >= 0) {\n        candidates.splice(addedIndex, 1);\n      }\n    }\n  }\n\n  // Determine reason for stopping\n  let reason = 'found_all';\n  if (results.length < k) {\n    if (candidates.length === 0) {\n      reason = 'exhausted_candidates';\n    } else {\n      reason = 'diversity_filter';\n    }\n  }\n\n  return { paths: results, reason };\n}\n\n/**\n * Simple BFS for shortest path (for use in GraphEngine)\n * Uses in-memory adjacency for efficiency\n */\nexport function simpleBFS(\n  startId: string,\n  endId: string,\n  forward: Map<string, AdjEntry[]>,\n  maxDepth: number = 15\n): string[] | null {\n  if (startId === endId) return [startId];\n\n  const visited = new Map<string, string | null>();\n  visited.set(startId, null);\n  let queue = [startId];\n  let depth = 0;\n\n  while (queue.length > 0 && depth < maxDepth) {\n    const nextQueue: string[] = [];\n    depth++;\n\n    for (const nodeId of queue) {\n      const neighbors = forward.get(nodeId) || [];\n\n      for (const { nodeId: neighborId } of neighbors) {\n        if (neighborId === endId) {\n          // Reconstruct path\n          const path: string[] = [endId, nodeId];\n          let current = nodeId;\n          while (visited.get(current) !== null) {\n            current = visited.get(current)!;\n            path.push(current);\n          }\n          return path.reverse();\n        }\n\n        if (!visited.has(neighborId)) {\n          visited.set(neighborId, nodeId);\n          nextQueue.push(neighborId);\n        }\n      }\n    }\n\n    queue = nextQueue;\n  }\n\n  return null;\n}\n","import type {\n  Node,\n  Edge,\n  EdgeType,\n  BacklinkResult,\n  NeighborResult,\n  TraversalResult,\n  ZettelScriptConfig,\n} from '../types/index.js';\nimport { DEFAULT_CONFIG } from '../types/index.js';\nimport { NodeRepository, EdgeRepository } from '../../storage/database/repositories/index.js';\nimport {\n  type PathResult,\n  type KShortestPathsOptions,\n  findKShortestPaths as findKShortestPathsImpl,\n  buildAdjacencyLists,\n  simpleBFS,\n} from './pathfinder.js';\n\nexport interface GraphEngineOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Graph engine for traversal, queries, and analytics\n */\nexport class GraphEngine {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private config: ZettelScriptConfig;\n\n  constructor(options: GraphEngineOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.config = options.config ?? DEFAULT_CONFIG;\n  }\n\n  // ============================================================================\n  // Node Operations\n  // ============================================================================\n\n  async getNode(nodeId: string): Promise<Node | null> {\n    return this.nodeRepo.findById(nodeId);\n  }\n\n  async getNodeByPath(path: string): Promise<Node | null> {\n    return this.nodeRepo.findByPath(path);\n  }\n\n  async getNodeByTitle(title: string): Promise<Node[]> {\n    return this.nodeRepo.findByTitle(title);\n  }\n\n  async getAllNodes(): Promise<Node[]> {\n    return this.nodeRepo.findAll();\n  }\n\n  // ============================================================================\n  // Edge Operations\n  // ============================================================================\n\n  async getEdge(edgeId: string): Promise<Edge | null> {\n    return this.edgeRepo.findById(edgeId);\n  }\n\n  async getOutgoingEdges(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    return this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n  }\n\n  async getIncomingEdges(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    return this.edgeRepo.findIncoming(nodeId, edgeTypes);\n  }\n\n  // ============================================================================\n  // Backlinks (Spec 6.2)\n  // ============================================================================\n\n  /**\n   * Get backlinks for a node\n   * backlinks(node) = { edge.source_id | edge.edge_type == 'explicit_link' AND edge.target_id == node }\n   */\n  async getBacklinks(nodeId: string): Promise<BacklinkResult[]> {\n    const edges = await this.edgeRepo.findBacklinks(nodeId);\n\n    if (edges.length === 0) return [];\n\n    const sourceIds = edges.map((e) => e.sourceId);\n    const sourceNodes = await this.nodeRepo.findByIds(sourceIds);\n    const nodeMap = new Map(sourceNodes.map((n) => [n.nodeId, n]));\n\n    const results: BacklinkResult[] = [];\n    for (const edge of edges) {\n      const sourceNode = nodeMap.get(edge.sourceId);\n      if (sourceNode) {\n        results.push({\n          sourceNode,\n          edge,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Count backlinks for a node\n   */\n  async countBacklinks(nodeId: string): Promise<number> {\n    const edges = await this.edgeRepo.findBacklinks(nodeId);\n    return edges.length;\n  }\n\n  // ============================================================================\n  // Neighbors\n  // ============================================================================\n\n  /**\n   * Get all neighbors of a node (both directions)\n   */\n  async getNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<NeighborResult[]> {\n    const neighborsWithNodes = await this.edgeRepo.findNeighborsWithNodes(nodeId, edgeTypes);\n\n    return neighborsWithNodes.map(({ edge, node, direction }) => ({\n      node: {\n        nodeId: node.nodeId,\n        title: node.title,\n        type: node.type as Node['type'],\n        path: node.path,\n        createdAt: '',\n        updatedAt: '',\n      },\n      edge,\n      direction,\n    }));\n  }\n\n  /**\n   * Get outgoing neighbors\n   */\n  async getOutgoingNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<Node[]> {\n    const edges = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n    if (edges.length === 0) return [];\n\n    const targetIds = edges.map((e) => e.targetId);\n    return this.nodeRepo.findByIds(targetIds);\n  }\n\n  /**\n   * Get incoming neighbors\n   */\n  async getIncomingNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<Node[]> {\n    const edges = await this.edgeRepo.findIncoming(nodeId, edgeTypes);\n\n    if (edges.length === 0) return [];\n\n    const sourceIds = edges.map((e) => e.sourceId);\n    return this.nodeRepo.findByIds(sourceIds);\n  }\n\n  // ============================================================================\n  // Bounded Graph Traversal (Spec 7.3)\n  // ============================================================================\n\n  /**\n   * Bounded graph expansion from seed nodes\n   *\n   * Algorithm:\n   * frontier = seed_nodes\n   * for depth in 1..max_depth:\n   *     if visited_count >= budget: break\n   *     for node in frontier:\n   *         for edge in outgoing_edges(node, allowed_types):\n   *             score = current_score * edge_weight * decay^depth\n   *             accumulated_scores[edge.target] = max(existing, score)\n   *     frontier = newly_discovered_nodes\n   */\n  async expandGraph(options: {\n    seedNodes: Array<{ nodeId: string; score: number }>;\n    maxDepth?: number;\n    budget?: number;\n    edgeTypes?: EdgeType[];\n    decayFactor?: number;\n    includeIncoming?: boolean;\n  }): Promise<TraversalResult[]> {\n    const {\n      seedNodes,\n      maxDepth = this.config.graph.defaultMaxDepth,\n      budget = this.config.graph.defaultBudget,\n      edgeTypes = ['explicit_link', 'sequence', 'hierarchy'],\n      decayFactor = this.config.graph.decayFactor,\n      includeIncoming = false,\n    } = options;\n\n    if (seedNodes.length === 0) return [];\n\n    // Track scores and paths\n    const scores = new Map<string, number>();\n    const paths = new Map<string, string[]>();\n    const depths = new Map<string, number>();\n\n    // Initialize with seed nodes\n    let frontier = new Set<string>();\n    for (const seed of seedNodes) {\n      scores.set(seed.nodeId, seed.score);\n      paths.set(seed.nodeId, [seed.nodeId]);\n      depths.set(seed.nodeId, 0);\n      frontier.add(seed.nodeId);\n    }\n\n    const visited = new Set<string>(frontier);\n\n    // BFS with decay\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (visited.size >= budget) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (visited.size >= budget) break;\n\n        const currentScore = scores.get(nodeId) ?? 0;\n        const currentPath = paths.get(nodeId) ?? [];\n\n        // Get outgoing edges\n        const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n        // Optionally include incoming edges\n        const incoming = includeIncoming ? await this.edgeRepo.findIncoming(nodeId, edgeTypes) : [];\n\n        const allEdges = [...outgoing, ...incoming];\n\n        for (const edge of allEdges) {\n          if (visited.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Calculate new score with decay\n          const edgeWeight = edge.strength ?? 1.0;\n          const newScore = currentScore * edgeWeight * Math.pow(decayFactor, depth);\n\n          // Update if new score is better\n          const existingScore = scores.get(targetId) ?? 0;\n          if (newScore > existingScore) {\n            scores.set(targetId, newScore);\n            paths.set(targetId, [...currentPath, targetId]);\n            depths.set(targetId, depth);\n          }\n\n          if (!visited.has(targetId)) {\n            visited.add(targetId);\n            newFrontier.add(targetId);\n          }\n        }\n      }\n\n      frontier = newFrontier;\n\n      if (frontier.size === 0) break;\n    }\n\n    // Build results sorted by score\n    const results: TraversalResult[] = [];\n    for (const [nodeId, score] of scores) {\n      results.push({\n        nodeId,\n        depth: depths.get(nodeId) ?? 0,\n        score,\n        path: paths.get(nodeId) ?? [],\n      });\n    }\n\n    return results.sort((a, b) => b.score - a.score);\n  }\n\n  // ============================================================================\n  // Path Finding\n  // ============================================================================\n\n  /**\n   * Find shortest path between two nodes using optimized BFS\n   */\n  async findShortestPath(\n    startId: string,\n    endId: string,\n    edgeTypes?: EdgeType[]\n  ): Promise<string[] | null> {\n    if (startId === endId) return [startId];\n\n    // Fetch all relevant edges and build adjacency list in memory\n    const edges = await this.edgeRepo.findAll(edgeTypes);\n    const { forward } = buildAdjacencyLists(edges, edgeTypes);\n\n    return simpleBFS(startId, endId, forward, this.config.graph.defaultMaxDepth * 5);\n  }\n\n  /**\n   * Find K shortest diverse paths between two nodes\n   *\n   * Uses Yen's algorithm with Jaccard diversity filtering.\n   *\n   * @param startId - Starting node ID\n   * @param endId - Ending node ID\n   * @param options - Search options\n   * @returns Array of path results and reason for stopping\n   */\n  async findKShortestPaths(\n    startId: string,\n    endId: string,\n    options?: KShortestPathsOptions\n  ): Promise<{ paths: PathResult[]; reason: string }> {\n    const edgeTypes =\n      options?.edgeTypes ?? (['explicit_link', 'sequence', 'causes', 'semantic'] as EdgeType[]);\n\n    // Fetch all relevant edges\n    const edges = await this.edgeRepo.findAll(edgeTypes);\n\n    return findKShortestPathsImpl(startId, endId, edges, options);\n  }\n\n  /**\n   * Check if two nodes are connected\n   */\n  async areConnected(\n    nodeId1: string,\n    nodeId2: string,\n    edgeTypes?: EdgeType[],\n    maxDepth?: number\n  ): Promise<boolean> {\n    const depth = maxDepth ?? this.config.graph.defaultMaxDepth;\n    const result = await this.expandGraph({\n      seedNodes: [{ nodeId: nodeId1, score: 1 }],\n      maxDepth: depth,\n      budget: 1000,\n      ...(edgeTypes && { edgeTypes }),\n    });\n\n    return result.some((r) => r.nodeId === nodeId2);\n  }\n\n  // ============================================================================\n  // Subgraph Extraction\n  // ============================================================================\n\n  /**\n   * Extract a subgraph around a node\n   */\n  async extractSubgraph(\n    centerNodeId: string,\n    radius: number = 2,\n    edgeTypes?: EdgeType[]\n  ): Promise<{ nodes: Node[]; edges: Edge[] }> {\n    const traversal = await this.expandGraph({\n      seedNodes: [{ nodeId: centerNodeId, score: 1 }],\n      maxDepth: radius,\n      budget: 100,\n      ...(edgeTypes && { edgeTypes }),\n      includeIncoming: true,\n    });\n\n    const nodeIds = traversal.map((t) => t.nodeId);\n    const nodes = await this.nodeRepo.findByIds(nodeIds);\n\n    // Get all edges between these nodes\n    const nodeIdSet = new Set(nodeIds);\n    const edges: Edge[] = [];\n\n    for (const nodeId of nodeIds) {\n      const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n      for (const edge of outgoing) {\n        if (nodeIdSet.has(edge.targetId)) {\n          edges.push(edge);\n        }\n      }\n    }\n\n    return { nodes, edges };\n  }\n\n  // ============================================================================\n  // Graph Statistics\n  // ============================================================================\n\n  /**\n   * Calculate degree for a node\n   */\n  async getDegree(nodeId: string): Promise<{\n    in: number;\n    out: number;\n    total: number;\n  }> {\n    const incoming = await this.edgeRepo.findIncoming(nodeId);\n    const outgoing = await this.edgeRepo.findOutgoing(nodeId);\n\n    return {\n      in: incoming.length,\n      out: outgoing.length,\n      total: incoming.length + outgoing.length,\n    };\n  }\n\n  /**\n   * Find isolated nodes (no edges)\n   */\n  async findIsolatedNodes(): Promise<Node[]> {\n    const allNodes = await this.nodeRepo.findAll();\n    const isolated: Node[] = [];\n\n    for (const node of allNodes) {\n      const edges = await this.edgeRepo.findConnected(node.nodeId);\n      if (edges.length === 0) {\n        isolated.push(node);\n      }\n    }\n\n    return isolated;\n  }\n\n  /**\n   * Find nodes with high in-degree (potential hubs)\n   */\n  async findHighInDegreeNodes(threshold?: number): Promise<\n    Array<{\n      node: Node;\n      inDegree: number;\n    }>\n  > {\n    const minThreshold = threshold ?? this.config.moc?.defaultHubThreshold ?? 5;\n    const allNodes = await this.nodeRepo.findAll();\n    const results: Array<{ node: Node; inDegree: number }> = [];\n\n    for (const node of allNodes) {\n      const incoming = await this.edgeRepo.findIncoming(node.nodeId);\n      if (incoming.length >= minThreshold) {\n        results.push({ node, inDegree: incoming.length });\n      }\n    }\n\n    return results.sort((a, b) => b.inDegree - a.inDegree);\n  }\n\n  // ============================================================================\n  // Connected Components\n  // ============================================================================\n\n  /**\n   * Find connected components in the graph\n   */\n  async findConnectedComponents(): Promise<string[][]> {\n    const allNodes = await this.nodeRepo.findAll();\n    const visited = new Set<string>();\n    const components: string[][] = [];\n\n    for (const node of allNodes) {\n      if (visited.has(node.nodeId)) continue;\n\n      // BFS to find all connected nodes\n      const component: string[] = [];\n      const queue = [node.nodeId];\n\n      while (queue.length > 0) {\n        const currentId = queue.shift();\n        if (!currentId || visited.has(currentId)) continue;\n\n        visited.add(currentId);\n        component.push(currentId);\n\n        // Get all connected nodes (both directions)\n        const edges = await this.edgeRepo.findConnected(currentId);\n        for (const edge of edges) {\n          const neighborId = edge.sourceId === currentId ? edge.targetId : edge.sourceId;\n          if (!visited.has(neighborId)) {\n            queue.push(neighborId);\n          }\n        }\n      }\n\n      if (component.length > 0) {\n        components.push(component);\n      }\n    }\n\n    // Sort by size (largest first)\n    return components.sort((a, b) => b.length - a.length);\n  }\n\n  /**\n   * Get the component containing a specific node\n   */\n  async getComponentContaining(nodeId: string): Promise<string[]> {\n    const visited = new Set<string>();\n    const component: string[] = [];\n    const queue = [nodeId];\n\n    while (queue.length > 0) {\n      const currentId = queue.shift();\n      if (!currentId || visited.has(currentId)) continue;\n\n      visited.add(currentId);\n      component.push(currentId);\n\n      const edges = await this.edgeRepo.findConnected(currentId);\n      for (const edge of edges) {\n        const neighborId = edge.sourceId === currentId ? edge.targetId : edge.sourceId;\n        if (!visited.has(neighborId)) {\n          queue.push(neighborId);\n        }\n      }\n    }\n\n    return component;\n  }\n}\n","/**\n * Base error class for ZettelScript\n */\nexport class ZettelScriptError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'ZettelScriptError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n/**\n * Database-related errors\n */\nexport class DatabaseError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'DATABASE_ERROR', details);\n    this.name = 'DatabaseError';\n  }\n}\n\n/**\n * Parsing errors (markdown, frontmatter, wikilinks)\n */\nexport class ParseError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public filePath: string,\n    public line?: number,\n    public column?: number,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'PARSE_ERROR', { filePath, line, column, ...details });\n    this.name = 'ParseError';\n  }\n}\n\n/**\n * Link resolution errors\n */\nexport class ResolutionError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public linkText: string,\n    public candidates?: string[],\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'RESOLUTION_ERROR', { linkText, candidates, ...details });\n    this.name = 'ResolutionError';\n  }\n}\n\n/**\n * Validation errors\n */\nexport class ValidationError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public issues: Array<{\n      path: string;\n      message: string;\n      severity: 'error' | 'warning';\n    }>,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'VALIDATION_ERROR', { issues, ...details });\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'CONFIG_ERROR', details);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Graph operation errors\n */\nexport class GraphError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'GRAPH_ERROR', details);\n    this.name = 'GraphError';\n  }\n}\n\n/**\n * Retrieval/embedding errors\n */\nexport class RetrievalError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'RETRIEVAL_ERROR', details);\n    this.name = 'RetrievalError';\n  }\n}\n\n/**\n * File system errors\n */\nexport class FileSystemError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public filePath: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'FILESYSTEM_ERROR', { filePath, ...details });\n    this.name = 'FileSystemError';\n  }\n}\n\n/**\n * Manuscript/continuity errors\n */\nexport class ContinuityError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public issueType: string,\n    public nodeId: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'CONTINUITY_ERROR', { issueType, nodeId, ...details });\n    this.name = 'ContinuityError';\n  }\n}\n\n/**\n * Proposal/writeback errors\n */\nexport class ProposalError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public proposalId: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'PROPOSAL_ERROR', { proposalId, ...details });\n    this.name = 'ProposalError';\n  }\n}\n\n/**\n * Embedding provider errors\n */\nexport class EmbeddingError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public provider: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'EMBEDDING_ERROR', { provider, ...details });\n    this.name = 'EmbeddingError';\n  }\n}\n","import Database from 'better-sqlite3';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport * as schema from './schema.js';\nimport { DatabaseError } from '../../core/errors.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport type DrizzleDB = ReturnType<typeof drizzle<typeof schema>>;\n\n// SQL for creating FTS5 virtual table\nconst FTS5_SCHEMA = `\nCREATE VIRTUAL TABLE IF NOT EXISTS chunks_fts USING fts5(\n  chunk_id,\n  node_id,\n  text,\n  tokenize='porter'\n);\n`;\n\n// SQL for creating FTS triggers to keep it in sync\nconst FTS5_TRIGGERS = `\nCREATE TRIGGER IF NOT EXISTS chunks_ai AFTER INSERT ON chunks BEGIN\n  INSERT INTO chunks_fts(chunk_id, node_id, text)\n  VALUES (new.chunk_id, new.node_id, new.text);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS chunks_ad AFTER DELETE ON chunks BEGIN\n  DELETE FROM chunks_fts WHERE chunk_id = old.chunk_id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS chunks_au AFTER UPDATE ON chunks BEGIN\n  DELETE FROM chunks_fts WHERE chunk_id = old.chunk_id;\n  INSERT INTO chunks_fts(chunk_id, node_id, text)\n  VALUES (new.chunk_id, new.node_id, new.text);\nEND;\n`;\n\n// Schema version for migrations\n// Increment this when adding new tables or making schema changes\nconst SCHEMA_VERSION = 4;\n\n/**\n * Database connection manager for ZettelScript\n */\nexport class ConnectionManager {\n  private static instance: ConnectionManager | null = null;\n  private sqlite: Database.Database | null = null;\n  private db: DrizzleDB | null = null;\n  private dbPath: string;\n\n  private constructor(dbPath: string) {\n    this.dbPath = dbPath;\n  }\n\n  /**\n   * Get or create the singleton connection manager\n   */\n  static getInstance(dbPath?: string): ConnectionManager {\n    if (!ConnectionManager.instance) {\n      if (!dbPath) {\n        throw new DatabaseError('Database path required for initial connection');\n      }\n      ConnectionManager.instance = new ConnectionManager(dbPath);\n    }\n    return ConnectionManager.instance;\n  }\n\n  /**\n   * Reset the singleton (useful for testing)\n   */\n  static resetInstance(): void {\n    if (ConnectionManager.instance) {\n      ConnectionManager.instance.close();\n      ConnectionManager.instance = null;\n    }\n  }\n\n  /**\n   * Initialize the database connection and schema\n   */\n  async initialize(): Promise<void> {\n    if (this.db) {\n      return; // Already initialized\n    }\n\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(this.dbPath);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n\n      // Open SQLite connection\n      this.sqlite = new Database(this.dbPath);\n\n      // Enable WAL mode for better concurrent performance\n      this.sqlite.pragma('journal_mode = WAL');\n      this.sqlite.pragma('foreign_keys = ON');\n      this.sqlite.pragma('synchronous = NORMAL');\n\n      // Create Drizzle instance\n      this.db = drizzle(this.sqlite, { schema });\n\n      // Run migrations/schema creation\n      await this.migrate();\n    } catch (error) {\n      throw new DatabaseError(`Failed to initialize database: ${error}`, {\n        path: this.dbPath,\n        error: String(error),\n      });\n    }\n  }\n\n  /**\n   * Run database migrations\n   */\n  private async migrate(): Promise<void> {\n    if (!this.sqlite) {\n      throw new DatabaseError('SQLite connection not initialized');\n    }\n\n    // Check current schema version\n    let currentVersion = 0;\n    try {\n      const result = this.sqlite.prepare('SELECT version FROM schema_version LIMIT 1').get() as\n        | { version: number }\n        | undefined;\n      if (result) {\n        currentVersion = result.version;\n      }\n    } catch (error) {\n      // Only ignore \"no such table\" errors - other errors should propagate\n      const message = error instanceof Error ? error.message : String(error);\n      if (!message.includes('no such table')) {\n        throw new Error(`Database schema check failed: ${message}`);\n      }\n      // Table doesn't exist yet - will be created below\n    }\n\n    if (currentVersion >= SCHEMA_VERSION) {\n      return; // Already up to date\n    }\n\n    // Run initial schema creation\n    this.sqlite.exec(`\n      -- Schema version tracking\n      CREATE TABLE IF NOT EXISTS schema_version (\n        version INTEGER PRIMARY KEY\n      );\n\n      -- Nodes\n      CREATE TABLE IF NOT EXISTS nodes (\n        node_id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        title TEXT NOT NULL,\n        path TEXT NOT NULL UNIQUE,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL,\n        content_hash TEXT,\n        metadata TEXT,\n        is_ghost INTEGER NOT NULL DEFAULT 0\n      );\n\n      -- Edges with version ranges\n      CREATE TABLE IF NOT EXISTS edges (\n        edge_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        edge_type TEXT NOT NULL,\n        strength REAL,\n        provenance TEXT NOT NULL,\n        created_at TEXT NOT NULL,\n        version_start TEXT,\n        version_end TEXT,\n        attributes TEXT\n      );\n\n      -- Version history\n      CREATE TABLE IF NOT EXISTS versions (\n        version_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        content_hash TEXT NOT NULL,\n        parent_version_id TEXT,\n        created_at TEXT NOT NULL,\n        summary TEXT\n      );\n\n      -- Mention candidates\n      CREATE TABLE IF NOT EXISTS mention_candidates (\n        candidate_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        surface_text TEXT NOT NULL,\n        span_start INTEGER,\n        span_end INTEGER,\n        confidence REAL NOT NULL,\n        reasons TEXT,\n        status TEXT DEFAULT 'new'\n      );\n\n      -- Chunks for retrieval\n      CREATE TABLE IF NOT EXISTS chunks (\n        chunk_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        text TEXT NOT NULL,\n        offset_start INTEGER NOT NULL,\n        offset_end INTEGER NOT NULL,\n        version_id TEXT NOT NULL,\n        token_count INTEGER\n      );\n\n      -- Aliases\n      CREATE TABLE IF NOT EXISTS aliases (\n        alias_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        alias TEXT NOT NULL\n      );\n\n      -- Graph metrics cache\n      CREATE TABLE IF NOT EXISTS graph_metrics (\n        node_id TEXT PRIMARY KEY REFERENCES nodes(node_id) ON DELETE CASCADE,\n        centrality_pagerank REAL,\n        cluster_id TEXT,\n        computed_at TEXT NOT NULL\n      );\n\n      -- Proposals\n      CREATE TABLE IF NOT EXISTS proposals (\n        proposal_id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        description TEXT NOT NULL,\n        diff TEXT NOT NULL,\n        status TEXT DEFAULT 'pending',\n        created_at TEXT NOT NULL,\n        applied_at TEXT,\n        metadata TEXT\n      );\n\n      -- Unresolved links\n      CREATE TABLE IF NOT EXISTS unresolved_links (\n        link_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_text TEXT NOT NULL,\n        span_start INTEGER,\n        span_end INTEGER,\n        created_at TEXT NOT NULL\n      );\n\n      -- Constellations (saved graph views)\n      CREATE TABLE IF NOT EXISTS constellations (\n        constellation_id TEXT PRIMARY KEY,\n        name TEXT NOT NULL UNIQUE,\n        description TEXT,\n        hidden_node_types TEXT,\n        hidden_edge_types TEXT,\n        show_ghosts INTEGER NOT NULL DEFAULT 1,\n        ghost_threshold INTEGER NOT NULL DEFAULT 1,\n        camera_x REAL,\n        camera_y REAL,\n        camera_zoom REAL,\n        focus_node_ids TEXT,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL\n      );\n\n      -- Node embeddings (for semantic wormholes)\n      CREATE TABLE IF NOT EXISTS node_embeddings (\n        embedding_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL UNIQUE REFERENCES nodes(node_id) ON DELETE CASCADE,\n        embedding TEXT NOT NULL,\n        model TEXT NOT NULL,\n        dimensions INTEGER NOT NULL,\n        content_hash TEXT NOT NULL,\n        computed_at TEXT NOT NULL\n      );\n\n      -- Wormhole rejections (tracks rejected semantic suggestions)\n      CREATE TABLE IF NOT EXISTS wormhole_rejections (\n        rejection_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        source_content_hash TEXT NOT NULL,\n        target_content_hash TEXT NOT NULL,\n        rejected_at TEXT NOT NULL\n      );\n\n      -- Candidate edges (Phase 2: Suggestions)\n      CREATE TABLE IF NOT EXISTS candidate_edges (\n        suggestion_id TEXT PRIMARY KEY,\n        from_id TEXT NOT NULL,\n        to_id TEXT NOT NULL,\n        suggested_edge_type TEXT NOT NULL,\n        from_id_norm TEXT NOT NULL,\n        to_id_norm TEXT NOT NULL,\n        status TEXT NOT NULL DEFAULT 'suggested',\n        status_changed_at TEXT,\n        signals TEXT,\n        reasons TEXT,\n        provenance TEXT,\n        created_at TEXT NOT NULL,\n        last_computed_at TEXT NOT NULL,\n        last_seen_at TEXT,\n        writeback_status TEXT,\n        writeback_reason TEXT,\n        approved_edge_id TEXT\n      );\n\n      -- Performance indexes\n      CREATE INDEX IF NOT EXISTS idx_nodes_title ON nodes(title COLLATE NOCASE);\n      CREATE INDEX IF NOT EXISTS idx_nodes_type ON nodes(type);\n      CREATE INDEX IF NOT EXISTS idx_nodes_path ON nodes(path);\n      CREATE INDEX IF NOT EXISTS idx_nodes_ghost ON nodes(is_ghost);\n      CREATE INDEX IF NOT EXISTS idx_edges_source ON edges(source_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_target ON edges(target_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_type ON edges(edge_type);\n      CREATE INDEX IF NOT EXISTS idx_edges_source_target ON edges(source_id, target_id);\n      CREATE INDEX IF NOT EXISTS idx_versions_node ON versions(node_id);\n      CREATE INDEX IF NOT EXISTS idx_versions_parent ON versions(parent_version_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_source ON mention_candidates(source_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_target ON mention_candidates(target_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_status ON mention_candidates(status);\n      CREATE INDEX IF NOT EXISTS idx_chunks_node ON chunks(node_id);\n      CREATE INDEX IF NOT EXISTS idx_chunks_version ON chunks(version_id);\n      CREATE INDEX IF NOT EXISTS idx_aliases_node ON aliases(node_id);\n      CREATE INDEX IF NOT EXISTS idx_aliases_alias ON aliases(alias COLLATE NOCASE);\n      CREATE INDEX IF NOT EXISTS idx_proposals_node ON proposals(node_id);\n      CREATE INDEX IF NOT EXISTS idx_proposals_status ON proposals(status);\n      CREATE INDEX IF NOT EXISTS idx_unresolved_source ON unresolved_links(source_id);\n      CREATE INDEX IF NOT EXISTS idx_unresolved_target ON unresolved_links(target_text);\n      CREATE INDEX IF NOT EXISTS idx_constellations_name ON constellations(name);\n      CREATE INDEX IF NOT EXISTS idx_embeddings_node ON node_embeddings(node_id);\n      CREATE INDEX IF NOT EXISTS idx_embeddings_model ON node_embeddings(model);\n      CREATE INDEX IF NOT EXISTS idx_rejections_source ON wormhole_rejections(source_id);\n      CREATE INDEX IF NOT EXISTS idx_rejections_target ON wormhole_rejections(target_id);\n      CREATE INDEX IF NOT EXISTS idx_rejections_pair ON wormhole_rejections(source_id, target_id);\n      CREATE INDEX IF NOT EXISTS idx_candidate_from ON candidate_edges(from_id);\n      CREATE INDEX IF NOT EXISTS idx_candidate_to ON candidate_edges(to_id);\n      CREATE INDEX IF NOT EXISTS idx_candidate_status ON candidate_edges(status);\n      CREATE INDEX IF NOT EXISTS idx_candidate_norm ON candidate_edges(from_id_norm, to_id_norm, suggested_edge_type);\n    `);\n\n    // Create FTS5 virtual table\n    this.sqlite.exec(FTS5_SCHEMA);\n    this.sqlite.exec(FTS5_TRIGGERS);\n\n    // Update schema version\n    this.sqlite.exec(`\n      DELETE FROM schema_version;\n      INSERT INTO schema_version (version) VALUES (${SCHEMA_VERSION});\n    `);\n  }\n\n  /**\n   * Get the Drizzle database instance\n   */\n  getDb(): DrizzleDB {\n    if (!this.db) {\n      throw new DatabaseError('Database not initialized. Call initialize() first.');\n    }\n    return this.db;\n  }\n\n  /**\n   * Get the raw SQLite database instance (for FTS5 and custom queries)\n   */\n  getSqlite(): Database.Database {\n    if (!this.sqlite) {\n      throw new DatabaseError('Database not initialized. Call initialize() first.');\n    }\n    return this.sqlite;\n  }\n\n  /**\n   * Close the database connection\n   */\n  close(): void {\n    if (this.sqlite) {\n      this.sqlite.close();\n      this.sqlite = null;\n      this.db = null;\n    }\n  }\n\n  /**\n   * Run a transaction\n   */\n  transaction<T>(fn: () => T): T {\n    const sqlite = this.getSqlite();\n    return sqlite.transaction(fn)();\n  }\n\n  /**\n   * Check if the database is initialized\n   */\n  isInitialized(): boolean {\n    return this.db !== null;\n  }\n\n  /**\n   * Get database statistics\n   */\n  getStats(): {\n    nodeCount: number;\n    edgeCount: number;\n    chunkCount: number;\n    dbSizeBytes: number;\n  } {\n    const sqlite = this.getSqlite();\n\n    const nodeCount = (\n      sqlite.prepare('SELECT COUNT(*) as count FROM nodes').get() as { count: number }\n    ).count;\n    const edgeCount = (\n      sqlite.prepare('SELECT COUNT(*) as count FROM edges').get() as { count: number }\n    ).count;\n    const chunkCount = (\n      sqlite.prepare('SELECT COUNT(*) as count FROM chunks').get() as { count: number }\n    ).count;\n\n    const stats = fs.statSync(this.dbPath);\n\n    return {\n      nodeCount,\n      edgeCount,\n      chunkCount,\n      dbSizeBytes: stats.size,\n    };\n  }\n}\n\n/**\n * Helper to get a database connection for a vault\n */\nexport async function getDatabase(vaultPath: string): Promise<DrizzleDB> {\n  const dbPath = path.join(vaultPath, '.zettelscript', 'zettelscript.db');\n  const manager = ConnectionManager.getInstance(dbPath);\n  await manager.initialize();\n  return manager.getDb();\n}\n\n/**\n * Helper to get raw SQLite for FTS5 queries\n */\nexport function getRawSqlite(vaultPath: string): Database.Database {\n  const dbPath = path.join(vaultPath, '.zettelscript', 'zettelscript.db');\n  const manager = ConnectionManager.getInstance(dbPath);\n  return manager.getSqlite();\n}\n","import { sqliteTable, text, real, integer, index } from 'drizzle-orm/sqlite-core';\n\n// ============================================================================\n// Nodes Table\n// ============================================================================\n\nexport const nodes = sqliteTable(\n  'nodes',\n  {\n    nodeId: text('node_id').primaryKey(),\n    type: text('type').notNull(),\n    title: text('title').notNull(),\n    path: text('path').notNull().unique(),\n    createdAt: text('created_at').notNull(),\n    updatedAt: text('updated_at').notNull(),\n    contentHash: text('content_hash'),\n    metadata: text('metadata', { mode: 'json' }),\n    isGhost: integer('is_ghost').notNull().default(0), // 0 = real node, 1 = ghost\n  },\n  (table) => [\n    index('idx_nodes_title').on(table.title),\n    index('idx_nodes_type').on(table.type),\n    index('idx_nodes_path').on(table.path),\n    index('idx_nodes_ghost').on(table.isGhost),\n  ]\n);\n\n// ============================================================================\n// Edges Table\n// ============================================================================\n\nexport const edges = sqliteTable(\n  'edges',\n  {\n    edgeId: text('edge_id').primaryKey(),\n    sourceId: text('source_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    targetId: text('target_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    edgeType: text('edge_type').notNull(),\n    strength: real('strength'),\n    provenance: text('provenance').notNull(),\n    createdAt: text('created_at').notNull(),\n    versionStart: text('version_start'),\n    versionEnd: text('version_end'),\n    attributes: text('attributes', { mode: 'json' }),\n  },\n  (table) => [\n    index('idx_edges_source').on(table.sourceId),\n    index('idx_edges_target').on(table.targetId),\n    index('idx_edges_type').on(table.edgeType),\n    index('idx_edges_source_target').on(table.sourceId, table.targetId),\n  ]\n);\n\n// ============================================================================\n// Versions Table\n// ============================================================================\n\nexport const versions = sqliteTable(\n  'versions',\n  {\n    versionId: text('version_id').primaryKey(),\n    nodeId: text('node_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    contentHash: text('content_hash').notNull(),\n    parentVersionId: text('parent_version_id'),\n    createdAt: text('created_at').notNull(),\n    summary: text('summary'),\n  },\n  (table) => [\n    index('idx_versions_node').on(table.nodeId),\n    index('idx_versions_parent').on(table.parentVersionId),\n  ]\n);\n\n// ============================================================================\n// Mention Candidates Table\n// ============================================================================\n\nexport const mentionCandidates = sqliteTable(\n  'mention_candidates',\n  {\n    candidateId: text('candidate_id').primaryKey(),\n    sourceId: text('source_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    targetId: text('target_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    surfaceText: text('surface_text').notNull(),\n    spanStart: integer('span_start'),\n    spanEnd: integer('span_end'),\n    confidence: real('confidence').notNull(),\n    reasons: text('reasons', { mode: 'json' }),\n    status: text('status').default('new'),\n  },\n  (table) => [\n    index('idx_mentions_source').on(table.sourceId),\n    index('idx_mentions_target').on(table.targetId),\n    index('idx_mentions_status').on(table.status),\n  ]\n);\n\n// ============================================================================\n// Chunks Table\n// ============================================================================\n\nexport const chunks = sqliteTable(\n  'chunks',\n  {\n    chunkId: text('chunk_id').primaryKey(),\n    nodeId: text('node_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    text: text('text').notNull(),\n    offsetStart: integer('offset_start').notNull(),\n    offsetEnd: integer('offset_end').notNull(),\n    versionId: text('version_id').notNull(),\n    tokenCount: integer('token_count'),\n  },\n  (table) => [\n    index('idx_chunks_node').on(table.nodeId),\n    index('idx_chunks_version').on(table.versionId),\n  ]\n);\n\n// ============================================================================\n// Aliases Table\n// ============================================================================\n\nexport const aliases = sqliteTable(\n  'aliases',\n  {\n    aliasId: text('alias_id').primaryKey(),\n    nodeId: text('node_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    alias: text('alias').notNull(),\n  },\n  (table) => [\n    index('idx_aliases_node').on(table.nodeId),\n    index('idx_aliases_alias').on(table.alias),\n  ]\n);\n\n// ============================================================================\n// Graph Metrics Cache\n// ============================================================================\n\nexport const graphMetrics = sqliteTable('graph_metrics', {\n  nodeId: text('node_id')\n    .primaryKey()\n    .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  centralityPagerank: real('centrality_pagerank'),\n  clusterId: text('cluster_id'),\n  computedAt: text('computed_at').notNull(),\n});\n\n// ============================================================================\n// Proposals Table\n// ============================================================================\n\nexport const proposals = sqliteTable(\n  'proposals',\n  {\n    proposalId: text('proposal_id').primaryKey(),\n    type: text('type').notNull(),\n    nodeId: text('node_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    description: text('description').notNull(),\n    diff: text('diff', { mode: 'json' }).notNull(),\n    status: text('status').default('pending'),\n    createdAt: text('created_at').notNull(),\n    appliedAt: text('applied_at'),\n    metadata: text('metadata', { mode: 'json' }),\n  },\n  (table) => [\n    index('idx_proposals_node').on(table.nodeId),\n    index('idx_proposals_status').on(table.status),\n  ]\n);\n\n// ============================================================================\n// Unresolved Links Table\n// ============================================================================\n\nexport const unresolvedLinks = sqliteTable(\n  'unresolved_links',\n  {\n    linkId: text('link_id').primaryKey(),\n    sourceId: text('source_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    targetText: text('target_text').notNull(),\n    spanStart: integer('span_start'),\n    spanEnd: integer('span_end'),\n    createdAt: text('created_at').notNull(),\n  },\n  (table) => [\n    index('idx_unresolved_source').on(table.sourceId),\n    index('idx_unresolved_target').on(table.targetText),\n  ]\n);\n\n// ============================================================================\n// Constellations Table (Saved Graph Views)\n// ============================================================================\n\nexport const constellations = sqliteTable(\n  'constellations',\n  {\n    constellationId: text('constellation_id').primaryKey(),\n    name: text('name').notNull().unique(),\n    description: text('description'),\n\n    // Filter state (JSON arrays)\n    hiddenNodeTypes: text('hidden_node_types', { mode: 'json' }),\n    hiddenEdgeTypes: text('hidden_edge_types', { mode: 'json' }),\n\n    // Ghost node config\n    showGhosts: integer('show_ghosts').notNull().default(1),\n    ghostThreshold: integer('ghost_threshold').notNull().default(1),\n\n    // Camera state\n    cameraX: real('camera_x'),\n    cameraY: real('camera_y'),\n    cameraZoom: real('camera_zoom'),\n\n    // Focus nodes (seed nodes for the view)\n    focusNodeIds: text('focus_node_ids', { mode: 'json' }),\n\n    // Timestamps\n    createdAt: text('created_at').notNull(),\n    updatedAt: text('updated_at').notNull(),\n  },\n  (table) => [index('idx_constellations_name').on(table.name)]\n);\n\n// ============================================================================\n// Node Embeddings Table (for Semantic Wormholes)\n// ============================================================================\n\nexport const nodeEmbeddings = sqliteTable(\n  'node_embeddings',\n  {\n    embeddingId: text('embedding_id').primaryKey(),\n    nodeId: text('node_id')\n      .notNull()\n      .unique()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    embedding: text('embedding', { mode: 'json' }).notNull(), // Float array as JSON\n    model: text('model').notNull(), // e.g., 'openai:text-embedding-3-small'\n    dimensions: integer('dimensions').notNull(),\n    contentHash: text('content_hash').notNull(), // To detect when recompute is needed\n    computedAt: text('computed_at').notNull(),\n  },\n  (table) => [\n    index('idx_embeddings_node').on(table.nodeId),\n    index('idx_embeddings_model').on(table.model),\n  ]\n);\n\n// ============================================================================\n// Wormhole Rejections Table (Tracks Rejected Semantic Suggestions)\n// ============================================================================\n\nexport const wormholeRejections = sqliteTable(\n  'wormhole_rejections',\n  {\n    rejectionId: text('rejection_id').primaryKey(),\n    sourceId: text('source_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    targetId: text('target_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    sourceContentHash: text('source_content_hash').notNull(),\n    targetContentHash: text('target_content_hash').notNull(),\n    rejectedAt: text('rejected_at').notNull(),\n  },\n  (table) => [\n    index('idx_rejections_source').on(table.sourceId),\n    index('idx_rejections_target').on(table.targetId),\n    index('idx_rejections_pair').on(table.sourceId, table.targetId),\n  ]\n);\n\n// ============================================================================\n// Candidate Edges Table (Phase 2: Suggestions)\n// ============================================================================\n\nexport const candidateEdges = sqliteTable(\n  'candidate_edges',\n  {\n    suggestionId: text('suggestion_id').primaryKey(),\n    fromId: text('from_id').notNull(),\n    toId: text('to_id').notNull(),\n    suggestedEdgeType: text('suggested_edge_type').notNull(),\n\n    // For undirected uniqueness (canonical ordering)\n    fromIdNorm: text('from_id_norm').notNull(),\n    toIdNorm: text('to_id_norm').notNull(),\n\n    // Status lifecycle\n    status: text('status').default('suggested').notNull(),\n    statusChangedAt: text('status_changed_at'),\n\n    // Evidence (merged from multiple sources)\n    signals: text('signals', { mode: 'json' }), // { semantic?, mentionCount?, graphProximity? }\n    reasons: text('reasons', { mode: 'json' }), // string[]\n    provenance: text('provenance', { mode: 'json' }), // array of evidence objects\n\n    // Timestamps\n    createdAt: text('created_at').notNull(),\n    lastComputedAt: text('last_computed_at').notNull(),\n    lastSeenAt: text('last_seen_at'),\n\n    // Writeback tracking\n    writebackStatus: text('writeback_status'),\n    writebackReason: text('writeback_reason'),\n    approvedEdgeId: text('approved_edge_id'),\n  },\n  (table) => [\n    index('idx_candidate_from').on(table.fromId),\n    index('idx_candidate_to').on(table.toId),\n    index('idx_candidate_status').on(table.status),\n    index('idx_candidate_norm').on(table.fromIdNorm, table.toIdNorm, table.suggestedEdgeType),\n  ]\n);\n\n// Type exports for use in repositories\nexport type NodeRow = typeof nodes.$inferSelect;\nexport type NewNodeRow = typeof nodes.$inferInsert;\n\nexport type EdgeRow = typeof edges.$inferSelect;\nexport type NewEdgeRow = typeof edges.$inferInsert;\n\nexport type VersionRow = typeof versions.$inferSelect;\nexport type NewVersionRow = typeof versions.$inferInsert;\n\nexport type MentionCandidateRow = typeof mentionCandidates.$inferSelect;\nexport type NewMentionCandidateRow = typeof mentionCandidates.$inferInsert;\n\nexport type ChunkRow = typeof chunks.$inferSelect;\nexport type NewChunkRow = typeof chunks.$inferInsert;\n\nexport type AliasRow = typeof aliases.$inferSelect;\nexport type NewAliasRow = typeof aliases.$inferInsert;\n\nexport type ProposalRow = typeof proposals.$inferSelect;\nexport type NewProposalRow = typeof proposals.$inferInsert;\n\nexport type ConstellationRow = typeof constellations.$inferSelect;\nexport type NewConstellationRow = typeof constellations.$inferInsert;\n\nexport type NodeEmbeddingRow = typeof nodeEmbeddings.$inferSelect;\nexport type NewNodeEmbeddingRow = typeof nodeEmbeddings.$inferInsert;\n\nexport type WormholeRejectionRow = typeof wormholeRejections.$inferSelect;\nexport type NewWormholeRejectionRow = typeof wormholeRejections.$inferInsert;\n\nexport type CandidateEdgeRow = typeof candidateEdges.$inferSelect;\nexport type NewCandidateEdgeRow = typeof candidateEdges.$inferInsert;\n","import { eq, like, and, inArray, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { nodes, aliases, type NodeRow, type NewNodeRow } from '../schema.js';\nimport type { Node, NodeType } from '../../../core/types/index.js';\n\n/**\n * Repository for Node CRUD operations\n */\nexport class NodeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new node\n   */\n  async create(data: Omit<Node, 'nodeId'>): Promise<Node> {\n    const nodeId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewNodeRow = {\n      nodeId,\n      type: data.type,\n      title: data.title,\n      path: data.path,\n      createdAt: data.createdAt || now,\n      updatedAt: data.updatedAt || now,\n      contentHash: data.contentHash ?? null,\n      metadata: data.metadata ?? null,\n      isGhost: data.isGhost ? 1 : 0,\n    };\n\n    await this.db.insert(nodes).values(row);\n\n    return this.rowToNode({ ...row, nodeId } as NodeRow);\n  }\n\n  /**\n   * Create or update a node by path\n   */\n  async upsert(data: Omit<Node, 'nodeId'> & { nodeId?: string }): Promise<Node> {\n    const now = new Date().toISOString();\n    const nodeId = data.nodeId || nanoid();\n\n    const existing = await this.findByPath(data.path);\n\n    if (existing) {\n      return this.update(existing.nodeId, {\n        ...data,\n        updatedAt: now,\n      });\n    }\n\n    const row: NewNodeRow = {\n      nodeId,\n      type: data.type,\n      title: data.title,\n      path: data.path,\n      createdAt: data.createdAt || now,\n      updatedAt: data.updatedAt || now,\n      contentHash: data.contentHash ?? null,\n      metadata: data.metadata ?? null,\n      isGhost: data.isGhost ? 1 : 0,\n    };\n\n    await this.db.insert(nodes).values(row);\n\n    return this.rowToNode({ ...row, nodeId } as NodeRow);\n  }\n\n  /**\n   * Find a node by ID\n   */\n  async findById(nodeId: string): Promise<Node | null> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.nodeId, nodeId)).limit(1);\n\n    return result[0] ? this.rowToNode(result[0]) : null;\n  }\n\n  /**\n   * Find a node by path\n   */\n  async findByPath(path: string): Promise<Node | null> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.path, path)).limit(1);\n\n    return result[0] ? this.rowToNode(result[0]) : null;\n  }\n\n  /**\n   * Find a node by title (case-insensitive)\n   */\n  async findByTitle(title: string): Promise<Node[]> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(sql`${nodes.title} COLLATE NOCASE = ${title}`);\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Find a node by title or alias\n   */\n  async findByTitleOrAlias(text: string): Promise<Node[]> {\n    // First check exact title match\n    const titleMatches = await this.db\n      .select()\n      .from(nodes)\n      .where(sql`${nodes.title} COLLATE NOCASE = ${text}`);\n\n    // Then check aliases\n    const aliasMatches = await this.db\n      .select({ node: nodes })\n      .from(aliases)\n      .innerJoin(nodes, eq(aliases.nodeId, nodes.nodeId))\n      .where(sql`${aliases.alias} COLLATE NOCASE = ${text}`);\n\n    // Combine and deduplicate\n    const nodeMap = new Map<string, NodeRow>();\n    for (const row of titleMatches) {\n      nodeMap.set(row.nodeId, row);\n    }\n    for (const { node } of aliasMatches) {\n      nodeMap.set(node.nodeId, node);\n    }\n\n    return Array.from(nodeMap.values()).map(this.rowToNode);\n  }\n\n  /**\n   * Find nodes by type\n   */\n  async findByType(type: NodeType): Promise<Node[]> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.type, type));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Get all nodes\n   */\n  async findAll(): Promise<Node[]> {\n    const result = await this.db.select().from(nodes);\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Find nodes by IDs\n   */\n  async findByIds(nodeIds: string[]): Promise<Node[]> {\n    if (nodeIds.length === 0) return [];\n\n    const result = await this.db.select().from(nodes).where(inArray(nodes.nodeId, nodeIds));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Search nodes by title pattern\n   */\n  async searchByTitle(pattern: string): Promise<Node[]> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(like(nodes.title, `%${pattern}%`));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Update a node\n   */\n  async update(nodeId: string, data: Partial<Omit<Node, 'nodeId'>>): Promise<Node> {\n    const updateData: Partial<NodeRow> = {};\n\n    if (data.type !== undefined) updateData.type = data.type;\n    if (data.title !== undefined) updateData.title = data.title;\n    if (data.path !== undefined) updateData.path = data.path;\n    if (data.contentHash !== undefined) updateData.contentHash = data.contentHash;\n    if (data.metadata !== undefined) updateData.metadata = data.metadata;\n    if (data.isGhost !== undefined) updateData.isGhost = data.isGhost ? 1 : 0;\n    updateData.updatedAt = data.updatedAt || new Date().toISOString();\n\n    await this.db.update(nodes).set(updateData).where(eq(nodes.nodeId, nodeId));\n\n    const updated = await this.findById(nodeId);\n    if (!updated) {\n      throw new Error(`Node ${nodeId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a node\n   */\n  async delete(nodeId: string): Promise<void> {\n    await this.db.delete(nodes).where(eq(nodes.nodeId, nodeId));\n  }\n\n  /**\n   * Delete nodes by path pattern\n   */\n  async deleteByPathPattern(pattern: string): Promise<number> {\n    const result = await this.db.delete(nodes).where(like(nodes.path, pattern));\n\n    return result.changes;\n  }\n\n  /**\n   * Count nodes\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(nodes);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count nodes by type\n   */\n  async countByType(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        type: nodes.type,\n        count: sql<number>`count(*)`,\n      })\n      .from(nodes)\n      .groupBy(nodes.type);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      counts[row.type] = row.count;\n    }\n    return counts;\n  }\n\n  /**\n   * Add an alias for a node\n   */\n  async addAlias(nodeId: string, alias: string): Promise<void> {\n    await this.db.insert(aliases).values({\n      aliasId: nanoid(),\n      nodeId,\n      alias,\n    });\n  }\n\n  /**\n   * Remove an alias\n   */\n  async removeAlias(nodeId: string, alias: string): Promise<void> {\n    await this.db\n      .delete(aliases)\n      .where(and(eq(aliases.nodeId, nodeId), sql`${aliases.alias} COLLATE NOCASE = ${alias}`));\n  }\n\n  /**\n   * Get aliases for a node\n   */\n  async getAliases(nodeId: string): Promise<string[]> {\n    const result = await this.db\n      .select({ alias: aliases.alias })\n      .from(aliases)\n      .where(eq(aliases.nodeId, nodeId));\n\n    return result.map((r) => r.alias);\n  }\n\n  /**\n   * Set aliases for a node (replaces existing)\n   */\n  async setAliases(nodeId: string, newAliases: string[]): Promise<void> {\n    // Delete existing aliases\n    await this.db.delete(aliases).where(eq(aliases.nodeId, nodeId));\n\n    // Insert new aliases\n    if (newAliases.length > 0) {\n      await this.db.insert(aliases).values(\n        newAliases.map((alias) => ({\n          aliasId: nanoid(),\n          nodeId,\n          alias,\n        }))\n      );\n    }\n  }\n\n  /**\n   * Find all ghost nodes\n   */\n  async findGhosts(): Promise<Node[]> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.isGhost, 1));\n    return result.map((row) => this.rowToNode(row));\n  }\n\n  /**\n   * Find all non-ghost (real) nodes\n   */\n  async findRealNodes(): Promise<Node[]> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.isGhost, 0));\n    return result.map((row) => this.rowToNode(row));\n  }\n\n  /**\n   * Count ghost nodes\n   */\n  async countGhosts(): Promise<number> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(nodes)\n      .where(eq(nodes.isGhost, 1));\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Create or find a ghost node by title.\n   * Ghosts are placeholder nodes for unresolved references.\n   * They have a synthetic path based on title.\n   */\n  async getOrCreateGhost(title: string): Promise<Node> {\n    // Check if ghost already exists\n    const existing = await this.db\n      .select()\n      .from(nodes)\n      .where(and(eq(nodes.isGhost, 1), sql`${nodes.title} COLLATE NOCASE = ${title}`))\n      .limit(1);\n\n    if (existing[0]) {\n      return this.rowToNode(existing[0]);\n    }\n\n    // Create new ghost\n    const nodeId = nanoid();\n    const now = new Date().toISOString();\n    const ghostPath = `__ghost__/${title.replace(/[^a-zA-Z0-9-_]/g, '_')}`;\n\n    const row: NewNodeRow = {\n      nodeId,\n      type: 'note', // Ghosts default to 'note' type\n      title,\n      path: ghostPath,\n      createdAt: now,\n      updatedAt: now,\n      contentHash: null,\n      metadata: null,\n      isGhost: 1,\n    };\n\n    await this.db.insert(nodes).values(row);\n\n    return this.rowToNode({ ...row, nodeId } as NodeRow);\n  }\n\n  /**\n   * Materialize a ghost - convert it to a real node when the file is created.\n   * Updates the ghost to be a real node with the actual path.\n   */\n  async materializeGhost(nodeId: string, realPath: string): Promise<Node> {\n    const ghost = await this.findById(nodeId);\n    if (!ghost || !ghost.isGhost) {\n      throw new Error(`Node ${nodeId} is not a ghost`);\n    }\n\n    return this.update(nodeId, {\n      path: realPath,\n      isGhost: false,\n      updatedAt: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Convert database row to Node type\n   */\n  private rowToNode(row: NodeRow): Node {\n    const node: Node = {\n      nodeId: row.nodeId,\n      type: row.type as NodeType,\n      title: row.title,\n      path: row.path,\n      createdAt: row.createdAt,\n      updatedAt: row.updatedAt,\n    };\n\n    if (row.contentHash != null) node.contentHash = row.contentHash;\n    if (row.metadata != null) node.metadata = row.metadata as Record<string, unknown>;\n    if (row.isGhost === 1) node.isGhost = true;\n\n    return node;\n  }\n}\n","import { eq, and, or, inArray, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { edges, nodes, type EdgeRow, type NewEdgeRow } from '../schema.js';\nimport type { Edge, EdgeType, EdgeProvenance } from '../../../core/types/index.js';\n\n/**\n * Repository for Edge CRUD operations\n */\nexport class EdgeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new edge\n   */\n  async create(data: Omit<Edge, 'edgeId' | 'createdAt'>): Promise<Edge> {\n    const edgeId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewEdgeRow = {\n      edgeId,\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      edgeType: data.edgeType,\n      strength: data.strength ?? null,\n      provenance: data.provenance,\n      createdAt: now,\n      versionStart: data.versionStart ?? null,\n      versionEnd: data.versionEnd ?? null,\n      attributes: data.attributes ?? null,\n    };\n\n    await this.db.insert(edges).values(row);\n\n    return this.rowToEdge({ ...row, edgeId, createdAt: now } as EdgeRow);\n  }\n\n  /**\n   * Create or update an edge\n   */\n  async upsert(data: Omit<Edge, 'edgeId' | 'createdAt'>): Promise<Edge> {\n    // Check for existing edge with same source, target, and type\n    const existing = await this.findBySourceTargetType(data.sourceId, data.targetId, data.edgeType);\n\n    if (existing) {\n      return this.update(existing.edgeId, data);\n    }\n\n    return this.create(data);\n  }\n\n  /**\n   * Find an edge by ID\n   */\n  async findById(edgeId: string): Promise<Edge | null> {\n    const result = await this.db.select().from(edges).where(eq(edges.edgeId, edgeId)).limit(1);\n\n    return result[0] ? this.rowToEdge(result[0]) : null;\n  }\n\n  /**\n   * Find edge by source, target, and type\n   */\n  async findBySourceTargetType(\n    sourceId: string,\n    targetId: string,\n    edgeType: EdgeType\n  ): Promise<Edge | null> {\n    const result = await this.db\n      .select()\n      .from(edges)\n      .where(\n        and(\n          eq(edges.sourceId, sourceId),\n          eq(edges.targetId, targetId),\n          eq(edges.edgeType, edgeType)\n        )\n      )\n      .limit(1);\n\n    return result[0] ? this.rowToEdge(result[0]) : null;\n  }\n\n  /**\n   * Find all outgoing edges from a node\n   */\n  async findOutgoing(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    let query = this.db.select().from(edges).where(eq(edges.sourceId, nodeId));\n\n    if (edgeTypes && edgeTypes.length > 0) {\n      query = this.db\n        .select()\n        .from(edges)\n        .where(and(eq(edges.sourceId, nodeId), inArray(edges.edgeType, edgeTypes)));\n    }\n\n    const result = await query;\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find all incoming edges to a node\n   */\n  async findIncoming(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    let query = this.db.select().from(edges).where(eq(edges.targetId, nodeId));\n\n    if (edgeTypes && edgeTypes.length > 0) {\n      query = this.db\n        .select()\n        .from(edges)\n        .where(and(eq(edges.targetId, nodeId), inArray(edges.edgeType, edgeTypes)));\n    }\n\n    const result = await query;\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find all edges connected to a node (both directions)\n   */\n  async findConnected(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    const condition = or(eq(edges.sourceId, nodeId), eq(edges.targetId, nodeId));\n\n    let result;\n    if (edgeTypes && edgeTypes.length > 0) {\n      result = await this.db\n        .select()\n        .from(edges)\n        .where(and(condition, inArray(edges.edgeType, edgeTypes)));\n    } else {\n      result = await this.db.select().from(edges).where(condition);\n    }\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find edges by type\n   */\n  async findByType(edgeType: EdgeType): Promise<Edge[]> {\n    const result = await this.db.select().from(edges).where(eq(edges.edgeType, edgeType));\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Get all edges, optionally filtered by edge types\n   */\n  async findAll(edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    if (edgeTypes && edgeTypes.length > 0) {\n      const result = await this.db.select().from(edges).where(inArray(edges.edgeType, edgeTypes));\n      return result.map(this.rowToEdge);\n    }\n    const result = await this.db.select().from(edges);\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find backlinks (explicit_link edges targeting a node)\n   */\n  async findBacklinks(nodeId: string): Promise<Edge[]> {\n    const result = await this.db\n      .select()\n      .from(edges)\n      .where(and(eq(edges.targetId, nodeId), eq(edges.edgeType, 'explicit_link')));\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Update an edge\n   */\n  async update(edgeId: string, data: Partial<Omit<Edge, 'edgeId' | 'createdAt'>>): Promise<Edge> {\n    const updateData: Partial<EdgeRow> = {};\n\n    if (data.sourceId !== undefined) updateData.sourceId = data.sourceId;\n    if (data.targetId !== undefined) updateData.targetId = data.targetId;\n    if (data.edgeType !== undefined) updateData.edgeType = data.edgeType;\n    if (data.strength !== undefined) updateData.strength = data.strength;\n    if (data.provenance !== undefined) updateData.provenance = data.provenance;\n    if (data.versionStart !== undefined) updateData.versionStart = data.versionStart;\n    if (data.versionEnd !== undefined) updateData.versionEnd = data.versionEnd;\n    if (data.attributes !== undefined) updateData.attributes = data.attributes;\n\n    await this.db.update(edges).set(updateData).where(eq(edges.edgeId, edgeId));\n\n    const updated = await this.findById(edgeId);\n    if (!updated) {\n      throw new Error(`Edge ${edgeId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete an edge\n   */\n  async delete(edgeId: string): Promise<void> {\n    await this.db.delete(edges).where(eq(edges.edgeId, edgeId));\n  }\n\n  /**\n   * Delete all edges for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(edges)\n      .where(or(eq(edges.sourceId, nodeId), eq(edges.targetId, nodeId)));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete edges by source and type\n   */\n  async deleteBySourceAndType(sourceId: string, edgeType: EdgeType): Promise<number> {\n    const result = await this.db\n      .delete(edges)\n      .where(and(eq(edges.sourceId, sourceId), eq(edges.edgeType, edgeType)));\n\n    return result.changes;\n  }\n\n  /**\n   * Count edges\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(edges);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count edges by type\n   */\n  async countByType(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        type: edges.edgeType,\n        count: sql<number>`count(*)`,\n      })\n      .from(edges)\n      .groupBy(edges.edgeType);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      counts[row.type] = row.count;\n    }\n    return counts;\n  }\n\n  /**\n   * Find neighbors with node info\n   */\n  async findNeighborsWithNodes(\n    nodeId: string,\n    edgeTypes?: EdgeType[]\n  ): Promise<\n    Array<{\n      edge: Edge;\n      node: { nodeId: string; title: string; type: string; path: string };\n      direction: 'incoming' | 'outgoing';\n    }>\n  > {\n    const outgoing = await this.findOutgoing(nodeId, edgeTypes);\n    const incoming = await this.findIncoming(nodeId, edgeTypes);\n\n    const results: Array<{\n      edge: Edge;\n      node: { nodeId: string; title: string; type: string; path: string };\n      direction: 'incoming' | 'outgoing';\n    }> = [];\n\n    // Get target nodes for outgoing edges\n    if (outgoing.length > 0) {\n      const targetIds = outgoing.map((e) => e.targetId);\n      const targetNodes = await this.db\n        .select({\n          nodeId: nodes.nodeId,\n          title: nodes.title,\n          type: nodes.type,\n          path: nodes.path,\n        })\n        .from(nodes)\n        .where(inArray(nodes.nodeId, targetIds));\n\n      const nodeMap = new Map(targetNodes.map((n) => [n.nodeId, n]));\n\n      for (const edge of outgoing) {\n        const node = nodeMap.get(edge.targetId);\n        if (node) {\n          results.push({ edge, node, direction: 'outgoing' });\n        }\n      }\n    }\n\n    // Get source nodes for incoming edges\n    if (incoming.length > 0) {\n      const sourceIds = incoming.map((e) => e.sourceId);\n      const sourceNodes = await this.db\n        .select({\n          nodeId: nodes.nodeId,\n          title: nodes.title,\n          type: nodes.type,\n          path: nodes.path,\n        })\n        .from(nodes)\n        .where(inArray(nodes.nodeId, sourceIds));\n\n      const nodeMap = new Map(sourceNodes.map((n) => [n.nodeId, n]));\n\n      for (const edge of incoming) {\n        const node = nodeMap.get(edge.sourceId);\n        if (node) {\n          results.push({ edge, node, direction: 'incoming' });\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Convert database row to Edge type\n   */\n  private rowToEdge(row: EdgeRow): Edge {\n    return {\n      edgeId: row.edgeId,\n      sourceId: row.sourceId,\n      targetId: row.targetId,\n      edgeType: row.edgeType as EdgeType,\n      provenance: row.provenance as EdgeProvenance,\n      createdAt: row.createdAt,\n      ...(row.strength != null && { strength: row.strength }),\n      ...(row.versionStart != null && { versionStart: row.versionStart }),\n      ...(row.versionEnd != null && { versionEnd: row.versionEnd }),\n      ...(row.attributes != null && { attributes: row.attributes as Record<string, unknown> }),\n    };\n  }\n}\n","import { eq, and, sql, desc } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { versions, type VersionRow, type NewVersionRow } from '../schema.js';\nimport type { Version } from '../../../core/types/index.js';\n\n/**\n * Repository for Version CRUD operations\n */\nexport class VersionRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new version\n   */\n  async create(data: Omit<Version, 'versionId' | 'createdAt'>): Promise<Version> {\n    const versionId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewVersionRow = {\n      versionId,\n      nodeId: data.nodeId,\n      contentHash: data.contentHash,\n      parentVersionId: data.parentVersionId ?? null,\n      createdAt: now,\n      summary: data.summary ?? null,\n    };\n\n    await this.db.insert(versions).values(row);\n\n    return this.rowToVersion({ ...row, versionId, createdAt: now } as VersionRow);\n  }\n\n  /**\n   * Find a version by ID\n   */\n  async findById(versionId: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.versionId, versionId))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Find all versions for a node\n   */\n  async findByNodeId(nodeId: string): Promise<Version[]> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.nodeId, nodeId))\n      .orderBy(desc(versions.createdAt));\n\n    return result.map(this.rowToVersion);\n  }\n\n  /**\n   * Find the latest version for a node\n   */\n  async findLatest(nodeId: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.nodeId, nodeId))\n      .orderBy(desc(versions.createdAt))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Find version by content hash\n   */\n  async findByContentHash(nodeId: string, contentHash: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(and(eq(versions.nodeId, nodeId), eq(versions.contentHash, contentHash)))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Get version chain (all ancestors)\n   */\n  async getVersionChain(versionId: string): Promise<Version[]> {\n    const chain: Version[] = [];\n    let currentId: string | null = versionId;\n\n    while (currentId) {\n      const version = await this.findById(currentId);\n      if (!version) break;\n      chain.push(version);\n      currentId = version.parentVersionId ?? null;\n    }\n\n    return chain;\n  }\n\n  /**\n   * Get child versions\n   */\n  async findChildren(versionId: string): Promise<Version[]> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.parentVersionId, versionId));\n\n    return result.map(this.rowToVersion);\n  }\n\n  /**\n   * Update a version (mainly for summary)\n   */\n  async update(versionId: string, data: Pick<Version, 'summary'>): Promise<Version> {\n    await this.db\n      .update(versions)\n      .set({ summary: data.summary ?? null })\n      .where(eq(versions.versionId, versionId));\n\n    const updated = await this.findById(versionId);\n    if (!updated) {\n      throw new Error(`Version ${versionId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a version\n   */\n  async delete(versionId: string): Promise<void> {\n    await this.db.delete(versions).where(eq(versions.versionId, versionId));\n  }\n\n  /**\n   * Delete all versions for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db.delete(versions).where(eq(versions.nodeId, nodeId));\n\n    return result.changes;\n  }\n\n  /**\n   * Count versions\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(versions);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count versions per node\n   */\n  async countPerNode(): Promise<Map<string, number>> {\n    const result = await this.db\n      .select({\n        nodeId: versions.nodeId,\n        count: sql<number>`count(*)`,\n      })\n      .from(versions)\n      .groupBy(versions.nodeId);\n\n    return new Map(result.map((r) => [r.nodeId, r.count]));\n  }\n\n  /**\n   * Convert database row to Version type\n   */\n  private rowToVersion(row: VersionRow): Version {\n    return {\n      versionId: row.versionId,\n      nodeId: row.nodeId,\n      contentHash: row.contentHash,\n      createdAt: row.createdAt,\n      ...(row.parentVersionId != null && { parentVersionId: row.parentVersionId }),\n      ...(row.summary != null && { summary: row.summary }),\n    };\n  }\n}\n","import { eq, sql, inArray } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport Database from 'better-sqlite3';\nimport { DrizzleDB } from '../connection.js';\nimport { chunks, type ChunkRow, type NewChunkRow } from '../schema.js';\nimport type { Chunk } from '../../../core/types/index.js';\n\n/**\n * Repository for Chunk CRUD operations including FTS5 queries\n */\nexport class ChunkRepository {\n  constructor(\n    private db: DrizzleDB,\n    private sqlite: Database.Database\n  ) {}\n\n  /**\n   * Create a new chunk\n   */\n  async create(data: Omit<Chunk, 'chunkId'>): Promise<Chunk> {\n    const chunkId = nanoid();\n\n    const row: NewChunkRow = {\n      chunkId,\n      nodeId: data.nodeId,\n      text: data.text,\n      offsetStart: data.offsetStart,\n      offsetEnd: data.offsetEnd,\n      versionId: data.versionId,\n      tokenCount: data.tokenCount ?? null,\n    };\n\n    await this.db.insert(chunks).values(row);\n\n    return this.rowToChunk({ ...row, chunkId } as ChunkRow);\n  }\n\n  /**\n   * Create multiple chunks\n   */\n  async createMany(dataArray: Array<Omit<Chunk, 'chunkId'>>): Promise<Chunk[]> {\n    if (dataArray.length === 0) return [];\n\n    const rows: NewChunkRow[] = dataArray.map((data) => ({\n      chunkId: nanoid(),\n      nodeId: data.nodeId,\n      text: data.text,\n      offsetStart: data.offsetStart,\n      offsetEnd: data.offsetEnd,\n      versionId: data.versionId,\n      tokenCount: data.tokenCount ?? null,\n    }));\n\n    await this.db.insert(chunks).values(rows);\n\n    return rows.map((row) => this.rowToChunk(row as ChunkRow));\n  }\n\n  /**\n   * Find a chunk by ID\n   */\n  async findById(chunkId: string): Promise<Chunk | null> {\n    const result = await this.db.select().from(chunks).where(eq(chunks.chunkId, chunkId)).limit(1);\n\n    return result[0] ? this.rowToChunk(result[0]) : null;\n  }\n\n  /**\n   * Find all chunks for a node\n   */\n  async findByNodeId(nodeId: string): Promise<Chunk[]> {\n    const result = await this.db\n      .select()\n      .from(chunks)\n      .where(eq(chunks.nodeId, nodeId))\n      .orderBy(chunks.offsetStart);\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Find chunks by version\n   */\n  async findByVersionId(versionId: string): Promise<Chunk[]> {\n    const result = await this.db\n      .select()\n      .from(chunks)\n      .where(eq(chunks.versionId, versionId))\n      .orderBy(chunks.offsetStart);\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Find chunks by IDs\n   */\n  async findByIds(chunkIds: string[]): Promise<Chunk[]> {\n    if (chunkIds.length === 0) return [];\n\n    const result = await this.db.select().from(chunks).where(inArray(chunks.chunkId, chunkIds));\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Full-text search using FTS5\n   */\n  searchFullText(\n    query: string,\n    limit: number = 20\n  ): Array<{ chunkId: string; nodeId: string; text: string; rank: number }> {\n    // Escape special FTS5 characters\n    const escapedQuery = query\n      .replace(/['\"]/g, '')\n      .replace(/\\*/g, '')\n      .split(/\\s+/)\n      .filter((word) => word.length > 0)\n      .join(' OR ');\n\n    if (!escapedQuery) return [];\n\n    const stmt = this.sqlite.prepare(`\n      SELECT\n        chunk_id as chunkId,\n        node_id as nodeId,\n        text,\n        rank\n      FROM chunks_fts\n      WHERE chunks_fts MATCH ?\n      ORDER BY rank\n      LIMIT ?\n    `);\n\n    return stmt.all(escapedQuery, limit) as Array<{\n      chunkId: string;\n      nodeId: string;\n      text: string;\n      rank: number;\n    }>;\n  }\n\n  /**\n   * Full-text search with BM25 ranking\n   */\n  searchBM25(\n    query: string,\n    limit: number = 20\n  ): Array<{ chunkId: string; nodeId: string; text: string; score: number }> {\n    const escapedQuery = query\n      .replace(/['\"]/g, '')\n      .replace(/\\*/g, '')\n      .split(/\\s+/)\n      .filter((word) => word.length > 0)\n      .join(' OR ');\n\n    if (!escapedQuery) return [];\n\n    const stmt = this.sqlite.prepare(`\n      SELECT\n        chunk_id as chunkId,\n        node_id as nodeId,\n        text,\n        bm25(chunks_fts) as score\n      FROM chunks_fts\n      WHERE chunks_fts MATCH ?\n      ORDER BY bm25(chunks_fts)\n      LIMIT ?\n    `);\n\n    return stmt.all(escapedQuery, limit) as Array<{\n      chunkId: string;\n      nodeId: string;\n      text: string;\n      score: number;\n    }>;\n  }\n\n  /**\n   * Update a chunk\n   */\n  async update(chunkId: string, data: Partial<Omit<Chunk, 'chunkId'>>): Promise<Chunk> {\n    const updateData: Partial<ChunkRow> = {};\n\n    if (data.nodeId !== undefined) updateData.nodeId = data.nodeId;\n    if (data.text !== undefined) updateData.text = data.text;\n    if (data.offsetStart !== undefined) updateData.offsetStart = data.offsetStart;\n    if (data.offsetEnd !== undefined) updateData.offsetEnd = data.offsetEnd;\n    if (data.versionId !== undefined) updateData.versionId = data.versionId;\n    if (data.tokenCount !== undefined) updateData.tokenCount = data.tokenCount;\n\n    await this.db.update(chunks).set(updateData).where(eq(chunks.chunkId, chunkId));\n\n    const updated = await this.findById(chunkId);\n    if (!updated) {\n      throw new Error(`Chunk ${chunkId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a chunk\n   */\n  async delete(chunkId: string): Promise<void> {\n    await this.db.delete(chunks).where(eq(chunks.chunkId, chunkId));\n  }\n\n  /**\n   * Delete all chunks for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db.delete(chunks).where(eq(chunks.nodeId, nodeId));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete chunks by version\n   */\n  async deleteByVersion(versionId: string): Promise<number> {\n    const result = await this.db.delete(chunks).where(eq(chunks.versionId, versionId));\n\n    return result.changes;\n  }\n\n  /**\n   * Count chunks\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(chunks);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Get total token count\n   */\n  async getTotalTokens(): Promise<number> {\n    const result = await this.db\n      .select({ total: sql<number>`COALESCE(SUM(token_count), 0)` })\n      .from(chunks);\n\n    return result[0]?.total ?? 0;\n  }\n\n  /**\n   * Convert database row to Chunk type\n   */\n  private rowToChunk(row: ChunkRow): Chunk {\n    return {\n      chunkId: row.chunkId,\n      nodeId: row.nodeId,\n      text: row.text,\n      offsetStart: row.offsetStart,\n      offsetEnd: row.offsetEnd,\n      versionId: row.versionId,\n      ...(row.tokenCount != null && { tokenCount: row.tokenCount }),\n    };\n  }\n}\n","import { eq, and, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport {\n  mentionCandidates,\n  type MentionCandidateRow,\n  type NewMentionCandidateRow,\n} from '../schema.js';\nimport type { MentionCandidate, MentionStatus } from '../../../core/types/index.js';\n\n/**\n * Repository for MentionCandidate CRUD operations\n */\nexport class MentionRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new mention candidate\n   */\n  async create(data: Omit<MentionCandidate, 'candidateId'>): Promise<MentionCandidate> {\n    const candidateId = nanoid();\n\n    const row: NewMentionCandidateRow = {\n      candidateId,\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      surfaceText: data.surfaceText,\n      spanStart: data.spanStart ?? null,\n      spanEnd: data.spanEnd ?? null,\n      confidence: data.confidence,\n      reasons: data.reasons ?? null,\n      status: data.status,\n    };\n\n    await this.db.insert(mentionCandidates).values(row);\n\n    return this.rowToMention({ ...row, candidateId } as MentionCandidateRow);\n  }\n\n  /**\n   * Create multiple mention candidates\n   */\n  async createMany(\n    dataArray: Array<Omit<MentionCandidate, 'candidateId'>>\n  ): Promise<MentionCandidate[]> {\n    if (dataArray.length === 0) return [];\n\n    const rows: NewMentionCandidateRow[] = dataArray.map((data) => ({\n      candidateId: nanoid(),\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      surfaceText: data.surfaceText,\n      spanStart: data.spanStart ?? null,\n      spanEnd: data.spanEnd ?? null,\n      confidence: data.confidence,\n      reasons: data.reasons ?? null,\n      status: data.status,\n    }));\n\n    await this.db.insert(mentionCandidates).values(rows);\n\n    return rows.map((row) => this.rowToMention(row as MentionCandidateRow));\n  }\n\n  /**\n   * Find a mention by ID\n   */\n  async findById(candidateId: string): Promise<MentionCandidate | null> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.candidateId, candidateId))\n      .limit(1);\n\n    return result[0] ? this.rowToMention(result[0]) : null;\n  }\n\n  /**\n   * Find mentions by source node\n   */\n  async findBySourceId(sourceId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.sourceId, sourceId));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find mentions by target node\n   */\n  async findByTargetId(targetId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.targetId, targetId));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find mentions by status\n   */\n  async findByStatus(status: MentionStatus): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.status, status));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find new (pending review) mentions for a source\n   */\n  async findNewForSource(sourceId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(and(eq(mentionCandidates.sourceId, sourceId), eq(mentionCandidates.status, 'new')));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Check if a mention already exists\n   */\n  async exists(\n    sourceId: string,\n    targetId: string,\n    spanStart: number,\n    spanEnd: number\n  ): Promise<boolean> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(mentionCandidates)\n      .where(\n        and(\n          eq(mentionCandidates.sourceId, sourceId),\n          eq(mentionCandidates.targetId, targetId),\n          eq(mentionCandidates.spanStart, spanStart),\n          eq(mentionCandidates.spanEnd, spanEnd)\n        )\n      );\n\n    return (result[0]?.count ?? 0) > 0;\n  }\n\n  /**\n   * Update mention status\n   */\n  async updateStatus(candidateId: string, status: MentionStatus): Promise<MentionCandidate> {\n    await this.db\n      .update(mentionCandidates)\n      .set({ status })\n      .where(eq(mentionCandidates.candidateId, candidateId));\n\n    const updated = await this.findById(candidateId);\n    if (!updated) {\n      throw new Error(`Mention ${candidateId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Approve a mention (converts to edge)\n   */\n  async approve(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'approved');\n  }\n\n  /**\n   * Reject a mention\n   */\n  async reject(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'rejected');\n  }\n\n  /**\n   * Defer a mention for later review\n   */\n  async defer(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'deferred');\n  }\n\n  /**\n   * Update confidence score\n   */\n  async updateConfidence(candidateId: string, confidence: number): Promise<MentionCandidate> {\n    await this.db\n      .update(mentionCandidates)\n      .set({ confidence })\n      .where(eq(mentionCandidates.candidateId, candidateId));\n\n    const updated = await this.findById(candidateId);\n    if (!updated) {\n      throw new Error(`Mention ${candidateId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a mention\n   */\n  async delete(candidateId: string): Promise<void> {\n    await this.db.delete(mentionCandidates).where(eq(mentionCandidates.candidateId, candidateId));\n  }\n\n  /**\n   * Delete all mentions for a source\n   */\n  async deleteForSource(sourceId: string): Promise<number> {\n    const result = await this.db\n      .delete(mentionCandidates)\n      .where(eq(mentionCandidates.sourceId, sourceId));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete rejected mentions\n   */\n  async deleteRejected(): Promise<number> {\n    const result = await this.db\n      .delete(mentionCandidates)\n      .where(eq(mentionCandidates.status, 'rejected'));\n\n    return result.changes;\n  }\n\n  /**\n   * Count mentions\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(mentionCandidates);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count mentions by status\n   */\n  async countByStatus(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        status: mentionCandidates.status,\n        count: sql<number>`count(*)`,\n      })\n      .from(mentionCandidates)\n      .groupBy(mentionCandidates.status);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      if (row.status) {\n        counts[row.status] = row.count;\n      }\n    }\n    return counts;\n  }\n\n  /**\n   * Get top mentions by confidence\n   */\n  async getTopByConfidence(limit: number = 10): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.status, 'new'))\n      .orderBy(sql`${mentionCandidates.confidence} DESC`)\n      .limit(limit);\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Convert database row to MentionCandidate type\n   */\n  private rowToMention(row: MentionCandidateRow): MentionCandidate {\n    return {\n      candidateId: row.candidateId,\n      sourceId: row.sourceId,\n      targetId: row.targetId,\n      surfaceText: row.surfaceText,\n      confidence: row.confidence,\n      status: (row.status ?? 'new') as MentionStatus,\n      ...(row.spanStart != null && { spanStart: row.spanStart }),\n      ...(row.spanEnd != null && { spanEnd: row.spanEnd }),\n      ...(row.reasons != null && { reasons: row.reasons as string[] }),\n    };\n  }\n}\n","import { sql } from 'drizzle-orm';\nimport { DrizzleDB } from '../connection.js';\nimport { unresolvedLinks, nodes } from '../schema.js';\n\n/**\n * Data structure for ghost nodes in the visualization\n */\nexport interface GhostNodeData {\n  /** The unresolved link text (e.g., \"Missing Note\") */\n  targetText: string;\n  /** All node IDs that reference this ghost */\n  sourceIds: string[];\n  /** Number of times this ghost is referenced */\n  referenceCount: number;\n  /** Timestamp of the earliest reference */\n  firstSeen: string;\n  /** Most recent reference timestamp (from unresolved_link or referencer's updatedAt) */\n  mostRecentRef?: string | undefined;\n}\n\n/**\n * Repository for unresolved link operations, primarily for ghost node visualization\n */\nexport class UnresolvedLinkRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Get all unresolved links grouped by target text for ghost node visualization.\n   * Returns ghost node data sorted by reference count (most referenced first).\n   */\n  async getGhostNodes(): Promise<GhostNodeData[]> {\n    const result = await this.db\n      .select({\n        targetText: unresolvedLinks.targetText,\n        sourceIds: sql<string>`GROUP_CONCAT(${unresolvedLinks.sourceId}, ',')`,\n        referenceCount: sql<number>`COUNT(*)`,\n        firstSeen: sql<string>`MIN(${unresolvedLinks.createdAt})`,\n      })\n      .from(unresolvedLinks)\n      .groupBy(unresolvedLinks.targetText)\n      .orderBy(sql`COUNT(*) DESC`);\n\n    return result\n      .filter((row) => row.targetText && row.targetText.trim() !== '')\n      .map((row) => ({\n        targetText: row.targetText,\n        sourceIds: row.sourceIds ? row.sourceIds.split(',') : [],\n        referenceCount: row.referenceCount,\n        firstSeen: row.firstSeen,\n      }));\n  }\n\n  /**\n   * Get ghost nodes with a minimum reference count threshold.\n   * Useful for filtering out rarely-referenced unresolved links.\n   */\n  async getGhostNodesWithThreshold(minReferenceCount: number): Promise<GhostNodeData[]> {\n    const result = await this.db\n      .select({\n        targetText: unresolvedLinks.targetText,\n        sourceIds: sql<string>`GROUP_CONCAT(${unresolvedLinks.sourceId}, ',')`,\n        referenceCount: sql<number>`COUNT(*)`,\n        firstSeen: sql<string>`MIN(${unresolvedLinks.createdAt})`,\n      })\n      .from(unresolvedLinks)\n      .groupBy(unresolvedLinks.targetText)\n      .having(sql`COUNT(*) >= ${minReferenceCount}`)\n      .orderBy(sql`COUNT(*) DESC`);\n\n    return result\n      .filter((row) => row.targetText && row.targetText.trim() !== '')\n      .map((row) => ({\n        targetText: row.targetText,\n        sourceIds: row.sourceIds ? row.sourceIds.split(',') : [],\n        referenceCount: row.referenceCount,\n        firstSeen: row.firstSeen,\n      }));\n  }\n\n  /**\n   * Count total number of unique unresolved link targets (ghost nodes)\n   */\n  async countGhostNodes(): Promise<number> {\n    const result = await this.db\n      .select({\n        count: sql<number>`COUNT(DISTINCT ${unresolvedLinks.targetText})`,\n      })\n      .from(unresolvedLinks);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count total number of unresolved link references\n   */\n  async countReferences(): Promise<number> {\n    const result = await this.db\n      .select({\n        count: sql<number>`COUNT(*)`,\n      })\n      .from(unresolvedLinks);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Get ghost nodes with most recent reference time included.\n   * The most recent reference time is the latest of:\n   * - The unresolved_link createdAt timestamp\n   * - The referencing node's updatedAt timestamp\n   *\n   * Returns ghost node data sorted by reference count (most referenced first).\n   */\n  async getGhostNodesWithRecency(): Promise<GhostNodeData[]> {\n    // Use a subquery to get the most recent reference time by joining with nodes\n    const result = await this.db\n      .select({\n        targetText: unresolvedLinks.targetText,\n        sourceIds: sql<string>`GROUP_CONCAT(${unresolvedLinks.sourceId}, ',')`,\n        referenceCount: sql<number>`COUNT(*)`,\n        firstSeen: sql<string>`MIN(${unresolvedLinks.createdAt})`,\n        mostRecentLinkCreated: sql<string>`MAX(${unresolvedLinks.createdAt})`,\n      })\n      .from(unresolvedLinks)\n      .groupBy(unresolvedLinks.targetText)\n      .orderBy(sql`COUNT(*) DESC`);\n\n    // For each ghost, get the most recent referencer's updatedAt\n    const ghostsWithRecency = await Promise.all(\n      result\n        .filter((row) => row.targetText && row.targetText.trim() !== '')\n        .map(async (row) => {\n          const sourceIds = row.sourceIds ? row.sourceIds.split(',') : [];\n\n          // Get the most recent updatedAt from referencing nodes\n          let mostRecentReferencerUpdate: string | null = null;\n          if (sourceIds.length > 0) {\n            const referencerResult = await this.db\n              .select({\n                maxUpdatedAt: sql<string>`MAX(${nodes.updatedAt})`,\n              })\n              .from(nodes)\n              .where(\n                sql`${nodes.nodeId} IN (${sql.join(\n                  sourceIds.map((id) => sql`${id}`),\n                  sql`, `\n                )})`\n              );\n\n            mostRecentReferencerUpdate = referencerResult[0]?.maxUpdatedAt ?? null;\n          }\n\n          // Use the more recent of link creation or referencer update\n          const mostRecentRef = [row.mostRecentLinkCreated, mostRecentReferencerUpdate]\n            .filter((t): t is string => t !== null)\n            .sort()\n            .reverse()[0];\n\n          return {\n            targetText: row.targetText,\n            sourceIds,\n            referenceCount: row.referenceCount,\n            firstSeen: row.firstSeen,\n            mostRecentRef,\n          };\n        })\n    );\n\n    return ghostsWithRecency;\n  }\n\n  /**\n   * Delete unresolved links by target text\n   */\n  async deleteByTargetText(targetText: string): Promise<number> {\n    const result = await this.db\n      .delete(unresolvedLinks)\n      .where(sql`${unresolvedLinks.targetText} COLLATE NOCASE = ${targetText}`);\n\n    return result.changes;\n  }\n}\n","import { eq } from 'drizzle-orm';\nimport { DrizzleDB } from '../connection.js';\nimport { constellations, ConstellationRow } from '../schema.js';\nimport { randomUUID } from 'node:crypto';\n\n/**\n * Constellation represents a saved graph view configuration\n */\nexport interface Constellation {\n  constellationId: string;\n  name: string;\n  description: string | undefined;\n  hiddenNodeTypes: string[];\n  hiddenEdgeTypes: string[];\n  showGhosts: boolean;\n  ghostThreshold: number;\n  cameraX: number | undefined;\n  cameraY: number | undefined;\n  cameraZoom: number | undefined;\n  focusNodeIds: string[] | undefined;\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * Input for creating a new constellation\n */\nexport interface CreateConstellationInput {\n  name: string;\n  description?: string;\n  hiddenNodeTypes?: string[];\n  hiddenEdgeTypes?: string[];\n  showGhosts?: boolean;\n  ghostThreshold?: number;\n  cameraX?: number;\n  cameraY?: number;\n  cameraZoom?: number;\n  focusNodeIds?: string[];\n}\n\n/**\n * Input for updating an existing constellation\n */\nexport interface UpdateConstellationInput {\n  name?: string;\n  description?: string;\n  hiddenNodeTypes?: string[];\n  hiddenEdgeTypes?: string[];\n  showGhosts?: boolean;\n  ghostThreshold?: number;\n  cameraX?: number;\n  cameraY?: number;\n  cameraZoom?: number;\n  focusNodeIds?: string[];\n}\n\n/**\n * Repository for constellation CRUD operations\n */\nexport class ConstellationRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Convert a database row to a Constellation object\n   */\n  private rowToConstellation(row: ConstellationRow): Constellation {\n    return {\n      constellationId: row.constellationId,\n      name: row.name,\n      description: row.description ?? undefined,\n      hiddenNodeTypes: (row.hiddenNodeTypes as string[] | null) ?? [],\n      hiddenEdgeTypes: (row.hiddenEdgeTypes as string[] | null) ?? [],\n      showGhosts: row.showGhosts === 1,\n      ghostThreshold: row.ghostThreshold,\n      cameraX: row.cameraX ?? undefined,\n      cameraY: row.cameraY ?? undefined,\n      cameraZoom: row.cameraZoom ?? undefined,\n      focusNodeIds: (row.focusNodeIds as string[] | null) ?? undefined,\n      createdAt: row.createdAt,\n      updatedAt: row.updatedAt,\n    };\n  }\n\n  /**\n   * Create a new constellation\n   */\n  async create(input: CreateConstellationInput): Promise<Constellation> {\n    const now = new Date().toISOString();\n    const id = randomUUID();\n\n    const row: typeof constellations.$inferInsert = {\n      constellationId: id,\n      name: input.name,\n      description: input.description ?? null,\n      hiddenNodeTypes: input.hiddenNodeTypes ?? [],\n      hiddenEdgeTypes: input.hiddenEdgeTypes ?? [],\n      showGhosts: input.showGhosts !== false ? 1 : 0,\n      ghostThreshold: input.ghostThreshold ?? 1,\n      cameraX: input.cameraX ?? null,\n      cameraY: input.cameraY ?? null,\n      cameraZoom: input.cameraZoom ?? null,\n      focusNodeIds: input.focusNodeIds ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    await this.db.insert(constellations).values(row);\n\n    return this.rowToConstellation(row as ConstellationRow);\n  }\n\n  /**\n   * Find a constellation by ID\n   */\n  async findById(id: string): Promise<Constellation | null> {\n    const rows = await this.db\n      .select()\n      .from(constellations)\n      .where(eq(constellations.constellationId, id))\n      .limit(1);\n\n    const row = rows[0];\n    if (!row) return null;\n    return this.rowToConstellation(row);\n  }\n\n  /**\n   * Find a constellation by name\n   */\n  async findByName(name: string): Promise<Constellation | null> {\n    const rows = await this.db\n      .select()\n      .from(constellations)\n      .where(eq(constellations.name, name))\n      .limit(1);\n\n    const row = rows[0];\n    if (!row) return null;\n    return this.rowToConstellation(row);\n  }\n\n  /**\n   * Find all constellations\n   */\n  async findAll(): Promise<Constellation[]> {\n    const rows = await this.db.select().from(constellations);\n    return rows.map((row) => this.rowToConstellation(row));\n  }\n\n  /**\n   * Update an existing constellation\n   */\n  async update(id: string, input: UpdateConstellationInput): Promise<Constellation | null> {\n    const existing = await this.findById(id);\n    if (!existing) return null;\n\n    const now = new Date().toISOString();\n\n    const updates: Partial<typeof constellations.$inferInsert> = {\n      updatedAt: now,\n    };\n\n    if (input.name !== undefined) updates.name = input.name;\n    if (input.description !== undefined) updates.description = input.description;\n    if (input.hiddenNodeTypes !== undefined) updates.hiddenNodeTypes = input.hiddenNodeTypes;\n    if (input.hiddenEdgeTypes !== undefined) updates.hiddenEdgeTypes = input.hiddenEdgeTypes;\n    if (input.showGhosts !== undefined) updates.showGhosts = input.showGhosts ? 1 : 0;\n    if (input.ghostThreshold !== undefined) updates.ghostThreshold = input.ghostThreshold;\n    if (input.cameraX !== undefined) updates.cameraX = input.cameraX;\n    if (input.cameraY !== undefined) updates.cameraY = input.cameraY;\n    if (input.cameraZoom !== undefined) updates.cameraZoom = input.cameraZoom;\n    if (input.focusNodeIds !== undefined) updates.focusNodeIds = input.focusNodeIds;\n\n    await this.db.update(constellations).set(updates).where(eq(constellations.constellationId, id));\n\n    return this.findById(id);\n  }\n\n  /**\n   * Delete a constellation by ID\n   */\n  async delete(id: string): Promise<boolean> {\n    const result = await this.db\n      .delete(constellations)\n      .where(eq(constellations.constellationId, id));\n\n    return (result as { changes?: number }).changes !== 0;\n  }\n\n  /**\n   * Delete a constellation by name\n   */\n  async deleteByName(name: string): Promise<boolean> {\n    const result = await this.db.delete(constellations).where(eq(constellations.name, name));\n\n    return (result as { changes?: number }).changes !== 0;\n  }\n}\n","import { eq, inArray, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport {\n  nodeEmbeddings,\n  nodes,\n  type NodeEmbeddingRow,\n  type NewNodeEmbeddingRow,\n} from '../schema.js';\nimport { getCircuitBreaker } from '../../../core/circuit-breaker.js';\n\n/**\n * Interface for a node's embedding data\n */\nexport interface NodeEmbedding {\n  embeddingId: string;\n  nodeId: string;\n  embedding: number[];\n  model: string;\n  dimensions: number;\n  contentHash: string;\n  computedAt: string;\n}\n\nexport interface CreateEmbeddingInput {\n  nodeId: string;\n  embedding: number[];\n  model: string;\n  dimensions: number;\n  contentHash: string;\n}\n\n/**\n * Repository for Node Embedding CRUD operations\n */\nexport class EmbeddingRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new embedding\n   * Protected by embeddings circuit breaker as this is part of the embedding pipeline\n   */\n  async create(data: CreateEmbeddingInput): Promise<NodeEmbedding | null> {\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('embeddings')) {\n      return null;\n    }\n\n    const embeddingId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewNodeEmbeddingRow = {\n      embeddingId,\n      nodeId: data.nodeId,\n      embedding: data.embedding,\n      model: data.model,\n      dimensions: data.dimensions,\n      contentHash: data.contentHash,\n      computedAt: now,\n    };\n\n    try {\n      await this.db.insert(nodeEmbeddings).values(row);\n      cb.recordSuccess('embeddings');\n      return this.rowToEmbedding({ ...row, embeddingId, computedAt: now } as NodeEmbeddingRow);\n    } catch (error) {\n      cb.recordFailure('embeddings', error instanceof Error ? error : new Error(String(error)));\n      return null;\n    }\n  }\n\n  /**\n   * Create or update an embedding for a node\n   * Protected by embeddings circuit breaker as this is part of the embedding pipeline\n   */\n  async upsert(data: CreateEmbeddingInput): Promise<NodeEmbedding | null> {\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('embeddings')) {\n      return null;\n    }\n\n    const existing = await this.findByNodeId(data.nodeId);\n\n    if (existing) {\n      return this.update(existing.embeddingId, data);\n    }\n\n    return this.create(data);\n  }\n\n  /**\n   * Find an embedding by ID\n   */\n  async findById(embeddingId: string): Promise<NodeEmbedding | null> {\n    const result = await this.db\n      .select()\n      .from(nodeEmbeddings)\n      .where(eq(nodeEmbeddings.embeddingId, embeddingId))\n      .limit(1);\n\n    return result[0] ? this.rowToEmbedding(result[0]) : null;\n  }\n\n  /**\n   * Find embedding by node ID\n   */\n  async findByNodeId(nodeId: string): Promise<NodeEmbedding | null> {\n    const result = await this.db\n      .select()\n      .from(nodeEmbeddings)\n      .where(eq(nodeEmbeddings.nodeId, nodeId))\n      .limit(1);\n\n    return result[0] ? this.rowToEmbedding(result[0]) : null;\n  }\n\n  /**\n   * Find all embeddings\n   * Protected by vectorDb circuit breaker as this powers similarity search\n   */\n  async findAll(): Promise<NodeEmbedding[]> {\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('vectorDb')) {\n      return [];\n    }\n\n    try {\n      const result = await this.db.select().from(nodeEmbeddings);\n      cb.recordSuccess('vectorDb');\n      return result.map((row) => this.rowToEmbedding(row));\n    } catch (error) {\n      cb.recordFailure('vectorDb', error instanceof Error ? error : new Error(String(error)));\n      return [];\n    }\n  }\n\n  /**\n   * Find embeddings by model\n   */\n  async findByModel(model: string): Promise<NodeEmbedding[]> {\n    const result = await this.db\n      .select()\n      .from(nodeEmbeddings)\n      .where(eq(nodeEmbeddings.model, model));\n\n    return result.map((row) => this.rowToEmbedding(row));\n  }\n\n  /**\n   * Find embeddings by node IDs\n   * Protected by vectorDb circuit breaker as this powers similarity search\n   */\n  async findByNodeIds(nodeIds: string[]): Promise<NodeEmbedding[]> {\n    if (nodeIds.length === 0) return [];\n\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('vectorDb')) {\n      return [];\n    }\n\n    try {\n      const result = await this.db\n        .select()\n        .from(nodeEmbeddings)\n        .where(inArray(nodeEmbeddings.nodeId, nodeIds));\n\n      cb.recordSuccess('vectorDb');\n      return result.map((row) => this.rowToEmbedding(row));\n    } catch (error) {\n      cb.recordFailure('vectorDb', error instanceof Error ? error : new Error(String(error)));\n      return [];\n    }\n  }\n\n  /**\n   * Find nodes that need embedding computation\n   * Returns nodes where either:\n   * - No embedding exists\n   * - The content hash has changed since last embedding\n   */\n  async findDirtyNodeIds(): Promise<string[]> {\n    // Get all nodes with their current content hash\n    const allNodes = await this.db\n      .select({\n        nodeId: nodes.nodeId,\n        contentHash: nodes.contentHash,\n      })\n      .from(nodes);\n\n    // Get all existing embeddings\n    const embeddings = await this.db\n      .select({\n        nodeId: nodeEmbeddings.nodeId,\n        contentHash: nodeEmbeddings.contentHash,\n      })\n      .from(nodeEmbeddings);\n\n    const embeddingMap = new Map(embeddings.map((e) => [e.nodeId, e.contentHash]));\n\n    const dirtyNodeIds: string[] = [];\n    for (const node of allNodes) {\n      const existingHash = embeddingMap.get(node.nodeId);\n      // Node is dirty if: no embedding exists, or content hash changed\n      if (!existingHash || existingHash !== node.contentHash) {\n        dirtyNodeIds.push(node.nodeId);\n      }\n    }\n\n    return dirtyNodeIds;\n  }\n\n  /**\n   * Update an embedding\n   * Protected by embeddings circuit breaker as this is part of the embedding pipeline\n   */\n  async update(embeddingId: string, data: Partial<CreateEmbeddingInput>): Promise<NodeEmbedding | null> {\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('embeddings')) {\n      return null;\n    }\n\n    const now = new Date().toISOString();\n    const updateData: Partial<NodeEmbeddingRow> = {\n      computedAt: now,\n    };\n\n    if (data.embedding !== undefined) updateData.embedding = data.embedding;\n    if (data.model !== undefined) updateData.model = data.model;\n    if (data.dimensions !== undefined) updateData.dimensions = data.dimensions;\n    if (data.contentHash !== undefined) updateData.contentHash = data.contentHash;\n\n    try {\n      await this.db\n        .update(nodeEmbeddings)\n        .set(updateData)\n        .where(eq(nodeEmbeddings.embeddingId, embeddingId));\n\n      cb.recordSuccess('embeddings');\n      const updated = await this.findById(embeddingId);\n      if (!updated) {\n        return null;\n      }\n      return updated;\n    } catch (error) {\n      cb.recordFailure('embeddings', error instanceof Error ? error : new Error(String(error)));\n      return null;\n    }\n  }\n\n  /**\n   * Delete an embedding by ID\n   */\n  async delete(embeddingId: string): Promise<void> {\n    await this.db.delete(nodeEmbeddings).where(eq(nodeEmbeddings.embeddingId, embeddingId));\n  }\n\n  /**\n   * Delete embedding by node ID\n   */\n  async deleteByNodeId(nodeId: string): Promise<void> {\n    await this.db.delete(nodeEmbeddings).where(eq(nodeEmbeddings.nodeId, nodeId));\n  }\n\n  /**\n   * Delete all embeddings for a model\n   */\n  async deleteByModel(model: string): Promise<number> {\n    const result = await this.db.delete(nodeEmbeddings).where(eq(nodeEmbeddings.model, model));\n\n    return result.changes;\n  }\n\n  /**\n   * Count embeddings\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(nodeEmbeddings);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count embeddings by model\n   */\n  async countByModel(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        model: nodeEmbeddings.model,\n        count: sql<number>`count(*)`,\n      })\n      .from(nodeEmbeddings)\n      .groupBy(nodeEmbeddings.model);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      counts[row.model] = row.count;\n    }\n    return counts;\n  }\n\n  /**\n   * Convert database row to NodeEmbedding type\n   */\n  private rowToEmbedding(row: NodeEmbeddingRow): NodeEmbedding {\n    return {\n      embeddingId: row.embeddingId,\n      nodeId: row.nodeId,\n      embedding: row.embedding as number[],\n      model: row.model,\n      dimensions: row.dimensions,\n      contentHash: row.contentHash,\n      computedAt: row.computedAt,\n    };\n  }\n}\n","/**\n * Circuit breaker pattern for graceful degradation\n *\n * Prevents cascading failures by tracking error rates and temporarily\n * disabling expensive operations that are consistently failing.\n *\n * States:\n * - CLOSED: Normal operation, calls pass through\n * - OPEN: Too many failures, calls are blocked (returns empty/warning)\n * - HALF_OPEN: Cooldown elapsed, allowing a probe call to test recovery\n */\n\nimport { getLogger } from './logger';\n\nconst logger = getLogger().child('circuit-breaker');\n\nexport enum CircuitState {\n  CLOSED = 'CLOSED',\n  OPEN = 'OPEN',\n  HALF_OPEN = 'HALF_OPEN',\n}\n\nexport type SubsystemName = 'embeddings' | 'vectorDb' | 'fts';\n\nexport interface CircuitBreakerConfig {\n  maxFailures: number;\n  cooldownMs: number;\n}\n\nexport interface CircuitStatus {\n  state: CircuitState;\n  failureCount: number;\n  totalFailures: number;\n  lastFailure: Date | null;\n  lastError: string | null;\n  cooldownRemainingMs: number | null;\n}\n\ninterface SubsystemState {\n  failureCount: number;\n  totalFailures: number;\n  lastFailure: number | null;\n  lastError: string | null;\n  recoveryInProgress: boolean;\n}\n\nconst DEFAULT_CONFIG: CircuitBreakerConfig = {\n  maxFailures: 3,\n  cooldownMs: 600_000, // 10 minutes\n};\n\n/**\n * Circuit breaker for a single subsystem\n */\nclass SubsystemBreaker {\n  private state: SubsystemState = {\n    failureCount: 0,\n    totalFailures: 0,\n    lastFailure: null,\n    lastError: null,\n    recoveryInProgress: false,\n  };\n\n  constructor(\n    private name: SubsystemName,\n    private config: CircuitBreakerConfig\n  ) {}\n\n  /**\n   * Check if a call should be attempted\n   * Returns true for CLOSED or HALF_OPEN states\n   */\n  shouldAttempt(): boolean {\n    // Under failure threshold = CLOSED state\n    if (this.state.failureCount < this.config.maxFailures) {\n      return true;\n    }\n\n    // Check if cooldown has elapsed\n    if (this.state.lastFailure !== null) {\n      const elapsed = Date.now() - this.state.lastFailure;\n      if (elapsed >= this.config.cooldownMs) {\n        // Prevent multiple concurrent recovery attempts\n        if (this.state.recoveryInProgress) {\n          return false;\n        }\n\n        // Enter HALF_OPEN state\n        this.state.recoveryInProgress = true;\n        logger.info(`${this.name}: circuit breaker entering HALF_OPEN - attempting recovery`);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Record a successful call (resets the breaker)\n   */\n  recordSuccess(): void {\n    const wasOpen = this.state.failureCount >= this.config.maxFailures;\n    this.state.failureCount = 0;\n    this.state.lastFailure = null;\n    this.state.lastError = null;\n    this.state.recoveryInProgress = false;\n\n    if (wasOpen) {\n      logger.info(`${this.name}: circuit breaker CLOSED - recovery successful`);\n    }\n  }\n\n  /**\n   * Record a failed call\n   */\n  recordFailure(error: Error): void {\n    this.state.failureCount++;\n    this.state.totalFailures++;\n    this.state.lastFailure = Date.now();\n    this.state.lastError = error.message;\n    this.state.recoveryInProgress = false;\n\n    logger.warn(\n      `${this.name}: failure ${this.state.failureCount}/${this.config.maxFailures}: ${error.message}`\n    );\n\n    if (this.state.failureCount >= this.config.maxFailures) {\n      logger.error(\n        `${this.name}: circuit breaker OPEN - will retry after ${this.config.cooldownMs / 1000}s cooldown`\n      );\n    }\n  }\n\n  /**\n   * Get the current state of this subsystem\n   */\n  getState(): CircuitState {\n    if (this.state.failureCount < this.config.maxFailures) {\n      return CircuitState.CLOSED;\n    }\n\n    if (this.state.lastFailure !== null) {\n      const elapsed = Date.now() - this.state.lastFailure;\n      if (elapsed >= this.config.cooldownMs) {\n        return CircuitState.HALF_OPEN;\n      }\n    }\n\n    return CircuitState.OPEN;\n  }\n\n  /**\n   * Get detailed status for reporting\n   */\n  getStatus(): CircuitStatus {\n    const state = this.getState();\n    let cooldownRemainingMs: number | null = null;\n\n    if (state === CircuitState.OPEN && this.state.lastFailure !== null) {\n      const elapsed = Date.now() - this.state.lastFailure;\n      cooldownRemainingMs = Math.max(0, this.config.cooldownMs - elapsed);\n    }\n\n    return {\n      state,\n      failureCount: this.state.failureCount,\n      totalFailures: this.state.totalFailures,\n      lastFailure: this.state.lastFailure ? new Date(this.state.lastFailure) : null,\n      lastError: this.state.lastError,\n      cooldownRemainingMs,\n    };\n  }\n\n  /**\n   * Reset the breaker (for testing or manual intervention)\n   */\n  reset(): void {\n    this.state = {\n      failureCount: 0,\n      totalFailures: 0,\n      lastFailure: null,\n      lastError: null,\n      recoveryInProgress: false,\n    };\n    logger.info(`${this.name}: circuit breaker manually reset`);\n  }\n}\n\n/**\n * Central circuit breaker manager for all subsystems\n */\nexport class CircuitBreaker {\n  private breakers: Map<SubsystemName, SubsystemBreaker> = new Map();\n  private config: CircuitBreakerConfig;\n\n  constructor(config: Partial<CircuitBreakerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  private getBreaker(subsystem: SubsystemName): SubsystemBreaker {\n    let breaker = this.breakers.get(subsystem);\n    if (!breaker) {\n      breaker = new SubsystemBreaker(subsystem, this.config);\n      this.breakers.set(subsystem, breaker);\n    }\n    return breaker;\n  }\n\n  /**\n   * Check if a call to the subsystem should be attempted\n   */\n  shouldAttempt(subsystem: SubsystemName): boolean {\n    return this.getBreaker(subsystem).shouldAttempt();\n  }\n\n  /**\n   * Record a successful call to the subsystem\n   */\n  recordSuccess(subsystem: SubsystemName): void {\n    this.getBreaker(subsystem).recordSuccess();\n  }\n\n  /**\n   * Record a failed call to the subsystem\n   */\n  recordFailure(subsystem: SubsystemName, error: Error): void {\n    this.getBreaker(subsystem).recordFailure(error);\n  }\n\n  /**\n   * Get the state of a subsystem\n   */\n  getState(subsystem: SubsystemName): CircuitState {\n    return this.getBreaker(subsystem).getState();\n  }\n\n  /**\n   * Get detailed status of a subsystem\n   */\n  getStatus(subsystem: SubsystemName): CircuitStatus {\n    return this.getBreaker(subsystem).getStatus();\n  }\n\n  /**\n   * Get status of all active subsystems\n   */\n  getAllStatus(): Record<SubsystemName, CircuitStatus> {\n    const result: Partial<Record<SubsystemName, CircuitStatus>> = {};\n    for (const [name, breaker] of this.breakers) {\n      result[name] = breaker.getStatus();\n    }\n    return result as Record<SubsystemName, CircuitStatus>;\n  }\n\n  /**\n   * Check if any subsystem is in a degraded state (OPEN or HALF_OPEN)\n   */\n  hasDegradedSubsystems(): boolean {\n    for (const breaker of this.breakers.values()) {\n      const state = breaker.getState();\n      if (state !== CircuitState.CLOSED) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get warnings for degraded subsystems (for health summary)\n   */\n  getWarnings(): string[] {\n    const warnings: string[] = [];\n    for (const [name, breaker] of this.breakers) {\n      const status = breaker.getStatus();\n      if (status.state === CircuitState.OPEN && status.cooldownRemainingMs !== null) {\n        const cooldownMinutes = Math.ceil(status.cooldownRemainingMs / 60_000);\n        warnings.push(`${name} disabled (cooldown ${cooldownMinutes}m)`);\n      } else if (status.state === CircuitState.HALF_OPEN) {\n        warnings.push(`${name} recovering`);\n      }\n    }\n    return warnings;\n  }\n\n  /**\n   * Reset a specific subsystem (for testing or manual intervention)\n   */\n  reset(subsystem: SubsystemName): void {\n    this.getBreaker(subsystem).reset();\n  }\n\n  /**\n   * Reset all subsystems\n   */\n  resetAll(): void {\n    for (const breaker of this.breakers.values()) {\n      breaker.reset();\n    }\n  }\n}\n\n// Default singleton instance\nlet defaultCircuitBreaker: CircuitBreaker | null = null;\n\n/**\n * Get the default circuit breaker instance\n */\nexport function getCircuitBreaker(): CircuitBreaker {\n  if (!defaultCircuitBreaker) {\n    defaultCircuitBreaker = new CircuitBreaker();\n  }\n  return defaultCircuitBreaker;\n}\n\n/**\n * Set the default circuit breaker instance (for testing)\n */\nexport function setCircuitBreaker(breaker: CircuitBreaker): void {\n  defaultCircuitBreaker = breaker;\n}\n\n/**\n * Reset the default circuit breaker instance (for testing)\n */\nexport function resetCircuitBreaker(): void {\n  defaultCircuitBreaker = null;\n}\n","import { eq, and, or, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport {\n  wormholeRejections,\n  type WormholeRejectionRow,\n  type NewWormholeRejectionRow,\n} from '../schema.js';\n\n/**\n * Interface for a wormhole rejection\n */\nexport interface WormholeRejection {\n  rejectionId: string;\n  sourceId: string;\n  targetId: string;\n  sourceContentHash: string;\n  targetContentHash: string;\n  rejectedAt: string;\n}\n\nexport interface CreateRejectionInput {\n  sourceId: string;\n  targetId: string;\n  sourceContentHash: string;\n  targetContentHash: string;\n}\n\n/**\n * Repository for Wormhole Rejection CRUD operations\n */\nexport class WormholeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new rejection\n   */\n  async createRejection(data: CreateRejectionInput): Promise<WormholeRejection> {\n    const rejectionId = nanoid();\n    const now = new Date().toISOString();\n\n    // Normalize pair order (smaller ID first) for consistent lookups\n    const [normalizedSourceId, normalizedTargetId, normalizedSourceHash, normalizedTargetHash] =\n      data.sourceId < data.targetId\n        ? [data.sourceId, data.targetId, data.sourceContentHash, data.targetContentHash]\n        : [data.targetId, data.sourceId, data.targetContentHash, data.sourceContentHash];\n\n    const row: NewWormholeRejectionRow = {\n      rejectionId,\n      sourceId: normalizedSourceId,\n      targetId: normalizedTargetId,\n      sourceContentHash: normalizedSourceHash,\n      targetContentHash: normalizedTargetHash,\n      rejectedAt: now,\n    };\n\n    await this.db.insert(wormholeRejections).values(row);\n\n    return this.rowToRejection({ ...row, rejectionId, rejectedAt: now } as WormholeRejectionRow);\n  }\n\n  /**\n   * Check if a pair is rejected (considering content hashes)\n   * Returns true if the pair was rejected AND the content hasn't changed\n   */\n  async isRejected(\n    sourceId: string,\n    targetId: string,\n    sourceContentHash: string,\n    targetContentHash: string\n  ): Promise<boolean> {\n    // Normalize pair order\n    const [normalizedSourceId, normalizedTargetId, normalizedSourceHash, normalizedTargetHash] =\n      sourceId < targetId\n        ? [sourceId, targetId, sourceContentHash, targetContentHash]\n        : [targetId, sourceId, targetContentHash, sourceContentHash];\n\n    const result = await this.db\n      .select()\n      .from(wormholeRejections)\n      .where(\n        and(\n          eq(wormholeRejections.sourceId, normalizedSourceId),\n          eq(wormholeRejections.targetId, normalizedTargetId),\n          eq(wormholeRejections.sourceContentHash, normalizedSourceHash),\n          eq(wormholeRejections.targetContentHash, normalizedTargetHash)\n        )\n      )\n      .limit(1);\n\n    return result.length > 0;\n  }\n\n  /**\n   * Check if any rejection exists for a pair (regardless of content hash)\n   */\n  async hasAnyRejection(sourceId: string, targetId: string): Promise<boolean> {\n    // Normalize pair order\n    const [normalizedSourceId, normalizedTargetId] =\n      sourceId < targetId ? [sourceId, targetId] : [targetId, sourceId];\n\n    const result = await this.db\n      .select()\n      .from(wormholeRejections)\n      .where(\n        and(\n          eq(wormholeRejections.sourceId, normalizedSourceId),\n          eq(wormholeRejections.targetId, normalizedTargetId)\n        )\n      )\n      .limit(1);\n\n    return result.length > 0;\n  }\n\n  /**\n   * Find all rejections\n   */\n  async findAll(): Promise<WormholeRejection[]> {\n    const result = await this.db.select().from(wormholeRejections);\n    return result.map((row) => this.rowToRejection(row));\n  }\n\n  /**\n   * Find rejections for a specific node\n   */\n  async findByNodeId(nodeId: string): Promise<WormholeRejection[]> {\n    const result = await this.db\n      .select()\n      .from(wormholeRejections)\n      .where(or(eq(wormholeRejections.sourceId, nodeId), eq(wormholeRejections.targetId, nodeId)));\n\n    return result.map((row) => this.rowToRejection(row));\n  }\n\n  /**\n   * Delete a rejection by ID\n   */\n  async delete(rejectionId: string): Promise<void> {\n    await this.db.delete(wormholeRejections).where(eq(wormholeRejections.rejectionId, rejectionId));\n  }\n\n  /**\n   * Delete rejections for a node pair\n   */\n  async deleteForPair(sourceId: string, targetId: string): Promise<void> {\n    // Normalize pair order\n    const [normalizedSourceId, normalizedTargetId] =\n      sourceId < targetId ? [sourceId, targetId] : [targetId, sourceId];\n\n    await this.db\n      .delete(wormholeRejections)\n      .where(\n        and(\n          eq(wormholeRejections.sourceId, normalizedSourceId),\n          eq(wormholeRejections.targetId, normalizedTargetId)\n        )\n      );\n  }\n\n  /**\n   * Delete all rejections for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(wormholeRejections)\n      .where(or(eq(wormholeRejections.sourceId, nodeId), eq(wormholeRejections.targetId, nodeId)));\n\n    return result.changes;\n  }\n\n  /**\n   * Clear all rejections\n   */\n  async clearAll(): Promise<number> {\n    const result = await this.db.delete(wormholeRejections);\n    return result.changes;\n  }\n\n  /**\n   * Count rejections\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(wormholeRejections);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Convert database row to WormholeRejection type\n   */\n  private rowToRejection(row: WormholeRejectionRow): WormholeRejection {\n    return {\n      rejectionId: row.rejectionId,\n      sourceId: row.sourceId,\n      targetId: row.targetId,\n      sourceContentHash: row.sourceContentHash,\n      targetContentHash: row.targetContentHash,\n      rejectedAt: row.rejectedAt,\n    };\n  }\n}\n","import { eq, and, inArray, sql } from 'drizzle-orm';\nimport { DrizzleDB } from '../connection.js';\nimport {\n  candidateEdges,\n  type CandidateEdgeRow,\n  type NewCandidateEdgeRow,\n} from '../schema.js';\nimport type {\n  CandidateEdge,\n  CandidateEdgeStatus,\n  CandidateEdgeSignals,\n  CandidateEdgeProvenance,\n  EdgeType,\n} from '../../../core/types/index.js';\n\n/**\n * Input for creating a new candidate edge\n */\nexport interface CreateCandidateEdgeInput {\n  suggestionId: string;\n  fromId: string;\n  toId: string;\n  suggestedEdgeType: EdgeType;\n  signals?: CandidateEdgeSignals;\n  reasons?: string[];\n  provenance?: CandidateEdgeProvenance[];\n}\n\n/**\n * Input for updating a candidate edge\n */\nexport interface UpdateCandidateEdgeInput {\n  status?: CandidateEdgeStatus;\n  signals?: CandidateEdgeSignals;\n  reasons?: string[];\n  provenance?: CandidateEdgeProvenance[];\n  writebackStatus?: string;\n  writebackReason?: string;\n  approvedEdgeId?: string;\n}\n\n/**\n * Repository for candidate edge CRUD operations.\n * Candidate edges are suggestions that may be approved or rejected.\n */\nexport class CandidateEdgeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new candidate edge\n   */\n  async create(data: CreateCandidateEdgeInput): Promise<CandidateEdge> {\n    const now = new Date().toISOString();\n\n    // Compute normalized IDs for undirected uniqueness\n    const [fromIdNorm, toIdNorm] =\n      data.fromId < data.toId ? [data.fromId, data.toId] : [data.toId, data.fromId];\n\n    const row: NewCandidateEdgeRow = {\n      suggestionId: data.suggestionId,\n      fromId: data.fromId,\n      toId: data.toId,\n      suggestedEdgeType: data.suggestedEdgeType,\n      fromIdNorm,\n      toIdNorm,\n      status: 'suggested',\n      signals: data.signals ?? null,\n      reasons: data.reasons ?? null,\n      provenance: data.provenance ?? null,\n      createdAt: now,\n      lastComputedAt: now,\n    };\n\n    await this.db.insert(candidateEdges).values(row);\n\n    return this.rowToCandidateEdge({\n      ...row,\n      statusChangedAt: null,\n      lastSeenAt: null,\n      writebackStatus: null,\n      writebackReason: null,\n      approvedEdgeId: null,\n    } as CandidateEdgeRow);\n  }\n\n  /**\n   * Create or update a candidate edge (upsert by suggestionId)\n   */\n  async upsert(data: CreateCandidateEdgeInput): Promise<CandidateEdge> {\n    const existing = await this.findById(data.suggestionId);\n\n    if (existing) {\n      // Update existing - merge signals and reasons\n      const mergedSignals = { ...existing.signals, ...data.signals };\n      const mergedReasons = [...new Set([...(existing.reasons || []), ...(data.reasons || [])])];\n      const mergedProvenance = [...(existing.provenance || []), ...(data.provenance || [])];\n\n      return this.update(data.suggestionId, {\n        signals: mergedSignals,\n        reasons: mergedReasons.slice(0, 3), // Keep top 3\n        provenance: mergedProvenance,\n      });\n    }\n\n    return this.create(data);\n  }\n\n  /**\n   * Find a candidate edge by ID\n   */\n  async findById(suggestionId: string): Promise<CandidateEdge | null> {\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(eq(candidateEdges.suggestionId, suggestionId))\n      .limit(1);\n\n    return result[0] ? this.rowToCandidateEdge(result[0]) : null;\n  }\n\n  /**\n   * Find candidate edges by status\n   */\n  async findByStatus(status: CandidateEdgeStatus): Promise<CandidateEdge[]> {\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(eq(candidateEdges.status, status));\n\n    return result.map((row) => this.rowToCandidateEdge(row));\n  }\n\n  /**\n   * Find candidate edges involving a specific node (as source or target)\n   */\n  async findByNodeId(nodeId: string): Promise<CandidateEdge[]> {\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(\n        sql`${candidateEdges.fromId} = ${nodeId} OR ${candidateEdges.toId} = ${nodeId}`\n      );\n\n    return result.map((row) => this.rowToCandidateEdge(row));\n  }\n\n  /**\n   * Find suggested candidate edges for nodes in a given set\n   */\n  async findSuggestedForNodes(nodeIds: string[]): Promise<CandidateEdge[]> {\n    if (nodeIds.length === 0) return [];\n\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(\n        and(\n          eq(candidateEdges.status, 'suggested'),\n          sql`(${candidateEdges.fromId} IN ${nodeIds} OR ${candidateEdges.toId} IN ${nodeIds})`\n        )\n      );\n\n    return result.map((row) => this.rowToCandidateEdge(row));\n  }\n\n  /**\n   * Find by normalized pair (for checking duplicates)\n   */\n  async findByNormalizedPair(\n    nodeId1: string,\n    nodeId2: string,\n    edgeType: EdgeType\n  ): Promise<CandidateEdge | null> {\n    const [fromIdNorm, toIdNorm] = nodeId1 < nodeId2 ? [nodeId1, nodeId2] : [nodeId2, nodeId1];\n\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(\n        and(\n          eq(candidateEdges.fromIdNorm, fromIdNorm),\n          eq(candidateEdges.toIdNorm, toIdNorm),\n          eq(candidateEdges.suggestedEdgeType, edgeType)\n        )\n      )\n      .limit(1);\n\n    return result[0] ? this.rowToCandidateEdge(result[0]) : null;\n  }\n\n  /**\n   * Update a candidate edge\n   */\n  async update(suggestionId: string, data: UpdateCandidateEdgeInput): Promise<CandidateEdge> {\n    const updateData: Partial<CandidateEdgeRow> = {\n      lastComputedAt: new Date().toISOString(),\n    };\n\n    if (data.status !== undefined) {\n      updateData.status = data.status;\n      updateData.statusChangedAt = new Date().toISOString();\n    }\n    if (data.signals !== undefined) updateData.signals = data.signals;\n    if (data.reasons !== undefined) updateData.reasons = data.reasons;\n    if (data.provenance !== undefined) updateData.provenance = data.provenance;\n    if (data.writebackStatus !== undefined) updateData.writebackStatus = data.writebackStatus;\n    if (data.writebackReason !== undefined) updateData.writebackReason = data.writebackReason;\n    if (data.approvedEdgeId !== undefined) updateData.approvedEdgeId = data.approvedEdgeId;\n\n    await this.db\n      .update(candidateEdges)\n      .set(updateData)\n      .where(eq(candidateEdges.suggestionId, suggestionId));\n\n    const updated = await this.findById(suggestionId);\n    if (!updated) {\n      throw new Error(`Candidate edge ${suggestionId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Update status of a candidate edge\n   */\n  async updateStatus(\n    suggestionId: string,\n    status: CandidateEdgeStatus,\n    approvedEdgeId?: string\n  ): Promise<CandidateEdge> {\n    const updateData: UpdateCandidateEdgeInput = { status };\n    if (approvedEdgeId !== undefined) {\n      updateData.approvedEdgeId = approvedEdgeId;\n    }\n    return this.update(suggestionId, updateData);\n  }\n\n  /**\n   * Mark last seen time for candidate edges (for pruning stale suggestions)\n   */\n  async markSeen(suggestionIds: string[]): Promise<void> {\n    if (suggestionIds.length === 0) return;\n\n    await this.db\n      .update(candidateEdges)\n      .set({ lastSeenAt: new Date().toISOString() })\n      .where(inArray(candidateEdges.suggestionId, suggestionIds));\n  }\n\n  /**\n   * Delete a candidate edge\n   */\n  async delete(suggestionId: string): Promise<void> {\n    await this.db.delete(candidateEdges).where(eq(candidateEdges.suggestionId, suggestionId));\n  }\n\n  /**\n   * Delete all candidate edges for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(candidateEdges)\n      .where(\n        sql`${candidateEdges.fromId} = ${nodeId} OR ${candidateEdges.toId} = ${nodeId}`\n      );\n\n    return result.changes;\n  }\n\n  /**\n   * Count candidate edges by status\n   */\n  async countByStatus(): Promise<Record<CandidateEdgeStatus, number>> {\n    const result = await this.db\n      .select({\n        status: candidateEdges.status,\n        count: sql<number>`count(*)`,\n      })\n      .from(candidateEdges)\n      .groupBy(candidateEdges.status);\n\n    const counts: Record<string, number> = {\n      suggested: 0,\n      approved: 0,\n      rejected: 0,\n    };\n    for (const row of result) {\n      counts[row.status] = row.count;\n    }\n    return counts as Record<CandidateEdgeStatus, number>;\n  }\n\n  /**\n   * Count total candidate edges\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(candidateEdges);\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Convert database row to CandidateEdge type\n   */\n  private rowToCandidateEdge(row: CandidateEdgeRow): CandidateEdge {\n    const result: CandidateEdge = {\n      suggestionId: row.suggestionId,\n      fromId: row.fromId,\n      toId: row.toId,\n      suggestedEdgeType: row.suggestedEdgeType as EdgeType,\n      status: row.status as CandidateEdgeStatus,\n      createdAt: row.createdAt,\n      lastComputedAt: row.lastComputedAt,\n    };\n\n    if (row.statusChangedAt) result.statusChangedAt = row.statusChangedAt;\n    if (row.signals) result.signals = row.signals as CandidateEdgeSignals;\n    if (row.reasons) result.reasons = row.reasons as string[];\n    if (row.provenance) result.provenance = row.provenance as CandidateEdgeProvenance[];\n    if (row.lastSeenAt) result.lastSeenAt = row.lastSeenAt;\n    if (row.writebackStatus) result.writebackStatus = row.writebackStatus;\n    if (row.writebackReason) result.writebackReason = row.writebackReason;\n    if (row.approvedEdgeId) result.approvedEdgeId = row.approvedEdgeId;\n\n    return result;\n  }\n}\n","import { unified } from 'unified';\nimport remarkParse from 'remark-parse';\nimport remarkFrontmatter from 'remark-frontmatter';\nimport remarkStringify from 'remark-stringify';\nimport type { Root, Content, Heading, Paragraph, Text } from 'mdast';\nimport type { WikiLink, Frontmatter, NodeType } from '../core/types/index.js';\nimport { parseFrontmatter, extractTitle, extractNodeType, extractAliases } from './frontmatter.js';\nimport { extractWikilinks, type WikiLinkParseResult } from './wikilink.js';\nimport type { ExclusionZone } from './exclusions.js';\n\nexport interface ParsedMarkdown {\n  frontmatter: Frontmatter | null;\n  title: string;\n  type: NodeType;\n  aliases: string[];\n  content: string;\n  contentStartOffset: number;\n  links: WikiLink[];\n  exclusionZones: ExclusionZone[];\n  headings: Array<{\n    level: number;\n    text: string;\n    position: { start: number; end: number };\n  }>;\n  paragraphs: Array<{\n    text: string;\n    position: { start: number; end: number };\n  }>;\n  ast: Root;\n}\n\n/**\n * Create the unified markdown processor\n */\nfunction createProcessor() {\n  return unified().use(remarkParse).use(remarkFrontmatter, ['yaml']).use(remarkStringify);\n}\n\n/**\n * Parse a markdown document into structured data\n */\nexport function parseMarkdown(source: string, filePath: string): ParsedMarkdown {\n  // Parse frontmatter first\n  const { frontmatter, content, contentStartOffset } = parseFrontmatter(source, filePath);\n\n  // Extract title, type, and aliases from frontmatter\n  const title = extractTitle(frontmatter, content, filePath);\n  const type = extractNodeType(frontmatter) as NodeType;\n  const aliases = extractAliases(frontmatter);\n\n  // Extract wikilinks\n  const linkResult: WikiLinkParseResult = extractWikilinks(content, contentStartOffset);\n\n  // Parse AST\n  const processor = createProcessor();\n  const ast = processor.parse(source) as Root;\n\n  // Extract headings and paragraphs\n  const headings: ParsedMarkdown['headings'] = [];\n  const paragraphs: ParsedMarkdown['paragraphs'] = [];\n\n  function visitNode(node: Content) {\n    if (node.type === 'heading' && node.position) {\n      const heading = node as Heading;\n      const text = getTextContent(heading);\n      headings.push({\n        level: heading.depth,\n        text,\n        position: {\n          start: node.position.start.offset ?? 0,\n          end: node.position.end.offset ?? 0,\n        },\n      });\n    }\n\n    if (node.type === 'paragraph' && node.position) {\n      const paragraph = node as Paragraph;\n      const text = getTextContent(paragraph);\n      paragraphs.push({\n        text,\n        position: {\n          start: node.position.start.offset ?? 0,\n          end: node.position.end.offset ?? 0,\n        },\n      });\n    }\n\n    // Recurse into children\n    if ('children' in node && Array.isArray(node.children)) {\n      for (const child of node.children) {\n        visitNode(child as Content);\n      }\n    }\n  }\n\n  for (const node of ast.children) {\n    visitNode(node);\n  }\n\n  return {\n    frontmatter,\n    title,\n    type,\n    aliases,\n    content,\n    contentStartOffset,\n    links: linkResult.links,\n    exclusionZones: linkResult.exclusionZones,\n    headings,\n    paragraphs,\n    ast,\n  };\n}\n\n/**\n * Get text content from an AST node\n */\nfunction getTextContent(node: Content): string {\n  if (node.type === 'text') {\n    return (node as Text).value;\n  }\n\n  if ('children' in node && Array.isArray(node.children)) {\n    return node.children.map((child) => getTextContent(child as Content)).join('');\n  }\n\n  return '';\n}\n\n/**\n * Extract plain text from markdown (strips formatting)\n */\nexport function extractPlainText(source: string): string {\n  const processor = createProcessor();\n  const ast = processor.parse(source) as Root;\n\n  function getText(node: Content): string {\n    if (node.type === 'text') {\n      return (node as Text).value;\n    }\n\n    if (node.type === 'code') {\n      return ''; // Skip code blocks\n    }\n\n    if (node.type === 'yaml') {\n      return ''; // Skip frontmatter\n    }\n\n    if ('children' in node && Array.isArray(node.children)) {\n      return node.children.map((child) => getText(child as Content)).join(' ');\n    }\n\n    return '';\n  }\n\n  return ast.children\n    .map((node) => getText(node))\n    .join('\\n')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n/**\n * Split content into sections based on headings\n */\nexport function splitIntoSections(parsed: ParsedMarkdown): Array<{\n  heading: string | null;\n  level: number;\n  content: string;\n  start: number;\n  end: number;\n}> {\n  const sections: Array<{\n    heading: string | null;\n    level: number;\n    content: string;\n    start: number;\n    end: number;\n  }> = [];\n\n  const source = parsed.content;\n\n  if (parsed.headings.length === 0) {\n    // No headings - entire content is one section\n    return [\n      {\n        heading: null,\n        level: 0,\n        content: source,\n        start: parsed.contentStartOffset,\n        end: parsed.contentStartOffset + source.length,\n      },\n    ];\n  }\n\n  // Content before first heading\n  const firstHeading = parsed.headings[0];\n  if (firstHeading && firstHeading.position.start > parsed.contentStartOffset) {\n    const contentBefore = source.slice(0, firstHeading.position.start - parsed.contentStartOffset);\n    if (contentBefore.trim()) {\n      sections.push({\n        heading: null,\n        level: 0,\n        content: contentBefore,\n        start: parsed.contentStartOffset,\n        end: firstHeading.position.start,\n      });\n    }\n  }\n\n  // Process each heading and its content\n  for (let i = 0; i < parsed.headings.length; i++) {\n    const heading = parsed.headings[i];\n    const nextHeading = parsed.headings[i + 1];\n\n    if (!heading) continue;\n\n    const start = heading.position.end;\n    const end = nextHeading\n      ? nextHeading.position.start\n      : parsed.contentStartOffset + source.length;\n\n    const content = source.slice(\n      start - parsed.contentStartOffset,\n      end - parsed.contentStartOffset\n    );\n\n    sections.push({\n      heading: heading.text,\n      level: heading.level,\n      content: content.trim(),\n      start,\n      end,\n    });\n  }\n\n  return sections;\n}\n\n/**\n * Split content into paragraphs\n */\nexport function splitIntoParagraphs(content: string): Array<{\n  text: string;\n  start: number;\n  end: number;\n}> {\n  const paragraphs: Array<{ text: string; start: number; end: number }> = [];\n\n  // Split by blank lines\n  const regex = /(?:\\r?\\n){2,}/g;\n  let lastEnd = 0;\n  let match;\n\n  while ((match = regex.exec(content)) !== null) {\n    const text = content.slice(lastEnd, match.index).trim();\n    if (text) {\n      paragraphs.push({\n        text,\n        start: lastEnd,\n        end: match.index,\n      });\n    }\n    lastEnd = match.index + match[0].length;\n  }\n\n  // Last paragraph\n  const remaining = content.slice(lastEnd).trim();\n  if (remaining) {\n    paragraphs.push({\n      text: remaining,\n      start: lastEnd,\n      end: content.length,\n    });\n  }\n\n  return paragraphs;\n}\n\n/**\n * Stringify markdown AST back to text\n */\nexport function stringifyMarkdown(ast: Root): string {\n  const processor = createProcessor();\n  return processor.stringify(ast);\n}\n","import { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport type { Frontmatter } from '../core/types/index.js';\nimport { ParseError } from '../core/errors.js';\n\n// Frontmatter delimiter\nconst FRONTMATTER_REGEX = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---\\r?\\n?/;\n\nexport interface ParsedDocument {\n  frontmatter: Frontmatter | null;\n  content: string;\n  contentStartOffset: number;\n}\n\n/**\n * Parse frontmatter from a markdown document\n */\nexport function parseFrontmatter(source: string, filePath: string): ParsedDocument {\n  const match = source.match(FRONTMATTER_REGEX);\n\n  if (!match) {\n    return {\n      frontmatter: null,\n      content: source,\n      contentStartOffset: 0,\n    };\n  }\n\n  const yamlContent = match[1];\n  const fullMatch = match[0];\n\n  if (!yamlContent) {\n    return {\n      frontmatter: null,\n      content: source,\n      contentStartOffset: 0,\n    };\n  }\n\n  try {\n    const parsed = parseYaml(yamlContent) as Frontmatter | null;\n\n    return {\n      frontmatter: parsed ?? null,\n      content: source.slice(fullMatch.length),\n      contentStartOffset: fullMatch.length,\n    };\n  } catch (error) {\n    throw new ParseError(`Invalid YAML frontmatter: ${error}`, filePath, undefined, undefined, {\n      yaml: yamlContent,\n    });\n  }\n}\n\n/**\n * Extract title from frontmatter or first heading\n */\nexport function extractTitle(\n  frontmatter: Frontmatter | null,\n  content: string,\n  filePath: string\n): string {\n  // Priority 1: frontmatter title\n  if (frontmatter?.title) {\n    return frontmatter.title;\n  }\n\n  // Priority 2: first H1 heading\n  const h1Match = content.match(/^#\\s+(.+)$/m);\n  if (h1Match?.[1]) {\n    return h1Match[1].trim();\n  }\n\n  // Priority 3: filename without extension\n  const filename = filePath.split('/').pop() || filePath;\n  return filename.replace(/\\.md$/, '');\n}\n\n/**\n * Extract node type from frontmatter\n */\nexport function extractNodeType(frontmatter: Frontmatter | null): string {\n  if (frontmatter?.type) {\n    return frontmatter.type;\n  }\n  return 'note';\n}\n\n/**\n * Extract aliases from frontmatter\n */\nexport function extractAliases(frontmatter: Frontmatter | null): string[] {\n  if (!frontmatter?.aliases) {\n    return [];\n  }\n\n  if (Array.isArray(frontmatter.aliases)) {\n    return frontmatter.aliases.filter((a) => typeof a === 'string');\n  }\n\n  return [];\n}\n\n/**\n * Serialize frontmatter back to YAML string\n */\nexport function serializeFrontmatter(frontmatter: Frontmatter): string {\n  return `---\\n${stringifyYaml(frontmatter)}---\\n`;\n}\n\n/**\n * Update frontmatter in a document\n */\nexport function updateFrontmatter(\n  source: string,\n  updates: Partial<Frontmatter>,\n  filePath: string\n): string {\n  const { frontmatter, content } = parseFrontmatter(source, filePath);\n\n  const newFrontmatter: Frontmatter = {\n    ...frontmatter,\n    ...updates,\n  };\n\n  return serializeFrontmatter(newFrontmatter) + content;\n}\n\n/**\n * Validate frontmatter schema\n */\nexport function validateFrontmatter(frontmatter: Frontmatter): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Check type is valid if present\n  const validTypes = [\n    'note',\n    'scene',\n    'character',\n    'location',\n    'object',\n    'event',\n    'concept',\n    'moc',\n    'timeline',\n    'draft',\n  ];\n\n  if (frontmatter.type && !validTypes.includes(frontmatter.type)) {\n    errors.push(`Invalid type \"${frontmatter.type}\". Valid types: ${validTypes.join(', ')}`);\n  }\n\n  // Check aliases is an array if present\n  if (frontmatter.aliases !== undefined && !Array.isArray(frontmatter.aliases)) {\n    errors.push('aliases must be an array');\n  }\n\n  // Check tags is an array if present\n  if (frontmatter.tags !== undefined && !Array.isArray(frontmatter.tags)) {\n    errors.push('tags must be an array');\n  }\n\n  // Check scene_order is a number if present\n  if (frontmatter.scene_order !== undefined && typeof frontmatter.scene_order !== 'number') {\n    errors.push('scene_order must be a number');\n  }\n\n  // Check characters is an array if present\n  if (frontmatter.characters !== undefined && !Array.isArray(frontmatter.characters)) {\n    errors.push('characters must be an array');\n  }\n\n  // Check locations is an array if present\n  if (frontmatter.locations !== undefined && !Array.isArray(frontmatter.locations)) {\n    errors.push('locations must be an array');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Exclusion zones for wikilink detection.\n * These areas should not be scanned for wikilinks or unlinked mentions.\n */\n\nexport interface ExclusionZone {\n  start: number;\n  end: number;\n  type: 'code_block' | 'inline_code' | 'url' | 'existing_link' | 'frontmatter' | 'html_tag';\n}\n\n// Regex patterns for exclusion zones\nconst PATTERNS = {\n  // Fenced code blocks (``` or ~~~)\n  codeBlock: /```[\\s\\S]*?```|~~~[\\s\\S]*?~~~/g,\n\n  // Inline code\n  inlineCode: /`[^`\\n]+`/g,\n\n  // URLs (http, https, ftp)\n  url: /(?:https?|ftp):\\/\\/[^\\s<>[\\]()]+/g,\n\n  // Markdown links [text](url) and ![alt](url)\n  markdownLink: /!?\\[[^\\]]*\\]\\([^)]+\\)/g,\n\n  // Existing wikilinks [[...]]\n  wikilink: /\\[\\[[^\\]]+\\]\\]/g,\n\n  // HTML tags\n  htmlTag: /<[^>]+>/g,\n\n  // HTML comments\n  htmlComment: /<!--[\\s\\S]*?-->/g,\n\n  // LaTeX math blocks\n  mathBlock: /\\$\\$[\\s\\S]*?\\$\\$/g,\n\n  // Inline math\n  inlineMath: /\\$[^$\\n]+\\$/g,\n};\n\n/**\n * Find all exclusion zones in a document\n */\nexport function findExclusionZones(\n  content: string,\n  frontmatterOffset: number = 0\n): ExclusionZone[] {\n  const zones: ExclusionZone[] = [];\n\n  // Add frontmatter zone if present\n  if (frontmatterOffset > 0) {\n    zones.push({\n      start: 0,\n      end: frontmatterOffset,\n      type: 'frontmatter',\n    });\n  }\n\n  // Find code blocks first (they have priority)\n  for (const match of content.matchAll(PATTERNS.codeBlock)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'code_block',\n      });\n    }\n  }\n\n  // Find inline code\n  for (const match of content.matchAll(PATTERNS.inlineCode)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'inline_code',\n      });\n    }\n  }\n\n  // Find URLs\n  for (const match of content.matchAll(PATTERNS.url)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'url',\n      });\n    }\n  }\n\n  // Find existing wikilinks\n  for (const match of content.matchAll(PATTERNS.wikilink)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'existing_link',\n      });\n    }\n  }\n\n  // Find markdown links\n  for (const match of content.matchAll(PATTERNS.markdownLink)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'existing_link',\n      });\n    }\n  }\n\n  // Find HTML tags\n  for (const match of content.matchAll(PATTERNS.htmlTag)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'html_tag',\n      });\n    }\n  }\n\n  // Find HTML comments\n  for (const match of content.matchAll(PATTERNS.htmlComment)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'html_tag',\n      });\n    }\n  }\n\n  // Find math blocks (treat as code)\n  for (const match of content.matchAll(PATTERNS.mathBlock)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'code_block',\n      });\n    }\n  }\n\n  // Find inline math\n  for (const match of content.matchAll(PATTERNS.inlineMath)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'inline_code',\n      });\n    }\n  }\n\n  // Sort by start position and merge overlapping zones\n  return mergeZones(zones);\n}\n\n/**\n * Merge overlapping exclusion zones\n */\nfunction mergeZones(zones: ExclusionZone[]): ExclusionZone[] {\n  if (zones.length === 0) return [];\n\n  // Sort by start position\n  zones.sort((a, b) => a.start - b.start);\n\n  const merged: ExclusionZone[] = [];\n  let current = zones[0];\n\n  if (!current) return [];\n\n  for (let i = 1; i < zones.length; i++) {\n    const next = zones[i];\n    if (!next) continue;\n\n    if (next.start <= current.end) {\n      // Overlapping or adjacent - extend current zone\n      current = {\n        start: current.start,\n        end: Math.max(current.end, next.end),\n        type: current.type, // Keep the type of the first zone\n      };\n    } else {\n      // Non-overlapping - save current and start new\n      merged.push(current);\n      current = next;\n    }\n  }\n\n  merged.push(current);\n  return merged;\n}\n\n/**\n * Check if a position is within an exclusion zone\n */\nexport function isInExclusionZone(position: number, zones: ExclusionZone[]): boolean {\n  return zones.some((zone) => position >= zone.start && position < zone.end);\n}\n\n/**\n * Check if a range overlaps with any exclusion zone\n */\nexport function overlapsExclusionZone(start: number, end: number, zones: ExclusionZone[]): boolean {\n  return zones.some((zone) => start < zone.end && end > zone.start);\n}\n\n/**\n * Filter out matches that overlap with exclusion zones\n */\nexport function filterExcludedMatches<T extends { start: number; end: number }>(\n  matches: T[],\n  zones: ExclusionZone[]\n): T[] {\n  return matches.filter((match) => !overlapsExclusionZone(match.start, match.end, zones));\n}\n\n/**\n * Get content with exclusion zones replaced by spaces\n * (useful for text analysis that needs position preservation)\n */\nexport function maskExclusionZones(content: string, zones: ExclusionZone[]): string {\n  let masked = content;\n\n  // Process zones in reverse order to preserve positions\n  const sortedZones = [...zones].sort((a, b) => b.start - a.start);\n\n  for (const zone of sortedZones) {\n    const before = masked.slice(0, zone.start);\n    const after = masked.slice(zone.end);\n    const replacement = ' '.repeat(zone.end - zone.start);\n    masked = before + replacement + after;\n  }\n\n  return masked;\n}\n","import type { WikiLink } from '../core/types/index.js';\nimport { findExclusionZones, filterExcludedMatches, type ExclusionZone } from './exclusions.js';\n\n// Wikilink pattern: [[target]] or [[target|display]]\n// Also supports [[id:node-id]] for direct ID references\nconst WIKILINK_REGEX = /\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]/g;\n\n// ID prefix for direct node references\nconst ID_PREFIX = 'id:';\n\nexport interface WikiLinkParseResult {\n  links: WikiLink[];\n  exclusionZones: ExclusionZone[];\n}\n\n/**\n * Extract all wikilinks from content\n */\nexport function extractWikilinks(\n  content: string,\n  contentStartOffset: number = 0\n): WikiLinkParseResult {\n  const exclusionZones = findExclusionZones(content, contentStartOffset);\n  const rawLinks: WikiLink[] = [];\n\n  // Find all wikilinks\n  for (const match of content.matchAll(WIKILINK_REGEX)) {\n    if (match.index === undefined) continue;\n\n    const raw = match[0];\n    const targetPart = match[1]?.trim() ?? '';\n    const displayPart = match[2]?.trim();\n\n    // Check for id: prefix\n    const isIdLink = targetPart.startsWith(ID_PREFIX);\n    const target = isIdLink ? targetPart.slice(ID_PREFIX.length) : targetPart;\n\n    // Display text: explicit > target without id: prefix\n    const display = displayPart ?? target;\n\n    const start = match.index + contentStartOffset;\n    const end = start + raw.length;\n\n    rawLinks.push({\n      raw,\n      target,\n      display,\n      isIdLink,\n      start,\n      end,\n    });\n  }\n\n  // Filter out links that are inside exclusion zones\n  // (but keep the wikilinks themselves as valid - they create new exclusion zones)\n  const links = filterExcludedMatches(\n    rawLinks,\n    exclusionZones.filter((z) => z.type !== 'existing_link')\n  );\n\n  return { links, exclusionZones };\n}\n\n/**\n * Extract link targets only (simplified version)\n */\nexport function extractLinkTargets(content: string): string[] {\n  const { links } = extractWikilinks(content);\n  return links.map((link) => link.target);\n}\n\n/**\n * Check if a string contains wikilinks\n */\nexport function hasWikilinks(content: string): boolean {\n  WIKILINK_REGEX.lastIndex = 0;\n  return WIKILINK_REGEX.test(content);\n}\n\n/**\n * Create a wikilink string\n */\nexport function createWikilink(\n  target: string,\n  display?: string,\n  useIdPrefix: boolean = false\n): string {\n  const targetPart = useIdPrefix ? `id:${target}` : target;\n\n  if (display && display !== target) {\n    return `[[${targetPart}|${display}]]`;\n  }\n\n  return `[[${targetPart}]]`;\n}\n\n/**\n * Replace text with a wikilink at a specific position\n */\nexport function insertWikilink(\n  content: string,\n  start: number,\n  end: number,\n  target: string,\n  display?: string\n): string {\n  const before = content.slice(0, start);\n  const after = content.slice(end);\n  const link = createWikilink(target, display);\n  return before + link + after;\n}\n\n/**\n * Get all unique link targets from content\n */\nexport function getUniqueTargets(content: string): Set<string> {\n  const { links } = extractWikilinks(content);\n  return new Set(links.map((link) => link.target));\n}\n\n/**\n * Normalize a link target for comparison\n * - Trim whitespace\n * - Collapse multiple spaces\n * - Case-insensitive comparison done separately\n */\nexport function normalizeTarget(target: string): string {\n  return target.trim().replace(/\\s+/g, ' ');\n}\n\n/**\n * Check if two link targets match (case-insensitive)\n */\nexport function targetsMatch(target1: string, target2: string): boolean {\n  return normalizeTarget(target1).toLowerCase() === normalizeTarget(target2).toLowerCase();\n}\n\n/**\n * Parse a wikilink string into components\n */\nexport function parseWikilinkString(wikilink: string): WikiLink | null {\n  const match = wikilink.match(/^\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]$/);\n\n  if (!match) return null;\n\n  const targetPart = match[1]?.trim() ?? '';\n  const displayPart = match[2]?.trim();\n\n  const isIdLink = targetPart.startsWith(ID_PREFIX);\n  const target = isIdLink ? targetPart.slice(ID_PREFIX.length) : targetPart;\n  const display = displayPart ?? target;\n\n  return {\n    raw: wikilink,\n    target,\n    display,\n    isIdLink,\n    start: 0,\n    end: wikilink.length,\n  };\n}\n\n// Default context window size (can be overridden via config)\nconst DEFAULT_CONTEXT_CHARS = 50;\n\n/**\n * Get context around a wikilink (surrounding text)\n */\nexport function getWikilinkContext(\n  content: string,\n  link: WikiLink,\n  contextChars: number = DEFAULT_CONTEXT_CHARS\n): string {\n  const start = Math.max(0, link.start - contextChars);\n  const end = Math.min(content.length, link.end + contextChars);\n\n  let context = content.slice(start, end);\n\n  // Add ellipsis if truncated\n  if (start > 0) context = '...' + context;\n  if (end < content.length) context = context + '...';\n\n  return context;\n}\n","import type { WikiLink, ResolvedLink, Node } from '../core/types/index.js';\nimport { normalizeTarget, targetsMatch } from './wikilink.js';\n\nexport interface LinkResolverOptions {\n  /**\n   * Function to find nodes by title (case-insensitive)\n   */\n  findByTitle: (title: string) => Promise<Node[]>;\n\n  /**\n   * Function to find a node by ID\n   */\n  findById: (nodeId: string) => Promise<Node | null>;\n\n  /**\n   * Function to find nodes by title or alias\n   */\n  findByTitleOrAlias: (text: string) => Promise<Node[]>;\n}\n\nexport interface ResolutionResult {\n  resolved: ResolvedLink[];\n  unresolved: WikiLink[];\n  ambiguous: WikiLink[];\n}\n\n/**\n * Link resolver following the spec:\n * 1. If id: prefix  direct node_id lookup\n * 2. Else normalize text:\n *    a. Exact title match (case-insensitive)\n *    b. Alias match\n * 3. Multiple matches  ambiguous (prompt user)\n * 4. No matches  unresolved (record separately)\n */\nexport class LinkResolver {\n  private cache: Map<string, Node[]> = new Map();\n\n  constructor(private options: LinkResolverOptions) {}\n\n  /**\n   * Resolve a single wikilink\n   */\n  async resolveLink(link: WikiLink): Promise<ResolvedLink> {\n    // Case 1: Direct ID reference\n    if (link.isIdLink) {\n      const node = await this.options.findById(link.target);\n      return {\n        ...link,\n        resolvedNodeId: node?.nodeId ?? null,\n        ambiguous: false,\n        candidates: node ? [node.nodeId] : [],\n      };\n    }\n\n    // Case 2: Title/alias resolution\n    const normalizedTarget = normalizeTarget(link.target);\n\n    // Check cache first\n    let candidates = this.cache.get(normalizedTarget.toLowerCase());\n\n    if (!candidates) {\n      // Find by title or alias\n      candidates = await this.options.findByTitleOrAlias(normalizedTarget);\n      this.cache.set(normalizedTarget.toLowerCase(), candidates);\n    }\n\n    if (candidates.length === 0) {\n      // No matches - unresolved\n      return {\n        ...link,\n        resolvedNodeId: null,\n        ambiguous: false,\n        candidates: [],\n      };\n    }\n\n    if (candidates.length === 1) {\n      // Single match - resolved\n      return {\n        ...link,\n        resolvedNodeId: candidates[0]?.nodeId ?? null,\n        ambiguous: false,\n        candidates: [candidates[0]?.nodeId ?? ''],\n      };\n    }\n\n    // Multiple matches - ambiguous\n    // Try to disambiguate by exact title match\n    const exactMatch = candidates.find((c) => targetsMatch(c.title, normalizedTarget));\n\n    if (exactMatch) {\n      return {\n        ...link,\n        resolvedNodeId: exactMatch.nodeId,\n        ambiguous: false,\n        candidates: candidates.map((c) => c.nodeId),\n      };\n    }\n\n    // Still ambiguous\n    return {\n      ...link,\n      resolvedNodeId: null,\n      ambiguous: true,\n      candidates: candidates.map((c) => c.nodeId),\n    };\n  }\n\n  /**\n   * Resolve multiple wikilinks\n   */\n  async resolveLinks(links: WikiLink[]): Promise<ResolutionResult> {\n    const resolved: ResolvedLink[] = [];\n    const unresolved: WikiLink[] = [];\n    const ambiguous: WikiLink[] = [];\n\n    for (const link of links) {\n      const result = await this.resolveLink(link);\n\n      if (result.ambiguous) {\n        ambiguous.push(link);\n      } else if (result.resolvedNodeId === null) {\n        unresolved.push(link);\n      }\n\n      resolved.push(result);\n    }\n\n    return { resolved, unresolved, ambiguous };\n  }\n\n  /**\n   * Clear the resolution cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; hits: number } {\n    return {\n      size: this.cache.size,\n      hits: 0, // Would need to track this separately\n    };\n  }\n}\n\n/**\n * Create a link resolver with repository functions\n */\nexport function createLinkResolver(nodeRepository: {\n  findByTitle: (title: string) => Promise<Node[]>;\n  findById: (nodeId: string) => Promise<Node | null>;\n  findByTitleOrAlias: (text: string) => Promise<Node[]>;\n}): LinkResolver {\n  return new LinkResolver({\n    findByTitle: nodeRepository.findByTitle.bind(nodeRepository),\n    findById: nodeRepository.findById.bind(nodeRepository),\n    findByTitleOrAlias: nodeRepository.findByTitleOrAlias.bind(nodeRepository),\n  });\n}\n\n/**\n * Simple in-memory resolver for testing or single-file parsing\n */\nexport class InMemoryLinkResolver {\n  private nodesByTitle: Map<string, Node[]> = new Map();\n  private nodesById: Map<string, Node> = new Map();\n  private nodesByAlias: Map<string, Node[]> = new Map();\n\n  /**\n   * Add a node to the resolver\n   */\n  addNode(node: Node, aliases: string[] = []): void {\n    this.nodesById.set(node.nodeId, node);\n\n    // Index by title\n    const titleLower = node.title.toLowerCase();\n    const titleNodes = this.nodesByTitle.get(titleLower) || [];\n    titleNodes.push(node);\n    this.nodesByTitle.set(titleLower, titleNodes);\n\n    // Index by aliases\n    for (const alias of aliases) {\n      const aliasLower = alias.toLowerCase();\n      const aliasNodes = this.nodesByAlias.get(aliasLower) || [];\n      aliasNodes.push(node);\n      this.nodesByAlias.set(aliasLower, aliasNodes);\n    }\n  }\n\n  /**\n   * Resolve a wikilink\n   */\n  resolveLink(link: WikiLink): ResolvedLink {\n    // Case 1: Direct ID reference\n    if (link.isIdLink) {\n      const node = this.nodesById.get(link.target);\n      return {\n        ...link,\n        resolvedNodeId: node?.nodeId ?? null,\n        ambiguous: false,\n        candidates: node ? [node.nodeId] : [],\n      };\n    }\n\n    // Case 2: Title/alias resolution\n    const normalized = normalizeTarget(link.target).toLowerCase();\n\n    // Find by title\n    const titleMatches = this.nodesByTitle.get(normalized) || [];\n\n    // Find by alias\n    const aliasMatches = this.nodesByAlias.get(normalized) || [];\n\n    // Combine and deduplicate\n    const candidateMap = new Map<string, Node>();\n    for (const node of [...titleMatches, ...aliasMatches]) {\n      candidateMap.set(node.nodeId, node);\n    }\n\n    const candidates = Array.from(candidateMap.values());\n\n    if (candidates.length === 0) {\n      return {\n        ...link,\n        resolvedNodeId: null,\n        ambiguous: false,\n        candidates: [],\n      };\n    }\n\n    if (candidates.length === 1) {\n      return {\n        ...link,\n        resolvedNodeId: candidates[0]?.nodeId ?? null,\n        ambiguous: false,\n        candidates: [candidates[0]?.nodeId ?? ''],\n      };\n    }\n\n    // Try exact title match for disambiguation\n    const exactMatch = candidates.find((c) => targetsMatch(c.title, link.target));\n\n    if (exactMatch) {\n      return {\n        ...link,\n        resolvedNodeId: exactMatch.nodeId,\n        ambiguous: false,\n        candidates: candidates.map((c) => c.nodeId),\n      };\n    }\n\n    return {\n      ...link,\n      resolvedNodeId: null,\n      ambiguous: true,\n      candidates: candidates.map((c) => c.nodeId),\n    };\n  }\n\n  /**\n   * Clear all indexed nodes\n   */\n  clear(): void {\n    this.nodesByTitle.clear();\n    this.nodesById.clear();\n    this.nodesByAlias.clear();\n  }\n}\n","import type { Node, Edge, WikiLink, NodeType } from '../core/types/index.js';\nimport { parseMarkdown, type ParsedMarkdown } from '../parser/markdown.js';\nimport { createLinkResolver, type LinkResolver } from '../parser/resolver.js';\nimport type { FileInfo } from '../storage/filesystem/reader.js';\nimport {\n  NodeRepository,\n  EdgeRepository,\n  VersionRepository,\n} from '../storage/database/repositories/index.js';\n\nexport interface IndexingResult {\n  node: Node;\n  links: Array<{\n    wikilink: WikiLink;\n    targetNodeId: string | null;\n    ambiguous: boolean;\n  }>;\n  edges: Edge[];\n  unresolved: WikiLink[];\n  ambiguous: WikiLink[];\n}\n\nexport interface BatchIndexingResult {\n  indexed: IndexingResult[];\n  errors: Array<{ path: string; error: string }>;\n  stats: {\n    totalFiles: number;\n    successCount: number;\n    errorCount: number;\n    nodeCount: number;\n    edgeCount: number;\n    unresolvedCount: number;\n    ambiguousCount: number;\n    durationMs: number;\n  };\n}\n\nexport interface IndexerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  versionRepository: VersionRepository;\n}\n\n/**\n * Main indexing pipeline\n */\nexport class IndexingPipeline {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private versionRepo: VersionRepository;\n  private resolver: LinkResolver | null = null;\n\n  constructor(options: IndexerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.versionRepo = options.versionRepository;\n  }\n\n  /**\n   * Initialize the link resolver\n   */\n  private async getResolver(): Promise<LinkResolver> {\n    if (!this.resolver) {\n      this.resolver = createLinkResolver(this.nodeRepo);\n    }\n    return this.resolver;\n  }\n\n  /**\n   * Clear resolver cache (call after batch operations)\n   */\n  clearResolverCache(): void {\n    if (this.resolver) {\n      this.resolver.clearCache();\n    }\n  }\n\n  /**\n   * Index a single file\n   */\n  async indexFile(file: FileInfo): Promise<IndexingResult> {\n    // Parse the markdown\n    const parsed = parseMarkdown(file.content, file.relativePath);\n\n    // Create or update the node\n    const node = await this.upsertNode(file, parsed);\n\n    // Create version if content changed\n    await this.createVersionIfNeeded(node, file.contentHash);\n\n    // Update aliases\n    await this.nodeRepo.setAliases(node.nodeId, parsed.aliases);\n\n    // Resolve links and create edges\n    const { links, edges, unresolved, ambiguous } = await this.processLinks(node, parsed.links);\n\n    return { node, links, edges, unresolved, ambiguous };\n  }\n\n  /**\n   * Create or update a node from file info\n   */\n  private async upsertNode(file: FileInfo, parsed: ParsedMarkdown): Promise<Node> {\n    const existing = await this.nodeRepo.findByPath(file.relativePath);\n\n    const nodeData = {\n      type: parsed.type as NodeType,\n      title: parsed.title,\n      path: file.relativePath,\n      createdAt: existing?.createdAt || file.stats.createdAt.toISOString(),\n      updatedAt: file.stats.modifiedAt.toISOString(),\n      contentHash: file.contentHash,\n      ...(parsed.frontmatter && { metadata: { ...parsed.frontmatter } }),\n    };\n\n    if (existing) {\n      return this.nodeRepo.update(existing.nodeId, nodeData);\n    }\n\n    return this.nodeRepo.create(nodeData);\n  }\n\n  /**\n   * Create a version entry if content has changed\n   */\n  private async createVersionIfNeeded(node: Node, contentHash: string): Promise<void> {\n    const latestVersion = await this.versionRepo.findLatest(node.nodeId);\n\n    if (latestVersion?.contentHash === contentHash) {\n      return; // No change\n    }\n\n    await this.versionRepo.create({\n      nodeId: node.nodeId,\n      contentHash,\n      ...(latestVersion?.versionId && { parentVersionId: latestVersion.versionId }),\n    });\n  }\n\n  /**\n   * Process wikilinks and create edges\n   */\n  private async processLinks(\n    sourceNode: Node,\n    wikilinks: WikiLink[]\n  ): Promise<{\n    links: IndexingResult['links'];\n    edges: Edge[];\n    unresolved: WikiLink[];\n    ambiguous: WikiLink[];\n  }> {\n    const resolver = await this.getResolver();\n\n    // Delete existing explicit_link edges from this source\n    await this.edgeRepo.deleteBySourceAndType(sourceNode.nodeId, 'explicit_link');\n\n    const links: IndexingResult['links'] = [];\n    const edges: Edge[] = [];\n    const unresolved: WikiLink[] = [];\n    const ambiguous: WikiLink[] = [];\n\n    for (const wikilink of wikilinks) {\n      const resolved = await resolver.resolveLink(wikilink);\n\n      links.push({\n        wikilink,\n        targetNodeId: resolved.resolvedNodeId,\n        ambiguous: resolved.ambiguous,\n      });\n\n      if (resolved.ambiguous) {\n        ambiguous.push(wikilink);\n      } else if (resolved.resolvedNodeId === null) {\n        unresolved.push(wikilink);\n      } else {\n        // Create edge\n        const edge = await this.edgeRepo.create({\n          sourceId: sourceNode.nodeId,\n          targetId: resolved.resolvedNodeId,\n          edgeType: 'explicit_link',\n          provenance: 'explicit',\n          attributes: {\n            displayText: wikilink.display,\n            position: { start: wikilink.start, end: wikilink.end },\n          },\n        });\n        edges.push(edge);\n      }\n    }\n\n    return { links, edges, unresolved, ambiguous };\n  }\n\n  /**\n   * Two-pass batch indexing for handling circular references\n   *\n   * Pass 1: Create all nodes (stubs)\n   * Pass 2: Process links and create edges\n   */\n  async batchIndex(files: FileInfo[]): Promise<BatchIndexingResult> {\n    const startTime = Date.now();\n    const indexed: IndexingResult[] = [];\n    const errors: Array<{ path: string; error: string }> = [];\n\n    // Pass 1: Create/update all nodes\n    const nodeMap = new Map<string, { node: Node; parsed: ParsedMarkdown; file: FileInfo }>();\n\n    for (const file of files) {\n      try {\n        const parsed = parseMarkdown(file.content, file.relativePath);\n        const node = await this.upsertNode(file, parsed);\n        await this.nodeRepo.setAliases(node.nodeId, parsed.aliases);\n        nodeMap.set(file.relativePath, { node, parsed, file });\n      } catch (error) {\n        errors.push({\n          path: file.relativePath,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    // Clear resolver cache before pass 2 (new nodes are now visible)\n    this.clearResolverCache();\n\n    // Pass 2: Process links and create edges\n    let totalEdges = 0;\n    let totalUnresolved = 0;\n    let totalAmbiguous = 0;\n\n    for (const { node, parsed, file } of nodeMap.values()) {\n      try {\n        // Create version\n        await this.createVersionIfNeeded(node, file.contentHash);\n\n        // Process links\n        const { links, edges, unresolved, ambiguous } = await this.processLinks(node, parsed.links);\n\n        indexed.push({ node, links, edges, unresolved, ambiguous });\n        totalEdges += edges.length;\n        totalUnresolved += unresolved.length;\n        totalAmbiguous += ambiguous.length;\n      } catch (error) {\n        errors.push({\n          path: file.relativePath,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    const durationMs = Date.now() - startTime;\n\n    return {\n      indexed,\n      errors,\n      stats: {\n        totalFiles: files.length,\n        successCount: indexed.length,\n        errorCount: errors.length,\n        nodeCount: nodeMap.size,\n        edgeCount: totalEdges,\n        unresolvedCount: totalUnresolved,\n        ambiguousCount: totalAmbiguous,\n        durationMs,\n      },\n    };\n  }\n\n  /**\n   * Remove a node and its edges\n   */\n  async removeNode(nodeId: string): Promise<void> {\n    // Edges will be cascade deleted due to foreign key\n    await this.nodeRepo.delete(nodeId);\n    this.clearResolverCache();\n  }\n\n  /**\n   * Remove a node by path\n   */\n  async removeByPath(path: string): Promise<void> {\n    const node = await this.nodeRepo.findByPath(path);\n    if (node) {\n      await this.removeNode(node.nodeId);\n    }\n  }\n\n  /**\n   * Check if a file needs reindexing\n   */\n  async needsReindex(file: FileInfo): Promise<boolean> {\n    const node = await this.nodeRepo.findByPath(file.relativePath);\n\n    if (!node) {\n      return true; // New file\n    }\n\n    return node.contentHash !== file.contentHash;\n  }\n\n  /**\n   * Get indexing statistics\n   */\n  async getStats(): Promise<{\n    nodeCount: number;\n    edgeCount: number;\n    nodesByType: Record<string, number>;\n    edgesByType: Record<string, number>;\n  }> {\n    const [nodeCount, edgeCount, nodesByType, edgesByType] = await Promise.all([\n      this.nodeRepo.count(),\n      this.edgeRepo.count(),\n      this.nodeRepo.countByType(),\n      this.edgeRepo.countByType(),\n    ]);\n\n    return { nodeCount, edgeCount, nodesByType, edgesByType };\n  }\n}\n","import type { Edge, EdgeType, ZettelScriptConfig } from '../../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../../core/types/index.js';\nimport { EdgeRepository } from '../../storage/database/repositories/index.js';\n\nexport interface ExpansionOptions {\n  maxDepth: number;\n  budget: number;\n  edgeTypes: EdgeType[];\n  decayFactor: number;\n  includeIncoming: boolean;\n  scoreThreshold?: number;\n}\n\nexport interface ExpandedNode {\n  nodeId: string;\n  depth: number;\n  score: number;\n  path: string[];\n  edgeType: EdgeType | null;\n}\n\nexport interface GraphExpanderOptions {\n  edgeRepository: EdgeRepository;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Bounded graph expansion for GraphRAG retrieval\n *\n * Algorithm (from spec 7.3):\n * frontier = seed_nodes\n * for depth in 1..max_depth:\n *     if visited_count >= budget: break\n *     for node in frontier:\n *         for edge in outgoing_edges(node, allowed_types):\n *             score = current_score * edge_weight * decay^depth\n *             accumulated_scores[edge.target] = max(existing, score)\n *     frontier = newly_discovered_nodes\n */\nexport class GraphExpander {\n  private edgeRepo: EdgeRepository;\n  private config: ZettelScriptConfig;\n\n  constructor(options: GraphExpanderOptions | EdgeRepository) {\n    // Support both old and new constructor signature for backwards compatibility\n    if ('edgeRepository' in options) {\n      this.edgeRepo = options.edgeRepository;\n      this.config = options.config ?? DEFAULT_CONFIG;\n    } else {\n      this.edgeRepo = options;\n      this.config = DEFAULT_CONFIG;\n    }\n  }\n\n  /**\n   * Expand from seed nodes with bounded traversal\n   */\n  async expand(\n    seeds: Array<{ nodeId: string; score: number }>,\n    options: ExpansionOptions\n  ): Promise<ExpandedNode[]> {\n    const {\n      maxDepth,\n      budget,\n      edgeTypes,\n      decayFactor,\n      includeIncoming,\n      scoreThreshold = this.config.graph.scoreThreshold,\n    } = options;\n\n    if (seeds.length === 0) return [];\n\n    // Track accumulated scores and paths\n    const accumulated = new Map<string, ExpandedNode>();\n\n    // Initialize with seeds\n    let frontier = new Set<string>();\n    for (const seed of seeds) {\n      accumulated.set(seed.nodeId, {\n        nodeId: seed.nodeId,\n        depth: 0,\n        score: seed.score,\n        path: [seed.nodeId],\n        edgeType: null,\n      });\n      frontier.add(seed.nodeId);\n    }\n\n    // BFS with decay\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (accumulated.size >= budget) break;\n      if (frontier.size === 0) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (accumulated.size >= budget) break;\n\n        const current = accumulated.get(nodeId);\n        if (!current) continue;\n\n        // Get edges\n        const edges = await this.getEdges(nodeId, edgeTypes, includeIncoming);\n\n        for (const edge of edges) {\n          if (accumulated.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Calculate score with decay\n          const edgeWeight = edge.strength ?? 1.0;\n          const newScore = current.score * edgeWeight * Math.pow(decayFactor, depth);\n\n          // Skip if below threshold\n          if (newScore < scoreThreshold) continue;\n\n          const existing = accumulated.get(targetId);\n\n          if (!existing || newScore > existing.score) {\n            accumulated.set(targetId, {\n              nodeId: targetId,\n              depth,\n              score: newScore,\n              path: [...current.path, targetId],\n              edgeType: edge.edgeType as EdgeType,\n            });\n\n            if (!existing) {\n              newFrontier.add(targetId);\n            }\n          }\n        }\n      }\n\n      frontier = newFrontier;\n    }\n\n    // Convert to array and sort by score\n    return Array.from(accumulated.values()).sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Get edges for a node\n   */\n  private async getEdges(\n    nodeId: string,\n    edgeTypes: EdgeType[],\n    includeIncoming: boolean\n  ): Promise<Edge[]> {\n    const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n    if (!includeIncoming) {\n      return outgoing;\n    }\n\n    const incoming = await this.edgeRepo.findIncoming(nodeId, edgeTypes);\n    return [...outgoing, ...incoming];\n  }\n\n  /**\n   * Expand with prioritized edge types\n   * Some edge types are more valuable for retrieval\n   */\n  async expandPrioritized(\n    seeds: Array<{ nodeId: string; score: number }>,\n    options: ExpansionOptions,\n    edgeWeights: Partial<Record<EdgeType, number>>\n  ): Promise<ExpandedNode[]> {\n    const {\n      maxDepth,\n      budget,\n      edgeTypes,\n      decayFactor,\n      includeIncoming,\n      scoreThreshold = this.config.graph.scoreThreshold,\n    } = options;\n\n    if (seeds.length === 0) return [];\n\n    const accumulated = new Map<string, ExpandedNode>();\n\n    let frontier = new Set<string>();\n    for (const seed of seeds) {\n      accumulated.set(seed.nodeId, {\n        nodeId: seed.nodeId,\n        depth: 0,\n        score: seed.score,\n        path: [seed.nodeId],\n        edgeType: null,\n      });\n      frontier.add(seed.nodeId);\n    }\n\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (accumulated.size >= budget) break;\n      if (frontier.size === 0) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (accumulated.size >= budget) break;\n\n        const current = accumulated.get(nodeId);\n        if (!current) continue;\n\n        const edges = await this.getEdges(nodeId, edgeTypes, includeIncoming);\n\n        for (const edge of edges) {\n          if (accumulated.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Apply edge type weight\n          const typeWeight = edgeWeights[edge.edgeType as EdgeType] ?? 1.0;\n          const edgeWeight = (edge.strength ?? 1.0) * typeWeight;\n          const newScore = current.score * edgeWeight * Math.pow(decayFactor, depth);\n\n          if (newScore < scoreThreshold) continue;\n\n          const existing = accumulated.get(targetId);\n\n          if (!existing || newScore > existing.score) {\n            accumulated.set(targetId, {\n              nodeId: targetId,\n              depth,\n              score: newScore,\n              path: [...current.path, targetId],\n              edgeType: edge.edgeType as EdgeType,\n            });\n\n            if (!existing) {\n              newFrontier.add(targetId);\n            }\n          }\n        }\n      }\n\n      frontier = newFrontier;\n    }\n\n    return Array.from(accumulated.values()).sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Get expansion statistics\n   */\n  getExpansionStats(results: ExpandedNode[]): {\n    totalNodes: number;\n    maxDepth: number;\n    avgScore: number;\n    edgeTypeCounts: Record<string, number>;\n  } {\n    if (results.length === 0) {\n      return {\n        totalNodes: 0,\n        maxDepth: 0,\n        avgScore: 0,\n        edgeTypeCounts: {},\n      };\n    }\n\n    const edgeTypeCounts: Record<string, number> = {};\n    let totalScore = 0;\n    let maxDepth = 0;\n\n    for (const result of results) {\n      totalScore += result.score;\n      maxDepth = Math.max(maxDepth, result.depth);\n\n      if (result.edgeType) {\n        edgeTypeCounts[result.edgeType] = (edgeTypeCounts[result.edgeType] || 0) + 1;\n      }\n    }\n\n    return {\n      totalNodes: results.length,\n      maxDepth,\n      avgScore: totalScore / results.length,\n      edgeTypeCounts,\n    };\n  }\n}\n","/**\n * Reciprocal Rank Fusion (RRF) implementation\n *\n * Algorithm:\n * for each result in semantic_results:\n *     rrf_score += semantic_weight * (1 / (k + rank))\n * for each result in lexical_results:\n *     rrf_score += lexical_weight * (1 / (k + rank))\n * sort by rrf_score descending\n */\n\nexport interface RankedItem {\n  id: string;\n  score: number;\n  source: string;\n}\n\nexport interface FusionResult {\n  id: string;\n  score: number;\n  sources: string[];\n  ranks: Map<string, number>;\n}\n\nexport interface RRFOptions {\n  k?: number; // RRF constant (default 60)\n  weights?: Record<string, number>; // Weights per source\n}\n\n/**\n * Perform Reciprocal Rank Fusion on multiple result lists\n */\nexport function reciprocalRankFusion(\n  resultLists: Map<string, RankedItem[]>,\n  options: RRFOptions = {}\n): FusionResult[] {\n  const k = options.k ?? 60;\n  const weights = options.weights ?? {};\n\n  // Collect scores for each item\n  const scores = new Map<\n    string,\n    {\n      score: number;\n      sources: Set<string>;\n      ranks: Map<string, number>;\n    }\n  >();\n\n  for (const [source, items] of resultLists) {\n    const weight = weights[source] ?? 1.0;\n\n    for (let rank = 0; rank < items.length; rank++) {\n      const item = items[rank];\n      if (!item) continue;\n\n      const rrfScore = weight * (1 / (k + rank + 1)); // rank is 0-indexed, formula expects 1-indexed\n\n      const existing = scores.get(item.id);\n      if (existing) {\n        existing.score += rrfScore;\n        existing.sources.add(source);\n        existing.ranks.set(source, rank + 1);\n      } else {\n        scores.set(item.id, {\n          score: rrfScore,\n          sources: new Set([source]),\n          ranks: new Map([[source, rank + 1]]),\n        });\n      }\n    }\n  }\n\n  // Convert to results and sort\n  const results: FusionResult[] = [];\n  for (const [id, data] of scores) {\n    results.push({\n      id,\n      score: data.score,\n      sources: Array.from(data.sources),\n      ranks: data.ranks,\n    });\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Simple score combination (weighted average)\n */\nexport function weightedScoreFusion(\n  resultLists: Map<string, RankedItem[]>,\n  weights: Record<string, number>\n): FusionResult[] {\n  const scores = new Map<\n    string,\n    {\n      totalScore: number;\n      totalWeight: number;\n      sources: Set<string>;\n      ranks: Map<string, number>;\n    }\n  >();\n\n  for (const [source, items] of resultLists) {\n    const weight = weights[source] ?? 1.0;\n\n    for (let rank = 0; rank < items.length; rank++) {\n      const item = items[rank];\n      if (!item) continue;\n\n      const existing = scores.get(item.id);\n      if (existing) {\n        existing.totalScore += item.score * weight;\n        existing.totalWeight += weight;\n        existing.sources.add(source);\n        existing.ranks.set(source, rank + 1);\n      } else {\n        scores.set(item.id, {\n          totalScore: item.score * weight,\n          totalWeight: weight,\n          sources: new Set([source]),\n          ranks: new Map([[source, rank + 1]]),\n        });\n      }\n    }\n  }\n\n  const results: FusionResult[] = [];\n  for (const [id, data] of scores) {\n    results.push({\n      id,\n      score: data.totalScore / data.totalWeight,\n      sources: Array.from(data.sources),\n      ranks: data.ranks,\n    });\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Interleave results from multiple sources\n */\nexport function interleave(\n  resultLists: Map<string, RankedItem[]>,\n  maxResults: number\n): FusionResult[] {\n  const seen = new Set<string>();\n  const results: FusionResult[] = [];\n  const sources = Array.from(resultLists.keys());\n  const indices = new Map(sources.map((s) => [s, 0]));\n\n  while (results.length < maxResults) {\n    let added = false;\n\n    for (const source of sources) {\n      const items = resultLists.get(source) ?? [];\n      let idx = indices.get(source) ?? 0;\n\n      while (idx < items.length) {\n        const item = items[idx];\n        idx++;\n        indices.set(source, idx);\n\n        if (!item || seen.has(item.id)) continue;\n\n        seen.add(item.id);\n        results.push({\n          id: item.id,\n          score: item.score,\n          sources: [source],\n          ranks: new Map([[source, idx]]),\n        });\n        added = true;\n        break;\n      }\n\n      if (results.length >= maxResults) break;\n    }\n\n    if (!added) break;\n  }\n\n  return results;\n}\n\n/**\n * Combine fusion results with score boosting for items in multiple sources\n */\nexport function boostOverlap(results: FusionResult[], boostFactor: number = 1.2): FusionResult[] {\n  return results\n    .map((r) => ({\n      ...r,\n      score: r.score * Math.pow(boostFactor, r.sources.length - 1),\n    }))\n    .sort((a, b) => b.score - a.score);\n}\n","import type {\n  Chunk,\n  Node,\n  RetrievalQuery,\n  RetrievalResult,\n  EdgeType,\n} from '../../core/types/index.js';\nimport {\n  NodeRepository,\n  EdgeRepository,\n  ChunkRepository,\n} from '../../storage/database/repositories/index.js';\nimport type { GraphEngine } from '../../core/graph/engine.js';\nimport { GraphExpander, type ExpandedNode } from '../expansion/graph-expander.js';\nimport { reciprocalRankFusion, type RankedItem } from '../fusion/rrf.js';\n\nexport interface ContextAssemblerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  chunkRepository: ChunkRepository;\n  graphEngine: GraphEngine;\n  config: {\n    defaultMaxResults: number;\n    semanticWeight: number;\n    lexicalWeight: number;\n    graphWeight: number;\n    rrfK: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n}\n\ninterface ScoredChunk {\n  chunk: Chunk;\n  node: Node;\n  score: number;\n  matchType: 'semantic' | 'lexical' | 'graph';\n}\n\n/**\n * Assembles context from multiple retrieval strategies\n */\nexport class ContextAssembler {\n  private nodeRepo: NodeRepository;\n  private chunkRepo: ChunkRepository;\n  private expander: GraphExpander;\n  private config: ContextAssemblerOptions['config'];\n\n  constructor(options: ContextAssemblerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.chunkRepo = options.chunkRepository;\n    this.expander = new GraphExpander(options.edgeRepository);\n    this.config = options.config;\n  }\n\n  /**\n   * Main retrieval function\n   */\n  async retrieve(query: RetrievalQuery): Promise<RetrievalResult> {\n    const maxResults = query.maxResults ?? this.config.defaultMaxResults;\n\n    // Step 1: Seed retrieval (lexical for now, semantic when embeddings available)\n    const lexicalResults = await this.lexicalSearch(query.text, maxResults * 2);\n\n    // Step 2: Apply filters\n    const filteredLexical = await this.applyFilters(lexicalResults, query.filters);\n\n    // Step 3: Extract seed nodes\n    const seedNodes = this.extractSeeds(filteredLexical);\n\n    // Step 4: Graph expansion\n    const expansionOptions = {\n      maxDepth: query.expansion?.maxDepth ?? this.config.expansionMaxDepth,\n      budget: query.expansion?.budget ?? this.config.expansionBudget,\n      edgeTypes: (query.expansion?.edgeTypes ?? [\n        'explicit_link',\n        'sequence',\n        'hierarchy',\n      ]) as EdgeType[],\n      decayFactor: query.expansion?.decayFactor ?? 0.7,\n      includeIncoming: true,\n    };\n\n    const expandedNodes = await this.expander.expand(seedNodes, expansionOptions);\n\n    // Step 5: Fetch chunks for expanded nodes\n    const graphChunks = await this.fetchChunksForNodes(expandedNodes);\n\n    // Step 6: Fuse results\n    const fusedChunks = this.fuseResults(filteredLexical, graphChunks, maxResults);\n\n    // Step 7: Assemble context\n    const context = await this.assembleContext(fusedChunks);\n\n    // Step 8: Build provenance\n    const provenance = this.buildProvenance(fusedChunks);\n\n    return {\n      chunks: fusedChunks.map((sc) => ({\n        chunk: sc.chunk,\n        node: sc.node,\n        score: sc.score,\n        matchType: sc.matchType,\n      })),\n      context,\n      provenance,\n    };\n  }\n\n  /**\n   * Lexical search using FTS5\n   */\n  private async lexicalSearch(query: string, limit: number): Promise<ScoredChunk[]> {\n    const ftsResults = this.chunkRepo.searchBM25(query, limit);\n\n    if (ftsResults.length === 0) {\n      return [];\n    }\n\n    // Fetch full chunk and node data\n    const chunkIds = ftsResults.map((r) => r.chunkId);\n    const chunks = await this.chunkRepo.findByIds(chunkIds);\n    const chunkMap = new Map(chunks.map((c) => [c.chunkId, c]));\n\n    const nodeIds = [...new Set(ftsResults.map((r) => r.nodeId))];\n    const nodes = await this.nodeRepo.findByIds(nodeIds);\n    const nodeMap = new Map(nodes.map((n) => [n.nodeId, n]));\n\n    const results: ScoredChunk[] = [];\n\n    // Normalize scores\n    const maxScore = Math.max(...ftsResults.map((r) => Math.abs(r.score)));\n\n    for (const fts of ftsResults) {\n      const chunk = chunkMap.get(fts.chunkId);\n      const node = nodeMap.get(fts.nodeId);\n\n      if (chunk && node) {\n        results.push({\n          chunk,\n          node,\n          score: maxScore > 0 ? Math.abs(fts.score) / maxScore : 0.5,\n          matchType: 'lexical',\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Apply query filters\n   */\n  private async applyFilters(\n    chunks: ScoredChunk[],\n    filters?: RetrievalQuery['filters']\n  ): Promise<ScoredChunk[]> {\n    if (!filters) return chunks;\n\n    return chunks.filter((sc) => {\n      // Filter by node type\n      if (filters.nodeTypes && !filters.nodeTypes.includes(sc.node.type)) {\n        return false;\n      }\n\n      // Filter by excluded nodes\n      if (filters.excludeNodeIds?.includes(sc.node.nodeId)) {\n        return false;\n      }\n\n      // Filter by date range\n      if (filters.dateRange) {\n        const nodeDate = new Date(sc.node.updatedAt);\n        if (filters.dateRange.start && nodeDate < new Date(filters.dateRange.start)) {\n          return false;\n        }\n        if (filters.dateRange.end && nodeDate > new Date(filters.dateRange.end)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Extract seed nodes from initial results\n   */\n  private extractSeeds(chunks: ScoredChunk[]): Array<{ nodeId: string; score: number }> {\n    // Aggregate scores by node\n    const nodeScores = new Map<string, number>();\n\n    for (const sc of chunks) {\n      const current = nodeScores.get(sc.node.nodeId) ?? 0;\n      nodeScores.set(sc.node.nodeId, Math.max(current, sc.score));\n    }\n\n    return Array.from(nodeScores.entries())\n      .map(([nodeId, score]) => ({ nodeId, score }))\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 10); // Top 10 seeds\n  }\n\n  /**\n   * Fetch chunks for expanded nodes\n   */\n  private async fetchChunksForNodes(expanded: ExpandedNode[]): Promise<ScoredChunk[]> {\n    const results: ScoredChunk[] = [];\n\n    for (const exp of expanded) {\n      if (exp.depth === 0) continue; // Skip seeds, already have their chunks\n\n      const chunks = await this.chunkRepo.findByNodeId(exp.nodeId);\n      const node = await this.nodeRepo.findById(exp.nodeId);\n\n      if (!node) continue;\n\n      for (const chunk of chunks) {\n        results.push({\n          chunk,\n          node,\n          score: exp.score,\n          matchType: 'graph',\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Fuse lexical and graph results using RRF\n   */\n  private fuseResults(\n    lexical: ScoredChunk[],\n    graph: ScoredChunk[],\n    maxResults: number\n  ): ScoredChunk[] {\n    // Convert to ranked items\n    const lexicalItems: RankedItem[] = lexical.map((sc) => ({\n      id: sc.chunk.chunkId,\n      score: sc.score,\n      source: 'lexical',\n    }));\n\n    const graphItems: RankedItem[] = graph.map((sc) => ({\n      id: sc.chunk.chunkId,\n      score: sc.score,\n      source: 'graph',\n    }));\n\n    // Create chunk lookup\n    const chunkLookup = new Map<string, ScoredChunk>();\n    for (const sc of [...lexical, ...graph]) {\n      const existing = chunkLookup.get(sc.chunk.chunkId);\n      if (!existing || sc.score > existing.score) {\n        chunkLookup.set(sc.chunk.chunkId, sc);\n      }\n    }\n\n    // Perform RRF\n    const resultLists = new Map([\n      ['lexical', lexicalItems],\n      ['graph', graphItems],\n    ]);\n\n    const fused = reciprocalRankFusion(resultLists, {\n      k: this.config.rrfK,\n      weights: {\n        lexical: this.config.lexicalWeight,\n        graph: this.config.graphWeight,\n      },\n    });\n\n    // Map back to ScoredChunk\n    const results: ScoredChunk[] = [];\n    for (const f of fused.slice(0, maxResults)) {\n      const sc = chunkLookup.get(f.id);\n      if (sc) {\n        results.push({\n          ...sc,\n          score: f.score,\n          matchType: f.sources.length > 1 ? 'lexical' : (f.sources[0] as 'lexical' | 'graph'),\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Assemble context string from chunks\n   */\n  private async assembleContext(chunks: ScoredChunk[]): Promise<string> {\n    if (chunks.length === 0) {\n      return '';\n    }\n\n    // Group chunks by node for better organization\n    const nodeChunks = new Map<string, ScoredChunk[]>();\n    for (const sc of chunks) {\n      const existing = nodeChunks.get(sc.node.nodeId) ?? [];\n      existing.push(sc);\n      nodeChunks.set(sc.node.nodeId, existing);\n    }\n\n    const sections: string[] = [];\n\n    for (const [, nodeChunkList] of nodeChunks) {\n      const node = nodeChunkList[0]?.node;\n      if (!node) continue;\n\n      // Sort chunks by offset\n      nodeChunkList.sort((a, b) => a.chunk.offsetStart - b.chunk.offsetStart);\n\n      const chunkTexts = nodeChunkList.map((sc) => sc.chunk.text);\n      const combinedText = chunkTexts.join('\\n\\n');\n\n      sections.push(`## ${node.title}\\n\\n${combinedText}`);\n    }\n\n    return sections.join('\\n\\n---\\n\\n');\n  }\n\n  /**\n   * Build provenance information\n   */\n  private buildProvenance(chunks: ScoredChunk[]): RetrievalResult['provenance'] {\n    // Aggregate contribution by node\n    const nodeContributions = new Map<string, { path: string; score: number }>();\n\n    for (const sc of chunks) {\n      const existing = nodeContributions.get(sc.node.nodeId);\n      if (existing) {\n        existing.score += sc.score;\n      } else {\n        nodeContributions.set(sc.node.nodeId, {\n          path: sc.node.path,\n          score: sc.score,\n        });\n      }\n    }\n\n    // Normalize contributions\n    const totalScore = Array.from(nodeContributions.values()).reduce((sum, n) => sum + n.score, 0);\n\n    return Array.from(nodeContributions.entries())\n      .map(([nodeId, data]) => ({\n        nodeId,\n        path: data.path,\n        contribution: totalScore > 0 ? data.score / totalScore : 0,\n      }))\n      .sort((a, b) => b.contribution - a.contribution);\n  }\n}\n"],"mappings":"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","names":["edges","path","path","edges","nodes","path","text","eq","and","inArray","sql","nanoid","nanoid","eq","and","inArray","result","sql","eq","and","sql","nanoid","nanoid","eq","and","sql","eq","sql","inArray","nanoid","nanoid","eq","inArray","sql","eq","and","sql","nanoid","nanoid","eq","and","sql","sql","sql","eq","eq","eq","inArray","sql","nanoid","DEFAULT_CONFIG","nanoid","eq","inArray","sql","eq","and","or","sql","nanoid","nanoid","and","eq","or","sql","eq","and","inArray","sql","eq","sql","and","inArray","aliases","text","aliases","edges","path","edges","chunks","nodes"]}