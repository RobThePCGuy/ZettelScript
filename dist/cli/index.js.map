{"version":3,"sources":["../../src/cli/index.ts","../../src/cli/commands/init.ts","../../src/storage/database/connection.ts","../../src/storage/database/schema.ts","../../src/core/errors.ts","../../src/core/types/index.ts","../../src/core/logger.ts","../../src/cli/utils.ts","../../src/storage/database/repositories/node-repository.ts","../../src/storage/database/repositories/edge-repository.ts","../../src/storage/database/repositories/version-repository.ts","../../src/storage/database/repositories/chunk-repository.ts","../../src/storage/database/repositories/mention-repository.ts","../../src/storage/database/repositories/unresolved-link-repository.ts","../../src/storage/database/repositories/constellation-repository.ts","../../src/storage/database/repositories/embedding-repository.ts","../../src/core/circuit-breaker.ts","../../src/storage/database/repositories/wormhole-repository.ts","../../src/storage/database/repositories/candidate-edge-repository.ts","../../src/parser/markdown.ts","../../src/parser/frontmatter.ts","../../src/parser/exclusions.ts","../../src/parser/wikilink.ts","../../src/parser/resolver.ts","../../src/indexer/pipeline.ts","../../src/core/graph/pathfinder.ts","../../src/core/graph/engine.ts","../../src/cli/commands/index.ts","../../src/storage/filesystem/reader.ts","../../src/indexer/batch.ts","../../src/cli/commands/watch.ts","../../src/indexer/incremental.ts","../../src/storage/filesystem/watcher.ts","../../src/cli/commands/query.ts","../../src/core/validation.ts","../../src/cli/commands/validate.ts","../../src/validation/link-validator.ts","../../src/validation/schema-validator.ts","../../src/validation/continuity-checker.ts","../../src/cli/commands/discover.ts","../../src/discovery/mention-detector.ts","../../src/discovery/mention-ranker.ts","../../src/cli/interactive-approver.ts","../../src/cli/commands/retrieve.ts","../../src/retrieval/expansion/graph-expander.ts","../../src/retrieval/fusion/rrf.ts","../../src/retrieval/context/assembler.ts","../../src/cli/commands/rewrite.ts","../../src/engine/manuscript/impact-analyzer.ts","../../src/engine/manuscript/rewrite-orchestrator.ts","../../src/llm/provider.ts","../../src/llm/prompts.ts","../../src/cli/commands/extract.ts","../../src/extraction/entity-extractor.ts","../../src/extraction/json-parser.ts","../../src/cli/commands/generate.ts","../../src/generators/types.ts","../../src/generators/utils.ts","../../src/generators/relationships.ts","../../src/generators/related-entities.ts","../../src/generators/characters.ts","../../src/generators/chapters.ts","../../src/generators/locations.ts","../../src/generators/objects.ts","../../src/generators/lore.ts","../../src/generators/timeline.ts","../../src/generators/arcs.ts","../../src/generators/inject-links.ts","../../src/cli/commands/inject-links.ts","../../src/cli/commands/visualize.ts","../../src/cli/server/visualize-server.ts","../../src/cli/server/ws-protocol.ts","../../src/cli/commands/doctor.ts","../../src/cli/commands/setup.ts","../../src/retrieval/embeddings/provider.ts","../../src/retrieval/similarity/similarity.ts","../../src/retrieval/similarity/wormhole-detector.ts","../../src/cli/commands/constellation.ts","../../src/cli/commands/embed.ts","../../src/cli/commands/wormhole.ts","../../src/cli/commands/path.ts","../../src/cli/commands/focus.ts","../../src/discovery/focus-bundle.ts","../../src/discovery/suggestion-engine.ts","../../src/cli/commands/approve.ts","../../src/cli/commands/reject.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport { initCommand } from './commands/init.js';\nimport { indexCommand } from './commands/index.js';\nimport { watchCommand } from './commands/watch.js';\nimport { queryCommand } from './commands/query.js';\nimport { validateCommand } from './commands/validate.js';\nimport { discoverCommand } from './commands/discover.js';\nimport { retrieveCommand } from './commands/retrieve.js';\nimport { rewriteCommand } from './commands/rewrite.js';\nimport { extractCommand } from './commands/extract.js';\nimport { generateCommand } from './commands/generate.js';\nimport { injectLinksCommand } from './commands/inject-links.js';\nimport { visualizeCommand } from './commands/visualize.js';\nimport { setupCommand } from './commands/setup.js';\nimport { constellationCommand } from './commands/constellation.js';\nimport { embedCommand } from './commands/embed.js';\nimport { wormholeCommand } from './commands/wormhole.js';\nimport { pathCommand } from './commands/path.js';\nimport { doctorCommand } from './commands/doctor.js';\nimport { focusCommand } from './commands/focus.js';\nimport { approveCommand } from './commands/approve.js';\nimport { rejectCommand } from './commands/reject.js';\n\nconst program = new Command();\n\nprogram\n  .name('zettel')\n  .description('ZettelScript - Graph-first knowledge management system')\n  .version('0.1.0');\n\n// Register commands\nprogram.addCommand(initCommand);\nprogram.addCommand(indexCommand);\nprogram.addCommand(watchCommand);\nprogram.addCommand(queryCommand);\nprogram.addCommand(validateCommand);\nprogram.addCommand(discoverCommand);\nprogram.addCommand(retrieveCommand);\nprogram.addCommand(rewriteCommand);\nprogram.addCommand(extractCommand);\nprogram.addCommand(generateCommand);\nprogram.addCommand(injectLinksCommand);\nprogram.addCommand(visualizeCommand);\nprogram.addCommand(setupCommand);\nprogram.addCommand(constellationCommand);\nprogram.addCommand(embedCommand);\nprogram.addCommand(wormholeCommand);\nprogram.addCommand(pathCommand);\nprogram.addCommand(doctorCommand);\nprogram.addCommand(focusCommand);\nprogram.addCommand(approveCommand);\nprogram.addCommand(rejectCommand);\n\n// Parse arguments\nprogram.parse();\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { stringify as stringifyYaml } from 'yaml';\nimport { ConnectionManager } from '../../storage/database/connection.js';\nimport { DEFAULT_CONFIG, type ZettelScriptConfig } from '../../core/types/index.js';\nimport { getZettelScriptDir, getDbPath, getConfigPath, findVaultRoot } from '../utils.js';\n\nexport const initCommand = new Command('init')\n  .description('Initialize a ZettelScript vault in the current directory')\n  .option('-f, --force', 'Overwrite existing initialization')\n  .option('--manuscript', 'Enable manuscript mode with POV and timeline validation')\n  .action(async (options) => {\n    const vaultPath = process.cwd();\n    const zettelDir = getZettelScriptDir(vaultPath);\n\n    // Check if already initialized\n    if (fs.existsSync(zettelDir) && !options.force) {\n      const existingRoot = findVaultRoot(vaultPath);\n      if (existingRoot) {\n        console.log(`Already initialized at: ${existingRoot}`);\n        console.log('Use --force to reinitialize.');\n        return;\n      }\n    }\n\n    console.log('Initializing ZettelScript vault...');\n\n    try {\n      // Create .zettelscript directory\n      fs.mkdirSync(zettelDir, { recursive: true });\n      console.log(`  Created ${path.relative(vaultPath, zettelDir)}/`);\n\n      // Create config file\n      const config: ZettelScriptConfig = {\n        ...DEFAULT_CONFIG,\n        vault: {\n          ...DEFAULT_CONFIG.vault,\n          path: '.',\n        },\n        manuscript: {\n          ...DEFAULT_CONFIG.manuscript,\n          enabled: options.manuscript || false,\n        },\n      };\n\n      const configPath = getConfigPath(vaultPath);\n      fs.writeFileSync(configPath, stringifyYaml(config), 'utf-8');\n      console.log(`  Created ${path.relative(vaultPath, configPath)}`);\n\n      // Initialize database\n      const dbPath = getDbPath(vaultPath);\n      const manager = ConnectionManager.getInstance(dbPath);\n      await manager.initialize();\n      manager.close();\n      ConnectionManager.resetInstance();\n      console.log(`  Created ${path.relative(vaultPath, dbPath)}`);\n\n      // Create .gitignore for .zettelscript\n      const gitignorePath = path.join(zettelDir, '.gitignore');\n      fs.writeFileSync(\n        gitignorePath,\n        '# Ignore database (regenerated from files)\\nzettelscript.db\\nzettelscript.db-*\\n',\n        'utf-8'\n      );\n\n      console.log('\\nZettelScript vault initialized!');\n      console.log('\\nNext steps:');\n      console.log('  zettel index    Index all markdown files');\n      console.log('  zettel watch    Watch for file changes');\n      console.log('  zettel query    Query the graph');\n\n      if (options.manuscript) {\n        console.log('\\nManuscript mode enabled:');\n        console.log('  - Add \"type: scene\" to scene frontmatter');\n        console.log('  - Add \"pov: CharacterName\" for POV tracking');\n        console.log('  - Add \"scene_order: N\" for timeline ordering');\n        console.log('  - Run \"zettel validate --continuity\" to check consistency');\n      }\n    } catch (error) {\n      console.error('Failed to initialize:', error);\n      process.exit(1);\n    }\n  });\n","import Database from 'better-sqlite3';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport * as schema from './schema.js';\nimport { DatabaseError } from '../../core/errors.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport type DrizzleDB = ReturnType<typeof drizzle<typeof schema>>;\n\n// SQL for creating FTS5 virtual table\nconst FTS5_SCHEMA = `\nCREATE VIRTUAL TABLE IF NOT EXISTS chunks_fts USING fts5(\n  chunk_id,\n  node_id,\n  text,\n  tokenize='porter'\n);\n`;\n\n// SQL for creating FTS triggers to keep it in sync\nconst FTS5_TRIGGERS = `\nCREATE TRIGGER IF NOT EXISTS chunks_ai AFTER INSERT ON chunks BEGIN\n  INSERT INTO chunks_fts(chunk_id, node_id, text)\n  VALUES (new.chunk_id, new.node_id, new.text);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS chunks_ad AFTER DELETE ON chunks BEGIN\n  DELETE FROM chunks_fts WHERE chunk_id = old.chunk_id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS chunks_au AFTER UPDATE ON chunks BEGIN\n  DELETE FROM chunks_fts WHERE chunk_id = old.chunk_id;\n  INSERT INTO chunks_fts(chunk_id, node_id, text)\n  VALUES (new.chunk_id, new.node_id, new.text);\nEND;\n`;\n\n// Schema version for migrations\n// Increment this when adding new tables or making schema changes\nconst SCHEMA_VERSION = 4;\n\n/**\n * Database connection manager for ZettelScript\n */\nexport class ConnectionManager {\n  private static instance: ConnectionManager | null = null;\n  private sqlite: Database.Database | null = null;\n  private db: DrizzleDB | null = null;\n  private dbPath: string;\n\n  private constructor(dbPath: string) {\n    this.dbPath = dbPath;\n  }\n\n  /**\n   * Get or create the singleton connection manager\n   */\n  static getInstance(dbPath?: string): ConnectionManager {\n    if (!ConnectionManager.instance) {\n      if (!dbPath) {\n        throw new DatabaseError('Database path required for initial connection');\n      }\n      ConnectionManager.instance = new ConnectionManager(dbPath);\n    }\n    return ConnectionManager.instance;\n  }\n\n  /**\n   * Reset the singleton (useful for testing)\n   */\n  static resetInstance(): void {\n    if (ConnectionManager.instance) {\n      ConnectionManager.instance.close();\n      ConnectionManager.instance = null;\n    }\n  }\n\n  /**\n   * Initialize the database connection and schema\n   */\n  async initialize(): Promise<void> {\n    if (this.db) {\n      return; // Already initialized\n    }\n\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(this.dbPath);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n\n      // Open SQLite connection\n      this.sqlite = new Database(this.dbPath);\n\n      // Enable WAL mode for better concurrent performance\n      this.sqlite.pragma('journal_mode = WAL');\n      this.sqlite.pragma('foreign_keys = ON');\n      this.sqlite.pragma('synchronous = NORMAL');\n\n      // Create Drizzle instance\n      this.db = drizzle(this.sqlite, { schema });\n\n      // Run migrations/schema creation\n      await this.migrate();\n    } catch (error) {\n      throw new DatabaseError(`Failed to initialize database: ${error}`, {\n        path: this.dbPath,\n        error: String(error),\n      });\n    }\n  }\n\n  /**\n   * Run database migrations\n   */\n  private async migrate(): Promise<void> {\n    if (!this.sqlite) {\n      throw new DatabaseError('SQLite connection not initialized');\n    }\n\n    // Check current schema version\n    let currentVersion = 0;\n    try {\n      const result = this.sqlite.prepare('SELECT version FROM schema_version LIMIT 1').get() as\n        | { version: number }\n        | undefined;\n      if (result) {\n        currentVersion = result.version;\n      }\n    } catch (error) {\n      // Only ignore \"no such table\" errors - other errors should propagate\n      const message = error instanceof Error ? error.message : String(error);\n      if (!message.includes('no such table')) {\n        throw new Error(`Database schema check failed: ${message}`);\n      }\n      // Table doesn't exist yet - will be created below\n    }\n\n    if (currentVersion >= SCHEMA_VERSION) {\n      return; // Already up to date\n    }\n\n    // Run initial schema creation\n    this.sqlite.exec(`\n      -- Schema version tracking\n      CREATE TABLE IF NOT EXISTS schema_version (\n        version INTEGER PRIMARY KEY\n      );\n\n      -- Nodes\n      CREATE TABLE IF NOT EXISTS nodes (\n        node_id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        title TEXT NOT NULL,\n        path TEXT NOT NULL UNIQUE,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL,\n        content_hash TEXT,\n        metadata TEXT,\n        is_ghost INTEGER NOT NULL DEFAULT 0\n      );\n\n      -- Edges with version ranges\n      CREATE TABLE IF NOT EXISTS edges (\n        edge_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        edge_type TEXT NOT NULL,\n        strength REAL,\n        provenance TEXT NOT NULL,\n        created_at TEXT NOT NULL,\n        version_start TEXT,\n        version_end TEXT,\n        attributes TEXT\n      );\n\n      -- Version history\n      CREATE TABLE IF NOT EXISTS versions (\n        version_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        content_hash TEXT NOT NULL,\n        parent_version_id TEXT,\n        created_at TEXT NOT NULL,\n        summary TEXT\n      );\n\n      -- Mention candidates\n      CREATE TABLE IF NOT EXISTS mention_candidates (\n        candidate_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        surface_text TEXT NOT NULL,\n        span_start INTEGER,\n        span_end INTEGER,\n        confidence REAL NOT NULL,\n        reasons TEXT,\n        status TEXT DEFAULT 'new'\n      );\n\n      -- Chunks for retrieval\n      CREATE TABLE IF NOT EXISTS chunks (\n        chunk_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        text TEXT NOT NULL,\n        offset_start INTEGER NOT NULL,\n        offset_end INTEGER NOT NULL,\n        version_id TEXT NOT NULL,\n        token_count INTEGER\n      );\n\n      -- Aliases\n      CREATE TABLE IF NOT EXISTS aliases (\n        alias_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        alias TEXT NOT NULL\n      );\n\n      -- Graph metrics cache\n      CREATE TABLE IF NOT EXISTS graph_metrics (\n        node_id TEXT PRIMARY KEY REFERENCES nodes(node_id) ON DELETE CASCADE,\n        centrality_pagerank REAL,\n        cluster_id TEXT,\n        computed_at TEXT NOT NULL\n      );\n\n      -- Proposals\n      CREATE TABLE IF NOT EXISTS proposals (\n        proposal_id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        description TEXT NOT NULL,\n        diff TEXT NOT NULL,\n        status TEXT DEFAULT 'pending',\n        created_at TEXT NOT NULL,\n        applied_at TEXT,\n        metadata TEXT\n      );\n\n      -- Unresolved links\n      CREATE TABLE IF NOT EXISTS unresolved_links (\n        link_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_text TEXT NOT NULL,\n        span_start INTEGER,\n        span_end INTEGER,\n        created_at TEXT NOT NULL\n      );\n\n      -- Constellations (saved graph views)\n      CREATE TABLE IF NOT EXISTS constellations (\n        constellation_id TEXT PRIMARY KEY,\n        name TEXT NOT NULL UNIQUE,\n        description TEXT,\n        hidden_node_types TEXT,\n        hidden_edge_types TEXT,\n        show_ghosts INTEGER NOT NULL DEFAULT 1,\n        ghost_threshold INTEGER NOT NULL DEFAULT 1,\n        camera_x REAL,\n        camera_y REAL,\n        camera_zoom REAL,\n        focus_node_ids TEXT,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL\n      );\n\n      -- Node embeddings (for semantic wormholes)\n      CREATE TABLE IF NOT EXISTS node_embeddings (\n        embedding_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL UNIQUE REFERENCES nodes(node_id) ON DELETE CASCADE,\n        embedding TEXT NOT NULL,\n        model TEXT NOT NULL,\n        dimensions INTEGER NOT NULL,\n        content_hash TEXT NOT NULL,\n        computed_at TEXT NOT NULL\n      );\n\n      -- Wormhole rejections (tracks rejected semantic suggestions)\n      CREATE TABLE IF NOT EXISTS wormhole_rejections (\n        rejection_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        source_content_hash TEXT NOT NULL,\n        target_content_hash TEXT NOT NULL,\n        rejected_at TEXT NOT NULL\n      );\n\n      -- Candidate edges (Phase 2: Suggestions)\n      CREATE TABLE IF NOT EXISTS candidate_edges (\n        suggestion_id TEXT PRIMARY KEY,\n        from_id TEXT NOT NULL,\n        to_id TEXT NOT NULL,\n        suggested_edge_type TEXT NOT NULL,\n        from_id_norm TEXT NOT NULL,\n        to_id_norm TEXT NOT NULL,\n        status TEXT NOT NULL DEFAULT 'suggested',\n        status_changed_at TEXT,\n        signals TEXT,\n        reasons TEXT,\n        provenance TEXT,\n        created_at TEXT NOT NULL,\n        last_computed_at TEXT NOT NULL,\n        last_seen_at TEXT,\n        writeback_status TEXT,\n        writeback_reason TEXT,\n        approved_edge_id TEXT\n      );\n\n      -- Performance indexes\n      CREATE INDEX IF NOT EXISTS idx_nodes_title ON nodes(title COLLATE NOCASE);\n      CREATE INDEX IF NOT EXISTS idx_nodes_type ON nodes(type);\n      CREATE INDEX IF NOT EXISTS idx_nodes_path ON nodes(path);\n      CREATE INDEX IF NOT EXISTS idx_nodes_ghost ON nodes(is_ghost);\n      CREATE INDEX IF NOT EXISTS idx_edges_source ON edges(source_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_target ON edges(target_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_type ON edges(edge_type);\n      CREATE INDEX IF NOT EXISTS idx_edges_source_target ON edges(source_id, target_id);\n      CREATE INDEX IF NOT EXISTS idx_versions_node ON versions(node_id);\n      CREATE INDEX IF NOT EXISTS idx_versions_parent ON versions(parent_version_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_source ON mention_candidates(source_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_target ON mention_candidates(target_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_status ON mention_candidates(status);\n      CREATE INDEX IF NOT EXISTS idx_chunks_node ON chunks(node_id);\n      CREATE INDEX IF NOT EXISTS idx_chunks_version ON chunks(version_id);\n      CREATE INDEX IF NOT EXISTS idx_aliases_node ON aliases(node_id);\n      CREATE INDEX IF NOT EXISTS idx_aliases_alias ON aliases(alias COLLATE NOCASE);\n      CREATE INDEX IF NOT EXISTS idx_proposals_node ON proposals(node_id);\n      CREATE INDEX IF NOT EXISTS idx_proposals_status ON proposals(status);\n      CREATE INDEX IF NOT EXISTS idx_unresolved_source ON unresolved_links(source_id);\n      CREATE INDEX IF NOT EXISTS idx_unresolved_target ON unresolved_links(target_text);\n      CREATE INDEX IF NOT EXISTS idx_constellations_name ON constellations(name);\n      CREATE INDEX IF NOT EXISTS idx_embeddings_node ON node_embeddings(node_id);\n      CREATE INDEX IF NOT EXISTS idx_embeddings_model ON node_embeddings(model);\n      CREATE INDEX IF NOT EXISTS idx_rejections_source ON wormhole_rejections(source_id);\n      CREATE INDEX IF NOT EXISTS idx_rejections_target ON wormhole_rejections(target_id);\n      CREATE INDEX IF NOT EXISTS idx_rejections_pair ON wormhole_rejections(source_id, target_id);\n      CREATE INDEX IF NOT EXISTS idx_candidate_from ON candidate_edges(from_id);\n      CREATE INDEX IF NOT EXISTS idx_candidate_to ON candidate_edges(to_id);\n      CREATE INDEX IF NOT EXISTS idx_candidate_status ON candidate_edges(status);\n      CREATE INDEX IF NOT EXISTS idx_candidate_norm ON candidate_edges(from_id_norm, to_id_norm, suggested_edge_type);\n    `);\n\n    // Create FTS5 virtual table\n    this.sqlite.exec(FTS5_SCHEMA);\n    this.sqlite.exec(FTS5_TRIGGERS);\n\n    // Update schema version\n    this.sqlite.exec(`\n      DELETE FROM schema_version;\n      INSERT INTO schema_version (version) VALUES (${SCHEMA_VERSION});\n    `);\n  }\n\n  /**\n   * Get the Drizzle database instance\n   */\n  getDb(): DrizzleDB {\n    if (!this.db) {\n      throw new DatabaseError('Database not initialized. Call initialize() first.');\n    }\n    return this.db;\n  }\n\n  /**\n   * Get the raw SQLite database instance (for FTS5 and custom queries)\n   */\n  getSqlite(): Database.Database {\n    if (!this.sqlite) {\n      throw new DatabaseError('Database not initialized. Call initialize() first.');\n    }\n    return this.sqlite;\n  }\n\n  /**\n   * Close the database connection\n   */\n  close(): void {\n    if (this.sqlite) {\n      this.sqlite.close();\n      this.sqlite = null;\n      this.db = null;\n    }\n  }\n\n  /**\n   * Run a transaction\n   */\n  transaction<T>(fn: () => T): T {\n    const sqlite = this.getSqlite();\n    return sqlite.transaction(fn)();\n  }\n\n  /**\n   * Check if the database is initialized\n   */\n  isInitialized(): boolean {\n    return this.db !== null;\n  }\n\n  /**\n   * Get database statistics\n   */\n  getStats(): {\n    nodeCount: number;\n    edgeCount: number;\n    chunkCount: number;\n    dbSizeBytes: number;\n  } {\n    const sqlite = this.getSqlite();\n\n    const nodeCount = (\n      sqlite.prepare('SELECT COUNT(*) as count FROM nodes').get() as { count: number }\n    ).count;\n    const edgeCount = (\n      sqlite.prepare('SELECT COUNT(*) as count FROM edges').get() as { count: number }\n    ).count;\n    const chunkCount = (\n      sqlite.prepare('SELECT COUNT(*) as count FROM chunks').get() as { count: number }\n    ).count;\n\n    const stats = fs.statSync(this.dbPath);\n\n    return {\n      nodeCount,\n      edgeCount,\n      chunkCount,\n      dbSizeBytes: stats.size,\n    };\n  }\n}\n\n/**\n * Helper to get a database connection for a vault\n */\nexport async function getDatabase(vaultPath: string): Promise<DrizzleDB> {\n  const dbPath = path.join(vaultPath, '.zettelscript', 'zettelscript.db');\n  const manager = ConnectionManager.getInstance(dbPath);\n  await manager.initialize();\n  return manager.getDb();\n}\n\n/**\n * Helper to get raw SQLite for FTS5 queries\n */\nexport function getRawSqlite(vaultPath: string): Database.Database {\n  const dbPath = path.join(vaultPath, '.zettelscript', 'zettelscript.db');\n  const manager = ConnectionManager.getInstance(dbPath);\n  return manager.getSqlite();\n}\n","import { sqliteTable, text, real, integer, index } from 'drizzle-orm/sqlite-core';\n\n// ============================================================================\n// Nodes Table\n// ============================================================================\n\nexport const nodes = sqliteTable(\n  'nodes',\n  {\n    nodeId: text('node_id').primaryKey(),\n    type: text('type').notNull(),\n    title: text('title').notNull(),\n    path: text('path').notNull().unique(),\n    createdAt: text('created_at').notNull(),\n    updatedAt: text('updated_at').notNull(),\n    contentHash: text('content_hash'),\n    metadata: text('metadata', { mode: 'json' }),\n    isGhost: integer('is_ghost').notNull().default(0), // 0 = real node, 1 = ghost\n  },\n  (table) => [\n    index('idx_nodes_title').on(table.title),\n    index('idx_nodes_type').on(table.type),\n    index('idx_nodes_path').on(table.path),\n    index('idx_nodes_ghost').on(table.isGhost),\n  ]\n);\n\n// ============================================================================\n// Edges Table\n// ============================================================================\n\nexport const edges = sqliteTable(\n  'edges',\n  {\n    edgeId: text('edge_id').primaryKey(),\n    sourceId: text('source_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    targetId: text('target_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    edgeType: text('edge_type').notNull(),\n    strength: real('strength'),\n    provenance: text('provenance').notNull(),\n    createdAt: text('created_at').notNull(),\n    versionStart: text('version_start'),\n    versionEnd: text('version_end'),\n    attributes: text('attributes', { mode: 'json' }),\n  },\n  (table) => [\n    index('idx_edges_source').on(table.sourceId),\n    index('idx_edges_target').on(table.targetId),\n    index('idx_edges_type').on(table.edgeType),\n    index('idx_edges_source_target').on(table.sourceId, table.targetId),\n  ]\n);\n\n// ============================================================================\n// Versions Table\n// ============================================================================\n\nexport const versions = sqliteTable(\n  'versions',\n  {\n    versionId: text('version_id').primaryKey(),\n    nodeId: text('node_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    contentHash: text('content_hash').notNull(),\n    parentVersionId: text('parent_version_id'),\n    createdAt: text('created_at').notNull(),\n    summary: text('summary'),\n  },\n  (table) => [\n    index('idx_versions_node').on(table.nodeId),\n    index('idx_versions_parent').on(table.parentVersionId),\n  ]\n);\n\n// ============================================================================\n// Mention Candidates Table\n// ============================================================================\n\nexport const mentionCandidates = sqliteTable(\n  'mention_candidates',\n  {\n    candidateId: text('candidate_id').primaryKey(),\n    sourceId: text('source_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    targetId: text('target_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    surfaceText: text('surface_text').notNull(),\n    spanStart: integer('span_start'),\n    spanEnd: integer('span_end'),\n    confidence: real('confidence').notNull(),\n    reasons: text('reasons', { mode: 'json' }),\n    status: text('status').default('new'),\n  },\n  (table) => [\n    index('idx_mentions_source').on(table.sourceId),\n    index('idx_mentions_target').on(table.targetId),\n    index('idx_mentions_status').on(table.status),\n  ]\n);\n\n// ============================================================================\n// Chunks Table\n// ============================================================================\n\nexport const chunks = sqliteTable(\n  'chunks',\n  {\n    chunkId: text('chunk_id').primaryKey(),\n    nodeId: text('node_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    text: text('text').notNull(),\n    offsetStart: integer('offset_start').notNull(),\n    offsetEnd: integer('offset_end').notNull(),\n    versionId: text('version_id').notNull(),\n    tokenCount: integer('token_count'),\n  },\n  (table) => [\n    index('idx_chunks_node').on(table.nodeId),\n    index('idx_chunks_version').on(table.versionId),\n  ]\n);\n\n// ============================================================================\n// Aliases Table\n// ============================================================================\n\nexport const aliases = sqliteTable(\n  'aliases',\n  {\n    aliasId: text('alias_id').primaryKey(),\n    nodeId: text('node_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    alias: text('alias').notNull(),\n  },\n  (table) => [\n    index('idx_aliases_node').on(table.nodeId),\n    index('idx_aliases_alias').on(table.alias),\n  ]\n);\n\n// ============================================================================\n// Graph Metrics Cache\n// ============================================================================\n\nexport const graphMetrics = sqliteTable('graph_metrics', {\n  nodeId: text('node_id')\n    .primaryKey()\n    .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  centralityPagerank: real('centrality_pagerank'),\n  clusterId: text('cluster_id'),\n  computedAt: text('computed_at').notNull(),\n});\n\n// ============================================================================\n// Proposals Table\n// ============================================================================\n\nexport const proposals = sqliteTable(\n  'proposals',\n  {\n    proposalId: text('proposal_id').primaryKey(),\n    type: text('type').notNull(),\n    nodeId: text('node_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    description: text('description').notNull(),\n    diff: text('diff', { mode: 'json' }).notNull(),\n    status: text('status').default('pending'),\n    createdAt: text('created_at').notNull(),\n    appliedAt: text('applied_at'),\n    metadata: text('metadata', { mode: 'json' }),\n  },\n  (table) => [\n    index('idx_proposals_node').on(table.nodeId),\n    index('idx_proposals_status').on(table.status),\n  ]\n);\n\n// ============================================================================\n// Unresolved Links Table\n// ============================================================================\n\nexport const unresolvedLinks = sqliteTable(\n  'unresolved_links',\n  {\n    linkId: text('link_id').primaryKey(),\n    sourceId: text('source_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    targetText: text('target_text').notNull(),\n    spanStart: integer('span_start'),\n    spanEnd: integer('span_end'),\n    createdAt: text('created_at').notNull(),\n  },\n  (table) => [\n    index('idx_unresolved_source').on(table.sourceId),\n    index('idx_unresolved_target').on(table.targetText),\n  ]\n);\n\n// ============================================================================\n// Constellations Table (Saved Graph Views)\n// ============================================================================\n\nexport const constellations = sqliteTable(\n  'constellations',\n  {\n    constellationId: text('constellation_id').primaryKey(),\n    name: text('name').notNull().unique(),\n    description: text('description'),\n\n    // Filter state (JSON arrays)\n    hiddenNodeTypes: text('hidden_node_types', { mode: 'json' }),\n    hiddenEdgeTypes: text('hidden_edge_types', { mode: 'json' }),\n\n    // Ghost node config\n    showGhosts: integer('show_ghosts').notNull().default(1),\n    ghostThreshold: integer('ghost_threshold').notNull().default(1),\n\n    // Camera state\n    cameraX: real('camera_x'),\n    cameraY: real('camera_y'),\n    cameraZoom: real('camera_zoom'),\n\n    // Focus nodes (seed nodes for the view)\n    focusNodeIds: text('focus_node_ids', { mode: 'json' }),\n\n    // Timestamps\n    createdAt: text('created_at').notNull(),\n    updatedAt: text('updated_at').notNull(),\n  },\n  (table) => [index('idx_constellations_name').on(table.name)]\n);\n\n// ============================================================================\n// Node Embeddings Table (for Semantic Wormholes)\n// ============================================================================\n\nexport const nodeEmbeddings = sqliteTable(\n  'node_embeddings',\n  {\n    embeddingId: text('embedding_id').primaryKey(),\n    nodeId: text('node_id')\n      .notNull()\n      .unique()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    embedding: text('embedding', { mode: 'json' }).notNull(), // Float array as JSON\n    model: text('model').notNull(), // e.g., 'openai:text-embedding-3-small'\n    dimensions: integer('dimensions').notNull(),\n    contentHash: text('content_hash').notNull(), // To detect when recompute is needed\n    computedAt: text('computed_at').notNull(),\n  },\n  (table) => [\n    index('idx_embeddings_node').on(table.nodeId),\n    index('idx_embeddings_model').on(table.model),\n  ]\n);\n\n// ============================================================================\n// Wormhole Rejections Table (Tracks Rejected Semantic Suggestions)\n// ============================================================================\n\nexport const wormholeRejections = sqliteTable(\n  'wormhole_rejections',\n  {\n    rejectionId: text('rejection_id').primaryKey(),\n    sourceId: text('source_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    targetId: text('target_id')\n      .notNull()\n      .references(() => nodes.nodeId, { onDelete: 'cascade' }),\n    sourceContentHash: text('source_content_hash').notNull(),\n    targetContentHash: text('target_content_hash').notNull(),\n    rejectedAt: text('rejected_at').notNull(),\n  },\n  (table) => [\n    index('idx_rejections_source').on(table.sourceId),\n    index('idx_rejections_target').on(table.targetId),\n    index('idx_rejections_pair').on(table.sourceId, table.targetId),\n  ]\n);\n\n// ============================================================================\n// Candidate Edges Table (Phase 2: Suggestions)\n// ============================================================================\n\nexport const candidateEdges = sqliteTable(\n  'candidate_edges',\n  {\n    suggestionId: text('suggestion_id').primaryKey(),\n    fromId: text('from_id').notNull(),\n    toId: text('to_id').notNull(),\n    suggestedEdgeType: text('suggested_edge_type').notNull(),\n\n    // For undirected uniqueness (canonical ordering)\n    fromIdNorm: text('from_id_norm').notNull(),\n    toIdNorm: text('to_id_norm').notNull(),\n\n    // Status lifecycle\n    status: text('status').default('suggested').notNull(),\n    statusChangedAt: text('status_changed_at'),\n\n    // Evidence (merged from multiple sources)\n    signals: text('signals', { mode: 'json' }), // { semantic?, mentionCount?, graphProximity? }\n    reasons: text('reasons', { mode: 'json' }), // string[]\n    provenance: text('provenance', { mode: 'json' }), // array of evidence objects\n\n    // Timestamps\n    createdAt: text('created_at').notNull(),\n    lastComputedAt: text('last_computed_at').notNull(),\n    lastSeenAt: text('last_seen_at'),\n\n    // Writeback tracking\n    writebackStatus: text('writeback_status'),\n    writebackReason: text('writeback_reason'),\n    approvedEdgeId: text('approved_edge_id'),\n  },\n  (table) => [\n    index('idx_candidate_from').on(table.fromId),\n    index('idx_candidate_to').on(table.toId),\n    index('idx_candidate_status').on(table.status),\n    index('idx_candidate_norm').on(table.fromIdNorm, table.toIdNorm, table.suggestedEdgeType),\n  ]\n);\n\n// Type exports for use in repositories\nexport type NodeRow = typeof nodes.$inferSelect;\nexport type NewNodeRow = typeof nodes.$inferInsert;\n\nexport type EdgeRow = typeof edges.$inferSelect;\nexport type NewEdgeRow = typeof edges.$inferInsert;\n\nexport type VersionRow = typeof versions.$inferSelect;\nexport type NewVersionRow = typeof versions.$inferInsert;\n\nexport type MentionCandidateRow = typeof mentionCandidates.$inferSelect;\nexport type NewMentionCandidateRow = typeof mentionCandidates.$inferInsert;\n\nexport type ChunkRow = typeof chunks.$inferSelect;\nexport type NewChunkRow = typeof chunks.$inferInsert;\n\nexport type AliasRow = typeof aliases.$inferSelect;\nexport type NewAliasRow = typeof aliases.$inferInsert;\n\nexport type ProposalRow = typeof proposals.$inferSelect;\nexport type NewProposalRow = typeof proposals.$inferInsert;\n\nexport type ConstellationRow = typeof constellations.$inferSelect;\nexport type NewConstellationRow = typeof constellations.$inferInsert;\n\nexport type NodeEmbeddingRow = typeof nodeEmbeddings.$inferSelect;\nexport type NewNodeEmbeddingRow = typeof nodeEmbeddings.$inferInsert;\n\nexport type WormholeRejectionRow = typeof wormholeRejections.$inferSelect;\nexport type NewWormholeRejectionRow = typeof wormholeRejections.$inferInsert;\n\nexport type CandidateEdgeRow = typeof candidateEdges.$inferSelect;\nexport type NewCandidateEdgeRow = typeof candidateEdges.$inferInsert;\n","/**\n * Base error class for ZettelScript\n */\nexport class ZettelScriptError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'ZettelScriptError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n/**\n * Database-related errors\n */\nexport class DatabaseError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'DATABASE_ERROR', details);\n    this.name = 'DatabaseError';\n  }\n}\n\n/**\n * Parsing errors (markdown, frontmatter, wikilinks)\n */\nexport class ParseError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public filePath: string,\n    public line?: number,\n    public column?: number,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'PARSE_ERROR', { filePath, line, column, ...details });\n    this.name = 'ParseError';\n  }\n}\n\n/**\n * Link resolution errors\n */\nexport class ResolutionError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public linkText: string,\n    public candidates?: string[],\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'RESOLUTION_ERROR', { linkText, candidates, ...details });\n    this.name = 'ResolutionError';\n  }\n}\n\n/**\n * Validation errors\n */\nexport class ValidationError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public issues: Array<{\n      path: string;\n      message: string;\n      severity: 'error' | 'warning';\n    }>,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'VALIDATION_ERROR', { issues, ...details });\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'CONFIG_ERROR', details);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Graph operation errors\n */\nexport class GraphError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'GRAPH_ERROR', details);\n    this.name = 'GraphError';\n  }\n}\n\n/**\n * Retrieval/embedding errors\n */\nexport class RetrievalError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'RETRIEVAL_ERROR', details);\n    this.name = 'RetrievalError';\n  }\n}\n\n/**\n * File system errors\n */\nexport class FileSystemError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public filePath: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'FILESYSTEM_ERROR', { filePath, ...details });\n    this.name = 'FileSystemError';\n  }\n}\n\n/**\n * Manuscript/continuity errors\n */\nexport class ContinuityError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public issueType: string,\n    public nodeId: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'CONTINUITY_ERROR', { issueType, nodeId, ...details });\n    this.name = 'ContinuityError';\n  }\n}\n\n/**\n * Proposal/writeback errors\n */\nexport class ProposalError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public proposalId: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'PROPOSAL_ERROR', { proposalId, ...details });\n    this.name = 'ProposalError';\n  }\n}\n\n/**\n * Embedding provider errors\n */\nexport class EmbeddingError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public provider: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'EMBEDDING_ERROR', { provider, ...details });\n    this.name = 'EmbeddingError';\n  }\n}\n","import { Type, Static } from '@sinclair/typebox';\nimport { createHash } from 'node:crypto';\nimport { getLogger } from '../logger.js';\n\n// ============================================================================\n// Node Types\n// ============================================================================\n\nexport const NodeTypeSchema = Type.Union([\n  Type.Literal('note'),\n  Type.Literal('scene'),\n  Type.Literal('character'),\n  Type.Literal('location'),\n  Type.Literal('object'),\n  Type.Literal('event'),\n  Type.Literal('concept'),\n  Type.Literal('moc'),\n  Type.Literal('timeline'),\n  Type.Literal('draft'),\n]);\n\nexport type NodeType = Static<typeof NodeTypeSchema>;\n\nexport const NodeSchema = Type.Object({\n  nodeId: Type.String(),\n  type: NodeTypeSchema,\n  title: Type.String(),\n  path: Type.String(),\n  createdAt: Type.String({ format: 'date-time' }),\n  updatedAt: Type.String({ format: 'date-time' }),\n  contentHash: Type.Optional(Type.String()),\n  metadata: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n  isGhost: Type.Optional(Type.Boolean()),\n});\n\nexport type Node = Static<typeof NodeSchema>;\n\n// ============================================================================\n// Edge Types\n// ============================================================================\n\nexport const EdgeTypeSchema = Type.Union([\n  Type.Literal('explicit_link'),\n  Type.Literal('backlink'),\n  Type.Literal('sequence'),\n  Type.Literal('hierarchy'),\n  Type.Literal('participation'),\n  Type.Literal('pov_visible_to'),\n  Type.Literal('causes'),\n  Type.Literal('setup_payoff'),\n  Type.Literal('semantic'),\n  Type.Literal('semantic_suggestion'), // Pending semantic wormhole (not yet accepted)\n  Type.Literal('mention'),\n  Type.Literal('alias'),\n]);\n\nexport type EdgeType = Static<typeof EdgeTypeSchema>;\n\nexport const EdgeProvenanceSchema = Type.Union([\n  Type.Literal('explicit'),\n  Type.Literal('inferred'),\n  Type.Literal('computed'),\n  Type.Literal('user_approved'),\n]);\n\nexport type EdgeProvenance = Static<typeof EdgeProvenanceSchema>;\n\nexport const EdgeSchema = Type.Object({\n  edgeId: Type.String(),\n  sourceId: Type.String(),\n  targetId: Type.String(),\n  edgeType: EdgeTypeSchema,\n  strength: Type.Optional(Type.Number({ minimum: 0, maximum: 1 })),\n  provenance: EdgeProvenanceSchema,\n  createdAt: Type.String({ format: 'date-time' }),\n  versionStart: Type.Optional(Type.String()),\n  versionEnd: Type.Optional(Type.String()),\n  attributes: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n});\n\nexport type Edge = Static<typeof EdgeSchema>;\n\n// ============================================================================\n// Version Types\n// ============================================================================\n\nexport const VersionSchema = Type.Object({\n  versionId: Type.String(),\n  nodeId: Type.String(),\n  contentHash: Type.String(),\n  parentVersionId: Type.Optional(Type.String()),\n  createdAt: Type.String({ format: 'date-time' }),\n  summary: Type.Optional(Type.String()),\n});\n\nexport type Version = Static<typeof VersionSchema>;\n\n// ============================================================================\n// Mention Types\n// ============================================================================\n\nexport const MentionStatusSchema = Type.Union([\n  Type.Literal('new'),\n  Type.Literal('approved'),\n  Type.Literal('rejected'),\n  Type.Literal('deferred'),\n]);\n\nexport type MentionStatus = Static<typeof MentionStatusSchema>;\n\nexport const MentionCandidateSchema = Type.Object({\n  candidateId: Type.String(),\n  sourceId: Type.String(),\n  targetId: Type.String(),\n  surfaceText: Type.String(),\n  spanStart: Type.Optional(Type.Integer()),\n  spanEnd: Type.Optional(Type.Integer()),\n  confidence: Type.Number({ minimum: 0, maximum: 1 }),\n  reasons: Type.Optional(Type.Array(Type.String())),\n  status: MentionStatusSchema,\n});\n\nexport type MentionCandidate = Static<typeof MentionCandidateSchema>;\n\n// ============================================================================\n// Chunk Types (for retrieval)\n// ============================================================================\n\nexport const ChunkSchema = Type.Object({\n  chunkId: Type.String(),\n  nodeId: Type.String(),\n  text: Type.String(),\n  offsetStart: Type.Integer(),\n  offsetEnd: Type.Integer(),\n  versionId: Type.String(),\n  tokenCount: Type.Optional(Type.Integer()),\n});\n\nexport type Chunk = Static<typeof ChunkSchema>;\n\n// ============================================================================\n// Proposal Types (for writeback)\n// ============================================================================\n\nexport const ProposalTypeSchema = Type.Union([\n  Type.Literal('link_addition'),\n  Type.Literal('content_edit'),\n  Type.Literal('node_creation'),\n  Type.Literal('node_deletion'),\n  Type.Literal('metadata_update'),\n]);\n\nexport type ProposalType = Static<typeof ProposalTypeSchema>;\n\nexport const ProposalStatusSchema = Type.Union([\n  Type.Literal('pending'),\n  Type.Literal('approved'),\n  Type.Literal('rejected'),\n  Type.Literal('applied'),\n]);\n\nexport type ProposalStatus = Static<typeof ProposalStatusSchema>;\n\nexport const ProposalSchema = Type.Object({\n  proposalId: Type.String(),\n  type: ProposalTypeSchema,\n  nodeId: Type.String(),\n  description: Type.String(),\n  diff: Type.Object({\n    before: Type.Optional(Type.String()),\n    after: Type.String(),\n  }),\n  status: ProposalStatusSchema,\n  createdAt: Type.String({ format: 'date-time' }),\n  appliedAt: Type.Optional(Type.String({ format: 'date-time' })),\n  metadata: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n});\n\nexport type Proposal = Static<typeof ProposalSchema>;\n\n// ============================================================================\n// Graph Metrics\n// ============================================================================\n\nexport const GraphMetricsSchema = Type.Object({\n  nodeId: Type.String(),\n  centralityPagerank: Type.Optional(Type.Number()),\n  clusterId: Type.Optional(Type.String()),\n  computedAt: Type.String({ format: 'date-time' }),\n});\n\nexport type GraphMetrics = Static<typeof GraphMetricsSchema>;\n\n// ============================================================================\n// Frontmatter Schema\n// ============================================================================\n\nexport const FrontmatterSchema = Type.Object(\n  {\n    id: Type.Optional(Type.String()),\n    title: Type.Optional(Type.String()),\n    type: Type.Optional(NodeTypeSchema),\n    aliases: Type.Optional(Type.Array(Type.String())),\n    tags: Type.Optional(Type.Array(Type.String())),\n    created: Type.Optional(Type.String()),\n    updated: Type.Optional(Type.String()),\n    // Manuscript-specific fields\n    pov: Type.Optional(Type.String()),\n    scene_order: Type.Optional(Type.Number()),\n    timeline_position: Type.Optional(Type.String()),\n    characters: Type.Optional(Type.Array(Type.String())),\n    locations: Type.Optional(Type.Array(Type.String())),\n    // Allow additional fields\n  },\n  { additionalProperties: true }\n);\n\nexport type Frontmatter = Static<typeof FrontmatterSchema>;\n\n// ============================================================================\n// Wikilink Types\n// ============================================================================\n\nexport interface WikiLink {\n  raw: string; // Original text including brackets\n  target: string; // The link target (after id: prefix if present)\n  display: string; // Display text (after | if present)\n  isIdLink: boolean; // Whether it uses id: prefix\n  start: number; // Start position in source\n  end: number; // End position in source\n}\n\nexport interface ResolvedLink extends WikiLink {\n  resolvedNodeId: string | null;\n  ambiguous: boolean;\n  candidates: string[]; // Node IDs if ambiguous\n}\n\n// ============================================================================\n// Query Types\n// ============================================================================\n\nexport interface BacklinkResult {\n  sourceNode: Node;\n  edge: Edge;\n  context?: string; // Surrounding text for context\n}\n\nexport interface NeighborResult {\n  node: Node;\n  edge: Edge;\n  direction: 'incoming' | 'outgoing';\n}\n\nexport interface TraversalResult {\n  nodeId: string;\n  depth: number;\n  score: number;\n  path: string[]; // Node IDs forming the path\n}\n\n// ============================================================================\n// Retrieval Types\n// ============================================================================\n\nexport interface RetrievalQuery {\n  text: string;\n  maxResults?: number;\n  filters?: {\n    nodeTypes?: NodeType[];\n    excludeNodeIds?: string[];\n    dateRange?: { start?: string; end?: string };\n  };\n  expansion?: {\n    maxDepth?: number;\n    budget?: number;\n    edgeTypes?: EdgeType[];\n    decayFactor?: number;\n  };\n}\n\nexport interface RetrievalResult {\n  chunks: Array<{\n    chunk: Chunk;\n    node: Node;\n    score: number;\n    matchType: 'semantic' | 'lexical' | 'graph';\n  }>;\n  context: string;\n  provenance: Array<{\n    nodeId: string;\n    path: string;\n    contribution: number;\n  }>;\n}\n\n// ============================================================================\n// Manuscript Types\n// ============================================================================\n\nexport interface SceneInfo {\n  nodeId: string;\n  sceneOrder: number;\n  timelinePosition?: string;\n  pov?: string;\n  characters: string[];\n  locations: string[];\n}\n\nexport interface CharacterKnowledge {\n  characterId: string;\n  knows: Map<string, { learnedAt: string; source: string }>;\n  present: string[]; // Scene IDs where character is present\n}\n\nexport interface ContinuityIssue {\n  type:\n    | 'pov_leakage'\n    | 'timeline_inconsistency'\n    | 'missing_setup'\n    | 'orphaned_payoff'\n    | 'character_knowledge';\n  severity: 'error' | 'warning' | 'info';\n  nodeId: string;\n  description: string;\n  suggestion?: string;\n}\n\nexport interface ImpactAnalysis {\n  directImpact: string[]; // Directly affected node IDs\n  transitiveImpact: string[]; // Indirectly affected via graph\n  povImpact: string[]; // Scenes with same POV\n  timelineImpact: string[]; // Scenes in timeline range\n  characterImpact: string[]; // Characters whose knowledge changes\n}\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\nexport type VisualizationMode = 'focus' | 'classic';\n\nexport interface ZettelScriptConfig {\n  vault: {\n    path: string;\n    excludePatterns: string[];\n  };\n  database: {\n    path: string;\n  };\n  embeddings: {\n    provider: 'openai' | 'ollama';\n    model: string;\n    dimensions: number;\n    apiKey?: string;\n    baseUrl?: string;\n  };\n  retrieval: {\n    defaultMaxResults: number;\n    semanticWeight: number;\n    lexicalWeight: number;\n    graphWeight: number;\n    rrfK: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n  manuscript: {\n    enabled: boolean;\n    validatePov: boolean;\n    validateTimeline: boolean;\n    validateSetupPayoff: boolean;\n  };\n  graph: {\n    defaultMaxDepth: number;\n    defaultBudget: number;\n    decayFactor: number;\n    scoreThreshold: number;\n  };\n  chunking: {\n    maxTokens: number;\n    overlap: number;\n    minChunkSize: number;\n  };\n  discovery: {\n    weights: {\n      locality: number;\n      centrality: number;\n      frequency: number;\n      matchQuality: number;\n    };\n    confidenceThreshold: number;\n    ambiguityPenalty: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n  cache: {\n    defaultTtlMs: number;\n    defaultMaxSize: number;\n    mentionTtlMs: number;\n    mentionMaxSize: number;\n    mocTtlMs: number;\n    mocMaxSize: number;\n  };\n  impact: {\n    timelineRange: number;\n    maxTransitiveDepth: number;\n    maxTransitiveBudget: number;\n  };\n  moc: {\n    scoreNormalizationBase: number;\n    hubScoreNormalization: number;\n    clusterScoreNormalization: number;\n    defaultHubThreshold: number;\n  };\n  versioning: {\n    driftVersionWindow: number;\n    butterflyLogDefaultEntries: number;\n  };\n  search: {\n    defaultLimit: number;\n    contextWindowChars: number;\n    diffContextLines: number;\n  };\n  llm: {\n    provider: 'openai' | 'ollama' | 'none';\n    model: string;\n    apiKey?: string;\n    baseUrl?: string;\n    maxTokens?: number;\n    temperature?: number;\n  };\n  visualization: {\n    mode: VisualizationMode;\n  };\n}\n\nexport const DEFAULT_CONFIG: ZettelScriptConfig = {\n  vault: {\n    path: '.',\n    excludePatterns: ['node_modules/**', '.git/**', '.zettelscript/**'],\n  },\n  database: {\n    path: '.zettelscript/zettelscript.db',\n  },\n  embeddings: {\n    provider: 'openai',\n    model: 'text-embedding-3-small',\n    dimensions: 1536,\n  },\n  retrieval: {\n    defaultMaxResults: 20,\n    semanticWeight: 0.5,\n    lexicalWeight: 0.3,\n    graphWeight: 0.2,\n    rrfK: 60,\n    expansionMaxDepth: 3,\n    expansionBudget: 50,\n  },\n  manuscript: {\n    enabled: false,\n    validatePov: true,\n    validateTimeline: true,\n    validateSetupPayoff: true,\n  },\n  graph: {\n    defaultMaxDepth: 3,\n    defaultBudget: 50,\n    decayFactor: 0.7,\n    scoreThreshold: 0.01,\n  },\n  chunking: {\n    maxTokens: 512,\n    overlap: 50,\n    minChunkSize: 50,\n  },\n  discovery: {\n    weights: {\n      locality: 0.3,\n      centrality: 0.2,\n      frequency: 0.2,\n      matchQuality: 0.3,\n    },\n    confidenceThreshold: 0.3,\n    ambiguityPenalty: 0.7,\n    expansionMaxDepth: 4,\n    expansionBudget: 100,\n  },\n  cache: {\n    defaultTtlMs: 300000, // 5 minutes\n    defaultMaxSize: 1000,\n    mentionTtlMs: 600000, // 10 minutes\n    mentionMaxSize: 500,\n    mocTtlMs: 300000, // 5 minutes\n    mocMaxSize: 100,\n  },\n  impact: {\n    timelineRange: 5,\n    maxTransitiveDepth: 3,\n    maxTransitiveBudget: 50,\n  },\n  moc: {\n    scoreNormalizationBase: 100,\n    hubScoreNormalization: 50,\n    clusterScoreNormalization: 20,\n    defaultHubThreshold: 5,\n  },\n  versioning: {\n    driftVersionWindow: 5,\n    butterflyLogDefaultEntries: 50,\n  },\n  search: {\n    defaultLimit: 20,\n    contextWindowChars: 50,\n    diffContextLines: 3,\n  },\n  llm: {\n    provider: 'none',\n    model: 'gpt-4',\n  },\n  visualization: {\n    mode: 'focus', // v2 default: hide Layer C edges (mentions, suggestions)\n  },\n};\n\n// ============================================================================\n// Edge Layer Classification (per DESIGN.md v2)\n// ============================================================================\n\n/**\n * Layer A: Truth edges - explicit user intent or durable structure.\n * Always rendered in both focus and classic modes.\n */\nexport const LAYER_A_EDGES: EdgeType[] = [\n  'explicit_link', // User-authored [[wikilinks]]\n  'hierarchy', // Parent/child, folder structure\n  'sequence', // Chapter/scene order (chronology_next)\n  'causes', // Causal relationships\n  'setup_payoff', // Narrative foreshadowing\n  'participation', // Character in scene\n  'pov_visible_to', // POV constraints\n];\n\n/**\n * Layer B: Semantic edges - computed similarity.\n * Rendered with visual distinction (dotted, subdued).\n */\nexport const LAYER_B_EDGES: EdgeType[] = [\n  'semantic', // Accepted wormholes (similarity > threshold)\n];\n\n/**\n * Layer C: Suggestion edges - candidates, not truth.\n * Hidden by default in focus mode, shown in classic mode.\n */\nexport const LAYER_C_EDGES: EdgeType[] = [\n  'mention', // Approved mention (co-occurrence)\n  'semantic_suggestion', // Wormhole below threshold\n  'backlink', // Computed incoming (can be noisy)\n  'alias', // Alternative name reference\n];\n\n/**\n * Edge layer classification result.\n * A = Truth, B = Semantic, C = Suggestions, unknown = unclassified\n */\nexport type EdgeLayer = 'A' | 'B' | 'C' | 'unknown';\n\n/**\n * Get the layer classification for an edge type.\n * Single source of truth for edge categorization.\n * @param edgeType The type of edge to classify\n * @returns The layer ('A', 'B', 'C', or 'unknown')\n */\nexport function getEdgeLayer(edgeType: EdgeType): EdgeLayer {\n  if (LAYER_A_EDGES.includes(edgeType)) return 'A';\n  if (LAYER_B_EDGES.includes(edgeType)) return 'B';\n  if (LAYER_C_EDGES.includes(edgeType)) return 'C';\n  return 'unknown';\n}\n\n/**\n * Determine if an edge should be rendered based on visualization mode.\n * @param edgeType The type of edge to check\n * @param mode The current visualization mode ('focus' or 'classic')\n * @returns true if the edge should be rendered\n */\nexport function shouldRenderEdge(edgeType: EdgeType, mode: VisualizationMode): boolean {\n  if (mode === 'classic') return true;\n\n  const layer = getEdgeLayer(edgeType);\n\n  if (layer === 'A' || layer === 'B') return true;\n  if (layer === 'C') return false;\n\n  // Unknown edge types: warn and hide (safe default)\n  getLogger().warn(`Unknown edge type: ${edgeType}`);\n  return false;\n}\n\n// ============================================================================\n// Candidate Edge Types (Phase 2: Suggestions)\n// ============================================================================\n\nexport const CandidateEdgeStatusSchema = Type.Union([\n  Type.Literal('suggested'),\n  Type.Literal('approved'),\n  Type.Literal('rejected'),\n]);\n\nexport type CandidateEdgeStatus = Static<typeof CandidateEdgeStatusSchema>;\n\nexport const CandidateEdgeSourceSchema = Type.Union([\n  Type.Literal('mention'),\n  Type.Literal('semantic'),\n  Type.Literal('heuristic'),\n]);\n\nexport type CandidateEdgeSource = Static<typeof CandidateEdgeSourceSchema>;\n\nexport interface CandidateEdgeSignals {\n  semantic?: number;\n  mentionCount?: number;\n  graphProximity?: number;\n}\n\nexport interface CandidateEdgeProvenance {\n  model?: string;\n  excerpt?: string;\n  createdAt?: string;\n}\n\nexport interface CandidateEdge {\n  suggestionId: string;\n  fromId: string;\n  toId: string;\n  suggestedEdgeType: EdgeType;\n  status: CandidateEdgeStatus;\n  statusChangedAt?: string;\n  signals?: CandidateEdgeSignals;\n  reasons?: string[];\n  provenance?: CandidateEdgeProvenance[];\n  createdAt: string;\n  lastComputedAt: string;\n  lastSeenAt?: string;\n  writebackStatus?: string;\n  writebackReason?: string;\n  approvedEdgeId?: string;\n}\n\n/**\n * Generate a canonical suggestionId from edge components.\n *\n * Per Phase 2 design Section 2.4:\n * - 128-bit hash (32 hex chars) from (fromId, toId, edgeType)\n * - For undirected edges, IDs are canonically ordered (smaller first)\n * - For directed edges, order is preserved\n *\n * @param fromId Source node ID\n * @param toId Target node ID\n * @param edgeType The suggested edge type\n * @param isUndirected If true, IDs are canonically ordered for deduplication\n * @returns 32-character hex string (128 bits)\n */\nexport function generateSuggestionId(\n  fromId: string,\n  toId: string,\n  edgeType: EdgeType,\n  isUndirected: boolean = true\n): string {\n  // Canonical ordering for undirected edges only\n  const [a, b] = isUndirected && fromId > toId ? [toId, fromId] : [fromId, toId];\n\n  const input = `v1|${a}|${b}|${edgeType}`;\n  return createHash('sha256').update(input).digest('hex').slice(0, 32);\n}\n\n/**\n * Check if an edge type is undirected for suggestionId generation.\n * Most edges in ZettelScript are directed, but semantic similarity is undirected.\n */\nexport function isUndirectedEdgeType(edgeType: EdgeType): boolean {\n  // Semantic edges are undirected (A similar to B = B similar to A)\n  return edgeType === 'semantic' || edgeType === 'semantic_suggestion';\n}\n","/**\n * Lightweight logger with configurable log levels\n */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  SILENT = 4,\n}\n\nexport interface LoggerOptions {\n  level?: LogLevel;\n  prefix?: string;\n}\n\n/**\n * Simple logger with log levels\n */\nexport class Logger {\n  private level: LogLevel;\n  private prefix: string;\n\n  constructor(options: LoggerOptions = {}) {\n    this.level = options.level ?? LogLevel.INFO;\n    this.prefix = options.prefix ?? '';\n  }\n\n  /**\n   * Set the log level\n   */\n  setLevel(level: LogLevel): void {\n    this.level = level;\n  }\n\n  /**\n   * Get the current log level\n   */\n  getLevel(): LogLevel {\n    return this.level;\n  }\n\n  /**\n   * Format a log message with optional prefix\n   */\n  private format(message: string): string {\n    return this.prefix ? `[${this.prefix}] ${message}` : message;\n  }\n\n  /**\n   * Log a debug message\n   */\n  debug(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.DEBUG) {\n      console.debug(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log an info message\n   */\n  info(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.INFO) {\n      console.log(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log a warning message\n   */\n  warn(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.WARN) {\n      console.warn(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log an error message\n   */\n  error(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.ERROR) {\n      console.error(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Create a child logger with a prefix\n   */\n  child(prefix: string): Logger {\n    const childPrefix = this.prefix ? `${this.prefix}:${prefix}` : prefix;\n    return new Logger({ level: this.level, prefix: childPrefix });\n  }\n}\n\n// Default logger instance\nlet defaultLogger = new Logger();\n\n/**\n * Get the default logger\n */\nexport function getLogger(): Logger {\n  return defaultLogger;\n}\n\n/**\n * Set the default logger\n */\nexport function setDefaultLogger(logger: Logger): void {\n  defaultLogger = logger;\n}\n\n/**\n * Create a new logger with the given options\n */\nexport function createLogger(options: LoggerOptions = {}): Logger {\n  return new Logger(options);\n}\n\n/**\n * Configure the default logger\n */\nexport function configureLogger(options: LoggerOptions): void {\n  if (options.level !== undefined) {\n    defaultLogger.setLevel(options.level);\n  }\n}\n","import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport { ConnectionManager } from '../storage/database/connection.js';\nimport {\n  NodeRepository,\n  EdgeRepository,\n  VersionRepository,\n  ChunkRepository,\n  MentionRepository,\n  UnresolvedLinkRepository,\n  ConstellationRepository,\n  EmbeddingRepository,\n  WormholeRepository,\n  CandidateEdgeRepository,\n} from '../storage/database/repositories/index.js';\nimport { IndexingPipeline } from '../indexer/pipeline.js';\nimport { GraphEngine } from '../core/graph/engine.js';\nimport type { ZettelScriptConfig } from '../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../core/types/index.js';\n\nconst ZETTELSCRIPT_DIR = '.zettelscript';\nconst CONFIG_FILE = 'config.yaml';\nconst DB_FILE = 'zettelscript.db';\n\n/**\n * Find the vault root by looking for .zettelscript directory\n */\nexport function findVaultRoot(startPath: string = process.cwd()): string | null {\n  let currentPath = path.resolve(startPath);\n\n  while (currentPath !== path.dirname(currentPath)) {\n    const zettelDir = path.join(currentPath, ZETTELSCRIPT_DIR);\n    if (fs.existsSync(zettelDir)) {\n      return currentPath;\n    }\n    currentPath = path.dirname(currentPath);\n  }\n\n  return null;\n}\n\n/**\n * Get the .zettelscript directory path\n */\nexport function getZettelScriptDir(vaultPath: string): string {\n  return path.join(vaultPath, ZETTELSCRIPT_DIR);\n}\n\n/**\n * Get the database path\n */\nexport function getDbPath(vaultPath: string): string {\n  return path.join(vaultPath, ZETTELSCRIPT_DIR, DB_FILE);\n}\n\n/**\n * Get the config file path\n */\nexport function getConfigPath(vaultPath: string): string {\n  return path.join(vaultPath, ZETTELSCRIPT_DIR, CONFIG_FILE);\n}\n\n/**\n * Load configuration\n */\nexport function loadConfig(vaultPath: string): ZettelScriptConfig {\n  const configPath = getConfigPath(vaultPath);\n\n  if (!fs.existsSync(configPath)) {\n    return { ...DEFAULT_CONFIG, vault: { ...DEFAULT_CONFIG.vault, path: vaultPath } };\n  }\n\n  try {\n    const content = fs.readFileSync(configPath, 'utf-8');\n    const userConfig = parseYaml(content) as Partial<ZettelScriptConfig>;\n\n    return {\n      ...DEFAULT_CONFIG,\n      ...userConfig,\n      vault: { ...DEFAULT_CONFIG.vault, ...userConfig.vault, path: vaultPath },\n      database: { ...DEFAULT_CONFIG.database, ...userConfig.database },\n      embeddings: { ...DEFAULT_CONFIG.embeddings, ...userConfig.embeddings },\n      retrieval: { ...DEFAULT_CONFIG.retrieval, ...userConfig.retrieval },\n      manuscript: { ...DEFAULT_CONFIG.manuscript, ...userConfig.manuscript },\n      graph: { ...DEFAULT_CONFIG.graph, ...userConfig.graph },\n      chunking: { ...DEFAULT_CONFIG.chunking, ...userConfig.chunking },\n      discovery: {\n        ...DEFAULT_CONFIG.discovery,\n        ...userConfig.discovery,\n        weights: { ...DEFAULT_CONFIG.discovery.weights, ...userConfig.discovery?.weights },\n      },\n      cache: { ...DEFAULT_CONFIG.cache, ...userConfig.cache },\n      impact: { ...DEFAULT_CONFIG.impact, ...userConfig.impact },\n      moc: { ...DEFAULT_CONFIG.moc, ...userConfig.moc },\n      versioning: { ...DEFAULT_CONFIG.versioning, ...userConfig.versioning },\n      search: { ...DEFAULT_CONFIG.search, ...userConfig.search },\n      llm: { ...DEFAULT_CONFIG.llm, ...userConfig.llm },\n      visualization: { ...DEFAULT_CONFIG.visualization, ...userConfig.visualization },\n    };\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    console.warn(\n      `Warning: Could not parse config file at ${configPath}: ${errorMsg}. ` +\n        `Using defaults. Run \"zs init --force\" to regenerate.`\n    );\n    return { ...DEFAULT_CONFIG, vault: { ...DEFAULT_CONFIG.vault, path: vaultPath } };\n  }\n}\n\n/**\n * Save configuration\n */\nexport function saveConfig(vaultPath: string, config: ZettelScriptConfig): void {\n  const configPath = getConfigPath(vaultPath);\n  const content = stringifyYaml(config);\n  fs.writeFileSync(configPath, content, 'utf-8');\n}\n\n/**\n * Context object containing all initialized components\n */\nexport interface CLIContext {\n  vaultPath: string;\n  config: ZettelScriptConfig;\n  connectionManager: ConnectionManager;\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  versionRepository: VersionRepository;\n  chunkRepository: ChunkRepository;\n  mentionRepository: MentionRepository;\n  unresolvedLinkRepository: UnresolvedLinkRepository;\n  constellationRepository: ConstellationRepository;\n  embeddingRepository: EmbeddingRepository;\n  wormholeRepository: WormholeRepository;\n  candidateEdgeRepository: CandidateEdgeRepository;\n  pipeline: IndexingPipeline;\n  graphEngine: GraphEngine;\n}\n\n/**\n * Initialize CLI context\n */\nexport async function initContext(vaultPath?: string): Promise<CLIContext> {\n  // Find vault root\n  const resolvedPath = vaultPath ? path.resolve(vaultPath) : findVaultRoot();\n\n  if (!resolvedPath) {\n    throw new Error('Not in a ZettelScript vault. Run \"zettel init\" to create one.');\n  }\n\n  // Load config\n  const config = loadConfig(resolvedPath);\n\n  // Initialize database\n  const dbPath = getDbPath(resolvedPath);\n  const connectionManager = ConnectionManager.getInstance(dbPath);\n  await connectionManager.initialize();\n\n  const db = connectionManager.getDb();\n  const sqlite = connectionManager.getSqlite();\n\n  // Initialize repositories\n  const nodeRepository = new NodeRepository(db);\n  const edgeRepository = new EdgeRepository(db);\n  const versionRepository = new VersionRepository(db);\n  const chunkRepository = new ChunkRepository(db, sqlite);\n  const mentionRepository = new MentionRepository(db);\n  const unresolvedLinkRepository = new UnresolvedLinkRepository(db);\n  const constellationRepository = new ConstellationRepository(db);\n  const embeddingRepository = new EmbeddingRepository(db);\n  const wormholeRepository = new WormholeRepository(db);\n  const candidateEdgeRepository = new CandidateEdgeRepository(db);\n\n  // Initialize pipeline\n  const pipeline = new IndexingPipeline({\n    nodeRepository,\n    edgeRepository,\n    versionRepository,\n  });\n\n  // Initialize graph engine\n  const graphEngine = new GraphEngine({\n    nodeRepository,\n    edgeRepository,\n  });\n\n  return {\n    vaultPath: resolvedPath,\n    config,\n    connectionManager,\n    nodeRepository,\n    edgeRepository,\n    versionRepository,\n    chunkRepository,\n    mentionRepository,\n    unresolvedLinkRepository,\n    constellationRepository,\n    embeddingRepository,\n    wormholeRepository,\n    candidateEdgeRepository,\n    pipeline,\n    graphEngine,\n  };\n}\n\n/**\n * Format a duration in milliseconds\n */\nexport function formatDuration(ms: number): string {\n  if (ms < 1000) {\n    return `${ms}ms`;\n  }\n  if (ms < 60000) {\n    return `${(ms / 1000).toFixed(1)}s`;\n  }\n  const minutes = Math.floor(ms / 60000);\n  const seconds = ((ms % 60000) / 1000).toFixed(1);\n  return `${minutes}m ${seconds}s`;\n}\n\n/**\n * Format a file size\n */\nexport function formatSize(bytes: number): string {\n  if (bytes < 1024) {\n    return `${bytes}B`;\n  }\n  if (bytes < 1024 * 1024) {\n    return `${(bytes / 1024).toFixed(1)}KB`;\n  }\n  return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;\n}\n\n/**\n * Simple spinner for CLI feedback\n */\nexport class Spinner {\n  private frames = ['', '', '', '', '', '', '', '', '', ''];\n  private frameIndex = 0;\n  private interval: ReturnType<typeof setInterval> | null = null;\n  private message: string;\n\n  constructor(message: string) {\n    this.message = message;\n  }\n\n  start(): void {\n    this.interval = setInterval(() => {\n      const frame = this.frames[this.frameIndex];\n      process.stdout.write(`\\r${frame} ${this.message}`);\n      this.frameIndex = (this.frameIndex + 1) % this.frames.length;\n    }, 80);\n  }\n\n  update(message: string): void {\n    this.message = message;\n  }\n\n  stop(finalMessage?: string): void {\n    if (this.interval) {\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n    process.stdout.write('\\r' + ' '.repeat(this.message.length + 10) + '\\r');\n    if (finalMessage) {\n      console.log(finalMessage);\n    }\n  }\n}\n\n/**\n * Print a table\n */\nexport function printTable(\n  headers: string[],\n  rows: string[][],\n  options: { padding?: number } = {}\n): void {\n  const { padding = 2 } = options;\n\n  // Calculate column widths\n  const widths = headers.map((h, i) => {\n    const values = [h, ...rows.map((r) => r[i] || '')];\n    return Math.max(...values.map((v) => v.length));\n  });\n\n  // Print header\n  const headerLine = headers.map((h, i) => h.padEnd(widths[i] ?? 0)).join(' '.repeat(padding));\n  console.log(headerLine);\n  console.log('-'.repeat(headerLine.length));\n\n  // Print rows\n  for (const row of rows) {\n    const line = row\n      .map((cell, i) => (cell || '').padEnd(widths[i] ?? 0))\n      .join(' '.repeat(padding));\n    console.log(line);\n  }\n}\n","import { eq, like, and, inArray, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { nodes, aliases, type NodeRow, type NewNodeRow } from '../schema.js';\nimport type { Node, NodeType } from '../../../core/types/index.js';\n\n/**\n * Repository for Node CRUD operations\n */\nexport class NodeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new node\n   */\n  async create(data: Omit<Node, 'nodeId'>): Promise<Node> {\n    const nodeId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewNodeRow = {\n      nodeId,\n      type: data.type,\n      title: data.title,\n      path: data.path,\n      createdAt: data.createdAt || now,\n      updatedAt: data.updatedAt || now,\n      contentHash: data.contentHash ?? null,\n      metadata: data.metadata ?? null,\n      isGhost: data.isGhost ? 1 : 0,\n    };\n\n    await this.db.insert(nodes).values(row);\n\n    return this.rowToNode({ ...row, nodeId } as NodeRow);\n  }\n\n  /**\n   * Create or update a node by path\n   */\n  async upsert(data: Omit<Node, 'nodeId'> & { nodeId?: string }): Promise<Node> {\n    const now = new Date().toISOString();\n    const nodeId = data.nodeId || nanoid();\n\n    const existing = await this.findByPath(data.path);\n\n    if (existing) {\n      return this.update(existing.nodeId, {\n        ...data,\n        updatedAt: now,\n      });\n    }\n\n    const row: NewNodeRow = {\n      nodeId,\n      type: data.type,\n      title: data.title,\n      path: data.path,\n      createdAt: data.createdAt || now,\n      updatedAt: data.updatedAt || now,\n      contentHash: data.contentHash ?? null,\n      metadata: data.metadata ?? null,\n      isGhost: data.isGhost ? 1 : 0,\n    };\n\n    await this.db.insert(nodes).values(row);\n\n    return this.rowToNode({ ...row, nodeId } as NodeRow);\n  }\n\n  /**\n   * Find a node by ID\n   */\n  async findById(nodeId: string): Promise<Node | null> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.nodeId, nodeId)).limit(1);\n\n    return result[0] ? this.rowToNode(result[0]) : null;\n  }\n\n  /**\n   * Find a node by path\n   */\n  async findByPath(path: string): Promise<Node | null> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.path, path)).limit(1);\n\n    return result[0] ? this.rowToNode(result[0]) : null;\n  }\n\n  /**\n   * Find a node by title (case-insensitive)\n   */\n  async findByTitle(title: string): Promise<Node[]> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(sql`${nodes.title} COLLATE NOCASE = ${title}`);\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Find a node by title or alias\n   */\n  async findByTitleOrAlias(text: string): Promise<Node[]> {\n    // First check exact title match\n    const titleMatches = await this.db\n      .select()\n      .from(nodes)\n      .where(sql`${nodes.title} COLLATE NOCASE = ${text}`);\n\n    // Then check aliases\n    const aliasMatches = await this.db\n      .select({ node: nodes })\n      .from(aliases)\n      .innerJoin(nodes, eq(aliases.nodeId, nodes.nodeId))\n      .where(sql`${aliases.alias} COLLATE NOCASE = ${text}`);\n\n    // Combine and deduplicate\n    const nodeMap = new Map<string, NodeRow>();\n    for (const row of titleMatches) {\n      nodeMap.set(row.nodeId, row);\n    }\n    for (const { node } of aliasMatches) {\n      nodeMap.set(node.nodeId, node);\n    }\n\n    return Array.from(nodeMap.values()).map(this.rowToNode);\n  }\n\n  /**\n   * Find nodes by type\n   */\n  async findByType(type: NodeType): Promise<Node[]> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.type, type));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Get all nodes\n   */\n  async findAll(): Promise<Node[]> {\n    const result = await this.db.select().from(nodes);\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Find nodes by IDs\n   */\n  async findByIds(nodeIds: string[]): Promise<Node[]> {\n    if (nodeIds.length === 0) return [];\n\n    const result = await this.db.select().from(nodes).where(inArray(nodes.nodeId, nodeIds));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Search nodes by title pattern\n   */\n  async searchByTitle(pattern: string): Promise<Node[]> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(like(nodes.title, `%${pattern}%`));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Update a node\n   */\n  async update(nodeId: string, data: Partial<Omit<Node, 'nodeId'>>): Promise<Node> {\n    const updateData: Partial<NodeRow> = {};\n\n    if (data.type !== undefined) updateData.type = data.type;\n    if (data.title !== undefined) updateData.title = data.title;\n    if (data.path !== undefined) updateData.path = data.path;\n    if (data.contentHash !== undefined) updateData.contentHash = data.contentHash;\n    if (data.metadata !== undefined) updateData.metadata = data.metadata;\n    if (data.isGhost !== undefined) updateData.isGhost = data.isGhost ? 1 : 0;\n    updateData.updatedAt = data.updatedAt || new Date().toISOString();\n\n    await this.db.update(nodes).set(updateData).where(eq(nodes.nodeId, nodeId));\n\n    const updated = await this.findById(nodeId);\n    if (!updated) {\n      throw new Error(`Node ${nodeId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a node\n   */\n  async delete(nodeId: string): Promise<void> {\n    await this.db.delete(nodes).where(eq(nodes.nodeId, nodeId));\n  }\n\n  /**\n   * Delete nodes by path pattern\n   */\n  async deleteByPathPattern(pattern: string): Promise<number> {\n    const result = await this.db.delete(nodes).where(like(nodes.path, pattern));\n\n    return result.changes;\n  }\n\n  /**\n   * Count nodes\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(nodes);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count nodes by type\n   */\n  async countByType(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        type: nodes.type,\n        count: sql<number>`count(*)`,\n      })\n      .from(nodes)\n      .groupBy(nodes.type);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      counts[row.type] = row.count;\n    }\n    return counts;\n  }\n\n  /**\n   * Add an alias for a node\n   */\n  async addAlias(nodeId: string, alias: string): Promise<void> {\n    await this.db.insert(aliases).values({\n      aliasId: nanoid(),\n      nodeId,\n      alias,\n    });\n  }\n\n  /**\n   * Remove an alias\n   */\n  async removeAlias(nodeId: string, alias: string): Promise<void> {\n    await this.db\n      .delete(aliases)\n      .where(and(eq(aliases.nodeId, nodeId), sql`${aliases.alias} COLLATE NOCASE = ${alias}`));\n  }\n\n  /**\n   * Get aliases for a node\n   */\n  async getAliases(nodeId: string): Promise<string[]> {\n    const result = await this.db\n      .select({ alias: aliases.alias })\n      .from(aliases)\n      .where(eq(aliases.nodeId, nodeId));\n\n    return result.map((r) => r.alias);\n  }\n\n  /**\n   * Set aliases for a node (replaces existing)\n   */\n  async setAliases(nodeId: string, newAliases: string[]): Promise<void> {\n    // Delete existing aliases\n    await this.db.delete(aliases).where(eq(aliases.nodeId, nodeId));\n\n    // Insert new aliases\n    if (newAliases.length > 0) {\n      await this.db.insert(aliases).values(\n        newAliases.map((alias) => ({\n          aliasId: nanoid(),\n          nodeId,\n          alias,\n        }))\n      );\n    }\n  }\n\n  /**\n   * Find all ghost nodes\n   */\n  async findGhosts(): Promise<Node[]> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.isGhost, 1));\n    return result.map((row) => this.rowToNode(row));\n  }\n\n  /**\n   * Find all non-ghost (real) nodes\n   */\n  async findRealNodes(): Promise<Node[]> {\n    const result = await this.db.select().from(nodes).where(eq(nodes.isGhost, 0));\n    return result.map((row) => this.rowToNode(row));\n  }\n\n  /**\n   * Count ghost nodes\n   */\n  async countGhosts(): Promise<number> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(nodes)\n      .where(eq(nodes.isGhost, 1));\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Create or find a ghost node by title.\n   * Ghosts are placeholder nodes for unresolved references.\n   * They have a synthetic path based on title.\n   */\n  async getOrCreateGhost(title: string): Promise<Node> {\n    // Check if ghost already exists\n    const existing = await this.db\n      .select()\n      .from(nodes)\n      .where(and(eq(nodes.isGhost, 1), sql`${nodes.title} COLLATE NOCASE = ${title}`))\n      .limit(1);\n\n    if (existing[0]) {\n      return this.rowToNode(existing[0]);\n    }\n\n    // Create new ghost\n    const nodeId = nanoid();\n    const now = new Date().toISOString();\n    const ghostPath = `__ghost__/${title.replace(/[^a-zA-Z0-9-_]/g, '_')}`;\n\n    const row: NewNodeRow = {\n      nodeId,\n      type: 'note', // Ghosts default to 'note' type\n      title,\n      path: ghostPath,\n      createdAt: now,\n      updatedAt: now,\n      contentHash: null,\n      metadata: null,\n      isGhost: 1,\n    };\n\n    await this.db.insert(nodes).values(row);\n\n    return this.rowToNode({ ...row, nodeId } as NodeRow);\n  }\n\n  /**\n   * Materialize a ghost - convert it to a real node when the file is created.\n   * Updates the ghost to be a real node with the actual path.\n   */\n  async materializeGhost(nodeId: string, realPath: string): Promise<Node> {\n    const ghost = await this.findById(nodeId);\n    if (!ghost || !ghost.isGhost) {\n      throw new Error(`Node ${nodeId} is not a ghost`);\n    }\n\n    return this.update(nodeId, {\n      path: realPath,\n      isGhost: false,\n      updatedAt: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Convert database row to Node type\n   */\n  private rowToNode(row: NodeRow): Node {\n    const node: Node = {\n      nodeId: row.nodeId,\n      type: row.type as NodeType,\n      title: row.title,\n      path: row.path,\n      createdAt: row.createdAt,\n      updatedAt: row.updatedAt,\n    };\n\n    if (row.contentHash != null) node.contentHash = row.contentHash;\n    if (row.metadata != null) node.metadata = row.metadata as Record<string, unknown>;\n    if (row.isGhost === 1) node.isGhost = true;\n\n    return node;\n  }\n}\n","import { eq, and, or, inArray, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { edges, nodes, type EdgeRow, type NewEdgeRow } from '../schema.js';\nimport type { Edge, EdgeType, EdgeProvenance } from '../../../core/types/index.js';\n\n/**\n * Repository for Edge CRUD operations\n */\nexport class EdgeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new edge\n   */\n  async create(data: Omit<Edge, 'edgeId' | 'createdAt'>): Promise<Edge> {\n    const edgeId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewEdgeRow = {\n      edgeId,\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      edgeType: data.edgeType,\n      strength: data.strength ?? null,\n      provenance: data.provenance,\n      createdAt: now,\n      versionStart: data.versionStart ?? null,\n      versionEnd: data.versionEnd ?? null,\n      attributes: data.attributes ?? null,\n    };\n\n    await this.db.insert(edges).values(row);\n\n    return this.rowToEdge({ ...row, edgeId, createdAt: now } as EdgeRow);\n  }\n\n  /**\n   * Create or update an edge\n   */\n  async upsert(data: Omit<Edge, 'edgeId' | 'createdAt'>): Promise<Edge> {\n    // Check for existing edge with same source, target, and type\n    const existing = await this.findBySourceTargetType(data.sourceId, data.targetId, data.edgeType);\n\n    if (existing) {\n      return this.update(existing.edgeId, data);\n    }\n\n    return this.create(data);\n  }\n\n  /**\n   * Find an edge by ID\n   */\n  async findById(edgeId: string): Promise<Edge | null> {\n    const result = await this.db.select().from(edges).where(eq(edges.edgeId, edgeId)).limit(1);\n\n    return result[0] ? this.rowToEdge(result[0]) : null;\n  }\n\n  /**\n   * Find edge by source, target, and type\n   */\n  async findBySourceTargetType(\n    sourceId: string,\n    targetId: string,\n    edgeType: EdgeType\n  ): Promise<Edge | null> {\n    const result = await this.db\n      .select()\n      .from(edges)\n      .where(\n        and(\n          eq(edges.sourceId, sourceId),\n          eq(edges.targetId, targetId),\n          eq(edges.edgeType, edgeType)\n        )\n      )\n      .limit(1);\n\n    return result[0] ? this.rowToEdge(result[0]) : null;\n  }\n\n  /**\n   * Find all outgoing edges from a node\n   */\n  async findOutgoing(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    let query = this.db.select().from(edges).where(eq(edges.sourceId, nodeId));\n\n    if (edgeTypes && edgeTypes.length > 0) {\n      query = this.db\n        .select()\n        .from(edges)\n        .where(and(eq(edges.sourceId, nodeId), inArray(edges.edgeType, edgeTypes)));\n    }\n\n    const result = await query;\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find all incoming edges to a node\n   */\n  async findIncoming(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    let query = this.db.select().from(edges).where(eq(edges.targetId, nodeId));\n\n    if (edgeTypes && edgeTypes.length > 0) {\n      query = this.db\n        .select()\n        .from(edges)\n        .where(and(eq(edges.targetId, nodeId), inArray(edges.edgeType, edgeTypes)));\n    }\n\n    const result = await query;\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find all edges connected to a node (both directions)\n   */\n  async findConnected(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    const condition = or(eq(edges.sourceId, nodeId), eq(edges.targetId, nodeId));\n\n    let result;\n    if (edgeTypes && edgeTypes.length > 0) {\n      result = await this.db\n        .select()\n        .from(edges)\n        .where(and(condition, inArray(edges.edgeType, edgeTypes)));\n    } else {\n      result = await this.db.select().from(edges).where(condition);\n    }\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find edges by type\n   */\n  async findByType(edgeType: EdgeType): Promise<Edge[]> {\n    const result = await this.db.select().from(edges).where(eq(edges.edgeType, edgeType));\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Get all edges, optionally filtered by edge types\n   */\n  async findAll(edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    if (edgeTypes && edgeTypes.length > 0) {\n      const result = await this.db.select().from(edges).where(inArray(edges.edgeType, edgeTypes));\n      return result.map(this.rowToEdge);\n    }\n    const result = await this.db.select().from(edges);\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find backlinks (explicit_link edges targeting a node)\n   */\n  async findBacklinks(nodeId: string): Promise<Edge[]> {\n    const result = await this.db\n      .select()\n      .from(edges)\n      .where(and(eq(edges.targetId, nodeId), eq(edges.edgeType, 'explicit_link')));\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Update an edge\n   */\n  async update(edgeId: string, data: Partial<Omit<Edge, 'edgeId' | 'createdAt'>>): Promise<Edge> {\n    const updateData: Partial<EdgeRow> = {};\n\n    if (data.sourceId !== undefined) updateData.sourceId = data.sourceId;\n    if (data.targetId !== undefined) updateData.targetId = data.targetId;\n    if (data.edgeType !== undefined) updateData.edgeType = data.edgeType;\n    if (data.strength !== undefined) updateData.strength = data.strength;\n    if (data.provenance !== undefined) updateData.provenance = data.provenance;\n    if (data.versionStart !== undefined) updateData.versionStart = data.versionStart;\n    if (data.versionEnd !== undefined) updateData.versionEnd = data.versionEnd;\n    if (data.attributes !== undefined) updateData.attributes = data.attributes;\n\n    await this.db.update(edges).set(updateData).where(eq(edges.edgeId, edgeId));\n\n    const updated = await this.findById(edgeId);\n    if (!updated) {\n      throw new Error(`Edge ${edgeId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete an edge\n   */\n  async delete(edgeId: string): Promise<void> {\n    await this.db.delete(edges).where(eq(edges.edgeId, edgeId));\n  }\n\n  /**\n   * Delete all edges for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(edges)\n      .where(or(eq(edges.sourceId, nodeId), eq(edges.targetId, nodeId)));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete edges by source and type\n   */\n  async deleteBySourceAndType(sourceId: string, edgeType: EdgeType): Promise<number> {\n    const result = await this.db\n      .delete(edges)\n      .where(and(eq(edges.sourceId, sourceId), eq(edges.edgeType, edgeType)));\n\n    return result.changes;\n  }\n\n  /**\n   * Count edges\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(edges);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count edges by type\n   */\n  async countByType(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        type: edges.edgeType,\n        count: sql<number>`count(*)`,\n      })\n      .from(edges)\n      .groupBy(edges.edgeType);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      counts[row.type] = row.count;\n    }\n    return counts;\n  }\n\n  /**\n   * Find neighbors with node info\n   */\n  async findNeighborsWithNodes(\n    nodeId: string,\n    edgeTypes?: EdgeType[]\n  ): Promise<\n    Array<{\n      edge: Edge;\n      node: { nodeId: string; title: string; type: string; path: string };\n      direction: 'incoming' | 'outgoing';\n    }>\n  > {\n    const outgoing = await this.findOutgoing(nodeId, edgeTypes);\n    const incoming = await this.findIncoming(nodeId, edgeTypes);\n\n    const results: Array<{\n      edge: Edge;\n      node: { nodeId: string; title: string; type: string; path: string };\n      direction: 'incoming' | 'outgoing';\n    }> = [];\n\n    // Get target nodes for outgoing edges\n    if (outgoing.length > 0) {\n      const targetIds = outgoing.map((e) => e.targetId);\n      const targetNodes = await this.db\n        .select({\n          nodeId: nodes.nodeId,\n          title: nodes.title,\n          type: nodes.type,\n          path: nodes.path,\n        })\n        .from(nodes)\n        .where(inArray(nodes.nodeId, targetIds));\n\n      const nodeMap = new Map(targetNodes.map((n) => [n.nodeId, n]));\n\n      for (const edge of outgoing) {\n        const node = nodeMap.get(edge.targetId);\n        if (node) {\n          results.push({ edge, node, direction: 'outgoing' });\n        }\n      }\n    }\n\n    // Get source nodes for incoming edges\n    if (incoming.length > 0) {\n      const sourceIds = incoming.map((e) => e.sourceId);\n      const sourceNodes = await this.db\n        .select({\n          nodeId: nodes.nodeId,\n          title: nodes.title,\n          type: nodes.type,\n          path: nodes.path,\n        })\n        .from(nodes)\n        .where(inArray(nodes.nodeId, sourceIds));\n\n      const nodeMap = new Map(sourceNodes.map((n) => [n.nodeId, n]));\n\n      for (const edge of incoming) {\n        const node = nodeMap.get(edge.sourceId);\n        if (node) {\n          results.push({ edge, node, direction: 'incoming' });\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Convert database row to Edge type\n   */\n  private rowToEdge(row: EdgeRow): Edge {\n    return {\n      edgeId: row.edgeId,\n      sourceId: row.sourceId,\n      targetId: row.targetId,\n      edgeType: row.edgeType as EdgeType,\n      provenance: row.provenance as EdgeProvenance,\n      createdAt: row.createdAt,\n      ...(row.strength != null && { strength: row.strength }),\n      ...(row.versionStart != null && { versionStart: row.versionStart }),\n      ...(row.versionEnd != null && { versionEnd: row.versionEnd }),\n      ...(row.attributes != null && { attributes: row.attributes as Record<string, unknown> }),\n    };\n  }\n}\n","import { eq, and, sql, desc } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { versions, type VersionRow, type NewVersionRow } from '../schema.js';\nimport type { Version } from '../../../core/types/index.js';\n\n/**\n * Repository for Version CRUD operations\n */\nexport class VersionRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new version\n   */\n  async create(data: Omit<Version, 'versionId' | 'createdAt'>): Promise<Version> {\n    const versionId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewVersionRow = {\n      versionId,\n      nodeId: data.nodeId,\n      contentHash: data.contentHash,\n      parentVersionId: data.parentVersionId ?? null,\n      createdAt: now,\n      summary: data.summary ?? null,\n    };\n\n    await this.db.insert(versions).values(row);\n\n    return this.rowToVersion({ ...row, versionId, createdAt: now } as VersionRow);\n  }\n\n  /**\n   * Find a version by ID\n   */\n  async findById(versionId: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.versionId, versionId))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Find all versions for a node\n   */\n  async findByNodeId(nodeId: string): Promise<Version[]> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.nodeId, nodeId))\n      .orderBy(desc(versions.createdAt));\n\n    return result.map(this.rowToVersion);\n  }\n\n  /**\n   * Find the latest version for a node\n   */\n  async findLatest(nodeId: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.nodeId, nodeId))\n      .orderBy(desc(versions.createdAt))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Find version by content hash\n   */\n  async findByContentHash(nodeId: string, contentHash: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(and(eq(versions.nodeId, nodeId), eq(versions.contentHash, contentHash)))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Get version chain (all ancestors)\n   */\n  async getVersionChain(versionId: string): Promise<Version[]> {\n    const chain: Version[] = [];\n    let currentId: string | null = versionId;\n\n    while (currentId) {\n      const version = await this.findById(currentId);\n      if (!version) break;\n      chain.push(version);\n      currentId = version.parentVersionId ?? null;\n    }\n\n    return chain;\n  }\n\n  /**\n   * Get child versions\n   */\n  async findChildren(versionId: string): Promise<Version[]> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.parentVersionId, versionId));\n\n    return result.map(this.rowToVersion);\n  }\n\n  /**\n   * Update a version (mainly for summary)\n   */\n  async update(versionId: string, data: Pick<Version, 'summary'>): Promise<Version> {\n    await this.db\n      .update(versions)\n      .set({ summary: data.summary ?? null })\n      .where(eq(versions.versionId, versionId));\n\n    const updated = await this.findById(versionId);\n    if (!updated) {\n      throw new Error(`Version ${versionId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a version\n   */\n  async delete(versionId: string): Promise<void> {\n    await this.db.delete(versions).where(eq(versions.versionId, versionId));\n  }\n\n  /**\n   * Delete all versions for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db.delete(versions).where(eq(versions.nodeId, nodeId));\n\n    return result.changes;\n  }\n\n  /**\n   * Count versions\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(versions);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count versions per node\n   */\n  async countPerNode(): Promise<Map<string, number>> {\n    const result = await this.db\n      .select({\n        nodeId: versions.nodeId,\n        count: sql<number>`count(*)`,\n      })\n      .from(versions)\n      .groupBy(versions.nodeId);\n\n    return new Map(result.map((r) => [r.nodeId, r.count]));\n  }\n\n  /**\n   * Convert database row to Version type\n   */\n  private rowToVersion(row: VersionRow): Version {\n    return {\n      versionId: row.versionId,\n      nodeId: row.nodeId,\n      contentHash: row.contentHash,\n      createdAt: row.createdAt,\n      ...(row.parentVersionId != null && { parentVersionId: row.parentVersionId }),\n      ...(row.summary != null && { summary: row.summary }),\n    };\n  }\n}\n","import { eq, sql, inArray } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport Database from 'better-sqlite3';\nimport { DrizzleDB } from '../connection.js';\nimport { chunks, type ChunkRow, type NewChunkRow } from '../schema.js';\nimport type { Chunk } from '../../../core/types/index.js';\n\n/**\n * Repository for Chunk CRUD operations including FTS5 queries\n */\nexport class ChunkRepository {\n  constructor(\n    private db: DrizzleDB,\n    private sqlite: Database.Database\n  ) {}\n\n  /**\n   * Create a new chunk\n   */\n  async create(data: Omit<Chunk, 'chunkId'>): Promise<Chunk> {\n    const chunkId = nanoid();\n\n    const row: NewChunkRow = {\n      chunkId,\n      nodeId: data.nodeId,\n      text: data.text,\n      offsetStart: data.offsetStart,\n      offsetEnd: data.offsetEnd,\n      versionId: data.versionId,\n      tokenCount: data.tokenCount ?? null,\n    };\n\n    await this.db.insert(chunks).values(row);\n\n    return this.rowToChunk({ ...row, chunkId } as ChunkRow);\n  }\n\n  /**\n   * Create multiple chunks\n   */\n  async createMany(dataArray: Array<Omit<Chunk, 'chunkId'>>): Promise<Chunk[]> {\n    if (dataArray.length === 0) return [];\n\n    const rows: NewChunkRow[] = dataArray.map((data) => ({\n      chunkId: nanoid(),\n      nodeId: data.nodeId,\n      text: data.text,\n      offsetStart: data.offsetStart,\n      offsetEnd: data.offsetEnd,\n      versionId: data.versionId,\n      tokenCount: data.tokenCount ?? null,\n    }));\n\n    await this.db.insert(chunks).values(rows);\n\n    return rows.map((row) => this.rowToChunk(row as ChunkRow));\n  }\n\n  /**\n   * Find a chunk by ID\n   */\n  async findById(chunkId: string): Promise<Chunk | null> {\n    const result = await this.db.select().from(chunks).where(eq(chunks.chunkId, chunkId)).limit(1);\n\n    return result[0] ? this.rowToChunk(result[0]) : null;\n  }\n\n  /**\n   * Find all chunks for a node\n   */\n  async findByNodeId(nodeId: string): Promise<Chunk[]> {\n    const result = await this.db\n      .select()\n      .from(chunks)\n      .where(eq(chunks.nodeId, nodeId))\n      .orderBy(chunks.offsetStart);\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Find chunks by version\n   */\n  async findByVersionId(versionId: string): Promise<Chunk[]> {\n    const result = await this.db\n      .select()\n      .from(chunks)\n      .where(eq(chunks.versionId, versionId))\n      .orderBy(chunks.offsetStart);\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Find chunks by IDs\n   */\n  async findByIds(chunkIds: string[]): Promise<Chunk[]> {\n    if (chunkIds.length === 0) return [];\n\n    const result = await this.db.select().from(chunks).where(inArray(chunks.chunkId, chunkIds));\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Full-text search using FTS5\n   */\n  searchFullText(\n    query: string,\n    limit: number = 20\n  ): Array<{ chunkId: string; nodeId: string; text: string; rank: number }> {\n    // Escape special FTS5 characters\n    const escapedQuery = query\n      .replace(/['\"]/g, '')\n      .replace(/\\*/g, '')\n      .split(/\\s+/)\n      .filter((word) => word.length > 0)\n      .join(' OR ');\n\n    if (!escapedQuery) return [];\n\n    const stmt = this.sqlite.prepare(`\n      SELECT\n        chunk_id as chunkId,\n        node_id as nodeId,\n        text,\n        rank\n      FROM chunks_fts\n      WHERE chunks_fts MATCH ?\n      ORDER BY rank\n      LIMIT ?\n    `);\n\n    return stmt.all(escapedQuery, limit) as Array<{\n      chunkId: string;\n      nodeId: string;\n      text: string;\n      rank: number;\n    }>;\n  }\n\n  /**\n   * Full-text search with BM25 ranking\n   */\n  searchBM25(\n    query: string,\n    limit: number = 20\n  ): Array<{ chunkId: string; nodeId: string; text: string; score: number }> {\n    const escapedQuery = query\n      .replace(/['\"]/g, '')\n      .replace(/\\*/g, '')\n      .split(/\\s+/)\n      .filter((word) => word.length > 0)\n      .join(' OR ');\n\n    if (!escapedQuery) return [];\n\n    const stmt = this.sqlite.prepare(`\n      SELECT\n        chunk_id as chunkId,\n        node_id as nodeId,\n        text,\n        bm25(chunks_fts) as score\n      FROM chunks_fts\n      WHERE chunks_fts MATCH ?\n      ORDER BY bm25(chunks_fts)\n      LIMIT ?\n    `);\n\n    return stmt.all(escapedQuery, limit) as Array<{\n      chunkId: string;\n      nodeId: string;\n      text: string;\n      score: number;\n    }>;\n  }\n\n  /**\n   * Update a chunk\n   */\n  async update(chunkId: string, data: Partial<Omit<Chunk, 'chunkId'>>): Promise<Chunk> {\n    const updateData: Partial<ChunkRow> = {};\n\n    if (data.nodeId !== undefined) updateData.nodeId = data.nodeId;\n    if (data.text !== undefined) updateData.text = data.text;\n    if (data.offsetStart !== undefined) updateData.offsetStart = data.offsetStart;\n    if (data.offsetEnd !== undefined) updateData.offsetEnd = data.offsetEnd;\n    if (data.versionId !== undefined) updateData.versionId = data.versionId;\n    if (data.tokenCount !== undefined) updateData.tokenCount = data.tokenCount;\n\n    await this.db.update(chunks).set(updateData).where(eq(chunks.chunkId, chunkId));\n\n    const updated = await this.findById(chunkId);\n    if (!updated) {\n      throw new Error(`Chunk ${chunkId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a chunk\n   */\n  async delete(chunkId: string): Promise<void> {\n    await this.db.delete(chunks).where(eq(chunks.chunkId, chunkId));\n  }\n\n  /**\n   * Delete all chunks for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db.delete(chunks).where(eq(chunks.nodeId, nodeId));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete chunks by version\n   */\n  async deleteByVersion(versionId: string): Promise<number> {\n    const result = await this.db.delete(chunks).where(eq(chunks.versionId, versionId));\n\n    return result.changes;\n  }\n\n  /**\n   * Count chunks\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(chunks);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Get total token count\n   */\n  async getTotalTokens(): Promise<number> {\n    const result = await this.db\n      .select({ total: sql<number>`COALESCE(SUM(token_count), 0)` })\n      .from(chunks);\n\n    return result[0]?.total ?? 0;\n  }\n\n  /**\n   * Convert database row to Chunk type\n   */\n  private rowToChunk(row: ChunkRow): Chunk {\n    return {\n      chunkId: row.chunkId,\n      nodeId: row.nodeId,\n      text: row.text,\n      offsetStart: row.offsetStart,\n      offsetEnd: row.offsetEnd,\n      versionId: row.versionId,\n      ...(row.tokenCount != null && { tokenCount: row.tokenCount }),\n    };\n  }\n}\n","import { eq, and, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport {\n  mentionCandidates,\n  type MentionCandidateRow,\n  type NewMentionCandidateRow,\n} from '../schema.js';\nimport type { MentionCandidate, MentionStatus } from '../../../core/types/index.js';\n\n/**\n * Repository for MentionCandidate CRUD operations\n */\nexport class MentionRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new mention candidate\n   */\n  async create(data: Omit<MentionCandidate, 'candidateId'>): Promise<MentionCandidate> {\n    const candidateId = nanoid();\n\n    const row: NewMentionCandidateRow = {\n      candidateId,\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      surfaceText: data.surfaceText,\n      spanStart: data.spanStart ?? null,\n      spanEnd: data.spanEnd ?? null,\n      confidence: data.confidence,\n      reasons: data.reasons ?? null,\n      status: data.status,\n    };\n\n    await this.db.insert(mentionCandidates).values(row);\n\n    return this.rowToMention({ ...row, candidateId } as MentionCandidateRow);\n  }\n\n  /**\n   * Create multiple mention candidates\n   */\n  async createMany(\n    dataArray: Array<Omit<MentionCandidate, 'candidateId'>>\n  ): Promise<MentionCandidate[]> {\n    if (dataArray.length === 0) return [];\n\n    const rows: NewMentionCandidateRow[] = dataArray.map((data) => ({\n      candidateId: nanoid(),\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      surfaceText: data.surfaceText,\n      spanStart: data.spanStart ?? null,\n      spanEnd: data.spanEnd ?? null,\n      confidence: data.confidence,\n      reasons: data.reasons ?? null,\n      status: data.status,\n    }));\n\n    await this.db.insert(mentionCandidates).values(rows);\n\n    return rows.map((row) => this.rowToMention(row as MentionCandidateRow));\n  }\n\n  /**\n   * Find a mention by ID\n   */\n  async findById(candidateId: string): Promise<MentionCandidate | null> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.candidateId, candidateId))\n      .limit(1);\n\n    return result[0] ? this.rowToMention(result[0]) : null;\n  }\n\n  /**\n   * Find mentions by source node\n   */\n  async findBySourceId(sourceId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.sourceId, sourceId));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find mentions by target node\n   */\n  async findByTargetId(targetId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.targetId, targetId));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find mentions by status\n   */\n  async findByStatus(status: MentionStatus): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.status, status));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find new (pending review) mentions for a source\n   */\n  async findNewForSource(sourceId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(and(eq(mentionCandidates.sourceId, sourceId), eq(mentionCandidates.status, 'new')));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Check if a mention already exists\n   */\n  async exists(\n    sourceId: string,\n    targetId: string,\n    spanStart: number,\n    spanEnd: number\n  ): Promise<boolean> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(mentionCandidates)\n      .where(\n        and(\n          eq(mentionCandidates.sourceId, sourceId),\n          eq(mentionCandidates.targetId, targetId),\n          eq(mentionCandidates.spanStart, spanStart),\n          eq(mentionCandidates.spanEnd, spanEnd)\n        )\n      );\n\n    return (result[0]?.count ?? 0) > 0;\n  }\n\n  /**\n   * Update mention status\n   */\n  async updateStatus(candidateId: string, status: MentionStatus): Promise<MentionCandidate> {\n    await this.db\n      .update(mentionCandidates)\n      .set({ status })\n      .where(eq(mentionCandidates.candidateId, candidateId));\n\n    const updated = await this.findById(candidateId);\n    if (!updated) {\n      throw new Error(`Mention ${candidateId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Approve a mention (converts to edge)\n   */\n  async approve(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'approved');\n  }\n\n  /**\n   * Reject a mention\n   */\n  async reject(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'rejected');\n  }\n\n  /**\n   * Defer a mention for later review\n   */\n  async defer(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'deferred');\n  }\n\n  /**\n   * Update confidence score\n   */\n  async updateConfidence(candidateId: string, confidence: number): Promise<MentionCandidate> {\n    await this.db\n      .update(mentionCandidates)\n      .set({ confidence })\n      .where(eq(mentionCandidates.candidateId, candidateId));\n\n    const updated = await this.findById(candidateId);\n    if (!updated) {\n      throw new Error(`Mention ${candidateId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a mention\n   */\n  async delete(candidateId: string): Promise<void> {\n    await this.db.delete(mentionCandidates).where(eq(mentionCandidates.candidateId, candidateId));\n  }\n\n  /**\n   * Delete all mentions for a source\n   */\n  async deleteForSource(sourceId: string): Promise<number> {\n    const result = await this.db\n      .delete(mentionCandidates)\n      .where(eq(mentionCandidates.sourceId, sourceId));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete rejected mentions\n   */\n  async deleteRejected(): Promise<number> {\n    const result = await this.db\n      .delete(mentionCandidates)\n      .where(eq(mentionCandidates.status, 'rejected'));\n\n    return result.changes;\n  }\n\n  /**\n   * Count mentions\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(mentionCandidates);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count mentions by status\n   */\n  async countByStatus(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        status: mentionCandidates.status,\n        count: sql<number>`count(*)`,\n      })\n      .from(mentionCandidates)\n      .groupBy(mentionCandidates.status);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      if (row.status) {\n        counts[row.status] = row.count;\n      }\n    }\n    return counts;\n  }\n\n  /**\n   * Get top mentions by confidence\n   */\n  async getTopByConfidence(limit: number = 10): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.status, 'new'))\n      .orderBy(sql`${mentionCandidates.confidence} DESC`)\n      .limit(limit);\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Convert database row to MentionCandidate type\n   */\n  private rowToMention(row: MentionCandidateRow): MentionCandidate {\n    return {\n      candidateId: row.candidateId,\n      sourceId: row.sourceId,\n      targetId: row.targetId,\n      surfaceText: row.surfaceText,\n      confidence: row.confidence,\n      status: (row.status ?? 'new') as MentionStatus,\n      ...(row.spanStart != null && { spanStart: row.spanStart }),\n      ...(row.spanEnd != null && { spanEnd: row.spanEnd }),\n      ...(row.reasons != null && { reasons: row.reasons as string[] }),\n    };\n  }\n}\n","import { sql } from 'drizzle-orm';\nimport { DrizzleDB } from '../connection.js';\nimport { unresolvedLinks, nodes } from '../schema.js';\n\n/**\n * Data structure for ghost nodes in the visualization\n */\nexport interface GhostNodeData {\n  /** The unresolved link text (e.g., \"Missing Note\") */\n  targetText: string;\n  /** All node IDs that reference this ghost */\n  sourceIds: string[];\n  /** Number of times this ghost is referenced */\n  referenceCount: number;\n  /** Timestamp of the earliest reference */\n  firstSeen: string;\n  /** Most recent reference timestamp (from unresolved_link or referencer's updatedAt) */\n  mostRecentRef?: string | undefined;\n}\n\n/**\n * Repository for unresolved link operations, primarily for ghost node visualization\n */\nexport class UnresolvedLinkRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Get all unresolved links grouped by target text for ghost node visualization.\n   * Returns ghost node data sorted by reference count (most referenced first).\n   */\n  async getGhostNodes(): Promise<GhostNodeData[]> {\n    const result = await this.db\n      .select({\n        targetText: unresolvedLinks.targetText,\n        sourceIds: sql<string>`GROUP_CONCAT(${unresolvedLinks.sourceId}, ',')`,\n        referenceCount: sql<number>`COUNT(*)`,\n        firstSeen: sql<string>`MIN(${unresolvedLinks.createdAt})`,\n      })\n      .from(unresolvedLinks)\n      .groupBy(unresolvedLinks.targetText)\n      .orderBy(sql`COUNT(*) DESC`);\n\n    return result\n      .filter((row) => row.targetText && row.targetText.trim() !== '')\n      .map((row) => ({\n        targetText: row.targetText,\n        sourceIds: row.sourceIds ? row.sourceIds.split(',') : [],\n        referenceCount: row.referenceCount,\n        firstSeen: row.firstSeen,\n      }));\n  }\n\n  /**\n   * Get ghost nodes with a minimum reference count threshold.\n   * Useful for filtering out rarely-referenced unresolved links.\n   */\n  async getGhostNodesWithThreshold(minReferenceCount: number): Promise<GhostNodeData[]> {\n    const result = await this.db\n      .select({\n        targetText: unresolvedLinks.targetText,\n        sourceIds: sql<string>`GROUP_CONCAT(${unresolvedLinks.sourceId}, ',')`,\n        referenceCount: sql<number>`COUNT(*)`,\n        firstSeen: sql<string>`MIN(${unresolvedLinks.createdAt})`,\n      })\n      .from(unresolvedLinks)\n      .groupBy(unresolvedLinks.targetText)\n      .having(sql`COUNT(*) >= ${minReferenceCount}`)\n      .orderBy(sql`COUNT(*) DESC`);\n\n    return result\n      .filter((row) => row.targetText && row.targetText.trim() !== '')\n      .map((row) => ({\n        targetText: row.targetText,\n        sourceIds: row.sourceIds ? row.sourceIds.split(',') : [],\n        referenceCount: row.referenceCount,\n        firstSeen: row.firstSeen,\n      }));\n  }\n\n  /**\n   * Count total number of unique unresolved link targets (ghost nodes)\n   */\n  async countGhostNodes(): Promise<number> {\n    const result = await this.db\n      .select({\n        count: sql<number>`COUNT(DISTINCT ${unresolvedLinks.targetText})`,\n      })\n      .from(unresolvedLinks);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count total number of unresolved link references\n   */\n  async countReferences(): Promise<number> {\n    const result = await this.db\n      .select({\n        count: sql<number>`COUNT(*)`,\n      })\n      .from(unresolvedLinks);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Get ghost nodes with most recent reference time included.\n   * The most recent reference time is the latest of:\n   * - The unresolved_link createdAt timestamp\n   * - The referencing node's updatedAt timestamp\n   *\n   * Returns ghost node data sorted by reference count (most referenced first).\n   */\n  async getGhostNodesWithRecency(): Promise<GhostNodeData[]> {\n    // Use a subquery to get the most recent reference time by joining with nodes\n    const result = await this.db\n      .select({\n        targetText: unresolvedLinks.targetText,\n        sourceIds: sql<string>`GROUP_CONCAT(${unresolvedLinks.sourceId}, ',')`,\n        referenceCount: sql<number>`COUNT(*)`,\n        firstSeen: sql<string>`MIN(${unresolvedLinks.createdAt})`,\n        mostRecentLinkCreated: sql<string>`MAX(${unresolvedLinks.createdAt})`,\n      })\n      .from(unresolvedLinks)\n      .groupBy(unresolvedLinks.targetText)\n      .orderBy(sql`COUNT(*) DESC`);\n\n    // For each ghost, get the most recent referencer's updatedAt\n    const ghostsWithRecency = await Promise.all(\n      result\n        .filter((row) => row.targetText && row.targetText.trim() !== '')\n        .map(async (row) => {\n          const sourceIds = row.sourceIds ? row.sourceIds.split(',') : [];\n\n          // Get the most recent updatedAt from referencing nodes\n          let mostRecentReferencerUpdate: string | null = null;\n          if (sourceIds.length > 0) {\n            const referencerResult = await this.db\n              .select({\n                maxUpdatedAt: sql<string>`MAX(${nodes.updatedAt})`,\n              })\n              .from(nodes)\n              .where(\n                sql`${nodes.nodeId} IN (${sql.join(\n                  sourceIds.map((id) => sql`${id}`),\n                  sql`, `\n                )})`\n              );\n\n            mostRecentReferencerUpdate = referencerResult[0]?.maxUpdatedAt ?? null;\n          }\n\n          // Use the more recent of link creation or referencer update\n          const mostRecentRef = [row.mostRecentLinkCreated, mostRecentReferencerUpdate]\n            .filter((t): t is string => t !== null)\n            .sort()\n            .reverse()[0];\n\n          return {\n            targetText: row.targetText,\n            sourceIds,\n            referenceCount: row.referenceCount,\n            firstSeen: row.firstSeen,\n            mostRecentRef,\n          };\n        })\n    );\n\n    return ghostsWithRecency;\n  }\n\n  /**\n   * Delete unresolved links by target text\n   */\n  async deleteByTargetText(targetText: string): Promise<number> {\n    const result = await this.db\n      .delete(unresolvedLinks)\n      .where(sql`${unresolvedLinks.targetText} COLLATE NOCASE = ${targetText}`);\n\n    return result.changes;\n  }\n}\n","import { eq } from 'drizzle-orm';\nimport { DrizzleDB } from '../connection.js';\nimport { constellations, ConstellationRow } from '../schema.js';\nimport { randomUUID } from 'node:crypto';\n\n/**\n * Constellation represents a saved graph view configuration\n */\nexport interface Constellation {\n  constellationId: string;\n  name: string;\n  description: string | undefined;\n  hiddenNodeTypes: string[];\n  hiddenEdgeTypes: string[];\n  showGhosts: boolean;\n  ghostThreshold: number;\n  cameraX: number | undefined;\n  cameraY: number | undefined;\n  cameraZoom: number | undefined;\n  focusNodeIds: string[] | undefined;\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * Input for creating a new constellation\n */\nexport interface CreateConstellationInput {\n  name: string;\n  description?: string;\n  hiddenNodeTypes?: string[];\n  hiddenEdgeTypes?: string[];\n  showGhosts?: boolean;\n  ghostThreshold?: number;\n  cameraX?: number;\n  cameraY?: number;\n  cameraZoom?: number;\n  focusNodeIds?: string[];\n}\n\n/**\n * Input for updating an existing constellation\n */\nexport interface UpdateConstellationInput {\n  name?: string;\n  description?: string;\n  hiddenNodeTypes?: string[];\n  hiddenEdgeTypes?: string[];\n  showGhosts?: boolean;\n  ghostThreshold?: number;\n  cameraX?: number;\n  cameraY?: number;\n  cameraZoom?: number;\n  focusNodeIds?: string[];\n}\n\n/**\n * Repository for constellation CRUD operations\n */\nexport class ConstellationRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Convert a database row to a Constellation object\n   */\n  private rowToConstellation(row: ConstellationRow): Constellation {\n    return {\n      constellationId: row.constellationId,\n      name: row.name,\n      description: row.description ?? undefined,\n      hiddenNodeTypes: (row.hiddenNodeTypes as string[] | null) ?? [],\n      hiddenEdgeTypes: (row.hiddenEdgeTypes as string[] | null) ?? [],\n      showGhosts: row.showGhosts === 1,\n      ghostThreshold: row.ghostThreshold,\n      cameraX: row.cameraX ?? undefined,\n      cameraY: row.cameraY ?? undefined,\n      cameraZoom: row.cameraZoom ?? undefined,\n      focusNodeIds: (row.focusNodeIds as string[] | null) ?? undefined,\n      createdAt: row.createdAt,\n      updatedAt: row.updatedAt,\n    };\n  }\n\n  /**\n   * Create a new constellation\n   */\n  async create(input: CreateConstellationInput): Promise<Constellation> {\n    const now = new Date().toISOString();\n    const id = randomUUID();\n\n    const row: typeof constellations.$inferInsert = {\n      constellationId: id,\n      name: input.name,\n      description: input.description ?? null,\n      hiddenNodeTypes: input.hiddenNodeTypes ?? [],\n      hiddenEdgeTypes: input.hiddenEdgeTypes ?? [],\n      showGhosts: input.showGhosts !== false ? 1 : 0,\n      ghostThreshold: input.ghostThreshold ?? 1,\n      cameraX: input.cameraX ?? null,\n      cameraY: input.cameraY ?? null,\n      cameraZoom: input.cameraZoom ?? null,\n      focusNodeIds: input.focusNodeIds ?? null,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    await this.db.insert(constellations).values(row);\n\n    return this.rowToConstellation(row as ConstellationRow);\n  }\n\n  /**\n   * Find a constellation by ID\n   */\n  async findById(id: string): Promise<Constellation | null> {\n    const rows = await this.db\n      .select()\n      .from(constellations)\n      .where(eq(constellations.constellationId, id))\n      .limit(1);\n\n    const row = rows[0];\n    if (!row) return null;\n    return this.rowToConstellation(row);\n  }\n\n  /**\n   * Find a constellation by name\n   */\n  async findByName(name: string): Promise<Constellation | null> {\n    const rows = await this.db\n      .select()\n      .from(constellations)\n      .where(eq(constellations.name, name))\n      .limit(1);\n\n    const row = rows[0];\n    if (!row) return null;\n    return this.rowToConstellation(row);\n  }\n\n  /**\n   * Find all constellations\n   */\n  async findAll(): Promise<Constellation[]> {\n    const rows = await this.db.select().from(constellations);\n    return rows.map((row) => this.rowToConstellation(row));\n  }\n\n  /**\n   * Update an existing constellation\n   */\n  async update(id: string, input: UpdateConstellationInput): Promise<Constellation | null> {\n    const existing = await this.findById(id);\n    if (!existing) return null;\n\n    const now = new Date().toISOString();\n\n    const updates: Partial<typeof constellations.$inferInsert> = {\n      updatedAt: now,\n    };\n\n    if (input.name !== undefined) updates.name = input.name;\n    if (input.description !== undefined) updates.description = input.description;\n    if (input.hiddenNodeTypes !== undefined) updates.hiddenNodeTypes = input.hiddenNodeTypes;\n    if (input.hiddenEdgeTypes !== undefined) updates.hiddenEdgeTypes = input.hiddenEdgeTypes;\n    if (input.showGhosts !== undefined) updates.showGhosts = input.showGhosts ? 1 : 0;\n    if (input.ghostThreshold !== undefined) updates.ghostThreshold = input.ghostThreshold;\n    if (input.cameraX !== undefined) updates.cameraX = input.cameraX;\n    if (input.cameraY !== undefined) updates.cameraY = input.cameraY;\n    if (input.cameraZoom !== undefined) updates.cameraZoom = input.cameraZoom;\n    if (input.focusNodeIds !== undefined) updates.focusNodeIds = input.focusNodeIds;\n\n    await this.db.update(constellations).set(updates).where(eq(constellations.constellationId, id));\n\n    return this.findById(id);\n  }\n\n  /**\n   * Delete a constellation by ID\n   */\n  async delete(id: string): Promise<boolean> {\n    const result = await this.db\n      .delete(constellations)\n      .where(eq(constellations.constellationId, id));\n\n    return (result as { changes?: number }).changes !== 0;\n  }\n\n  /**\n   * Delete a constellation by name\n   */\n  async deleteByName(name: string): Promise<boolean> {\n    const result = await this.db.delete(constellations).where(eq(constellations.name, name));\n\n    return (result as { changes?: number }).changes !== 0;\n  }\n}\n","import { eq, inArray, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport {\n  nodeEmbeddings,\n  nodes,\n  type NodeEmbeddingRow,\n  type NewNodeEmbeddingRow,\n} from '../schema.js';\nimport { getCircuitBreaker } from '../../../core/circuit-breaker.js';\n\n/**\n * Interface for a node's embedding data\n */\nexport interface NodeEmbedding {\n  embeddingId: string;\n  nodeId: string;\n  embedding: number[];\n  model: string;\n  dimensions: number;\n  contentHash: string;\n  computedAt: string;\n}\n\nexport interface CreateEmbeddingInput {\n  nodeId: string;\n  embedding: number[];\n  model: string;\n  dimensions: number;\n  contentHash: string;\n}\n\n/**\n * Repository for Node Embedding CRUD operations\n */\nexport class EmbeddingRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new embedding\n   * Protected by embeddings circuit breaker as this is part of the embedding pipeline\n   */\n  async create(data: CreateEmbeddingInput): Promise<NodeEmbedding | null> {\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('embeddings')) {\n      return null;\n    }\n\n    const embeddingId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewNodeEmbeddingRow = {\n      embeddingId,\n      nodeId: data.nodeId,\n      embedding: data.embedding,\n      model: data.model,\n      dimensions: data.dimensions,\n      contentHash: data.contentHash,\n      computedAt: now,\n    };\n\n    try {\n      await this.db.insert(nodeEmbeddings).values(row);\n      cb.recordSuccess('embeddings');\n      return this.rowToEmbedding({ ...row, embeddingId, computedAt: now } as NodeEmbeddingRow);\n    } catch (error) {\n      cb.recordFailure('embeddings', error instanceof Error ? error : new Error(String(error)));\n      return null;\n    }\n  }\n\n  /**\n   * Create or update an embedding for a node\n   * Protected by embeddings circuit breaker as this is part of the embedding pipeline\n   */\n  async upsert(data: CreateEmbeddingInput): Promise<NodeEmbedding | null> {\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('embeddings')) {\n      return null;\n    }\n\n    const existing = await this.findByNodeId(data.nodeId);\n\n    if (existing) {\n      return this.update(existing.embeddingId, data);\n    }\n\n    return this.create(data);\n  }\n\n  /**\n   * Find an embedding by ID\n   */\n  async findById(embeddingId: string): Promise<NodeEmbedding | null> {\n    const result = await this.db\n      .select()\n      .from(nodeEmbeddings)\n      .where(eq(nodeEmbeddings.embeddingId, embeddingId))\n      .limit(1);\n\n    return result[0] ? this.rowToEmbedding(result[0]) : null;\n  }\n\n  /**\n   * Find embedding by node ID\n   */\n  async findByNodeId(nodeId: string): Promise<NodeEmbedding | null> {\n    const result = await this.db\n      .select()\n      .from(nodeEmbeddings)\n      .where(eq(nodeEmbeddings.nodeId, nodeId))\n      .limit(1);\n\n    return result[0] ? this.rowToEmbedding(result[0]) : null;\n  }\n\n  /**\n   * Find all embeddings\n   * Protected by vectorDb circuit breaker as this powers similarity search\n   */\n  async findAll(): Promise<NodeEmbedding[]> {\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('vectorDb')) {\n      return [];\n    }\n\n    try {\n      const result = await this.db.select().from(nodeEmbeddings);\n      cb.recordSuccess('vectorDb');\n      return result.map((row) => this.rowToEmbedding(row));\n    } catch (error) {\n      cb.recordFailure('vectorDb', error instanceof Error ? error : new Error(String(error)));\n      return [];\n    }\n  }\n\n  /**\n   * Find embeddings by model\n   */\n  async findByModel(model: string): Promise<NodeEmbedding[]> {\n    const result = await this.db\n      .select()\n      .from(nodeEmbeddings)\n      .where(eq(nodeEmbeddings.model, model));\n\n    return result.map((row) => this.rowToEmbedding(row));\n  }\n\n  /**\n   * Find embeddings by node IDs\n   * Protected by vectorDb circuit breaker as this powers similarity search\n   */\n  async findByNodeIds(nodeIds: string[]): Promise<NodeEmbedding[]> {\n    if (nodeIds.length === 0) return [];\n\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('vectorDb')) {\n      return [];\n    }\n\n    try {\n      const result = await this.db\n        .select()\n        .from(nodeEmbeddings)\n        .where(inArray(nodeEmbeddings.nodeId, nodeIds));\n\n      cb.recordSuccess('vectorDb');\n      return result.map((row) => this.rowToEmbedding(row));\n    } catch (error) {\n      cb.recordFailure('vectorDb', error instanceof Error ? error : new Error(String(error)));\n      return [];\n    }\n  }\n\n  /**\n   * Find nodes that need embedding computation\n   * Returns nodes where either:\n   * - No embedding exists\n   * - The content hash has changed since last embedding\n   */\n  async findDirtyNodeIds(): Promise<string[]> {\n    // Get all nodes with their current content hash\n    const allNodes = await this.db\n      .select({\n        nodeId: nodes.nodeId,\n        contentHash: nodes.contentHash,\n      })\n      .from(nodes);\n\n    // Get all existing embeddings\n    const embeddings = await this.db\n      .select({\n        nodeId: nodeEmbeddings.nodeId,\n        contentHash: nodeEmbeddings.contentHash,\n      })\n      .from(nodeEmbeddings);\n\n    const embeddingMap = new Map(embeddings.map((e) => [e.nodeId, e.contentHash]));\n\n    const dirtyNodeIds: string[] = [];\n    for (const node of allNodes) {\n      const existingHash = embeddingMap.get(node.nodeId);\n      // Node is dirty if: no embedding exists, or content hash changed\n      if (!existingHash || existingHash !== node.contentHash) {\n        dirtyNodeIds.push(node.nodeId);\n      }\n    }\n\n    return dirtyNodeIds;\n  }\n\n  /**\n   * Update an embedding\n   * Protected by embeddings circuit breaker as this is part of the embedding pipeline\n   */\n  async update(\n    embeddingId: string,\n    data: Partial<CreateEmbeddingInput>\n  ): Promise<NodeEmbedding | null> {\n    const cb = getCircuitBreaker();\n    if (!cb.shouldAttempt('embeddings')) {\n      return null;\n    }\n\n    const now = new Date().toISOString();\n    const updateData: Partial<NodeEmbeddingRow> = {\n      computedAt: now,\n    };\n\n    if (data.embedding !== undefined) updateData.embedding = data.embedding;\n    if (data.model !== undefined) updateData.model = data.model;\n    if (data.dimensions !== undefined) updateData.dimensions = data.dimensions;\n    if (data.contentHash !== undefined) updateData.contentHash = data.contentHash;\n\n    try {\n      await this.db\n        .update(nodeEmbeddings)\n        .set(updateData)\n        .where(eq(nodeEmbeddings.embeddingId, embeddingId));\n\n      cb.recordSuccess('embeddings');\n      const updated = await this.findById(embeddingId);\n      if (!updated) {\n        return null;\n      }\n      return updated;\n    } catch (error) {\n      cb.recordFailure('embeddings', error instanceof Error ? error : new Error(String(error)));\n      return null;\n    }\n  }\n\n  /**\n   * Delete an embedding by ID\n   */\n  async delete(embeddingId: string): Promise<void> {\n    await this.db.delete(nodeEmbeddings).where(eq(nodeEmbeddings.embeddingId, embeddingId));\n  }\n\n  /**\n   * Delete embedding by node ID\n   */\n  async deleteByNodeId(nodeId: string): Promise<void> {\n    await this.db.delete(nodeEmbeddings).where(eq(nodeEmbeddings.nodeId, nodeId));\n  }\n\n  /**\n   * Delete all embeddings for a model\n   */\n  async deleteByModel(model: string): Promise<number> {\n    const result = await this.db.delete(nodeEmbeddings).where(eq(nodeEmbeddings.model, model));\n\n    return result.changes;\n  }\n\n  /**\n   * Count embeddings\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(nodeEmbeddings);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count embeddings by model\n   */\n  async countByModel(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        model: nodeEmbeddings.model,\n        count: sql<number>`count(*)`,\n      })\n      .from(nodeEmbeddings)\n      .groupBy(nodeEmbeddings.model);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      counts[row.model] = row.count;\n    }\n    return counts;\n  }\n\n  /**\n   * Convert database row to NodeEmbedding type\n   */\n  private rowToEmbedding(row: NodeEmbeddingRow): NodeEmbedding {\n    return {\n      embeddingId: row.embeddingId,\n      nodeId: row.nodeId,\n      embedding: row.embedding as number[],\n      model: row.model,\n      dimensions: row.dimensions,\n      contentHash: row.contentHash,\n      computedAt: row.computedAt,\n    };\n  }\n}\n","/**\n * Circuit breaker pattern for graceful degradation\n *\n * Prevents cascading failures by tracking error rates and temporarily\n * disabling expensive operations that are consistently failing.\n *\n * States:\n * - CLOSED: Normal operation, calls pass through\n * - OPEN: Too many failures, calls are blocked (returns empty/warning)\n * - HALF_OPEN: Cooldown elapsed, allowing a probe call to test recovery\n */\n\nimport { getLogger } from './logger';\n\nconst logger = getLogger().child('circuit-breaker');\n\nexport enum CircuitState {\n  CLOSED = 'CLOSED',\n  OPEN = 'OPEN',\n  HALF_OPEN = 'HALF_OPEN',\n}\n\nexport type SubsystemName = 'embeddings' | 'vectorDb' | 'fts';\n\nexport interface CircuitBreakerConfig {\n  maxFailures: number;\n  cooldownMs: number;\n}\n\nexport interface CircuitStatus {\n  state: CircuitState;\n  failureCount: number;\n  totalFailures: number;\n  lastFailure: Date | null;\n  lastError: string | null;\n  cooldownRemainingMs: number | null;\n}\n\ninterface SubsystemState {\n  failureCount: number;\n  totalFailures: number;\n  lastFailure: number | null;\n  lastError: string | null;\n  recoveryInProgress: boolean;\n}\n\nconst DEFAULT_CONFIG: CircuitBreakerConfig = {\n  maxFailures: 3,\n  cooldownMs: 600_000, // 10 minutes\n};\n\n/**\n * Circuit breaker for a single subsystem\n */\nclass SubsystemBreaker {\n  private state: SubsystemState = {\n    failureCount: 0,\n    totalFailures: 0,\n    lastFailure: null,\n    lastError: null,\n    recoveryInProgress: false,\n  };\n\n  constructor(\n    private name: SubsystemName,\n    private config: CircuitBreakerConfig\n  ) {}\n\n  /**\n   * Check if a call should be attempted\n   * Returns true for CLOSED or HALF_OPEN states\n   */\n  shouldAttempt(): boolean {\n    // Under failure threshold = CLOSED state\n    if (this.state.failureCount < this.config.maxFailures) {\n      return true;\n    }\n\n    // Check if cooldown has elapsed\n    if (this.state.lastFailure !== null) {\n      const elapsed = Date.now() - this.state.lastFailure;\n      if (elapsed >= this.config.cooldownMs) {\n        // Prevent multiple concurrent recovery attempts\n        if (this.state.recoveryInProgress) {\n          return false;\n        }\n\n        // Enter HALF_OPEN state\n        this.state.recoveryInProgress = true;\n        logger.info(`${this.name}: circuit breaker entering HALF_OPEN - attempting recovery`);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Record a successful call (resets the breaker)\n   */\n  recordSuccess(): void {\n    const wasOpen = this.state.failureCount >= this.config.maxFailures;\n    this.state.failureCount = 0;\n    this.state.lastFailure = null;\n    this.state.lastError = null;\n    this.state.recoveryInProgress = false;\n\n    if (wasOpen) {\n      logger.info(`${this.name}: circuit breaker CLOSED - recovery successful`);\n    }\n  }\n\n  /**\n   * Record a failed call\n   */\n  recordFailure(error: Error): void {\n    this.state.failureCount++;\n    this.state.totalFailures++;\n    this.state.lastFailure = Date.now();\n    this.state.lastError = error.message;\n    this.state.recoveryInProgress = false;\n\n    logger.warn(\n      `${this.name}: failure ${this.state.failureCount}/${this.config.maxFailures}: ${error.message}`\n    );\n\n    if (this.state.failureCount >= this.config.maxFailures) {\n      logger.error(\n        `${this.name}: circuit breaker OPEN - will retry after ${this.config.cooldownMs / 1000}s cooldown`\n      );\n    }\n  }\n\n  /**\n   * Get the current state of this subsystem\n   */\n  getState(): CircuitState {\n    if (this.state.failureCount < this.config.maxFailures) {\n      return CircuitState.CLOSED;\n    }\n\n    if (this.state.lastFailure !== null) {\n      const elapsed = Date.now() - this.state.lastFailure;\n      if (elapsed >= this.config.cooldownMs) {\n        return CircuitState.HALF_OPEN;\n      }\n    }\n\n    return CircuitState.OPEN;\n  }\n\n  /**\n   * Get detailed status for reporting\n   */\n  getStatus(): CircuitStatus {\n    const state = this.getState();\n    let cooldownRemainingMs: number | null = null;\n\n    if (state === CircuitState.OPEN && this.state.lastFailure !== null) {\n      const elapsed = Date.now() - this.state.lastFailure;\n      cooldownRemainingMs = Math.max(0, this.config.cooldownMs - elapsed);\n    }\n\n    return {\n      state,\n      failureCount: this.state.failureCount,\n      totalFailures: this.state.totalFailures,\n      lastFailure: this.state.lastFailure ? new Date(this.state.lastFailure) : null,\n      lastError: this.state.lastError,\n      cooldownRemainingMs,\n    };\n  }\n\n  /**\n   * Reset the breaker (for testing or manual intervention)\n   */\n  reset(): void {\n    this.state = {\n      failureCount: 0,\n      totalFailures: 0,\n      lastFailure: null,\n      lastError: null,\n      recoveryInProgress: false,\n    };\n    logger.info(`${this.name}: circuit breaker manually reset`);\n  }\n}\n\n/**\n * Central circuit breaker manager for all subsystems\n */\nexport class CircuitBreaker {\n  private breakers: Map<SubsystemName, SubsystemBreaker> = new Map();\n  private config: CircuitBreakerConfig;\n\n  constructor(config: Partial<CircuitBreakerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  private getBreaker(subsystem: SubsystemName): SubsystemBreaker {\n    let breaker = this.breakers.get(subsystem);\n    if (!breaker) {\n      breaker = new SubsystemBreaker(subsystem, this.config);\n      this.breakers.set(subsystem, breaker);\n    }\n    return breaker;\n  }\n\n  /**\n   * Check if a call to the subsystem should be attempted\n   */\n  shouldAttempt(subsystem: SubsystemName): boolean {\n    return this.getBreaker(subsystem).shouldAttempt();\n  }\n\n  /**\n   * Record a successful call to the subsystem\n   */\n  recordSuccess(subsystem: SubsystemName): void {\n    this.getBreaker(subsystem).recordSuccess();\n  }\n\n  /**\n   * Record a failed call to the subsystem\n   */\n  recordFailure(subsystem: SubsystemName, error: Error): void {\n    this.getBreaker(subsystem).recordFailure(error);\n  }\n\n  /**\n   * Get the state of a subsystem\n   */\n  getState(subsystem: SubsystemName): CircuitState {\n    return this.getBreaker(subsystem).getState();\n  }\n\n  /**\n   * Get detailed status of a subsystem\n   */\n  getStatus(subsystem: SubsystemName): CircuitStatus {\n    return this.getBreaker(subsystem).getStatus();\n  }\n\n  /**\n   * Get status of all active subsystems\n   */\n  getAllStatus(): Record<SubsystemName, CircuitStatus> {\n    const result: Partial<Record<SubsystemName, CircuitStatus>> = {};\n    for (const [name, breaker] of this.breakers) {\n      result[name] = breaker.getStatus();\n    }\n    return result as Record<SubsystemName, CircuitStatus>;\n  }\n\n  /**\n   * Check if any subsystem is in a degraded state (OPEN or HALF_OPEN)\n   */\n  hasDegradedSubsystems(): boolean {\n    for (const breaker of this.breakers.values()) {\n      const state = breaker.getState();\n      if (state !== CircuitState.CLOSED) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get warnings for degraded subsystems (for health summary)\n   */\n  getWarnings(): string[] {\n    const warnings: string[] = [];\n    for (const [name, breaker] of this.breakers) {\n      const status = breaker.getStatus();\n      if (status.state === CircuitState.OPEN && status.cooldownRemainingMs !== null) {\n        const cooldownMinutes = Math.ceil(status.cooldownRemainingMs / 60_000);\n        warnings.push(`${name} disabled (cooldown ${cooldownMinutes}m)`);\n      } else if (status.state === CircuitState.HALF_OPEN) {\n        warnings.push(`${name} recovering`);\n      }\n    }\n    return warnings;\n  }\n\n  /**\n   * Reset a specific subsystem (for testing or manual intervention)\n   */\n  reset(subsystem: SubsystemName): void {\n    this.getBreaker(subsystem).reset();\n  }\n\n  /**\n   * Reset all subsystems\n   */\n  resetAll(): void {\n    for (const breaker of this.breakers.values()) {\n      breaker.reset();\n    }\n  }\n}\n\n// Default singleton instance\nlet defaultCircuitBreaker: CircuitBreaker | null = null;\n\n/**\n * Get the default circuit breaker instance\n */\nexport function getCircuitBreaker(): CircuitBreaker {\n  if (!defaultCircuitBreaker) {\n    defaultCircuitBreaker = new CircuitBreaker();\n  }\n  return defaultCircuitBreaker;\n}\n\n/**\n * Set the default circuit breaker instance (for testing)\n */\nexport function setCircuitBreaker(breaker: CircuitBreaker): void {\n  defaultCircuitBreaker = breaker;\n}\n\n/**\n * Reset the default circuit breaker instance (for testing)\n */\nexport function resetCircuitBreaker(): void {\n  defaultCircuitBreaker = null;\n}\n","import { eq, and, or, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport {\n  wormholeRejections,\n  type WormholeRejectionRow,\n  type NewWormholeRejectionRow,\n} from '../schema.js';\n\n/**\n * Interface for a wormhole rejection\n */\nexport interface WormholeRejection {\n  rejectionId: string;\n  sourceId: string;\n  targetId: string;\n  sourceContentHash: string;\n  targetContentHash: string;\n  rejectedAt: string;\n}\n\nexport interface CreateRejectionInput {\n  sourceId: string;\n  targetId: string;\n  sourceContentHash: string;\n  targetContentHash: string;\n}\n\n/**\n * Repository for Wormhole Rejection CRUD operations\n */\nexport class WormholeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new rejection\n   */\n  async createRejection(data: CreateRejectionInput): Promise<WormholeRejection> {\n    const rejectionId = nanoid();\n    const now = new Date().toISOString();\n\n    // Normalize pair order (smaller ID first) for consistent lookups\n    const [normalizedSourceId, normalizedTargetId, normalizedSourceHash, normalizedTargetHash] =\n      data.sourceId < data.targetId\n        ? [data.sourceId, data.targetId, data.sourceContentHash, data.targetContentHash]\n        : [data.targetId, data.sourceId, data.targetContentHash, data.sourceContentHash];\n\n    const row: NewWormholeRejectionRow = {\n      rejectionId,\n      sourceId: normalizedSourceId,\n      targetId: normalizedTargetId,\n      sourceContentHash: normalizedSourceHash,\n      targetContentHash: normalizedTargetHash,\n      rejectedAt: now,\n    };\n\n    await this.db.insert(wormholeRejections).values(row);\n\n    return this.rowToRejection({ ...row, rejectionId, rejectedAt: now } as WormholeRejectionRow);\n  }\n\n  /**\n   * Check if a pair is rejected (considering content hashes)\n   * Returns true if the pair was rejected AND the content hasn't changed\n   */\n  async isRejected(\n    sourceId: string,\n    targetId: string,\n    sourceContentHash: string,\n    targetContentHash: string\n  ): Promise<boolean> {\n    // Normalize pair order\n    const [normalizedSourceId, normalizedTargetId, normalizedSourceHash, normalizedTargetHash] =\n      sourceId < targetId\n        ? [sourceId, targetId, sourceContentHash, targetContentHash]\n        : [targetId, sourceId, targetContentHash, sourceContentHash];\n\n    const result = await this.db\n      .select()\n      .from(wormholeRejections)\n      .where(\n        and(\n          eq(wormholeRejections.sourceId, normalizedSourceId),\n          eq(wormholeRejections.targetId, normalizedTargetId),\n          eq(wormholeRejections.sourceContentHash, normalizedSourceHash),\n          eq(wormholeRejections.targetContentHash, normalizedTargetHash)\n        )\n      )\n      .limit(1);\n\n    return result.length > 0;\n  }\n\n  /**\n   * Check if any rejection exists for a pair (regardless of content hash)\n   */\n  async hasAnyRejection(sourceId: string, targetId: string): Promise<boolean> {\n    // Normalize pair order\n    const [normalizedSourceId, normalizedTargetId] =\n      sourceId < targetId ? [sourceId, targetId] : [targetId, sourceId];\n\n    const result = await this.db\n      .select()\n      .from(wormholeRejections)\n      .where(\n        and(\n          eq(wormholeRejections.sourceId, normalizedSourceId),\n          eq(wormholeRejections.targetId, normalizedTargetId)\n        )\n      )\n      .limit(1);\n\n    return result.length > 0;\n  }\n\n  /**\n   * Find all rejections\n   */\n  async findAll(): Promise<WormholeRejection[]> {\n    const result = await this.db.select().from(wormholeRejections);\n    return result.map((row) => this.rowToRejection(row));\n  }\n\n  /**\n   * Find rejections for a specific node\n   */\n  async findByNodeId(nodeId: string): Promise<WormholeRejection[]> {\n    const result = await this.db\n      .select()\n      .from(wormholeRejections)\n      .where(or(eq(wormholeRejections.sourceId, nodeId), eq(wormholeRejections.targetId, nodeId)));\n\n    return result.map((row) => this.rowToRejection(row));\n  }\n\n  /**\n   * Delete a rejection by ID\n   */\n  async delete(rejectionId: string): Promise<void> {\n    await this.db.delete(wormholeRejections).where(eq(wormholeRejections.rejectionId, rejectionId));\n  }\n\n  /**\n   * Delete rejections for a node pair\n   */\n  async deleteForPair(sourceId: string, targetId: string): Promise<void> {\n    // Normalize pair order\n    const [normalizedSourceId, normalizedTargetId] =\n      sourceId < targetId ? [sourceId, targetId] : [targetId, sourceId];\n\n    await this.db\n      .delete(wormholeRejections)\n      .where(\n        and(\n          eq(wormholeRejections.sourceId, normalizedSourceId),\n          eq(wormholeRejections.targetId, normalizedTargetId)\n        )\n      );\n  }\n\n  /**\n   * Delete all rejections for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(wormholeRejections)\n      .where(or(eq(wormholeRejections.sourceId, nodeId), eq(wormholeRejections.targetId, nodeId)));\n\n    return result.changes;\n  }\n\n  /**\n   * Clear all rejections\n   */\n  async clearAll(): Promise<number> {\n    const result = await this.db.delete(wormholeRejections);\n    return result.changes;\n  }\n\n  /**\n   * Count rejections\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(wormholeRejections);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Convert database row to WormholeRejection type\n   */\n  private rowToRejection(row: WormholeRejectionRow): WormholeRejection {\n    return {\n      rejectionId: row.rejectionId,\n      sourceId: row.sourceId,\n      targetId: row.targetId,\n      sourceContentHash: row.sourceContentHash,\n      targetContentHash: row.targetContentHash,\n      rejectedAt: row.rejectedAt,\n    };\n  }\n}\n","import { eq, and, inArray, sql } from 'drizzle-orm';\nimport { DrizzleDB } from '../connection.js';\nimport { candidateEdges, type CandidateEdgeRow, type NewCandidateEdgeRow } from '../schema.js';\nimport type {\n  CandidateEdge,\n  CandidateEdgeStatus,\n  CandidateEdgeSignals,\n  CandidateEdgeProvenance,\n  EdgeType,\n} from '../../../core/types/index.js';\n\n/**\n * Input for creating a new candidate edge\n */\nexport interface CreateCandidateEdgeInput {\n  suggestionId: string;\n  fromId: string;\n  toId: string;\n  suggestedEdgeType: EdgeType;\n  signals?: CandidateEdgeSignals;\n  reasons?: string[];\n  provenance?: CandidateEdgeProvenance[];\n}\n\n/**\n * Input for updating a candidate edge\n */\nexport interface UpdateCandidateEdgeInput {\n  status?: CandidateEdgeStatus;\n  signals?: CandidateEdgeSignals;\n  reasons?: string[];\n  provenance?: CandidateEdgeProvenance[];\n  writebackStatus?: string;\n  writebackReason?: string;\n  approvedEdgeId?: string;\n}\n\n/**\n * Repository for candidate edge CRUD operations.\n * Candidate edges are suggestions that may be approved or rejected.\n */\nexport class CandidateEdgeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new candidate edge\n   */\n  async create(data: CreateCandidateEdgeInput): Promise<CandidateEdge> {\n    const now = new Date().toISOString();\n\n    // Compute normalized IDs for undirected uniqueness\n    const [fromIdNorm, toIdNorm] =\n      data.fromId < data.toId ? [data.fromId, data.toId] : [data.toId, data.fromId];\n\n    const row: NewCandidateEdgeRow = {\n      suggestionId: data.suggestionId,\n      fromId: data.fromId,\n      toId: data.toId,\n      suggestedEdgeType: data.suggestedEdgeType,\n      fromIdNorm,\n      toIdNorm,\n      status: 'suggested',\n      signals: data.signals ?? null,\n      reasons: data.reasons ?? null,\n      provenance: data.provenance ?? null,\n      createdAt: now,\n      lastComputedAt: now,\n    };\n\n    await this.db.insert(candidateEdges).values(row);\n\n    return this.rowToCandidateEdge({\n      ...row,\n      statusChangedAt: null,\n      lastSeenAt: null,\n      writebackStatus: null,\n      writebackReason: null,\n      approvedEdgeId: null,\n    } as CandidateEdgeRow);\n  }\n\n  /**\n   * Create or update a candidate edge (upsert by suggestionId)\n   */\n  async upsert(data: CreateCandidateEdgeInput): Promise<CandidateEdge> {\n    const existing = await this.findById(data.suggestionId);\n\n    if (existing) {\n      // Update existing - merge signals and reasons\n      const mergedSignals = { ...existing.signals, ...data.signals };\n      const mergedReasons = [...new Set([...(existing.reasons || []), ...(data.reasons || [])])];\n      const mergedProvenance = [...(existing.provenance || []), ...(data.provenance || [])];\n\n      return this.update(data.suggestionId, {\n        signals: mergedSignals,\n        reasons: mergedReasons.slice(0, 3), // Keep top 3\n        provenance: mergedProvenance,\n      });\n    }\n\n    return this.create(data);\n  }\n\n  /**\n   * Find a candidate edge by ID\n   */\n  async findById(suggestionId: string): Promise<CandidateEdge | null> {\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(eq(candidateEdges.suggestionId, suggestionId))\n      .limit(1);\n\n    return result[0] ? this.rowToCandidateEdge(result[0]) : null;\n  }\n\n  /**\n   * Find candidate edges by status\n   */\n  async findByStatus(status: CandidateEdgeStatus): Promise<CandidateEdge[]> {\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(eq(candidateEdges.status, status));\n\n    return result.map((row) => this.rowToCandidateEdge(row));\n  }\n\n  /**\n   * Find candidate edges involving a specific node (as source or target)\n   */\n  async findByNodeId(nodeId: string): Promise<CandidateEdge[]> {\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(sql`${candidateEdges.fromId} = ${nodeId} OR ${candidateEdges.toId} = ${nodeId}`);\n\n    return result.map((row) => this.rowToCandidateEdge(row));\n  }\n\n  /**\n   * Find suggested candidate edges for nodes in a given set\n   */\n  async findSuggestedForNodes(nodeIds: string[]): Promise<CandidateEdge[]> {\n    if (nodeIds.length === 0) return [];\n\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(\n        and(\n          eq(candidateEdges.status, 'suggested'),\n          sql`(${candidateEdges.fromId} IN ${nodeIds} OR ${candidateEdges.toId} IN ${nodeIds})`\n        )\n      );\n\n    return result.map((row) => this.rowToCandidateEdge(row));\n  }\n\n  /**\n   * Find by normalized pair (for checking duplicates)\n   */\n  async findByNormalizedPair(\n    nodeId1: string,\n    nodeId2: string,\n    edgeType: EdgeType\n  ): Promise<CandidateEdge | null> {\n    const [fromIdNorm, toIdNorm] = nodeId1 < nodeId2 ? [nodeId1, nodeId2] : [nodeId2, nodeId1];\n\n    const result = await this.db\n      .select()\n      .from(candidateEdges)\n      .where(\n        and(\n          eq(candidateEdges.fromIdNorm, fromIdNorm),\n          eq(candidateEdges.toIdNorm, toIdNorm),\n          eq(candidateEdges.suggestedEdgeType, edgeType)\n        )\n      )\n      .limit(1);\n\n    return result[0] ? this.rowToCandidateEdge(result[0]) : null;\n  }\n\n  /**\n   * Update a candidate edge\n   */\n  async update(suggestionId: string, data: UpdateCandidateEdgeInput): Promise<CandidateEdge> {\n    const updateData: Partial<CandidateEdgeRow> = {\n      lastComputedAt: new Date().toISOString(),\n    };\n\n    if (data.status !== undefined) {\n      updateData.status = data.status;\n      updateData.statusChangedAt = new Date().toISOString();\n    }\n    if (data.signals !== undefined) updateData.signals = data.signals;\n    if (data.reasons !== undefined) updateData.reasons = data.reasons;\n    if (data.provenance !== undefined) updateData.provenance = data.provenance;\n    if (data.writebackStatus !== undefined) updateData.writebackStatus = data.writebackStatus;\n    if (data.writebackReason !== undefined) updateData.writebackReason = data.writebackReason;\n    if (data.approvedEdgeId !== undefined) updateData.approvedEdgeId = data.approvedEdgeId;\n\n    await this.db\n      .update(candidateEdges)\n      .set(updateData)\n      .where(eq(candidateEdges.suggestionId, suggestionId));\n\n    const updated = await this.findById(suggestionId);\n    if (!updated) {\n      throw new Error(`Candidate edge ${suggestionId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Update status of a candidate edge\n   */\n  async updateStatus(\n    suggestionId: string,\n    status: CandidateEdgeStatus,\n    approvedEdgeId?: string\n  ): Promise<CandidateEdge> {\n    const updateData: UpdateCandidateEdgeInput = { status };\n    if (approvedEdgeId !== undefined) {\n      updateData.approvedEdgeId = approvedEdgeId;\n    }\n    return this.update(suggestionId, updateData);\n  }\n\n  /**\n   * Mark last seen time for candidate edges (for pruning stale suggestions)\n   */\n  async markSeen(suggestionIds: string[]): Promise<void> {\n    if (suggestionIds.length === 0) return;\n\n    await this.db\n      .update(candidateEdges)\n      .set({ lastSeenAt: new Date().toISOString() })\n      .where(inArray(candidateEdges.suggestionId, suggestionIds));\n  }\n\n  /**\n   * Delete a candidate edge\n   */\n  async delete(suggestionId: string): Promise<void> {\n    await this.db.delete(candidateEdges).where(eq(candidateEdges.suggestionId, suggestionId));\n  }\n\n  /**\n   * Delete all candidate edges for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(candidateEdges)\n      .where(sql`${candidateEdges.fromId} = ${nodeId} OR ${candidateEdges.toId} = ${nodeId}`);\n\n    return result.changes;\n  }\n\n  /**\n   * Count candidate edges by status\n   */\n  async countByStatus(): Promise<Record<CandidateEdgeStatus, number>> {\n    const result = await this.db\n      .select({\n        status: candidateEdges.status,\n        count: sql<number>`count(*)`,\n      })\n      .from(candidateEdges)\n      .groupBy(candidateEdges.status);\n\n    const counts: Record<string, number> = {\n      suggested: 0,\n      approved: 0,\n      rejected: 0,\n    };\n    for (const row of result) {\n      counts[row.status] = row.count;\n    }\n    return counts as Record<CandidateEdgeStatus, number>;\n  }\n\n  /**\n   * Count total candidate edges\n   */\n  async count(): Promise<number> {\n    const result = await this.db.select({ count: sql<number>`count(*)` }).from(candidateEdges);\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Convert database row to CandidateEdge type\n   */\n  private rowToCandidateEdge(row: CandidateEdgeRow): CandidateEdge {\n    const result: CandidateEdge = {\n      suggestionId: row.suggestionId,\n      fromId: row.fromId,\n      toId: row.toId,\n      suggestedEdgeType: row.suggestedEdgeType as EdgeType,\n      status: row.status as CandidateEdgeStatus,\n      createdAt: row.createdAt,\n      lastComputedAt: row.lastComputedAt,\n    };\n\n    if (row.statusChangedAt) result.statusChangedAt = row.statusChangedAt;\n    if (row.signals) result.signals = row.signals as CandidateEdgeSignals;\n    if (row.reasons) result.reasons = row.reasons as string[];\n    if (row.provenance) result.provenance = row.provenance as CandidateEdgeProvenance[];\n    if (row.lastSeenAt) result.lastSeenAt = row.lastSeenAt;\n    if (row.writebackStatus) result.writebackStatus = row.writebackStatus;\n    if (row.writebackReason) result.writebackReason = row.writebackReason;\n    if (row.approvedEdgeId) result.approvedEdgeId = row.approvedEdgeId;\n\n    return result;\n  }\n}\n","import { unified } from 'unified';\nimport remarkParse from 'remark-parse';\nimport remarkFrontmatter from 'remark-frontmatter';\nimport remarkStringify from 'remark-stringify';\nimport type { Root, Content, Heading, Paragraph, Text } from 'mdast';\nimport type { WikiLink, Frontmatter, NodeType } from '../core/types/index.js';\nimport { parseFrontmatter, extractTitle, extractNodeType, extractAliases } from './frontmatter.js';\nimport { extractWikilinks, type WikiLinkParseResult } from './wikilink.js';\nimport type { ExclusionZone } from './exclusions.js';\n\nexport interface ParsedMarkdown {\n  frontmatter: Frontmatter | null;\n  title: string;\n  type: NodeType;\n  aliases: string[];\n  content: string;\n  contentStartOffset: number;\n  links: WikiLink[];\n  exclusionZones: ExclusionZone[];\n  headings: Array<{\n    level: number;\n    text: string;\n    position: { start: number; end: number };\n  }>;\n  paragraphs: Array<{\n    text: string;\n    position: { start: number; end: number };\n  }>;\n  ast: Root;\n}\n\n/**\n * Create the unified markdown processor\n */\nfunction createProcessor() {\n  return unified().use(remarkParse).use(remarkFrontmatter, ['yaml']).use(remarkStringify);\n}\n\n/**\n * Parse a markdown document into structured data\n */\nexport function parseMarkdown(source: string, filePath: string): ParsedMarkdown {\n  // Parse frontmatter first\n  const { frontmatter, content, contentStartOffset } = parseFrontmatter(source, filePath);\n\n  // Extract title, type, and aliases from frontmatter\n  const title = extractTitle(frontmatter, content, filePath);\n  const type = extractNodeType(frontmatter) as NodeType;\n  const aliases = extractAliases(frontmatter);\n\n  // Extract wikilinks\n  const linkResult: WikiLinkParseResult = extractWikilinks(content, contentStartOffset);\n\n  // Parse AST\n  const processor = createProcessor();\n  const ast = processor.parse(source) as Root;\n\n  // Extract headings and paragraphs\n  const headings: ParsedMarkdown['headings'] = [];\n  const paragraphs: ParsedMarkdown['paragraphs'] = [];\n\n  function visitNode(node: Content) {\n    if (node.type === 'heading' && node.position) {\n      const heading = node as Heading;\n      const text = getTextContent(heading);\n      headings.push({\n        level: heading.depth,\n        text,\n        position: {\n          start: node.position.start.offset ?? 0,\n          end: node.position.end.offset ?? 0,\n        },\n      });\n    }\n\n    if (node.type === 'paragraph' && node.position) {\n      const paragraph = node as Paragraph;\n      const text = getTextContent(paragraph);\n      paragraphs.push({\n        text,\n        position: {\n          start: node.position.start.offset ?? 0,\n          end: node.position.end.offset ?? 0,\n        },\n      });\n    }\n\n    // Recurse into children\n    if ('children' in node && Array.isArray(node.children)) {\n      for (const child of node.children) {\n        visitNode(child as Content);\n      }\n    }\n  }\n\n  for (const node of ast.children) {\n    visitNode(node);\n  }\n\n  return {\n    frontmatter,\n    title,\n    type,\n    aliases,\n    content,\n    contentStartOffset,\n    links: linkResult.links,\n    exclusionZones: linkResult.exclusionZones,\n    headings,\n    paragraphs,\n    ast,\n  };\n}\n\n/**\n * Get text content from an AST node\n */\nfunction getTextContent(node: Content): string {\n  if (node.type === 'text') {\n    return (node as Text).value;\n  }\n\n  if ('children' in node && Array.isArray(node.children)) {\n    return node.children.map((child) => getTextContent(child as Content)).join('');\n  }\n\n  return '';\n}\n\n/**\n * Extract plain text from markdown (strips formatting)\n */\nexport function extractPlainText(source: string): string {\n  const processor = createProcessor();\n  const ast = processor.parse(source) as Root;\n\n  function getText(node: Content): string {\n    if (node.type === 'text') {\n      return (node as Text).value;\n    }\n\n    if (node.type === 'code') {\n      return ''; // Skip code blocks\n    }\n\n    if (node.type === 'yaml') {\n      return ''; // Skip frontmatter\n    }\n\n    if ('children' in node && Array.isArray(node.children)) {\n      return node.children.map((child) => getText(child as Content)).join(' ');\n    }\n\n    return '';\n  }\n\n  return ast.children\n    .map((node) => getText(node))\n    .join('\\n')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n/**\n * Split content into sections based on headings\n */\nexport function splitIntoSections(parsed: ParsedMarkdown): Array<{\n  heading: string | null;\n  level: number;\n  content: string;\n  start: number;\n  end: number;\n}> {\n  const sections: Array<{\n    heading: string | null;\n    level: number;\n    content: string;\n    start: number;\n    end: number;\n  }> = [];\n\n  const source = parsed.content;\n\n  if (parsed.headings.length === 0) {\n    // No headings - entire content is one section\n    return [\n      {\n        heading: null,\n        level: 0,\n        content: source,\n        start: parsed.contentStartOffset,\n        end: parsed.contentStartOffset + source.length,\n      },\n    ];\n  }\n\n  // Content before first heading\n  const firstHeading = parsed.headings[0];\n  if (firstHeading && firstHeading.position.start > parsed.contentStartOffset) {\n    const contentBefore = source.slice(0, firstHeading.position.start - parsed.contentStartOffset);\n    if (contentBefore.trim()) {\n      sections.push({\n        heading: null,\n        level: 0,\n        content: contentBefore,\n        start: parsed.contentStartOffset,\n        end: firstHeading.position.start,\n      });\n    }\n  }\n\n  // Process each heading and its content\n  for (let i = 0; i < parsed.headings.length; i++) {\n    const heading = parsed.headings[i];\n    const nextHeading = parsed.headings[i + 1];\n\n    if (!heading) continue;\n\n    const start = heading.position.end;\n    const end = nextHeading\n      ? nextHeading.position.start\n      : parsed.contentStartOffset + source.length;\n\n    const content = source.slice(\n      start - parsed.contentStartOffset,\n      end - parsed.contentStartOffset\n    );\n\n    sections.push({\n      heading: heading.text,\n      level: heading.level,\n      content: content.trim(),\n      start,\n      end,\n    });\n  }\n\n  return sections;\n}\n\n/**\n * Split content into paragraphs\n */\nexport function splitIntoParagraphs(content: string): Array<{\n  text: string;\n  start: number;\n  end: number;\n}> {\n  const paragraphs: Array<{ text: string; start: number; end: number }> = [];\n\n  // Split by blank lines\n  const regex = /(?:\\r?\\n){2,}/g;\n  let lastEnd = 0;\n  let match;\n\n  while ((match = regex.exec(content)) !== null) {\n    const text = content.slice(lastEnd, match.index).trim();\n    if (text) {\n      paragraphs.push({\n        text,\n        start: lastEnd,\n        end: match.index,\n      });\n    }\n    lastEnd = match.index + match[0].length;\n  }\n\n  // Last paragraph\n  const remaining = content.slice(lastEnd).trim();\n  if (remaining) {\n    paragraphs.push({\n      text: remaining,\n      start: lastEnd,\n      end: content.length,\n    });\n  }\n\n  return paragraphs;\n}\n\n/**\n * Stringify markdown AST back to text\n */\nexport function stringifyMarkdown(ast: Root): string {\n  const processor = createProcessor();\n  return processor.stringify(ast);\n}\n","import { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport type { Frontmatter } from '../core/types/index.js';\nimport { ParseError } from '../core/errors.js';\n\n// Frontmatter delimiter\nconst FRONTMATTER_REGEX = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---\\r?\\n?/;\n\nexport interface ParsedDocument {\n  frontmatter: Frontmatter | null;\n  content: string;\n  contentStartOffset: number;\n}\n\n/**\n * Parse frontmatter from a markdown document\n */\nexport function parseFrontmatter(source: string, filePath: string): ParsedDocument {\n  const match = source.match(FRONTMATTER_REGEX);\n\n  if (!match) {\n    return {\n      frontmatter: null,\n      content: source,\n      contentStartOffset: 0,\n    };\n  }\n\n  const yamlContent = match[1];\n  const fullMatch = match[0];\n\n  if (!yamlContent) {\n    return {\n      frontmatter: null,\n      content: source,\n      contentStartOffset: 0,\n    };\n  }\n\n  try {\n    const parsed = parseYaml(yamlContent) as Frontmatter | null;\n\n    return {\n      frontmatter: parsed ?? null,\n      content: source.slice(fullMatch.length),\n      contentStartOffset: fullMatch.length,\n    };\n  } catch (error) {\n    throw new ParseError(`Invalid YAML frontmatter: ${error}`, filePath, undefined, undefined, {\n      yaml: yamlContent,\n    });\n  }\n}\n\n/**\n * Extract title from frontmatter or first heading\n */\nexport function extractTitle(\n  frontmatter: Frontmatter | null,\n  content: string,\n  filePath: string\n): string {\n  // Priority 1: frontmatter title\n  if (frontmatter?.title) {\n    return frontmatter.title;\n  }\n\n  // Priority 2: first H1 heading\n  const h1Match = content.match(/^#\\s+(.+)$/m);\n  if (h1Match?.[1]) {\n    return h1Match[1].trim();\n  }\n\n  // Priority 3: filename without extension\n  const filename = filePath.split('/').pop() || filePath;\n  return filename.replace(/\\.md$/, '');\n}\n\n/**\n * Extract node type from frontmatter\n */\nexport function extractNodeType(frontmatter: Frontmatter | null): string {\n  if (frontmatter?.type) {\n    return frontmatter.type;\n  }\n  return 'note';\n}\n\n/**\n * Extract aliases from frontmatter\n */\nexport function extractAliases(frontmatter: Frontmatter | null): string[] {\n  if (!frontmatter?.aliases) {\n    return [];\n  }\n\n  if (Array.isArray(frontmatter.aliases)) {\n    return frontmatter.aliases.filter((a) => typeof a === 'string');\n  }\n\n  return [];\n}\n\n/**\n * Serialize frontmatter back to YAML string\n */\nexport function serializeFrontmatter(frontmatter: Frontmatter): string {\n  return `---\\n${stringifyYaml(frontmatter)}---\\n`;\n}\n\n/**\n * Update frontmatter in a document\n */\nexport function updateFrontmatter(\n  source: string,\n  updates: Partial<Frontmatter>,\n  filePath: string\n): string {\n  const { frontmatter, content } = parseFrontmatter(source, filePath);\n\n  const newFrontmatter: Frontmatter = {\n    ...frontmatter,\n    ...updates,\n  };\n\n  return serializeFrontmatter(newFrontmatter) + content;\n}\n\n/**\n * Validate frontmatter schema\n */\nexport function validateFrontmatter(frontmatter: Frontmatter): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Check type is valid if present\n  const validTypes = [\n    'note',\n    'scene',\n    'character',\n    'location',\n    'object',\n    'event',\n    'concept',\n    'moc',\n    'timeline',\n    'draft',\n  ];\n\n  if (frontmatter.type && !validTypes.includes(frontmatter.type)) {\n    errors.push(`Invalid type \"${frontmatter.type}\". Valid types: ${validTypes.join(', ')}`);\n  }\n\n  // Check aliases is an array if present\n  if (frontmatter.aliases !== undefined && !Array.isArray(frontmatter.aliases)) {\n    errors.push('aliases must be an array');\n  }\n\n  // Check tags is an array if present\n  if (frontmatter.tags !== undefined && !Array.isArray(frontmatter.tags)) {\n    errors.push('tags must be an array');\n  }\n\n  // Check scene_order is a number if present\n  if (frontmatter.scene_order !== undefined && typeof frontmatter.scene_order !== 'number') {\n    errors.push('scene_order must be a number');\n  }\n\n  // Check characters is an array if present\n  if (frontmatter.characters !== undefined && !Array.isArray(frontmatter.characters)) {\n    errors.push('characters must be an array');\n  }\n\n  // Check locations is an array if present\n  if (frontmatter.locations !== undefined && !Array.isArray(frontmatter.locations)) {\n    errors.push('locations must be an array');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Exclusion zones for wikilink detection.\n * These areas should not be scanned for wikilinks or unlinked mentions.\n */\n\nexport interface ExclusionZone {\n  start: number;\n  end: number;\n  type: 'code_block' | 'inline_code' | 'url' | 'existing_link' | 'frontmatter' | 'html_tag';\n}\n\n// Regex patterns for exclusion zones\nconst PATTERNS = {\n  // Fenced code blocks (``` or ~~~)\n  codeBlock: /```[\\s\\S]*?```|~~~[\\s\\S]*?~~~/g,\n\n  // Inline code\n  inlineCode: /`[^`\\n]+`/g,\n\n  // URLs (http, https, ftp)\n  url: /(?:https?|ftp):\\/\\/[^\\s<>[\\]()]+/g,\n\n  // Markdown links [text](url) and ![alt](url)\n  markdownLink: /!?\\[[^\\]]*\\]\\([^)]+\\)/g,\n\n  // Existing wikilinks [[...]]\n  wikilink: /\\[\\[[^\\]]+\\]\\]/g,\n\n  // HTML tags\n  htmlTag: /<[^>]+>/g,\n\n  // HTML comments\n  htmlComment: /<!--[\\s\\S]*?-->/g,\n\n  // LaTeX math blocks\n  mathBlock: /\\$\\$[\\s\\S]*?\\$\\$/g,\n\n  // Inline math\n  inlineMath: /\\$[^$\\n]+\\$/g,\n};\n\n/**\n * Find all exclusion zones in a document\n */\nexport function findExclusionZones(\n  content: string,\n  frontmatterOffset: number = 0\n): ExclusionZone[] {\n  const zones: ExclusionZone[] = [];\n\n  // Add frontmatter zone if present\n  if (frontmatterOffset > 0) {\n    zones.push({\n      start: 0,\n      end: frontmatterOffset,\n      type: 'frontmatter',\n    });\n  }\n\n  // Find code blocks first (they have priority)\n  for (const match of content.matchAll(PATTERNS.codeBlock)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'code_block',\n      });\n    }\n  }\n\n  // Find inline code\n  for (const match of content.matchAll(PATTERNS.inlineCode)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'inline_code',\n      });\n    }\n  }\n\n  // Find URLs\n  for (const match of content.matchAll(PATTERNS.url)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'url',\n      });\n    }\n  }\n\n  // Find existing wikilinks\n  for (const match of content.matchAll(PATTERNS.wikilink)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'existing_link',\n      });\n    }\n  }\n\n  // Find markdown links\n  for (const match of content.matchAll(PATTERNS.markdownLink)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'existing_link',\n      });\n    }\n  }\n\n  // Find HTML tags\n  for (const match of content.matchAll(PATTERNS.htmlTag)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'html_tag',\n      });\n    }\n  }\n\n  // Find HTML comments\n  for (const match of content.matchAll(PATTERNS.htmlComment)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'html_tag',\n      });\n    }\n  }\n\n  // Find math blocks (treat as code)\n  for (const match of content.matchAll(PATTERNS.mathBlock)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'code_block',\n      });\n    }\n  }\n\n  // Find inline math\n  for (const match of content.matchAll(PATTERNS.inlineMath)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'inline_code',\n      });\n    }\n  }\n\n  // Sort by start position and merge overlapping zones\n  return mergeZones(zones);\n}\n\n/**\n * Merge overlapping exclusion zones\n */\nfunction mergeZones(zones: ExclusionZone[]): ExclusionZone[] {\n  if (zones.length === 0) return [];\n\n  // Sort by start position\n  zones.sort((a, b) => a.start - b.start);\n\n  const merged: ExclusionZone[] = [];\n  let current = zones[0];\n\n  if (!current) return [];\n\n  for (let i = 1; i < zones.length; i++) {\n    const next = zones[i];\n    if (!next) continue;\n\n    if (next.start <= current.end) {\n      // Overlapping or adjacent - extend current zone\n      current = {\n        start: current.start,\n        end: Math.max(current.end, next.end),\n        type: current.type, // Keep the type of the first zone\n      };\n    } else {\n      // Non-overlapping - save current and start new\n      merged.push(current);\n      current = next;\n    }\n  }\n\n  merged.push(current);\n  return merged;\n}\n\n/**\n * Check if a position is within an exclusion zone\n */\nexport function isInExclusionZone(position: number, zones: ExclusionZone[]): boolean {\n  return zones.some((zone) => position >= zone.start && position < zone.end);\n}\n\n/**\n * Check if a range overlaps with any exclusion zone\n */\nexport function overlapsExclusionZone(start: number, end: number, zones: ExclusionZone[]): boolean {\n  return zones.some((zone) => start < zone.end && end > zone.start);\n}\n\n/**\n * Filter out matches that overlap with exclusion zones\n */\nexport function filterExcludedMatches<T extends { start: number; end: number }>(\n  matches: T[],\n  zones: ExclusionZone[]\n): T[] {\n  return matches.filter((match) => !overlapsExclusionZone(match.start, match.end, zones));\n}\n\n/**\n * Get content with exclusion zones replaced by spaces\n * (useful for text analysis that needs position preservation)\n */\nexport function maskExclusionZones(content: string, zones: ExclusionZone[]): string {\n  let masked = content;\n\n  // Process zones in reverse order to preserve positions\n  const sortedZones = [...zones].sort((a, b) => b.start - a.start);\n\n  for (const zone of sortedZones) {\n    const before = masked.slice(0, zone.start);\n    const after = masked.slice(zone.end);\n    const replacement = ' '.repeat(zone.end - zone.start);\n    masked = before + replacement + after;\n  }\n\n  return masked;\n}\n","import type { WikiLink } from '../core/types/index.js';\nimport { findExclusionZones, filterExcludedMatches, type ExclusionZone } from './exclusions.js';\n\n// Wikilink pattern: [[target]] or [[target|display]]\n// Also supports [[id:node-id]] for direct ID references\nconst WIKILINK_REGEX = /\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]/g;\n\n// ID prefix for direct node references\nconst ID_PREFIX = 'id:';\n\nexport interface WikiLinkParseResult {\n  links: WikiLink[];\n  exclusionZones: ExclusionZone[];\n}\n\n/**\n * Extract all wikilinks from content\n */\nexport function extractWikilinks(\n  content: string,\n  contentStartOffset: number = 0\n): WikiLinkParseResult {\n  const exclusionZones = findExclusionZones(content, contentStartOffset);\n  const rawLinks: WikiLink[] = [];\n\n  // Find all wikilinks\n  for (const match of content.matchAll(WIKILINK_REGEX)) {\n    if (match.index === undefined) continue;\n\n    const raw = match[0];\n    const targetPart = match[1]?.trim() ?? '';\n    const displayPart = match[2]?.trim();\n\n    // Check for id: prefix\n    const isIdLink = targetPart.startsWith(ID_PREFIX);\n    const target = isIdLink ? targetPart.slice(ID_PREFIX.length) : targetPart;\n\n    // Display text: explicit > target without id: prefix\n    const display = displayPart ?? target;\n\n    const start = match.index + contentStartOffset;\n    const end = start + raw.length;\n\n    rawLinks.push({\n      raw,\n      target,\n      display,\n      isIdLink,\n      start,\n      end,\n    });\n  }\n\n  // Filter out links that are inside exclusion zones\n  // (but keep the wikilinks themselves as valid - they create new exclusion zones)\n  const links = filterExcludedMatches(\n    rawLinks,\n    exclusionZones.filter((z) => z.type !== 'existing_link')\n  );\n\n  return { links, exclusionZones };\n}\n\n/**\n * Extract link targets only (simplified version)\n */\nexport function extractLinkTargets(content: string): string[] {\n  const { links } = extractWikilinks(content);\n  return links.map((link) => link.target);\n}\n\n/**\n * Check if a string contains wikilinks\n */\nexport function hasWikilinks(content: string): boolean {\n  WIKILINK_REGEX.lastIndex = 0;\n  return WIKILINK_REGEX.test(content);\n}\n\n/**\n * Create a wikilink string\n */\nexport function createWikilink(\n  target: string,\n  display?: string,\n  useIdPrefix: boolean = false\n): string {\n  const targetPart = useIdPrefix ? `id:${target}` : target;\n\n  if (display && display !== target) {\n    return `[[${targetPart}|${display}]]`;\n  }\n\n  return `[[${targetPart}]]`;\n}\n\n/**\n * Replace text with a wikilink at a specific position\n */\nexport function insertWikilink(\n  content: string,\n  start: number,\n  end: number,\n  target: string,\n  display?: string\n): string {\n  const before = content.slice(0, start);\n  const after = content.slice(end);\n  const link = createWikilink(target, display);\n  return before + link + after;\n}\n\n/**\n * Get all unique link targets from content\n */\nexport function getUniqueTargets(content: string): Set<string> {\n  const { links } = extractWikilinks(content);\n  return new Set(links.map((link) => link.target));\n}\n\n/**\n * Normalize a link target for comparison\n * - Trim whitespace\n * - Collapse multiple spaces\n * - Case-insensitive comparison done separately\n */\nexport function normalizeTarget(target: string): string {\n  return target.trim().replace(/\\s+/g, ' ');\n}\n\n/**\n * Check if two link targets match (case-insensitive)\n */\nexport function targetsMatch(target1: string, target2: string): boolean {\n  return normalizeTarget(target1).toLowerCase() === normalizeTarget(target2).toLowerCase();\n}\n\n/**\n * Parse a wikilink string into components\n */\nexport function parseWikilinkString(wikilink: string): WikiLink | null {\n  const match = wikilink.match(/^\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]$/);\n\n  if (!match) return null;\n\n  const targetPart = match[1]?.trim() ?? '';\n  const displayPart = match[2]?.trim();\n\n  const isIdLink = targetPart.startsWith(ID_PREFIX);\n  const target = isIdLink ? targetPart.slice(ID_PREFIX.length) : targetPart;\n  const display = displayPart ?? target;\n\n  return {\n    raw: wikilink,\n    target,\n    display,\n    isIdLink,\n    start: 0,\n    end: wikilink.length,\n  };\n}\n\n// Default context window size (can be overridden via config)\nconst DEFAULT_CONTEXT_CHARS = 50;\n\n/**\n * Get context around a wikilink (surrounding text)\n */\nexport function getWikilinkContext(\n  content: string,\n  link: WikiLink,\n  contextChars: number = DEFAULT_CONTEXT_CHARS\n): string {\n  const start = Math.max(0, link.start - contextChars);\n  const end = Math.min(content.length, link.end + contextChars);\n\n  let context = content.slice(start, end);\n\n  // Add ellipsis if truncated\n  if (start > 0) context = '...' + context;\n  if (end < content.length) context = context + '...';\n\n  return context;\n}\n","import type { WikiLink, ResolvedLink, Node } from '../core/types/index.js';\nimport { normalizeTarget, targetsMatch } from './wikilink.js';\n\nexport interface LinkResolverOptions {\n  /**\n   * Function to find nodes by title (case-insensitive)\n   */\n  findByTitle: (title: string) => Promise<Node[]>;\n\n  /**\n   * Function to find a node by ID\n   */\n  findById: (nodeId: string) => Promise<Node | null>;\n\n  /**\n   * Function to find nodes by title or alias\n   */\n  findByTitleOrAlias: (text: string) => Promise<Node[]>;\n}\n\nexport interface ResolutionResult {\n  resolved: ResolvedLink[];\n  unresolved: WikiLink[];\n  ambiguous: WikiLink[];\n}\n\n/**\n * Link resolver following the spec:\n * 1. If id: prefix  direct node_id lookup\n * 2. Else normalize text:\n *    a. Exact title match (case-insensitive)\n *    b. Alias match\n * 3. Multiple matches  ambiguous (prompt user)\n * 4. No matches  unresolved (record separately)\n */\nexport class LinkResolver {\n  private cache: Map<string, Node[]> = new Map();\n\n  constructor(private options: LinkResolverOptions) {}\n\n  /**\n   * Resolve a single wikilink\n   */\n  async resolveLink(link: WikiLink): Promise<ResolvedLink> {\n    // Case 1: Direct ID reference\n    if (link.isIdLink) {\n      const node = await this.options.findById(link.target);\n      return {\n        ...link,\n        resolvedNodeId: node?.nodeId ?? null,\n        ambiguous: false,\n        candidates: node ? [node.nodeId] : [],\n      };\n    }\n\n    // Case 2: Title/alias resolution\n    const normalizedTarget = normalizeTarget(link.target);\n\n    // Check cache first\n    let candidates = this.cache.get(normalizedTarget.toLowerCase());\n\n    if (!candidates) {\n      // Find by title or alias\n      candidates = await this.options.findByTitleOrAlias(normalizedTarget);\n      this.cache.set(normalizedTarget.toLowerCase(), candidates);\n    }\n\n    if (candidates.length === 0) {\n      // No matches - unresolved\n      return {\n        ...link,\n        resolvedNodeId: null,\n        ambiguous: false,\n        candidates: [],\n      };\n    }\n\n    if (candidates.length === 1) {\n      // Single match - resolved\n      return {\n        ...link,\n        resolvedNodeId: candidates[0]?.nodeId ?? null,\n        ambiguous: false,\n        candidates: [candidates[0]?.nodeId ?? ''],\n      };\n    }\n\n    // Multiple matches - ambiguous\n    // Try to disambiguate by exact title match\n    const exactMatch = candidates.find((c) => targetsMatch(c.title, normalizedTarget));\n\n    if (exactMatch) {\n      return {\n        ...link,\n        resolvedNodeId: exactMatch.nodeId,\n        ambiguous: false,\n        candidates: candidates.map((c) => c.nodeId),\n      };\n    }\n\n    // Still ambiguous\n    return {\n      ...link,\n      resolvedNodeId: null,\n      ambiguous: true,\n      candidates: candidates.map((c) => c.nodeId),\n    };\n  }\n\n  /**\n   * Resolve multiple wikilinks\n   */\n  async resolveLinks(links: WikiLink[]): Promise<ResolutionResult> {\n    const resolved: ResolvedLink[] = [];\n    const unresolved: WikiLink[] = [];\n    const ambiguous: WikiLink[] = [];\n\n    for (const link of links) {\n      const result = await this.resolveLink(link);\n\n      if (result.ambiguous) {\n        ambiguous.push(link);\n      } else if (result.resolvedNodeId === null) {\n        unresolved.push(link);\n      }\n\n      resolved.push(result);\n    }\n\n    return { resolved, unresolved, ambiguous };\n  }\n\n  /**\n   * Clear the resolution cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; hits: number } {\n    return {\n      size: this.cache.size,\n      hits: 0, // Would need to track this separately\n    };\n  }\n}\n\n/**\n * Create a link resolver with repository functions\n */\nexport function createLinkResolver(nodeRepository: {\n  findByTitle: (title: string) => Promise<Node[]>;\n  findById: (nodeId: string) => Promise<Node | null>;\n  findByTitleOrAlias: (text: string) => Promise<Node[]>;\n}): LinkResolver {\n  return new LinkResolver({\n    findByTitle: nodeRepository.findByTitle.bind(nodeRepository),\n    findById: nodeRepository.findById.bind(nodeRepository),\n    findByTitleOrAlias: nodeRepository.findByTitleOrAlias.bind(nodeRepository),\n  });\n}\n\n/**\n * Simple in-memory resolver for testing or single-file parsing\n */\nexport class InMemoryLinkResolver {\n  private nodesByTitle: Map<string, Node[]> = new Map();\n  private nodesById: Map<string, Node> = new Map();\n  private nodesByAlias: Map<string, Node[]> = new Map();\n\n  /**\n   * Add a node to the resolver\n   */\n  addNode(node: Node, aliases: string[] = []): void {\n    this.nodesById.set(node.nodeId, node);\n\n    // Index by title\n    const titleLower = node.title.toLowerCase();\n    const titleNodes = this.nodesByTitle.get(titleLower) || [];\n    titleNodes.push(node);\n    this.nodesByTitle.set(titleLower, titleNodes);\n\n    // Index by aliases\n    for (const alias of aliases) {\n      const aliasLower = alias.toLowerCase();\n      const aliasNodes = this.nodesByAlias.get(aliasLower) || [];\n      aliasNodes.push(node);\n      this.nodesByAlias.set(aliasLower, aliasNodes);\n    }\n  }\n\n  /**\n   * Resolve a wikilink\n   */\n  resolveLink(link: WikiLink): ResolvedLink {\n    // Case 1: Direct ID reference\n    if (link.isIdLink) {\n      const node = this.nodesById.get(link.target);\n      return {\n        ...link,\n        resolvedNodeId: node?.nodeId ?? null,\n        ambiguous: false,\n        candidates: node ? [node.nodeId] : [],\n      };\n    }\n\n    // Case 2: Title/alias resolution\n    const normalized = normalizeTarget(link.target).toLowerCase();\n\n    // Find by title\n    const titleMatches = this.nodesByTitle.get(normalized) || [];\n\n    // Find by alias\n    const aliasMatches = this.nodesByAlias.get(normalized) || [];\n\n    // Combine and deduplicate\n    const candidateMap = new Map<string, Node>();\n    for (const node of [...titleMatches, ...aliasMatches]) {\n      candidateMap.set(node.nodeId, node);\n    }\n\n    const candidates = Array.from(candidateMap.values());\n\n    if (candidates.length === 0) {\n      return {\n        ...link,\n        resolvedNodeId: null,\n        ambiguous: false,\n        candidates: [],\n      };\n    }\n\n    if (candidates.length === 1) {\n      return {\n        ...link,\n        resolvedNodeId: candidates[0]?.nodeId ?? null,\n        ambiguous: false,\n        candidates: [candidates[0]?.nodeId ?? ''],\n      };\n    }\n\n    // Try exact title match for disambiguation\n    const exactMatch = candidates.find((c) => targetsMatch(c.title, link.target));\n\n    if (exactMatch) {\n      return {\n        ...link,\n        resolvedNodeId: exactMatch.nodeId,\n        ambiguous: false,\n        candidates: candidates.map((c) => c.nodeId),\n      };\n    }\n\n    return {\n      ...link,\n      resolvedNodeId: null,\n      ambiguous: true,\n      candidates: candidates.map((c) => c.nodeId),\n    };\n  }\n\n  /**\n   * Clear all indexed nodes\n   */\n  clear(): void {\n    this.nodesByTitle.clear();\n    this.nodesById.clear();\n    this.nodesByAlias.clear();\n  }\n}\n","import type { Node, Edge, WikiLink, NodeType } from '../core/types/index.js';\nimport { parseMarkdown, type ParsedMarkdown } from '../parser/markdown.js';\nimport { createLinkResolver, type LinkResolver } from '../parser/resolver.js';\nimport type { FileInfo } from '../storage/filesystem/reader.js';\nimport {\n  NodeRepository,\n  EdgeRepository,\n  VersionRepository,\n} from '../storage/database/repositories/index.js';\n\nexport interface IndexingResult {\n  node: Node;\n  links: Array<{\n    wikilink: WikiLink;\n    targetNodeId: string | null;\n    ambiguous: boolean;\n  }>;\n  edges: Edge[];\n  unresolved: WikiLink[];\n  ambiguous: WikiLink[];\n}\n\nexport interface BatchIndexingResult {\n  indexed: IndexingResult[];\n  errors: Array<{ path: string; error: string }>;\n  stats: {\n    totalFiles: number;\n    successCount: number;\n    errorCount: number;\n    nodeCount: number;\n    edgeCount: number;\n    unresolvedCount: number;\n    ambiguousCount: number;\n    durationMs: number;\n  };\n}\n\nexport interface IndexerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  versionRepository: VersionRepository;\n}\n\n/**\n * Main indexing pipeline\n */\nexport class IndexingPipeline {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private versionRepo: VersionRepository;\n  private resolver: LinkResolver | null = null;\n\n  constructor(options: IndexerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.versionRepo = options.versionRepository;\n  }\n\n  /**\n   * Initialize the link resolver\n   */\n  private async getResolver(): Promise<LinkResolver> {\n    if (!this.resolver) {\n      this.resolver = createLinkResolver(this.nodeRepo);\n    }\n    return this.resolver;\n  }\n\n  /**\n   * Clear resolver cache (call after batch operations)\n   */\n  clearResolverCache(): void {\n    if (this.resolver) {\n      this.resolver.clearCache();\n    }\n  }\n\n  /**\n   * Index a single file\n   */\n  async indexFile(file: FileInfo): Promise<IndexingResult> {\n    // Parse the markdown\n    const parsed = parseMarkdown(file.content, file.relativePath);\n\n    // Create or update the node\n    const node = await this.upsertNode(file, parsed);\n\n    // Create version if content changed\n    await this.createVersionIfNeeded(node, file.contentHash);\n\n    // Update aliases\n    await this.nodeRepo.setAliases(node.nodeId, parsed.aliases);\n\n    // Resolve links and create edges\n    const { links, edges, unresolved, ambiguous } = await this.processLinks(node, parsed.links);\n\n    return { node, links, edges, unresolved, ambiguous };\n  }\n\n  /**\n   * Create or update a node from file info\n   */\n  private async upsertNode(file: FileInfo, parsed: ParsedMarkdown): Promise<Node> {\n    const existing = await this.nodeRepo.findByPath(file.relativePath);\n\n    const nodeData = {\n      type: parsed.type as NodeType,\n      title: parsed.title,\n      path: file.relativePath,\n      createdAt: existing?.createdAt || file.stats.createdAt.toISOString(),\n      updatedAt: file.stats.modifiedAt.toISOString(),\n      contentHash: file.contentHash,\n      ...(parsed.frontmatter && { metadata: { ...parsed.frontmatter } }),\n    };\n\n    if (existing) {\n      return this.nodeRepo.update(existing.nodeId, nodeData);\n    }\n\n    return this.nodeRepo.create(nodeData);\n  }\n\n  /**\n   * Create a version entry if content has changed\n   */\n  private async createVersionIfNeeded(node: Node, contentHash: string): Promise<void> {\n    const latestVersion = await this.versionRepo.findLatest(node.nodeId);\n\n    if (latestVersion?.contentHash === contentHash) {\n      return; // No change\n    }\n\n    await this.versionRepo.create({\n      nodeId: node.nodeId,\n      contentHash,\n      ...(latestVersion?.versionId && { parentVersionId: latestVersion.versionId }),\n    });\n  }\n\n  /**\n   * Process wikilinks and create edges\n   */\n  private async processLinks(\n    sourceNode: Node,\n    wikilinks: WikiLink[]\n  ): Promise<{\n    links: IndexingResult['links'];\n    edges: Edge[];\n    unresolved: WikiLink[];\n    ambiguous: WikiLink[];\n  }> {\n    const resolver = await this.getResolver();\n\n    // Delete existing explicit_link edges from this source\n    await this.edgeRepo.deleteBySourceAndType(sourceNode.nodeId, 'explicit_link');\n\n    const links: IndexingResult['links'] = [];\n    const edges: Edge[] = [];\n    const unresolved: WikiLink[] = [];\n    const ambiguous: WikiLink[] = [];\n\n    for (const wikilink of wikilinks) {\n      const resolved = await resolver.resolveLink(wikilink);\n\n      links.push({\n        wikilink,\n        targetNodeId: resolved.resolvedNodeId,\n        ambiguous: resolved.ambiguous,\n      });\n\n      if (resolved.ambiguous) {\n        ambiguous.push(wikilink);\n      } else if (resolved.resolvedNodeId === null) {\n        unresolved.push(wikilink);\n      } else {\n        // Create edge\n        const edge = await this.edgeRepo.create({\n          sourceId: sourceNode.nodeId,\n          targetId: resolved.resolvedNodeId,\n          edgeType: 'explicit_link',\n          provenance: 'explicit',\n          attributes: {\n            displayText: wikilink.display,\n            position: { start: wikilink.start, end: wikilink.end },\n          },\n        });\n        edges.push(edge);\n      }\n    }\n\n    return { links, edges, unresolved, ambiguous };\n  }\n\n  /**\n   * Two-pass batch indexing for handling circular references\n   *\n   * Pass 1: Create all nodes (stubs)\n   * Pass 2: Process links and create edges\n   */\n  async batchIndex(files: FileInfo[]): Promise<BatchIndexingResult> {\n    const startTime = Date.now();\n    const indexed: IndexingResult[] = [];\n    const errors: Array<{ path: string; error: string }> = [];\n\n    // Pass 1: Create/update all nodes\n    const nodeMap = new Map<string, { node: Node; parsed: ParsedMarkdown; file: FileInfo }>();\n\n    for (const file of files) {\n      try {\n        const parsed = parseMarkdown(file.content, file.relativePath);\n        const node = await this.upsertNode(file, parsed);\n        await this.nodeRepo.setAliases(node.nodeId, parsed.aliases);\n        nodeMap.set(file.relativePath, { node, parsed, file });\n      } catch (error) {\n        errors.push({\n          path: file.relativePath,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    // Clear resolver cache before pass 2 (new nodes are now visible)\n    this.clearResolverCache();\n\n    // Pass 2: Process links and create edges\n    let totalEdges = 0;\n    let totalUnresolved = 0;\n    let totalAmbiguous = 0;\n\n    for (const { node, parsed, file } of nodeMap.values()) {\n      try {\n        // Create version\n        await this.createVersionIfNeeded(node, file.contentHash);\n\n        // Process links\n        const { links, edges, unresolved, ambiguous } = await this.processLinks(node, parsed.links);\n\n        indexed.push({ node, links, edges, unresolved, ambiguous });\n        totalEdges += edges.length;\n        totalUnresolved += unresolved.length;\n        totalAmbiguous += ambiguous.length;\n      } catch (error) {\n        errors.push({\n          path: file.relativePath,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    const durationMs = Date.now() - startTime;\n\n    return {\n      indexed,\n      errors,\n      stats: {\n        totalFiles: files.length,\n        successCount: indexed.length,\n        errorCount: errors.length,\n        nodeCount: nodeMap.size,\n        edgeCount: totalEdges,\n        unresolvedCount: totalUnresolved,\n        ambiguousCount: totalAmbiguous,\n        durationMs,\n      },\n    };\n  }\n\n  /**\n   * Remove a node and its edges\n   */\n  async removeNode(nodeId: string): Promise<void> {\n    // Edges will be cascade deleted due to foreign key\n    await this.nodeRepo.delete(nodeId);\n    this.clearResolverCache();\n  }\n\n  /**\n   * Remove a node by path\n   */\n  async removeByPath(path: string): Promise<void> {\n    const node = await this.nodeRepo.findByPath(path);\n    if (node) {\n      await this.removeNode(node.nodeId);\n    }\n  }\n\n  /**\n   * Check if a file needs reindexing\n   */\n  async needsReindex(file: FileInfo): Promise<boolean> {\n    const node = await this.nodeRepo.findByPath(file.relativePath);\n\n    if (!node) {\n      return true; // New file\n    }\n\n    return node.contentHash !== file.contentHash;\n  }\n\n  /**\n   * Get indexing statistics\n   */\n  async getStats(): Promise<{\n    nodeCount: number;\n    edgeCount: number;\n    nodesByType: Record<string, number>;\n    edgesByType: Record<string, number>;\n  }> {\n    const [nodeCount, edgeCount, nodesByType, edgesByType] = await Promise.all([\n      this.nodeRepo.count(),\n      this.edgeRepo.count(),\n      this.nodeRepo.countByType(),\n      this.edgeRepo.countByType(),\n    ]);\n\n    return { nodeCount, edgeCount, nodesByType, edgesByType };\n  }\n}\n","import type { Edge, EdgeType } from '../types/index.js';\n\n/**\n * Result of a path search\n */\nexport interface PathResult {\n  path: string[]; // Node IDs\n  edges: EdgeType[]; // Length = path.length - 1\n  hopCount: number;\n  score: number;\n}\n\n/**\n * Options for K-shortest paths search\n */\nexport interface KShortestPathsOptions {\n  k?: number; // Default: 3\n  edgeTypes?: EdgeType[]; // Default: explicit_link, sequence, causes, semantic\n  maxDepth?: number; // Default: 15\n  overlapThreshold?: number; // Default: 0.7 (max allowed Jaccard overlap)\n  maxCandidates?: number; // Default: 100\n  maxExtraHops?: number; // Default: 2\n}\n\n/**\n * Edge penalties for cosmetic scoring (lower = preferred)\n */\nconst EDGE_PENALTIES: Record<string, number> = {\n  explicit_link: 0,\n  sequence: 0.1,\n  causes: 0.2,\n  semantic: 0.3,\n  semantic_suggestion: 0.5,\n};\n\n/**\n * Default edge penalty for unknown types\n */\nconst DEFAULT_EDGE_PENALTY = 0.3;\n\n/**\n * Adjacency list entry\n */\ninterface AdjEntry {\n  nodeId: string;\n  edgeType: EdgeType;\n}\n\n/**\n * Build adjacency lists from edges\n */\nexport function buildAdjacencyLists(\n  edges: Edge[],\n  edgeTypes?: EdgeType[]\n): {\n  forward: Map<string, AdjEntry[]>;\n  backward: Map<string, AdjEntry[]>;\n} {\n  const forward = new Map<string, AdjEntry[]>();\n  const backward = new Map<string, AdjEntry[]>();\n  const typeSet = edgeTypes ? new Set(edgeTypes) : null;\n\n  for (const edge of edges) {\n    if (typeSet && !typeSet.has(edge.edgeType)) continue;\n\n    // Forward adjacency (source -> target)\n    if (!forward.has(edge.sourceId)) {\n      forward.set(edge.sourceId, []);\n    }\n    forward.get(edge.sourceId)!.push({\n      nodeId: edge.targetId,\n      edgeType: edge.edgeType,\n    });\n\n    // Backward adjacency (target -> source)\n    if (!backward.has(edge.targetId)) {\n      backward.set(edge.targetId, []);\n    }\n    backward.get(edge.targetId)!.push({\n      nodeId: edge.sourceId,\n      edgeType: edge.edgeType,\n    });\n  }\n\n  return { forward, backward };\n}\n\n/**\n * Bidirectional BFS to find shortest path\n *\n * Key insight: Don't stop at first meeting. Track bestDistance and continue\n * until both frontiers exceed it.\n */\nexport function bidirectionalBFS(\n  startId: string,\n  endId: string,\n  forward: Map<string, AdjEntry[]>,\n  backward: Map<string, AdjEntry[]>,\n  maxDepth: number,\n  disabledEdges?: Set<string>, // Set of \"sourceId->targetId\" strings\n  disabledNodes?: Set<string>\n): { path: string[]; edges: EdgeType[] } | null {\n  if (startId === endId) {\n    return { path: [startId], edges: [] };\n  }\n\n  // Check if start/end are disabled\n  if (disabledNodes?.has(startId) || disabledNodes?.has(endId)) {\n    return null;\n  }\n\n  // Forward search state (from start)\n  const forwardVisited = new Map<string, { parent: string | null; edgeType: EdgeType | null }>();\n  forwardVisited.set(startId, { parent: null, edgeType: null });\n  let forwardQueue: string[] = [startId];\n  let forwardDepth = 0;\n\n  // Backward search state (from end)\n  const backwardVisited = new Map<string, { parent: string | null; edgeType: EdgeType | null }>();\n  backwardVisited.set(endId, { parent: null, edgeType: null });\n  let backwardQueue: string[] = [endId];\n  let backwardDepth = 0;\n\n  let bestDistance = Infinity;\n  let meetingNode: string | null = null;\n\n  while (\n    (forwardQueue.length > 0 || backwardQueue.length > 0) &&\n    forwardDepth + backwardDepth < bestDistance\n  ) {\n    // Check depth limit\n    if (forwardDepth + backwardDepth >= maxDepth * 2) break;\n\n    // Expand the smaller frontier\n    const expandForward =\n      forwardQueue.length > 0 &&\n      (backwardQueue.length === 0 || forwardQueue.length <= backwardQueue.length);\n\n    if (expandForward && forwardQueue.length > 0) {\n      const nextQueue: string[] = [];\n      forwardDepth++;\n\n      // Can we possibly find a shorter path?\n      if (forwardDepth > bestDistance) break;\n\n      for (const nodeId of forwardQueue) {\n        const neighbors = forward.get(nodeId) || [];\n\n        for (const { nodeId: neighborId, edgeType } of neighbors) {\n          // Check if edge/node is disabled\n          if (disabledNodes?.has(neighborId)) continue;\n          const edgeKey = `${nodeId}->${neighborId}`;\n          if (disabledEdges?.has(edgeKey)) continue;\n\n          if (!forwardVisited.has(neighborId)) {\n            forwardVisited.set(neighborId, { parent: nodeId, edgeType });\n            nextQueue.push(neighborId);\n\n            // Check for meeting point\n            if (backwardVisited.has(neighborId)) {\n              const totalDist = forwardDepth + backwardDepth;\n              if (totalDist < bestDistance) {\n                bestDistance = totalDist;\n                meetingNode = neighborId;\n              }\n            }\n          }\n        }\n      }\n      forwardQueue = nextQueue;\n    } else if (backwardQueue.length > 0) {\n      const nextQueue: string[] = [];\n      backwardDepth++;\n\n      // Can we possibly find a shorter path?\n      if (backwardDepth > bestDistance) break;\n\n      for (const nodeId of backwardQueue) {\n        const neighbors = backward.get(nodeId) || [];\n\n        for (const { nodeId: neighborId, edgeType } of neighbors) {\n          // Check if edge/node is disabled\n          if (disabledNodes?.has(neighborId)) continue;\n          const edgeKey = `${neighborId}->${nodeId}`;\n          if (disabledEdges?.has(edgeKey)) continue;\n\n          if (!backwardVisited.has(neighborId)) {\n            backwardVisited.set(neighborId, { parent: nodeId, edgeType });\n            nextQueue.push(neighborId);\n\n            // Check for meeting point\n            if (forwardVisited.has(neighborId)) {\n              const totalDist = forwardDepth + backwardDepth;\n              if (totalDist < bestDistance) {\n                bestDistance = totalDist;\n                meetingNode = neighborId;\n              }\n            }\n          }\n        }\n      }\n      backwardQueue = nextQueue;\n    } else {\n      break;\n    }\n  }\n\n  if (!meetingNode) {\n    return null;\n  }\n\n  // Reconstruct path from start to meeting point\n  const pathToMeeting: string[] = [];\n  const edgesToMeeting: EdgeType[] = [];\n  let current: string | null = meetingNode;\n\n  while (current !== null) {\n    pathToMeeting.unshift(current);\n    const info = forwardVisited.get(current);\n    if (info?.edgeType) {\n      edgesToMeeting.unshift(info.edgeType);\n    }\n    current = info?.parent ?? null;\n  }\n\n  // Reconstruct path from meeting point to end\n  const pathFromMeeting: string[] = [];\n  const edgesFromMeeting: EdgeType[] = [];\n  current = backwardVisited.get(meetingNode)?.parent ?? null;\n\n  while (current !== null) {\n    pathFromMeeting.push(current);\n    const info = backwardVisited.get(current);\n    // Edge type is stored in child pointing to parent\n    const prevNode: string =\n      pathFromMeeting.length > 1 ? pathFromMeeting[pathFromMeeting.length - 2]! : meetingNode;\n    const prevInfo = backwardVisited.get(prevNode);\n    if (prevInfo?.edgeType) {\n      edgesFromMeeting.push(prevInfo.edgeType);\n    }\n    current = info?.parent ?? null;\n  }\n\n  const path = [...pathToMeeting, ...pathFromMeeting];\n  const edges = [...edgesToMeeting, ...edgesFromMeeting];\n\n  return { path, edges };\n}\n\n/**\n * Calculate Jaccard overlap between two paths\n * Optionally excludes endpoints for short paths\n */\nexport function calculateJaccardOverlap(\n  pathA: string[],\n  pathB: string[],\n  excludeEndpoints: boolean = false\n): number {\n  let nodesA = new Set(pathA);\n  let nodesB = new Set(pathB);\n\n  if (excludeEndpoints && pathA.length >= 2 && pathB.length >= 2) {\n    // Exclude first and last nodes\n    nodesA = new Set(pathA.slice(1, -1));\n    nodesB = new Set(pathB.slice(1, -1));\n  }\n\n  if (nodesA.size === 0 && nodesB.size === 0) {\n    // Both have no intermediate nodes, consider as 100% overlap\n    return 1.0;\n  }\n\n  const intersection = new Set([...nodesA].filter((x) => nodesB.has(x)));\n  const union = new Set([...nodesA, ...nodesB]);\n\n  if (union.size === 0) return 1.0;\n\n  return intersection.size / union.size;\n}\n\n/**\n * Calculate cosmetic score for a path\n * score = hopCount + sum of edge penalties\n */\nexport function calculatePathScore(edges: EdgeType[]): number {\n  const hopCount = edges.length;\n  let penalty = 0;\n\n  for (const edgeType of edges) {\n    penalty += EDGE_PENALTIES[edgeType] ?? DEFAULT_EDGE_PENALTY;\n  }\n\n  return hopCount + penalty;\n}\n\n/**\n * Check if a path is simple (no repeated nodes)\n */\nexport function isSimplePath(path: string[]): boolean {\n  const seen = new Set<string>();\n  for (const nodeId of path) {\n    if (seen.has(nodeId)) return false;\n    seen.add(nodeId);\n  }\n  return true;\n}\n\n/**\n * Yen's K-Shortest Paths algorithm with diversity filtering\n *\n * Algorithm:\n * 1. Find shortest path first\n * 2. For each spur node, temporarily remove edges to force deviation\n * 3. Find shortest path through spur node\n * 4. Add to candidate heap\n * 5. Filter by diversity (Jaccard overlap)\n */\nexport function findKShortestPaths(\n  startId: string,\n  endId: string,\n  edges: Edge[],\n  options: KShortestPathsOptions = {}\n): { paths: PathResult[]; reason: string } {\n  const {\n    k = 3,\n    edgeTypes = ['explicit_link', 'sequence', 'causes', 'semantic'] as EdgeType[],\n    maxDepth = 15,\n    overlapThreshold = 0.7,\n    maxCandidates = 100,\n    maxExtraHops = 2,\n  } = options;\n\n  // Build adjacency lists\n  const { forward, backward } = buildAdjacencyLists(edges, edgeTypes);\n\n  // Find the first (shortest) path\n  const firstResult = bidirectionalBFS(startId, endId, forward, backward, maxDepth);\n\n  if (!firstResult) {\n    return { paths: [], reason: 'no_path' };\n  }\n\n  const shortestHopCount = firstResult.path.length - 1;\n  const maxAllowedHops = shortestHopCount + maxExtraHops;\n\n  // Result paths\n  const results: PathResult[] = [\n    {\n      path: firstResult.path,\n      edges: firstResult.edges,\n      hopCount: shortestHopCount,\n      score: calculatePathScore(firstResult.edges),\n    },\n  ];\n\n  // Candidate heap: [score, path, edges]\n  // We use an array and sort as needed (small heap)\n  const candidates: Array<{ path: string[]; edges: EdgeType[]; score: number }> = [];\n  const seenPaths = new Set<string>([firstResult.path.join('|')]);\n\n  // Yen's algorithm: iterate over accepted paths\n  for (let i = 0; i < results.length && results.length < k; i++) {\n    const resultItem = results[i]!;\n    const currentPath = resultItem.path;\n\n    // For each spur node (except the last)\n    for (let spurIndex = 0; spurIndex < currentPath.length - 1; spurIndex++) {\n      const spurNode = currentPath[spurIndex]!;\n      const rootPath = currentPath.slice(0, spurIndex + 1);\n      const rootEdges = resultItem.edges.slice(0, spurIndex);\n\n      // Disable edges used by paths that share the same root\n      const disabledEdges = new Set<string>();\n      const disabledNodes = new Set<string>();\n\n      for (const result of results) {\n        if (result.path.length > spurIndex) {\n          // Check if root matches\n          const matchesRoot = rootPath.every((node, idx) => result.path[idx] === node);\n          if (matchesRoot && spurIndex < result.path.length - 1) {\n            // Disable the edge leaving the spur node in this path\n            const edgeKey = `${result.path[spurIndex]}->${result.path[spurIndex + 1]}`;\n            disabledEdges.add(edgeKey);\n          }\n        }\n      }\n\n      // Also disable nodes in root path (except spur node) to prevent cycles\n      for (let j = 0; j < rootPath.length - 1; j++) {\n        const nodeToDisable = rootPath[j];\n        if (nodeToDisable) {\n          disabledNodes.add(nodeToDisable);\n        }\n      }\n\n      // Find spur path from spurNode to end\n      const spurResult = bidirectionalBFS(\n        spurNode,\n        endId,\n        forward,\n        backward,\n        maxDepth - spurIndex,\n        disabledEdges,\n        disabledNodes\n      );\n\n      if (spurResult && spurResult.path.length > 1) {\n        // Combine root + spur (skip duplicate spur node)\n        const totalPath = [...rootPath.slice(0, -1), ...spurResult.path];\n        const totalEdges = [...rootEdges, ...spurResult.edges];\n        const pathKey = totalPath.join('|');\n\n        // Check if path is valid\n        if (\n          !seenPaths.has(pathKey) &&\n          isSimplePath(totalPath) &&\n          totalPath.length - 1 <= maxAllowedHops\n        ) {\n          seenPaths.add(pathKey);\n          candidates.push({\n            path: totalPath,\n            edges: totalEdges,\n            score: calculatePathScore(totalEdges),\n          });\n        }\n      }\n\n      // Cap candidates\n      if (candidates.length > maxCandidates) {\n        // Sort and trim\n        candidates.sort((a, b) => {\n          // Primary: hop count ascending\n          const hopDiff = a.path.length - 1 - (b.path.length - 1);\n          if (hopDiff !== 0) return hopDiff;\n          // Secondary: score ascending\n          const scoreDiff = a.score - b.score;\n          if (scoreDiff !== 0) return scoreDiff;\n          // Tertiary: lexical\n          return a.path.join('|').localeCompare(b.path.join('|'));\n        });\n        candidates.length = maxCandidates;\n      }\n    }\n\n    // Try to add the best candidate that passes diversity check\n    if (candidates.length > 0) {\n      // Sort candidates\n      candidates.sort((a, b) => {\n        const hopDiff = a.path.length - 1 - (b.path.length - 1);\n        if (hopDiff !== 0) return hopDiff;\n        const scoreDiff = a.score - b.score;\n        if (scoreDiff !== 0) return scoreDiff;\n        return a.path.join('|').localeCompare(b.path.join('|'));\n      });\n\n      // Find first candidate that passes diversity check\n      let addedIndex = -1;\n      for (let j = 0; j < candidates.length; j++) {\n        const candidate = candidates[j]!;\n\n        // Check diversity against all accepted paths\n        let tooSimilar = false;\n        for (const accepted of results) {\n          const overlap = calculateJaccardOverlap(\n            candidate.path,\n            accepted.path,\n            candidate.path.length <= 4 || accepted.path.length <= 4\n          );\n          if (overlap > overlapThreshold) {\n            tooSimilar = true;\n            break;\n          }\n        }\n\n        if (!tooSimilar) {\n          results.push({\n            path: candidate.path,\n            edges: candidate.edges,\n            hopCount: candidate.path.length - 1,\n            score: candidate.score,\n          });\n          addedIndex = j;\n          break;\n        }\n      }\n\n      // Remove added candidate\n      if (addedIndex >= 0) {\n        candidates.splice(addedIndex, 1);\n      }\n    }\n  }\n\n  // Determine reason for stopping\n  let reason = 'found_all';\n  if (results.length < k) {\n    if (candidates.length === 0) {\n      reason = 'exhausted_candidates';\n    } else {\n      reason = 'diversity_filter';\n    }\n  }\n\n  return { paths: results, reason };\n}\n\n/**\n * Simple BFS for shortest path (for use in GraphEngine)\n * Uses in-memory adjacency for efficiency\n */\nexport function simpleBFS(\n  startId: string,\n  endId: string,\n  forward: Map<string, AdjEntry[]>,\n  maxDepth: number = 15\n): string[] | null {\n  if (startId === endId) return [startId];\n\n  const visited = new Map<string, string | null>();\n  visited.set(startId, null);\n  let queue = [startId];\n  let depth = 0;\n\n  while (queue.length > 0 && depth < maxDepth) {\n    const nextQueue: string[] = [];\n    depth++;\n\n    for (const nodeId of queue) {\n      const neighbors = forward.get(nodeId) || [];\n\n      for (const { nodeId: neighborId } of neighbors) {\n        if (neighborId === endId) {\n          // Reconstruct path\n          const path: string[] = [endId, nodeId];\n          let current = nodeId;\n          while (visited.get(current) !== null) {\n            current = visited.get(current)!;\n            path.push(current);\n          }\n          return path.reverse();\n        }\n\n        if (!visited.has(neighborId)) {\n          visited.set(neighborId, nodeId);\n          nextQueue.push(neighborId);\n        }\n      }\n    }\n\n    queue = nextQueue;\n  }\n\n  return null;\n}\n","import type {\n  Node,\n  Edge,\n  EdgeType,\n  BacklinkResult,\n  NeighborResult,\n  TraversalResult,\n  ZettelScriptConfig,\n} from '../types/index.js';\nimport { DEFAULT_CONFIG } from '../types/index.js';\nimport { NodeRepository, EdgeRepository } from '../../storage/database/repositories/index.js';\nimport {\n  type PathResult,\n  type KShortestPathsOptions,\n  findKShortestPaths as findKShortestPathsImpl,\n  buildAdjacencyLists,\n  simpleBFS,\n} from './pathfinder.js';\n\nexport interface GraphEngineOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Graph engine for traversal, queries, and analytics\n */\nexport class GraphEngine {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private config: ZettelScriptConfig;\n\n  constructor(options: GraphEngineOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.config = options.config ?? DEFAULT_CONFIG;\n  }\n\n  // ============================================================================\n  // Node Operations\n  // ============================================================================\n\n  async getNode(nodeId: string): Promise<Node | null> {\n    return this.nodeRepo.findById(nodeId);\n  }\n\n  async getNodeByPath(path: string): Promise<Node | null> {\n    return this.nodeRepo.findByPath(path);\n  }\n\n  async getNodeByTitle(title: string): Promise<Node[]> {\n    return this.nodeRepo.findByTitle(title);\n  }\n\n  async getAllNodes(): Promise<Node[]> {\n    return this.nodeRepo.findAll();\n  }\n\n  // ============================================================================\n  // Edge Operations\n  // ============================================================================\n\n  async getEdge(edgeId: string): Promise<Edge | null> {\n    return this.edgeRepo.findById(edgeId);\n  }\n\n  async getOutgoingEdges(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    return this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n  }\n\n  async getIncomingEdges(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    return this.edgeRepo.findIncoming(nodeId, edgeTypes);\n  }\n\n  // ============================================================================\n  // Backlinks (Spec 6.2)\n  // ============================================================================\n\n  /**\n   * Get backlinks for a node\n   * backlinks(node) = { edge.source_id | edge.edge_type == 'explicit_link' AND edge.target_id == node }\n   */\n  async getBacklinks(nodeId: string): Promise<BacklinkResult[]> {\n    const edges = await this.edgeRepo.findBacklinks(nodeId);\n\n    if (edges.length === 0) return [];\n\n    const sourceIds = edges.map((e) => e.sourceId);\n    const sourceNodes = await this.nodeRepo.findByIds(sourceIds);\n    const nodeMap = new Map(sourceNodes.map((n) => [n.nodeId, n]));\n\n    const results: BacklinkResult[] = [];\n    for (const edge of edges) {\n      const sourceNode = nodeMap.get(edge.sourceId);\n      if (sourceNode) {\n        results.push({\n          sourceNode,\n          edge,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Count backlinks for a node\n   */\n  async countBacklinks(nodeId: string): Promise<number> {\n    const edges = await this.edgeRepo.findBacklinks(nodeId);\n    return edges.length;\n  }\n\n  // ============================================================================\n  // Neighbors\n  // ============================================================================\n\n  /**\n   * Get all neighbors of a node (both directions)\n   */\n  async getNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<NeighborResult[]> {\n    const neighborsWithNodes = await this.edgeRepo.findNeighborsWithNodes(nodeId, edgeTypes);\n\n    return neighborsWithNodes.map(({ edge, node, direction }) => ({\n      node: {\n        nodeId: node.nodeId,\n        title: node.title,\n        type: node.type as Node['type'],\n        path: node.path,\n        createdAt: '',\n        updatedAt: '',\n      },\n      edge,\n      direction,\n    }));\n  }\n\n  /**\n   * Get outgoing neighbors\n   */\n  async getOutgoingNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<Node[]> {\n    const edges = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n    if (edges.length === 0) return [];\n\n    const targetIds = edges.map((e) => e.targetId);\n    return this.nodeRepo.findByIds(targetIds);\n  }\n\n  /**\n   * Get incoming neighbors\n   */\n  async getIncomingNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<Node[]> {\n    const edges = await this.edgeRepo.findIncoming(nodeId, edgeTypes);\n\n    if (edges.length === 0) return [];\n\n    const sourceIds = edges.map((e) => e.sourceId);\n    return this.nodeRepo.findByIds(sourceIds);\n  }\n\n  // ============================================================================\n  // Bounded Graph Traversal (Spec 7.3)\n  // ============================================================================\n\n  /**\n   * Bounded graph expansion from seed nodes\n   *\n   * Algorithm:\n   * frontier = seed_nodes\n   * for depth in 1..max_depth:\n   *     if visited_count >= budget: break\n   *     for node in frontier:\n   *         for edge in outgoing_edges(node, allowed_types):\n   *             score = current_score * edge_weight * decay^depth\n   *             accumulated_scores[edge.target] = max(existing, score)\n   *     frontier = newly_discovered_nodes\n   */\n  async expandGraph(options: {\n    seedNodes: Array<{ nodeId: string; score: number }>;\n    maxDepth?: number;\n    budget?: number;\n    edgeTypes?: EdgeType[];\n    decayFactor?: number;\n    includeIncoming?: boolean;\n  }): Promise<TraversalResult[]> {\n    const {\n      seedNodes,\n      maxDepth = this.config.graph.defaultMaxDepth,\n      budget = this.config.graph.defaultBudget,\n      edgeTypes = ['explicit_link', 'sequence', 'hierarchy'],\n      decayFactor = this.config.graph.decayFactor,\n      includeIncoming = false,\n    } = options;\n\n    if (seedNodes.length === 0) return [];\n\n    // Track scores and paths\n    const scores = new Map<string, number>();\n    const paths = new Map<string, string[]>();\n    const depths = new Map<string, number>();\n\n    // Initialize with seed nodes\n    let frontier = new Set<string>();\n    for (const seed of seedNodes) {\n      scores.set(seed.nodeId, seed.score);\n      paths.set(seed.nodeId, [seed.nodeId]);\n      depths.set(seed.nodeId, 0);\n      frontier.add(seed.nodeId);\n    }\n\n    const visited = new Set<string>(frontier);\n\n    // BFS with decay\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (visited.size >= budget) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (visited.size >= budget) break;\n\n        const currentScore = scores.get(nodeId) ?? 0;\n        const currentPath = paths.get(nodeId) ?? [];\n\n        // Get outgoing edges\n        const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n        // Optionally include incoming edges\n        const incoming = includeIncoming ? await this.edgeRepo.findIncoming(nodeId, edgeTypes) : [];\n\n        const allEdges = [...outgoing, ...incoming];\n\n        for (const edge of allEdges) {\n          if (visited.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Calculate new score with decay\n          const edgeWeight = edge.strength ?? 1.0;\n          const newScore = currentScore * edgeWeight * Math.pow(decayFactor, depth);\n\n          // Update if new score is better\n          const existingScore = scores.get(targetId) ?? 0;\n          if (newScore > existingScore) {\n            scores.set(targetId, newScore);\n            paths.set(targetId, [...currentPath, targetId]);\n            depths.set(targetId, depth);\n          }\n\n          if (!visited.has(targetId)) {\n            visited.add(targetId);\n            newFrontier.add(targetId);\n          }\n        }\n      }\n\n      frontier = newFrontier;\n\n      if (frontier.size === 0) break;\n    }\n\n    // Build results sorted by score\n    const results: TraversalResult[] = [];\n    for (const [nodeId, score] of scores) {\n      results.push({\n        nodeId,\n        depth: depths.get(nodeId) ?? 0,\n        score,\n        path: paths.get(nodeId) ?? [],\n      });\n    }\n\n    return results.sort((a, b) => b.score - a.score);\n  }\n\n  // ============================================================================\n  // Path Finding\n  // ============================================================================\n\n  /**\n   * Find shortest path between two nodes using optimized BFS\n   */\n  async findShortestPath(\n    startId: string,\n    endId: string,\n    edgeTypes?: EdgeType[]\n  ): Promise<string[] | null> {\n    if (startId === endId) return [startId];\n\n    // Fetch all relevant edges and build adjacency list in memory\n    const edges = await this.edgeRepo.findAll(edgeTypes);\n    const { forward } = buildAdjacencyLists(edges, edgeTypes);\n\n    return simpleBFS(startId, endId, forward, this.config.graph.defaultMaxDepth * 5);\n  }\n\n  /**\n   * Find K shortest diverse paths between two nodes\n   *\n   * Uses Yen's algorithm with Jaccard diversity filtering.\n   *\n   * @param startId - Starting node ID\n   * @param endId - Ending node ID\n   * @param options - Search options\n   * @returns Array of path results and reason for stopping\n   */\n  async findKShortestPaths(\n    startId: string,\n    endId: string,\n    options?: KShortestPathsOptions\n  ): Promise<{ paths: PathResult[]; reason: string }> {\n    const edgeTypes =\n      options?.edgeTypes ?? (['explicit_link', 'sequence', 'causes', 'semantic'] as EdgeType[]);\n\n    // Fetch all relevant edges\n    const edges = await this.edgeRepo.findAll(edgeTypes);\n\n    return findKShortestPathsImpl(startId, endId, edges, options);\n  }\n\n  /**\n   * Check if two nodes are connected\n   */\n  async areConnected(\n    nodeId1: string,\n    nodeId2: string,\n    edgeTypes?: EdgeType[],\n    maxDepth?: number\n  ): Promise<boolean> {\n    const depth = maxDepth ?? this.config.graph.defaultMaxDepth;\n    const result = await this.expandGraph({\n      seedNodes: [{ nodeId: nodeId1, score: 1 }],\n      maxDepth: depth,\n      budget: 1000,\n      ...(edgeTypes && { edgeTypes }),\n    });\n\n    return result.some((r) => r.nodeId === nodeId2);\n  }\n\n  // ============================================================================\n  // Subgraph Extraction\n  // ============================================================================\n\n  /**\n   * Extract a subgraph around a node\n   */\n  async extractSubgraph(\n    centerNodeId: string,\n    radius: number = 2,\n    edgeTypes?: EdgeType[]\n  ): Promise<{ nodes: Node[]; edges: Edge[] }> {\n    const traversal = await this.expandGraph({\n      seedNodes: [{ nodeId: centerNodeId, score: 1 }],\n      maxDepth: radius,\n      budget: 100,\n      ...(edgeTypes && { edgeTypes }),\n      includeIncoming: true,\n    });\n\n    const nodeIds = traversal.map((t) => t.nodeId);\n    const nodes = await this.nodeRepo.findByIds(nodeIds);\n\n    // Get all edges between these nodes\n    const nodeIdSet = new Set(nodeIds);\n    const edges: Edge[] = [];\n\n    for (const nodeId of nodeIds) {\n      const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n      for (const edge of outgoing) {\n        if (nodeIdSet.has(edge.targetId)) {\n          edges.push(edge);\n        }\n      }\n    }\n\n    return { nodes, edges };\n  }\n\n  // ============================================================================\n  // Graph Statistics\n  // ============================================================================\n\n  /**\n   * Calculate degree for a node\n   */\n  async getDegree(nodeId: string): Promise<{\n    in: number;\n    out: number;\n    total: number;\n  }> {\n    const incoming = await this.edgeRepo.findIncoming(nodeId);\n    const outgoing = await this.edgeRepo.findOutgoing(nodeId);\n\n    return {\n      in: incoming.length,\n      out: outgoing.length,\n      total: incoming.length + outgoing.length,\n    };\n  }\n\n  /**\n   * Find isolated nodes (no edges)\n   */\n  async findIsolatedNodes(): Promise<Node[]> {\n    const allNodes = await this.nodeRepo.findAll();\n    const isolated: Node[] = [];\n\n    for (const node of allNodes) {\n      const edges = await this.edgeRepo.findConnected(node.nodeId);\n      if (edges.length === 0) {\n        isolated.push(node);\n      }\n    }\n\n    return isolated;\n  }\n\n  /**\n   * Find nodes with high in-degree (potential hubs)\n   */\n  async findHighInDegreeNodes(threshold?: number): Promise<\n    Array<{\n      node: Node;\n      inDegree: number;\n    }>\n  > {\n    const minThreshold = threshold ?? this.config.moc?.defaultHubThreshold ?? 5;\n    const allNodes = await this.nodeRepo.findAll();\n    const results: Array<{ node: Node; inDegree: number }> = [];\n\n    for (const node of allNodes) {\n      const incoming = await this.edgeRepo.findIncoming(node.nodeId);\n      if (incoming.length >= minThreshold) {\n        results.push({ node, inDegree: incoming.length });\n      }\n    }\n\n    return results.sort((a, b) => b.inDegree - a.inDegree);\n  }\n\n  // ============================================================================\n  // Connected Components\n  // ============================================================================\n\n  /**\n   * Find connected components in the graph\n   */\n  async findConnectedComponents(): Promise<string[][]> {\n    const allNodes = await this.nodeRepo.findAll();\n    const visited = new Set<string>();\n    const components: string[][] = [];\n\n    for (const node of allNodes) {\n      if (visited.has(node.nodeId)) continue;\n\n      // BFS to find all connected nodes\n      const component: string[] = [];\n      const queue = [node.nodeId];\n\n      while (queue.length > 0) {\n        const currentId = queue.shift();\n        if (!currentId || visited.has(currentId)) continue;\n\n        visited.add(currentId);\n        component.push(currentId);\n\n        // Get all connected nodes (both directions)\n        const edges = await this.edgeRepo.findConnected(currentId);\n        for (const edge of edges) {\n          const neighborId = edge.sourceId === currentId ? edge.targetId : edge.sourceId;\n          if (!visited.has(neighborId)) {\n            queue.push(neighborId);\n          }\n        }\n      }\n\n      if (component.length > 0) {\n        components.push(component);\n      }\n    }\n\n    // Sort by size (largest first)\n    return components.sort((a, b) => b.length - a.length);\n  }\n\n  /**\n   * Get the component containing a specific node\n   */\n  async getComponentContaining(nodeId: string): Promise<string[]> {\n    const visited = new Set<string>();\n    const component: string[] = [];\n    const queue = [nodeId];\n\n    while (queue.length > 0) {\n      const currentId = queue.shift();\n      if (!currentId || visited.has(currentId)) continue;\n\n      visited.add(currentId);\n      component.push(currentId);\n\n      const edges = await this.edgeRepo.findConnected(currentId);\n      for (const edge of edges) {\n        const neighborId = edge.sourceId === currentId ? edge.targetId : edge.sourceId;\n        if (!visited.has(neighborId)) {\n          queue.push(neighborId);\n        }\n      }\n    }\n\n    return component;\n  }\n}\n","import { Command } from 'commander';\nimport { initContext, formatDuration, Spinner } from '../utils.js';\nimport { fullIndex } from '../../indexer/batch.js';\n\nexport const indexCommand = new Command('index')\n  .description('Index all markdown files in the vault')\n  .option('-v, --verbose', 'Show detailed output')\n  .option('--stats', 'Show indexing statistics')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      console.log(`Indexing vault: ${ctx.vaultPath}`);\n\n      const spinner = new Spinner('Scanning files...');\n      spinner.start();\n\n      let lastProgress = 0;\n      const result = await fullIndex(ctx.pipeline, ctx.vaultPath, {\n        excludePatterns: ctx.config.vault.excludePatterns,\n        onProgress: (current, total, path) => {\n          if (current > lastProgress) {\n            lastProgress = current;\n            spinner.update(`Indexing ${current}/${total}: ${path}`);\n          }\n        },\n      });\n\n      spinner.stop();\n\n      // Summary\n      console.log('\\nIndexing complete:');\n      console.log(`  Files processed: ${result.stats.totalFiles}`);\n      console.log(`  Nodes created:   ${result.stats.nodeCount}`);\n      console.log(`  Edges created:   ${result.stats.edgeCount}`);\n      console.log(`  Unresolved:      ${result.stats.unresolvedCount}`);\n      console.log(`  Ambiguous:       ${result.stats.ambiguousCount}`);\n      console.log(`  Duration:        ${formatDuration(result.stats.durationMs)}`);\n\n      // Show errors if any\n      if (result.errors.length > 0) {\n        console.log(`\\nErrors (${result.errors.length}):`);\n        for (const err of result.errors.slice(0, 10)) {\n          console.log(`  ${err.path}: ${err.error}`);\n        }\n        if (result.errors.length > 10) {\n          console.log(`  ... and ${result.errors.length - 10} more`);\n        }\n      }\n\n      // Show verbose output\n      if (options.verbose) {\n        // Show unresolved links\n        const allUnresolved = result.indexed.flatMap((r) =>\n          r.unresolved.map((u) => ({ path: r.node.path, link: u.target }))\n        );\n        if (allUnresolved.length > 0) {\n          console.log(`\\nUnresolved links (${allUnresolved.length}):`);\n          for (const u of allUnresolved.slice(0, 20)) {\n            console.log(`  ${u.path}: [[${u.link}]]`);\n          }\n          if (allUnresolved.length > 20) {\n            console.log(`  ... and ${allUnresolved.length - 20} more`);\n          }\n        }\n\n        // Show ambiguous links\n        const allAmbiguous = result.indexed.flatMap((r) =>\n          r.ambiguous.map((a) => ({ path: r.node.path, link: a.target }))\n        );\n        if (allAmbiguous.length > 0) {\n          console.log(`\\nAmbiguous links (${allAmbiguous.length}):`);\n          for (const a of allAmbiguous.slice(0, 20)) {\n            console.log(`  ${a.path}: [[${a.link}]]`);\n          }\n          if (allAmbiguous.length > 20) {\n            console.log(`  ... and ${allAmbiguous.length - 20} more`);\n          }\n        }\n      }\n\n      // Show stats\n      if (options.stats) {\n        const stats = await ctx.pipeline.getStats();\n        console.log('\\nGraph statistics:');\n        console.log('  Nodes by type:');\n        for (const [type, count] of Object.entries(stats.nodesByType)) {\n          console.log(`    ${type}: ${count}`);\n        }\n        console.log('  Edges by type:');\n        for (const [type, count] of Object.entries(stats.edgesByType)) {\n          console.log(`    ${type}: ${count}`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Index failed:', error);\n      process.exit(1);\n    }\n  });\n","import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { createHash } from 'node:crypto';\nimport { FileSystemError } from '../../core/errors.js';\nimport { getLogger } from '../../core/logger.js';\n\nexport interface FileInfo {\n  path: string;\n  relativePath: string;\n  content: string;\n  contentHash: string;\n  stats: {\n    size: number;\n    createdAt: Date;\n    modifiedAt: Date;\n  };\n}\n\nexport interface WalkOptions {\n  extensions?: string[];\n  excludePatterns?: string[];\n  maxDepth?: number;\n}\n\nconst DEFAULT_EXTENSIONS = ['.md', '.markdown'];\nconst DEFAULT_EXCLUDE = ['node_modules', '.git', '.zettelscript', '.obsidian', '.vscode', '.idea'];\n\n/**\n * Calculate content hash (SHA-256)\n */\nexport function hashContent(content: string): string {\n  return createHash('sha256').update(content).digest('hex');\n}\n\n/**\n * Read a single file\n */\nexport async function readFile(filePath: string, basePath: string): Promise<FileInfo> {\n  try {\n    const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(basePath, filePath);\n    const relativePath = path.relative(basePath, absolutePath);\n\n    const content = await fs.promises.readFile(absolutePath, 'utf-8');\n    const stats = await fs.promises.stat(absolutePath);\n\n    return {\n      path: absolutePath,\n      relativePath,\n      content,\n      contentHash: hashContent(content),\n      stats: {\n        size: stats.size,\n        createdAt: stats.birthtime,\n        modifiedAt: stats.mtime,\n      },\n    };\n  } catch (error) {\n    throw new FileSystemError(`Failed to read file: ${error}`, filePath);\n  }\n}\n\n/**\n * Check if a path should be excluded\n */\nfunction shouldExclude(relativePath: string, excludePatterns: string[]): boolean {\n  for (const pattern of excludePatterns) {\n    // Simple glob matching\n    if (pattern.includes('*')) {\n      const regex = new RegExp('^' + pattern.replace(/\\*/g, '.*').replace(/\\?/g, '.') + '$');\n      if (regex.test(relativePath)) return true;\n    } else {\n      // Direct match or prefix match\n      if (\n        relativePath === pattern ||\n        relativePath.startsWith(pattern + '/') ||\n        relativePath.startsWith(pattern + '\\\\')\n      ) {\n        return true;\n      }\n\n      // Check if any path segment matches\n      const segments = relativePath.split(/[/\\\\]/);\n      if (segments.some((s) => s === pattern)) return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Walk a directory tree and yield markdown files\n */\nexport async function* walkDirectory(\n  basePath: string,\n  options: WalkOptions = {}\n): AsyncGenerator<FileInfo> {\n  const {\n    extensions = DEFAULT_EXTENSIONS,\n    excludePatterns = DEFAULT_EXCLUDE,\n    maxDepth = Infinity,\n  } = options;\n\n  const logger = getLogger().child('filesystem');\n\n  async function* walk(dir: string, depth: number): AsyncGenerator<FileInfo> {\n    if (depth > maxDepth) return;\n\n    let entries;\n    try {\n      entries = await fs.promises.readdir(dir, { withFileTypes: true });\n    } catch (error) {\n      logger.error(`Error reading directory ${dir}: ${error}`);\n      return;\n    }\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      const relativePath = path.relative(basePath, fullPath);\n\n      // Check exclusions\n      if (shouldExclude(relativePath, excludePatterns)) continue;\n      if (entry.name.startsWith('.')) continue; // Skip hidden files\n\n      if (entry.isDirectory()) {\n        yield* walk(fullPath, depth + 1);\n      } else if (entry.isFile()) {\n        const ext = path.extname(entry.name).toLowerCase();\n        if (extensions.includes(ext)) {\n          try {\n            yield await readFile(fullPath, basePath);\n          } catch (error) {\n            logger.error(`Error reading file ${fullPath}: ${error}`);\n          }\n        }\n      }\n    }\n  }\n\n  yield* walk(basePath, 0);\n}\n\n/**\n * Get all markdown files in a directory (non-streaming)\n */\nexport async function getMarkdownFiles(\n  basePath: string,\n  options: WalkOptions = {}\n): Promise<FileInfo[]> {\n  const files: FileInfo[] = [];\n\n  for await (const file of walkDirectory(basePath, options)) {\n    files.push(file);\n  }\n\n  return files;\n}\n\n/**\n * Check if a file exists\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    await fs.promises.access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get file stats\n */\nexport async function getFileStats(filePath: string): Promise<fs.Stats | null> {\n  try {\n    return await fs.promises.stat(filePath);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Compare file modification time with stored time\n */\nexport async function hasFileChanged(filePath: string, storedHash: string): Promise<boolean> {\n  try {\n    const content = await fs.promises.readFile(filePath, 'utf-8');\n    const currentHash = hashContent(content);\n    return currentHash !== storedHash;\n  } catch {\n    return true; // Assume changed if we can't read\n  }\n}\n","import { getMarkdownFiles, type FileInfo, type WalkOptions } from '../storage/filesystem/reader.js';\nimport { IndexingPipeline, type BatchIndexingResult } from './pipeline.js';\n\nexport interface FullIndexOptions extends WalkOptions {\n  /** Callback for progress updates */\n  onProgress?: (current: number, total: number, path: string) => void;\n  /** Whether to clear existing data before indexing */\n  clearExisting?: boolean;\n}\n\n/**\n * Perform a full vault index\n */\nexport async function fullIndex(\n  pipeline: IndexingPipeline,\n  basePath: string,\n  options: FullIndexOptions = {}\n): Promise<BatchIndexingResult> {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { onProgress, clearExisting = false, ...walkOptions } = options;\n\n  // Get all markdown files\n  const files = await getMarkdownFiles(basePath, walkOptions);\n\n  if (onProgress) {\n    let current = 0;\n    const total = files.length;\n\n    // Wrap the batch indexing with progress\n    const originalIndex = pipeline.indexFile.bind(pipeline);\n    pipeline.indexFile = async (file: FileInfo) => {\n      current++;\n      onProgress(current, total, file.relativePath);\n      return originalIndex(file);\n    };\n  }\n\n  // Run batch indexing\n  return pipeline.batchIndex(files);\n}\n\n/**\n * Index files that have changed since last index\n */\nexport async function incrementalIndex(\n  pipeline: IndexingPipeline,\n  basePath: string,\n  options: WalkOptions = {}\n): Promise<BatchIndexingResult> {\n  const files = await getMarkdownFiles(basePath, options);\n\n  // Filter to only files that need reindexing\n  const filesToIndex: FileInfo[] = [];\n  for (const file of files) {\n    if (await pipeline.needsReindex(file)) {\n      filesToIndex.push(file);\n    }\n  }\n\n  if (filesToIndex.length === 0) {\n    return {\n      indexed: [],\n      errors: [],\n      stats: {\n        totalFiles: 0,\n        successCount: 0,\n        errorCount: 0,\n        nodeCount: 0,\n        edgeCount: 0,\n        unresolvedCount: 0,\n        ambiguousCount: 0,\n        durationMs: 0,\n      },\n    };\n  }\n\n  return pipeline.batchIndex(filesToIndex);\n}\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { createIncrementalIndexer, type IncrementalIndexEvent } from '../../indexer/incremental.js';\n\nexport const watchCommand = new Command('watch')\n  .description('Watch for file changes and incrementally index')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      console.log(`Watching vault: ${ctx.vaultPath}`);\n      console.log('Press Ctrl+C to stop.\\n');\n\n      const indexer = createIncrementalIndexer(ctx.vaultPath, ctx.pipeline, {\n        excludePatterns: ctx.config.vault.excludePatterns.map((p) => `**/${p}`),\n      });\n\n      indexer.on('ready', () => {\n        console.log('Watcher ready. Listening for changes...\\n');\n      });\n\n      indexer.on('event', (event: IncrementalIndexEvent) => {\n        const timestamp = new Date().toLocaleTimeString();\n\n        switch (event.type) {\n          case 'indexed':\n            console.log(`[${timestamp}] Indexed: ${event.path}`);\n            if (options.verbose && event.result) {\n              const { edges, unresolved, ambiguous } = event.result;\n              if (edges.length > 0) {\n                console.log(`  Links: ${edges.length}`);\n              }\n              if (unresolved.length > 0) {\n                console.log(`  Unresolved: ${unresolved.map((u) => u.target).join(', ')}`);\n              }\n              if (ambiguous.length > 0) {\n                console.log(`  Ambiguous: ${ambiguous.map((a) => a.target).join(', ')}`);\n              }\n            }\n            break;\n\n          case 'removed':\n            console.log(`[${timestamp}] Removed: ${event.path}`);\n            break;\n\n          case 'error':\n            console.log(`[${timestamp}] Error: ${event.path}`);\n            console.log(`  ${event.error}`);\n            break;\n        }\n      });\n\n      indexer.on('error', (error: Error) => {\n        console.error('Watcher error:', error.message);\n      });\n\n      indexer.start();\n\n      // Handle graceful shutdown\n      const shutdown = async () => {\n        console.log('\\nStopping watcher...');\n        await indexer.stop();\n        ctx.connectionManager.close();\n        process.exit(0);\n      };\n\n      process.on('SIGINT', shutdown);\n      process.on('SIGTERM', shutdown);\n    } catch (error) {\n      console.error('Watch failed:', error);\n      process.exit(1);\n    }\n  });\n","import { EventEmitter } from 'node:events';\nimport { FileWatcher, type FileEvent, type WatcherOptions } from '../storage/filesystem/watcher.js';\nimport { readFile } from '../storage/filesystem/reader.js';\nimport { IndexingPipeline, type IndexingResult } from './pipeline.js';\n\nexport interface IncrementalIndexerOptions extends Omit<WatcherOptions, 'basePath'> {\n  basePath: string;\n  pipeline: IndexingPipeline;\n}\n\nexport interface IncrementalIndexEvent {\n  type: 'indexed' | 'removed' | 'error';\n  path: string;\n  result?: IndexingResult;\n  error?: string;\n}\n\n/**\n * Incremental indexer that watches for file changes\n */\nexport class IncrementalIndexer extends EventEmitter {\n  private watcher: FileWatcher;\n  private pipeline: IndexingPipeline;\n  private basePath: string;\n  private processing: Set<string> = new Set();\n\n  constructor(options: IncrementalIndexerOptions) {\n    super();\n\n    this.basePath = options.basePath;\n    this.pipeline = options.pipeline;\n\n    this.watcher = new FileWatcher({\n      ...options,\n      basePath: this.basePath,\n    });\n\n    // Set up event handlers\n    this.watcher.on('file', this.handleFileEvent.bind(this));\n    this.watcher.on('error', (error) => this.emit('error', error));\n    this.watcher.on('ready', () => this.emit('ready'));\n  }\n\n  /**\n   * Start watching and indexing\n   */\n  start(): void {\n    this.watcher.start();\n  }\n\n  /**\n   * Stop watching\n   */\n  async stop(): Promise<void> {\n    await this.watcher.stop();\n  }\n\n  /**\n   * Handle a file event\n   */\n  private async handleFileEvent(event: FileEvent): Promise<void> {\n    // Prevent concurrent processing of the same file\n    if (this.processing.has(event.path)) {\n      return;\n    }\n\n    this.processing.add(event.path);\n\n    try {\n      switch (event.type) {\n        case 'add':\n        case 'change':\n          await this.handleAddOrChange(event);\n          break;\n\n        case 'unlink':\n          await this.handleUnlink(event);\n          break;\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.emit('event', {\n        type: 'error',\n        path: event.relativePath,\n        error: errorMessage,\n      } as IncrementalIndexEvent);\n    } finally {\n      this.processing.delete(event.path);\n    }\n  }\n\n  /**\n   * Handle file add or change\n   */\n  private async handleAddOrChange(event: FileEvent): Promise<void> {\n    const file = await readFile(event.path, this.basePath);\n    const result = await this.pipeline.indexFile(file);\n\n    this.emit('event', {\n      type: 'indexed',\n      path: event.relativePath,\n      result,\n    } as IncrementalIndexEvent);\n\n    // Clear resolver cache after changes\n    this.pipeline.clearResolverCache();\n  }\n\n  /**\n   * Handle file deletion\n   */\n  private async handleUnlink(event: FileEvent): Promise<void> {\n    await this.pipeline.removeByPath(event.relativePath);\n\n    this.emit('event', {\n      type: 'removed',\n      path: event.relativePath,\n    } as IncrementalIndexEvent);\n\n    // Clear resolver cache after deletion\n    this.pipeline.clearResolverCache();\n  }\n\n  /**\n   * Check if watching\n   */\n  isWatching(): boolean {\n    return this.watcher.isWatching();\n  }\n}\n\n/**\n * Create an incremental indexer\n */\nexport function createIncrementalIndexer(\n  basePath: string,\n  pipeline: IndexingPipeline,\n  options: Omit<IncrementalIndexerOptions, 'basePath' | 'pipeline'> = {}\n): IncrementalIndexer {\n  return new IncrementalIndexer({\n    ...options,\n    basePath,\n    pipeline,\n  });\n}\n","import { watch, type FSWatcher } from 'chokidar';\nimport * as path from 'node:path';\nimport { EventEmitter } from 'node:events';\n\nexport type FileEventType = 'add' | 'change' | 'unlink' | 'rename';\n\nexport interface FileEvent {\n  type: FileEventType;\n  path: string;\n  relativePath: string;\n  oldPath?: string; // For rename events\n}\n\nexport interface WatcherOptions {\n  basePath: string;\n  extensions?: string[];\n  excludePatterns?: string[];\n  debounceMs?: number;\n  awaitWriteFinish?: boolean;\n}\n\nconst DEFAULT_EXTENSIONS = ['.md', '.markdown'];\nconst DEFAULT_EXCLUDE = [\n  '**/node_modules/**',\n  '**/.git/**',\n  '**/.zettelscript/**',\n  '**/.obsidian/**',\n  '**/.vscode/**',\n  '**/.*',\n];\n\n/**\n * File system watcher using chokidar\n */\nexport class FileWatcher extends EventEmitter {\n  private watcher: FSWatcher | null = null;\n  private basePath: string;\n  private options: WatcherOptions;\n  private debounceTimers: Map<string, ReturnType<typeof setTimeout>> = new Map();\n  private pendingEvents: Map<string, FileEvent> = new Map();\n\n  constructor(options: WatcherOptions) {\n    super();\n    this.basePath = options.basePath;\n    this.options = {\n      extensions: DEFAULT_EXTENSIONS,\n      excludePatterns: DEFAULT_EXCLUDE,\n      debounceMs: 100,\n      awaitWriteFinish: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Start watching\n   */\n  start(): void {\n    if (this.watcher) {\n      return;\n    }\n\n    const patterns = this.options.extensions!.map((ext) =>\n      path.join(this.basePath, '**', `*${ext}`)\n    );\n\n    this.watcher = watch(patterns, {\n      ...(this.options.excludePatterns != null && { ignored: this.options.excludePatterns }),\n      persistent: true,\n      ignoreInitial: true,\n      awaitWriteFinish: this.options.awaitWriteFinish\n        ? { stabilityThreshold: 100, pollInterval: 50 }\n        : false,\n      usePolling: false,\n    });\n\n    this.watcher\n      .on('add', (filePath) => this.handleEvent('add', filePath))\n      .on('change', (filePath) => this.handleEvent('change', filePath))\n      .on('unlink', (filePath) => this.handleEvent('unlink', filePath))\n      .on('error', (error) => this.emit('error', error))\n      .on('ready', () => this.emit('ready'));\n  }\n\n  /**\n   * Stop watching\n   */\n  async stop(): Promise<void> {\n    if (!this.watcher) {\n      return;\n    }\n\n    // Clear pending timers\n    for (const timer of this.debounceTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.debounceTimers.clear();\n    this.pendingEvents.clear();\n\n    await this.watcher.close();\n    this.watcher = null;\n  }\n\n  /**\n   * Handle a file event with debouncing\n   */\n  private handleEvent(type: FileEventType, filePath: string): void {\n    const relativePath = path.relative(this.basePath, filePath);\n\n    // Cancel existing timer for this file\n    const existingTimer = this.debounceTimers.get(filePath);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n\n    // Store the event\n    const event: FileEvent = { type, path: filePath, relativePath };\n\n    // If there's a pending add followed by a change, keep it as add\n    const pending = this.pendingEvents.get(filePath);\n    if (pending?.type === 'add' && type === 'change') {\n      event.type = 'add';\n    }\n\n    this.pendingEvents.set(filePath, event);\n\n    // Set debounce timer\n    const timer = setTimeout(() => {\n      const finalEvent = this.pendingEvents.get(filePath);\n      if (finalEvent) {\n        this.pendingEvents.delete(filePath);\n        this.debounceTimers.delete(filePath);\n        this.emit('file', finalEvent);\n        this.emit(finalEvent.type, finalEvent);\n      }\n    }, this.options.debounceMs);\n\n    this.debounceTimers.set(filePath, timer);\n  }\n\n  /**\n   * Check if watching\n   */\n  isWatching(): boolean {\n    return this.watcher !== null;\n  }\n\n  /**\n   * Get watched paths\n   */\n  getWatched(): Record<string, string[]> {\n    if (!this.watcher) {\n      return {};\n    }\n    return this.watcher.getWatched();\n  }\n}\n\n/**\n * Create a file watcher\n */\nexport function createWatcher(options: WatcherOptions): FileWatcher {\n  return new FileWatcher(options);\n}\n","import { Command } from 'commander';\nimport { initContext, printTable } from '../utils.js';\nimport { parseIntSafe } from '../../core/validation.js';\n\nexport const queryCommand = new Command('query').description('Query the knowledge graph');\n\n// Backlinks subcommand\nqueryCommand\n  .command('backlinks <node>')\n  .description('Show incoming links to a node')\n  .option('-l, --limit <n>', 'Maximum results', '20')\n  .action(async (nodeIdentifier: string, options) => {\n    try {\n      const ctx = await initContext();\n      const limit = parseIntSafe(options.limit, ctx.config.search.defaultLimit);\n\n      // Find node by title or path\n      let node = await ctx.nodeRepository.findByPath(nodeIdentifier);\n      if (!node) {\n        const nodes = await ctx.nodeRepository.findByTitle(nodeIdentifier);\n        node = nodes[0] ?? null;\n      }\n      if (!node) {\n        const nodes = await ctx.nodeRepository.findByTitleOrAlias(nodeIdentifier);\n        node = nodes[0] ?? null;\n      }\n\n      if (!node) {\n        console.log(`Node not found: ${nodeIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`Backlinks to: ${node.title} (${node.path})\\n`);\n\n      const backlinks = await ctx.graphEngine.getBacklinks(node.nodeId);\n\n      if (backlinks.length === 0) {\n        console.log('No backlinks found.');\n      } else {\n        const rows = backlinks\n          .slice(0, limit)\n          .map((bl) => [bl.sourceNode.title, bl.sourceNode.type, bl.sourceNode.path]);\n        printTable(['Title', 'Type', 'Path'], rows);\n\n        if (backlinks.length > limit) {\n          console.log(`\\n... and ${backlinks.length - limit} more`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Neighbors subcommand\nqueryCommand\n  .command('neighbors <node>')\n  .description('Show connected nodes')\n  .option('-l, --limit <n>', 'Maximum results', '20')\n  .option('-d, --direction <dir>', 'Filter direction (in/out/both)', 'both')\n  .action(async (nodeIdentifier: string, options) => {\n    try {\n      const ctx = await initContext();\n      const limit = parseIntSafe(options.limit, ctx.config.search.defaultLimit);\n\n      // Find node\n      let node = await ctx.nodeRepository.findByPath(nodeIdentifier);\n      if (!node) {\n        const nodes = await ctx.nodeRepository.findByTitle(nodeIdentifier);\n        node = nodes[0] ?? null;\n      }\n      if (!node) {\n        const nodes = await ctx.nodeRepository.findByTitleOrAlias(nodeIdentifier);\n        node = nodes[0] ?? null;\n      }\n\n      if (!node) {\n        console.log(`Node not found: ${nodeIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`Neighbors of: ${node.title} (${node.path})\\n`);\n\n      const neighbors = await ctx.graphEngine.getNeighbors(node.nodeId);\n\n      // Filter by direction\n      const filtered = neighbors.filter((n) => {\n        if (options.direction === 'in') return n.direction === 'incoming';\n        if (options.direction === 'out') return n.direction === 'outgoing';\n        return true;\n      });\n\n      if (filtered.length === 0) {\n        console.log('No neighbors found.');\n      } else {\n        const rows = filtered\n          .slice(0, limit)\n          .map((n) => [\n            n.direction === 'incoming' ? '' : '',\n            n.node.title,\n            n.node.type,\n            n.edge.edgeType,\n          ]);\n        printTable(['Dir', 'Title', 'Type', 'Edge Type'], rows);\n\n        if (filtered.length > limit) {\n          console.log(`\\n... and ${filtered.length - limit} more`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Path subcommand\nqueryCommand\n  .command('path <from> <to>')\n  .description('Find shortest path between nodes')\n  .action(async (fromIdentifier: string, toIdentifier: string) => {\n    try {\n      const ctx = await initContext();\n\n      // Find from node\n      let fromNode = await ctx.nodeRepository.findByPath(fromIdentifier);\n      if (!fromNode) {\n        const nodes = await ctx.nodeRepository.findByTitle(fromIdentifier);\n        fromNode = nodes[0] ?? null;\n      }\n      if (!fromNode) {\n        console.log(`Node not found: ${fromIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Find to node\n      let toNode = await ctx.nodeRepository.findByPath(toIdentifier);\n      if (!toNode) {\n        const nodes = await ctx.nodeRepository.findByTitle(toIdentifier);\n        toNode = nodes[0] ?? null;\n      }\n      if (!toNode) {\n        console.log(`Node not found: ${toIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`Path from \"${fromNode.title}\" to \"${toNode.title}\":\\n`);\n\n      const path = await ctx.graphEngine.findShortestPath(fromNode.nodeId, toNode.nodeId);\n\n      if (!path) {\n        console.log('No path found.');\n      } else {\n        const pathNodes = await ctx.nodeRepository.findByIds(path);\n        const nodeMap = new Map(pathNodes.map((n) => [n.nodeId, n]));\n\n        for (let i = 0; i < path.length; i++) {\n          const nodeId = path[i];\n          if (nodeId) {\n            const node = nodeMap.get(nodeId);\n            const prefix = i === 0 ? '' : i === path.length - 1 ? '' : '';\n            console.log(`  ${prefix} ${node?.title || nodeId}`);\n          }\n        }\n        console.log(`\\nPath length: ${path.length - 1} hops`);\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Stats subcommand\nqueryCommand\n  .command('stats')\n  .description('Show graph statistics')\n  .action(async () => {\n    try {\n      const ctx = await initContext();\n\n      const stats = await ctx.pipeline.getStats();\n      const dbStats = ctx.connectionManager.getStats();\n\n      console.log('Graph Statistics\\n');\n      console.log(`Total nodes:  ${stats.nodeCount}`);\n      console.log(`Total edges:  ${stats.edgeCount}`);\n      console.log(`Total chunks: ${dbStats.chunkCount}`);\n      console.log(`DB size:      ${(dbStats.dbSizeBytes / 1024).toFixed(1)}KB`);\n\n      console.log('\\nNodes by type:');\n      for (const [type, count] of Object.entries(stats.nodesByType).sort((a, b) => b[1] - a[1])) {\n        console.log(`  ${type}: ${count}`);\n      }\n\n      console.log('\\nEdges by type:');\n      for (const [type, count] of Object.entries(stats.edgesByType).sort((a, b) => b[1] - a[1])) {\n        console.log(`  ${type}: ${count}`);\n      }\n\n      // Find orphan nodes\n      const components = await ctx.graphEngine.findConnectedComponents();\n      const isolatedCount = components.filter((c) => c.length === 1).length;\n      if (isolatedCount > 0) {\n        console.log(`\\nIsolated nodes: ${isolatedCount}`);\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Orphans subcommand\nqueryCommand\n  .command('orphans')\n  .description('Find nodes with no links')\n  .option('-l, --limit <n>', 'Maximum results', '20')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n      const limit = parseIntSafe(options.limit, ctx.config.search.defaultLimit);\n\n      const isolated = await ctx.graphEngine.findIsolatedNodes();\n\n      if (isolated.length === 0) {\n        console.log('No orphan nodes found.');\n      } else {\n        console.log(`Orphan nodes (${isolated.length}):\\n`);\n\n        const rows = isolated.slice(0, limit).map((n) => [n.title, n.type, n.path]);\n        printTable(['Title', 'Type', 'Path'], rows);\n\n        if (isolated.length > limit) {\n          console.log(`\\n... and ${isolated.length - limit} more`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Hubs subcommand\nqueryCommand\n  .command('hubs')\n  .description('Find highly-connected nodes')\n  .option('-l, --limit <n>', 'Maximum results', '10')\n  .option('-t, --threshold <n>', 'Minimum connections', '5')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n      const limit = parseIntSafe(options.limit, 10);\n      const threshold = parseIntSafe(options.threshold, ctx.config.moc.defaultHubThreshold);\n\n      const hubs = await ctx.graphEngine.findHighInDegreeNodes(threshold);\n\n      if (hubs.length === 0) {\n        console.log(`No nodes with ${threshold}+ incoming links.`);\n      } else {\n        console.log(`Hub nodes (${hubs.length}):\\n`);\n\n        const rows = hubs\n          .slice(0, limit)\n          .map((h) => [h.node.title, h.node.type, h.inDegree.toString()]);\n        printTable(['Title', 'Type', 'Incoming Links'], rows);\n\n        if (hubs.length > limit) {\n          console.log(`\\n... and ${hubs.length - limit} more`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n","/**\n * Safe parsing and validation utilities\n */\n\n/**\n * Parse an integer from a string with fallback to default value\n * Returns defaultValue if the string is not a valid integer\n */\nexport function parseIntSafe(value: string, defaultValue: number): number {\n  const parsed = parseInt(value, 10);\n  return Number.isNaN(parsed) ? defaultValue : parsed;\n}\n\n/**\n * Parse a float from a string with fallback to default value\n * Returns defaultValue if the string is not a valid number\n */\nexport function parseFloatSafe(value: string, defaultValue: number): number {\n  const parsed = parseFloat(value);\n  return Number.isNaN(parsed) ? defaultValue : parsed;\n}\n\n/**\n * Clamp a number between min and max values\n */\nexport function clampNumber(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * Parse an integer with bounds checking\n * Returns defaultValue if parsing fails or value is out of bounds\n */\nexport function parseIntBounded(\n  value: string,\n  defaultValue: number,\n  min: number,\n  max: number\n): number {\n  const parsed = parseIntSafe(value, defaultValue);\n  return clampNumber(parsed, min, max);\n}\n\n/**\n * Parse a float with bounds checking\n * Returns defaultValue if parsing fails or value is out of bounds\n */\nexport function parseFloatBounded(\n  value: string,\n  defaultValue: number,\n  min: number,\n  max: number\n): number {\n  const parsed = parseFloatSafe(value, defaultValue);\n  return clampNumber(parsed, min, max);\n}\n\n/**\n * Validate that a value is a positive integer\n */\nexport function isPositiveInt(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value > 0;\n}\n\n/**\n * Validate that a value is a non-negative integer\n */\nexport function isNonNegativeInt(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Validate that a value is a number in range [0, 1]\n */\nexport function isNormalizedNumber(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value <= 1;\n}\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { LinkValidator } from '../../validation/link-validator.js';\nimport { SchemaValidator } from '../../validation/schema-validator.js';\nimport { ContinuityChecker } from '../../validation/continuity-checker.js';\n\nexport const validateCommand = new Command('validate')\n  .description('Validate the vault')\n  .option('--links', 'Check for broken and ambiguous links')\n  .option('--schema', 'Validate frontmatter schema')\n  .option('--continuity', 'Check manuscript continuity (POV, timeline)')\n  .option('--all', 'Run all validations')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      const runAll = options.all || (!options.links && !options.schema && !options.continuity);\n      let hasErrors = false;\n\n      // Link validation\n      if (runAll || options.links) {\n        console.log('Checking links...\\n');\n\n        const linkValidator = new LinkValidator({\n          nodeRepository: ctx.nodeRepository,\n          edgeRepository: ctx.edgeRepository,\n        });\n\n        const linkResult = await linkValidator.validate();\n\n        if (linkResult.broken.length === 0 && linkResult.ambiguous.length === 0) {\n          console.log('   All links valid\\n');\n        } else {\n          if (linkResult.broken.length > 0) {\n            hasErrors = true;\n            console.log(`   Broken links: ${linkResult.broken.length}`);\n            if (options.verbose) {\n              for (const b of linkResult.broken.slice(0, 10)) {\n                console.log(`    ${b.sourcePath}: [[${b.targetText}]]`);\n              }\n              if (linkResult.broken.length > 10) {\n                console.log(`    ... and ${linkResult.broken.length - 10} more`);\n              }\n            }\n          }\n\n          if (linkResult.ambiguous.length > 0) {\n            console.log(`  ! Ambiguous links: ${linkResult.ambiguous.length}`);\n            if (options.verbose) {\n              for (const a of linkResult.ambiguous.slice(0, 10)) {\n                console.log(\n                  `    ${a.sourcePath}: [[${a.targetText}]]  ${a.candidates.length} matches`\n                );\n              }\n            }\n          }\n          console.log('');\n        }\n      }\n\n      // Schema validation\n      if (runAll || options.schema) {\n        console.log('Validating schema...\\n');\n\n        const schemaValidator = new SchemaValidator({\n          nodeRepository: ctx.nodeRepository,\n        });\n\n        const schemaResult = await schemaValidator.validate();\n\n        if (schemaResult.errors.length === 0) {\n          console.log('   All frontmatter valid\\n');\n        } else {\n          hasErrors = true;\n          console.log(`   Schema errors: ${schemaResult.errors.length}`);\n          if (options.verbose) {\n            for (const e of schemaResult.errors.slice(0, 10)) {\n              console.log(`    ${e.path}: ${e.message}`);\n            }\n            if (schemaResult.errors.length > 10) {\n              console.log(`    ... and ${schemaResult.errors.length - 10} more`);\n            }\n          }\n          console.log('');\n        }\n      }\n\n      // Continuity validation (manuscript mode)\n      if ((runAll || options.continuity) && ctx.config.manuscript.enabled) {\n        console.log('Checking continuity...\\n');\n\n        const continuityChecker = new ContinuityChecker({\n          nodeRepository: ctx.nodeRepository,\n          edgeRepository: ctx.edgeRepository,\n          config: ctx.config.manuscript,\n        });\n\n        const continuityResult = await continuityChecker.check();\n\n        const errors = continuityResult.issues.filter((i) => i.severity === 'error');\n        const warnings = continuityResult.issues.filter((i) => i.severity === 'warning');\n\n        if (errors.length === 0 && warnings.length === 0) {\n          console.log('   No continuity issues\\n');\n        } else {\n          if (errors.length > 0) {\n            hasErrors = true;\n            console.log(`   Continuity errors: ${errors.length}`);\n            if (options.verbose) {\n              for (const e of errors.slice(0, 10)) {\n                console.log(`    ${e.nodeId}: ${e.description}`);\n                if (e.suggestion) {\n                  console.log(`      Suggestion: ${e.suggestion}`);\n                }\n              }\n            }\n          }\n\n          if (warnings.length > 0) {\n            console.log(`  ! Continuity warnings: ${warnings.length}`);\n            if (options.verbose) {\n              for (const w of warnings.slice(0, 10)) {\n                console.log(`    ${w.nodeId}: ${w.description}`);\n              }\n            }\n          }\n          console.log('');\n        }\n      } else if ((runAll || options.continuity) && !ctx.config.manuscript.enabled) {\n        console.log('Continuity checking skipped (manuscript mode not enabled).\\n');\n        console.log('Enable with: zettel init --manuscript\\n');\n      }\n\n      // Summary\n      if (hasErrors) {\n        console.log('Validation completed with errors.');\n        process.exitCode = 1;\n      } else {\n        console.log('Validation passed.');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Validation failed:', error);\n      process.exit(1);\n    }\n  });\n","import type { Node } from '../core/types/index.js';\nimport { NodeRepository, EdgeRepository } from '../storage/database/repositories/index.js';\n\nexport interface BrokenLink {\n  sourceId: string;\n  sourcePath: string;\n  targetText: string;\n  spanStart?: number;\n  spanEnd?: number;\n}\n\nexport interface AmbiguousLink {\n  sourceId: string;\n  sourcePath: string;\n  targetText: string;\n  candidates: string[]; // Node IDs\n  candidateTitles: string[];\n}\n\nexport interface LinkValidationResult {\n  broken: BrokenLink[];\n  ambiguous: AmbiguousLink[];\n  valid: number;\n  total: number;\n}\n\nexport interface LinkValidatorOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n}\n\n/**\n * Validates links in the graph\n */\nexport class LinkValidator {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n\n  constructor(options: LinkValidatorOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n  }\n\n  /**\n   * Validate all links in the graph\n   */\n  async validate(): Promise<LinkValidationResult> {\n    const broken: BrokenLink[] = [];\n    const ambiguous: AmbiguousLink[] = [];\n    let valid = 0;\n\n    // Get all nodes\n    const nodes = await this.nodeRepo.findAll();\n    const nodeMap = new Map(nodes.map((n) => [n.nodeId, n]));\n\n    // Get all explicit_link edges\n    const edges = await this.edgeRepo.findByType('explicit_link');\n\n    for (const edge of edges) {\n      const sourceNode = nodeMap.get(edge.sourceId);\n      const targetNode = nodeMap.get(edge.targetId);\n\n      if (!sourceNode) {\n        // Source node missing (shouldn't happen due to FK constraints)\n        continue;\n      }\n\n      if (!targetNode) {\n        // Target node missing - broken link\n        const attributes = edge.attributes as\n          | { displayText?: string; position?: { start: number; end: number } }\n          | undefined;\n        broken.push({\n          sourceId: edge.sourceId,\n          sourcePath: sourceNode.path,\n          targetText: attributes?.displayText || edge.targetId,\n          ...(attributes?.position?.start != null && { spanStart: attributes.position.start }),\n          ...(attributes?.position?.end != null && { spanEnd: attributes.position.end }),\n        });\n      } else {\n        valid++;\n      }\n    }\n\n    // Note: Ambiguous links are tracked during indexing, not in edges\n    // They would be stored separately if we wanted to validate them\n\n    return {\n      broken,\n      ambiguous,\n      valid,\n      total: edges.length,\n    };\n  }\n\n  /**\n   * Validate links for a specific node\n   */\n  async validateNode(nodeId: string): Promise<{\n    broken: BrokenLink[];\n    valid: number;\n  }> {\n    const broken: BrokenLink[] = [];\n    let valid = 0;\n\n    const node = await this.nodeRepo.findById(nodeId);\n    if (!node) {\n      return { broken, valid: 0 };\n    }\n\n    const edges = await this.edgeRepo.findOutgoing(nodeId, ['explicit_link']);\n\n    for (const edge of edges) {\n      const targetNode = await this.nodeRepo.findById(edge.targetId);\n\n      if (!targetNode) {\n        const attributes = edge.attributes as\n          | { displayText?: string; position?: { start: number; end: number } }\n          | undefined;\n        broken.push({\n          sourceId: nodeId,\n          sourcePath: node.path,\n          targetText: attributes?.displayText || edge.targetId,\n          ...(attributes?.position?.start != null && { spanStart: attributes.position.start }),\n          ...(attributes?.position?.end != null && { spanEnd: attributes.position.end }),\n        });\n      } else {\n        valid++;\n      }\n    }\n\n    return { broken, valid };\n  }\n\n  /**\n   * Find all nodes that link to a given node\n   */\n  async findLinkers(targetNodeId: string): Promise<Node[]> {\n    const edges = await this.edgeRepo.findBacklinks(targetNodeId);\n    const sourceIds = edges.map((e) => e.sourceId);\n    return this.nodeRepo.findByIds(sourceIds);\n  }\n\n  /**\n   * Check if a link would create a cycle\n   */\n  async wouldCreateCycle(\n    sourceId: string,\n    targetId: string,\n    maxDepth: number = 10\n  ): Promise<boolean> {\n    // BFS from target to see if we can reach source\n    const visited = new Set<string>([targetId]);\n    let frontier = [targetId];\n\n    for (let depth = 0; depth < maxDepth && frontier.length > 0; depth++) {\n      const nextFrontier: string[] = [];\n\n      for (const nodeId of frontier) {\n        const outgoing = await this.edgeRepo.findOutgoing(nodeId, ['explicit_link']);\n\n        for (const edge of outgoing) {\n          if (edge.targetId === sourceId) {\n            return true; // Found cycle\n          }\n\n          if (!visited.has(edge.targetId)) {\n            visited.add(edge.targetId);\n            nextFrontier.push(edge.targetId);\n          }\n        }\n      }\n\n      frontier = nextFrontier;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get link statistics\n   */\n  async getStats(): Promise<{\n    totalNodes: number;\n    totalLinks: number;\n    avgLinksPerNode: number;\n    nodesWithNoLinks: number;\n    nodesWithNoIncoming: number;\n    nodesWithNoOutgoing: number;\n  }> {\n    const nodes = await this.nodeRepo.findAll();\n    const edges = await this.edgeRepo.findByType('explicit_link');\n\n    // Count links per node\n    const outgoingCount = new Map<string, number>();\n    const incomingCount = new Map<string, number>();\n\n    for (const edge of edges) {\n      outgoingCount.set(edge.sourceId, (outgoingCount.get(edge.sourceId) || 0) + 1);\n      incomingCount.set(edge.targetId, (incomingCount.get(edge.targetId) || 0) + 1);\n    }\n\n    let nodesWithNoLinks = 0;\n    let nodesWithNoIncoming = 0;\n    let nodesWithNoOutgoing = 0;\n\n    for (const node of nodes) {\n      const out = outgoingCount.get(node.nodeId) || 0;\n      const inc = incomingCount.get(node.nodeId) || 0;\n\n      if (out === 0 && inc === 0) nodesWithNoLinks++;\n      if (inc === 0) nodesWithNoIncoming++;\n      if (out === 0) nodesWithNoOutgoing++;\n    }\n\n    return {\n      totalNodes: nodes.length,\n      totalLinks: edges.length,\n      avgLinksPerNode: nodes.length > 0 ? edges.length / nodes.length : 0,\n      nodesWithNoLinks,\n      nodesWithNoIncoming,\n      nodesWithNoOutgoing,\n    };\n  }\n}\n","import Ajv, { type ValidateFunction } from 'ajv';\nimport { Type, type TSchema } from '@sinclair/typebox';\nimport type { Node, Frontmatter } from '../core/types/index.js';\nimport { NodeRepository } from '../storage/database/repositories/index.js';\n\nexport interface SchemaError {\n  nodeId: string;\n  path: string;\n  field: string;\n  message: string;\n  value?: unknown;\n}\n\nexport interface SchemaValidationResult {\n  errors: SchemaError[];\n  warnings: SchemaError[];\n  valid: number;\n  total: number;\n}\n\nexport interface SchemaValidatorOptions {\n  nodeRepository: NodeRepository;\n  customSchemas?: Record<string, TSchema>;\n}\n\n// Base frontmatter schema\nconst BaseFrontmatterSchema = Type.Object(\n  {\n    id: Type.Optional(Type.String()),\n    title: Type.Optional(Type.String()),\n    type: Type.Optional(\n      Type.Union([\n        Type.Literal('note'),\n        Type.Literal('scene'),\n        Type.Literal('character'),\n        Type.Literal('location'),\n        Type.Literal('object'),\n        Type.Literal('event'),\n        Type.Literal('concept'),\n        Type.Literal('moc'),\n        Type.Literal('timeline'),\n        Type.Literal('draft'),\n      ])\n    ),\n    aliases: Type.Optional(Type.Array(Type.String())),\n    tags: Type.Optional(Type.Array(Type.String())),\n    created: Type.Optional(Type.String()),\n    updated: Type.Optional(Type.String()),\n  },\n  { additionalProperties: true }\n);\n\n// Scene-specific schema\nconst SceneFrontmatterSchema = Type.Object(\n  {\n    type: Type.Literal('scene'),\n    pov: Type.Optional(Type.String()),\n    scene_order: Type.Optional(Type.Number()),\n    timeline_position: Type.Optional(Type.String()),\n    characters: Type.Optional(Type.Array(Type.String())),\n    locations: Type.Optional(Type.Array(Type.String())),\n  },\n  { additionalProperties: true }\n);\n\n// Character-specific schema\nconst CharacterFrontmatterSchema = Type.Object(\n  {\n    type: Type.Literal('character'),\n    aliases: Type.Optional(Type.Array(Type.String())),\n    description: Type.Optional(Type.String()),\n    traits: Type.Optional(Type.Array(Type.String())),\n  },\n  { additionalProperties: true }\n);\n\n/**\n * Validates frontmatter schema for nodes\n */\nexport class SchemaValidator {\n  private nodeRepo: NodeRepository;\n  private ajv: Ajv;\n  private validators: Map<string, ValidateFunction>;\n\n  constructor(options: SchemaValidatorOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.ajv = new Ajv({ allErrors: true, strict: false });\n    this.validators = new Map();\n\n    // Register base validator\n    this.validators.set('base', this.ajv.compile(BaseFrontmatterSchema));\n\n    // Register type-specific validators\n    this.validators.set('scene', this.ajv.compile(SceneFrontmatterSchema));\n    this.validators.set('character', this.ajv.compile(CharacterFrontmatterSchema));\n\n    // Register custom schemas\n    if (options.customSchemas) {\n      for (const [type, schema] of Object.entries(options.customSchemas)) {\n        this.validators.set(type, this.ajv.compile(schema));\n      }\n    }\n  }\n\n  /**\n   * Validate all nodes\n   */\n  async validate(): Promise<SchemaValidationResult> {\n    const errors: SchemaError[] = [];\n    const warnings: SchemaError[] = [];\n    let valid = 0;\n\n    const nodes = await this.nodeRepo.findAll();\n\n    for (const node of nodes) {\n      const result = this.validateNode(node);\n\n      if (result.errors.length === 0) {\n        valid++;\n      }\n\n      errors.push(...result.errors);\n      warnings.push(...result.warnings);\n    }\n\n    return {\n      errors,\n      warnings,\n      valid,\n      total: nodes.length,\n    };\n  }\n\n  /**\n   * Validate a single node's frontmatter\n   */\n  validateNode(node: Node): { errors: SchemaError[]; warnings: SchemaError[] } {\n    const errors: SchemaError[] = [];\n    const warnings: SchemaError[] = [];\n\n    const metadata = node.metadata as Frontmatter | undefined;\n\n    if (!metadata) {\n      // No frontmatter - could be a warning depending on requirements\n      return { errors, warnings };\n    }\n\n    // Validate against base schema\n    const baseValidator = this.validators.get('base');\n    if (baseValidator && !baseValidator(metadata)) {\n      for (const err of baseValidator.errors || []) {\n        errors.push({\n          nodeId: node.nodeId,\n          path: node.path,\n          field: err.instancePath || 'root',\n          message: err.message || 'Validation failed',\n          value: err.data,\n        });\n      }\n    }\n\n    // Validate against type-specific schema if available\n    const typeValidator = this.validators.get(node.type);\n    if (typeValidator && metadata.type === node.type) {\n      if (!typeValidator(metadata)) {\n        for (const err of typeValidator.errors || []) {\n          errors.push({\n            nodeId: node.nodeId,\n            path: node.path,\n            field: err.instancePath || 'root',\n            message: err.message || 'Validation failed',\n            value: err.data,\n          });\n        }\n      }\n    }\n\n    // Type-specific validation rules\n    if (node.type === 'scene') {\n      // Scene should have POV for manuscript mode\n      if (!metadata.pov) {\n        warnings.push({\n          nodeId: node.nodeId,\n          path: node.path,\n          field: 'pov',\n          message: 'Scene missing POV character',\n        });\n      }\n\n      // Scene should have scene_order for timeline\n      if (metadata.scene_order === undefined) {\n        warnings.push({\n          nodeId: node.nodeId,\n          path: node.path,\n          field: 'scene_order',\n          message: 'Scene missing scene_order for timeline tracking',\n        });\n      }\n    }\n\n    if (node.type === 'character') {\n      // Character should have aliases for mention detection\n      if (!metadata.aliases || metadata.aliases.length === 0) {\n        warnings.push({\n          nodeId: node.nodeId,\n          path: node.path,\n          field: 'aliases',\n          message: 'Character has no aliases defined',\n        });\n      }\n    }\n\n    return { errors, warnings };\n  }\n\n  /**\n   * Add a custom schema for a type\n   */\n  addSchema(type: string, schema: TSchema): void {\n    this.validators.set(type, this.ajv.compile(schema));\n  }\n\n  /**\n   * Get validation summary by type\n   */\n  async getSummary(): Promise<Record<string, { total: number; valid: number; errors: number }>> {\n    const nodes = await this.nodeRepo.findAll();\n    const summary: Record<string, { total: number; valid: number; errors: number }> = {};\n\n    for (const node of nodes) {\n      if (!summary[node.type]) {\n        summary[node.type] = { total: 0, valid: 0, errors: 0 };\n      }\n\n      const typeStats = summary[node.type];\n      if (typeStats) {\n        typeStats.total++;\n\n        const result = this.validateNode(node);\n        if (result.errors.length === 0) {\n          typeStats.valid++;\n        } else {\n          typeStats.errors++;\n        }\n      }\n    }\n\n    return summary;\n  }\n}\n","import type { Node, ContinuityIssue, Frontmatter, SceneInfo } from '../core/types/index.js';\nimport { NodeRepository, EdgeRepository } from '../storage/database/repositories/index.js';\n\nexport interface ContinuityCheckResult {\n  issues: ContinuityIssue[];\n  stats: {\n    scenesChecked: number;\n    povIssues: number;\n    timelineIssues: number;\n    setupPayoffIssues: number;\n    knowledgeIssues: number;\n  };\n}\n\nexport interface ContinuityCheckerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  config: {\n    validatePov: boolean;\n    validateTimeline: boolean;\n    validateSetupPayoff: boolean;\n  };\n}\n\n/**\n * Checks manuscript continuity for POV, timeline, and setup/payoff consistency\n */\nexport class ContinuityChecker {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private config: ContinuityCheckerOptions['config'];\n\n  constructor(options: ContinuityCheckerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.config = options.config;\n  }\n\n  /**\n   * Run all continuity checks\n   */\n  async check(): Promise<ContinuityCheckResult> {\n    const issues: ContinuityIssue[] = [];\n\n    // Get all scenes\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    if (scenes.length === 0) {\n      return {\n        issues: [],\n        stats: {\n          scenesChecked: 0,\n          povIssues: 0,\n          timelineIssues: 0,\n          setupPayoffIssues: 0,\n          knowledgeIssues: 0,\n        },\n      };\n    }\n\n    // Extract scene info\n    const sceneInfos = scenes.map((s) => this.extractSceneInfo(s));\n\n    // POV validation\n    if (this.config.validatePov) {\n      const povIssues = await this.checkPovConsistency(scenes, sceneInfos);\n      issues.push(...povIssues);\n    }\n\n    // Timeline validation\n    if (this.config.validateTimeline) {\n      const timelineIssues = await this.checkTimelineConsistency(scenes, sceneInfos);\n      issues.push(...timelineIssues);\n    }\n\n    // Setup/payoff validation\n    if (this.config.validateSetupPayoff) {\n      const setupPayoffIssues = await this.checkSetupPayoff(scenes);\n      issues.push(...setupPayoffIssues);\n    }\n\n    return {\n      issues,\n      stats: {\n        scenesChecked: scenes.length,\n        povIssues: issues.filter((i) => i.type === 'pov_leakage').length,\n        timelineIssues: issues.filter((i) => i.type === 'timeline_inconsistency').length,\n        setupPayoffIssues: issues.filter(\n          (i) => i.type === 'missing_setup' || i.type === 'orphaned_payoff'\n        ).length,\n        knowledgeIssues: issues.filter((i) => i.type === 'character_knowledge').length,\n      },\n    };\n  }\n\n  /**\n   * Extract scene info from node metadata\n   */\n  private extractSceneInfo(node: Node): SceneInfo {\n    const metadata = node.metadata as Frontmatter | undefined;\n\n    return {\n      nodeId: node.nodeId,\n      sceneOrder: metadata?.scene_order ?? Infinity,\n      ...(metadata?.timeline_position != null && { timelinePosition: metadata.timeline_position }),\n      ...(metadata?.pov != null && { pov: metadata.pov }),\n      characters: metadata?.characters ?? [],\n      locations: metadata?.locations ?? [],\n    };\n  }\n\n  /**\n   * Check POV consistency - ensure POV character knows information they reveal\n   */\n  private async checkPovConsistency(\n    scenes: Node[],\n    sceneInfos: SceneInfo[]\n  ): Promise<ContinuityIssue[]> {\n    const issues: ContinuityIssue[] = [];\n\n    // Sort scenes by order\n    const sortedScenes = [...sceneInfos].sort((a, b) => a.sceneOrder - b.sceneOrder);\n\n    // Track what each character knows\n    const characterKnowledge = new Map<string, Set<string>>();\n\n    for (const scene of sortedScenes) {\n      const sceneNode = scenes.find((s) => s.nodeId === scene.nodeId);\n      if (!sceneNode) continue;\n\n      if (!scene.pov) {\n        issues.push({\n          type: 'pov_leakage',\n          severity: 'warning',\n          nodeId: scene.nodeId,\n          description: 'Scene has no POV character defined',\n          suggestion: 'Add \"pov: CharacterName\" to frontmatter',\n        });\n        continue;\n      }\n\n      // Get links from this scene to other nodes\n      const outgoing = await this.edgeRepo.findOutgoing(scene.nodeId);\n\n      for (const edge of outgoing) {\n        // Check if target is a character\n        const targetNode = await this.nodeRepo.findById(edge.targetId);\n        if (!targetNode) continue;\n\n        if (targetNode.type === 'character' && targetNode.title !== scene.pov) {\n          // POV character is referencing another character\n          // This is generally fine, but check if POV should know about them\n          if (!scene.characters.includes(targetNode.title)) {\n            issues.push({\n              type: 'pov_leakage',\n              severity: 'info',\n              nodeId: scene.nodeId,\n              description: `POV (${scene.pov}) references ${targetNode.title} who is not listed in scene characters`,\n              suggestion: `Add \"${targetNode.title}\" to characters list if they are present`,\n            });\n          }\n        }\n      }\n\n      // Update character knowledge for characters in this scene\n      for (const char of scene.characters) {\n        if (!characterKnowledge.has(char)) {\n          characterKnowledge.set(char, new Set());\n        }\n        // Character now knows about events in this scene\n        characterKnowledge.get(char)?.add(scene.nodeId);\n      }\n    }\n\n    return issues;\n  }\n\n  /**\n   * Check timeline consistency - ensure scene_order is sequential and logical\n   */\n  private async checkTimelineConsistency(\n    scenes: Node[],\n    sceneInfos: SceneInfo[]\n  ): Promise<ContinuityIssue[]> {\n    const issues: ContinuityIssue[] = [];\n\n    // Check for missing scene_order\n    const withoutOrder = sceneInfos.filter((s) => s.sceneOrder === Infinity);\n    for (const scene of withoutOrder) {\n      const sceneNode = scenes.find((s) => s.nodeId === scene.nodeId);\n      issues.push({\n        type: 'timeline_inconsistency',\n        severity: 'warning',\n        nodeId: scene.nodeId,\n        description: `Scene \"${sceneNode?.title}\" has no scene_order`,\n        suggestion: 'Add \"scene_order: N\" to frontmatter for timeline tracking',\n      });\n    }\n\n    // Check for duplicate scene_order\n    const orderCounts = new Map<number, string[]>();\n    for (const scene of sceneInfos) {\n      if (scene.sceneOrder !== Infinity) {\n        const existing = orderCounts.get(scene.sceneOrder) || [];\n        existing.push(scene.nodeId);\n        orderCounts.set(scene.sceneOrder, existing);\n      }\n    }\n\n    for (const [order, nodeIds] of orderCounts) {\n      if (nodeIds.length > 1) {\n        for (const nodeId of nodeIds) {\n          const sceneNode = scenes.find((s) => s.nodeId === nodeId);\n          issues.push({\n            type: 'timeline_inconsistency',\n            severity: 'error',\n            nodeId,\n            description: `Scene \"${sceneNode?.title}\" has duplicate scene_order ${order}`,\n            suggestion: 'Ensure each scene has a unique scene_order',\n          });\n        }\n      }\n    }\n\n    // Check for large gaps in scene_order\n    const orderedScenes = sceneInfos\n      .filter((s) => s.sceneOrder !== Infinity)\n      .sort((a, b) => a.sceneOrder - b.sceneOrder);\n\n    for (let i = 1; i < orderedScenes.length; i++) {\n      const prev = orderedScenes[i - 1];\n      const curr = orderedScenes[i];\n      if (prev && curr) {\n        const gap = curr.sceneOrder - prev.sceneOrder;\n        if (gap > 10) {\n          issues.push({\n            type: 'timeline_inconsistency',\n            severity: 'info',\n            nodeId: curr.nodeId,\n            description: `Large gap (${gap}) in scene_order between scenes`,\n            suggestion: 'Consider renumbering scenes for clarity',\n          });\n        }\n      }\n    }\n\n    return issues;\n  }\n\n  /**\n   * Check setup/payoff consistency using edges\n   */\n  private async checkSetupPayoff(_scenes: Node[]): Promise<ContinuityIssue[]> {\n    const issues: ContinuityIssue[] = [];\n\n    // Get all setup_payoff edges\n    const setupPayoffEdges = await this.edgeRepo.findByType('setup_payoff');\n\n    // Track setups and payoffs\n    const setups = new Set<string>();\n    const payoffs = new Set<string>();\n\n    for (const edge of setupPayoffEdges) {\n      setups.add(edge.sourceId);\n      payoffs.add(edge.targetId);\n    }\n\n    // Check for setups without payoffs\n    for (const setupId of setups) {\n      const hasPayoff = setupPayoffEdges.some((e) => e.sourceId === setupId);\n      if (!hasPayoff) {\n        const node = await this.nodeRepo.findById(setupId);\n        if (node) {\n          issues.push({\n            type: 'orphaned_payoff',\n            severity: 'warning',\n            nodeId: setupId,\n            description: `Setup in \"${node.title}\" has no linked payoff`,\n            suggestion: 'Ensure this setup is resolved later in the narrative',\n          });\n        }\n      }\n    }\n\n    // Check for payoffs without setups\n    for (const payoffId of payoffs) {\n      const hasSetup = setupPayoffEdges.some((e) => e.targetId === payoffId);\n      if (!hasSetup) {\n        const node = await this.nodeRepo.findById(payoffId);\n        if (node) {\n          issues.push({\n            type: 'missing_setup',\n            severity: 'warning',\n            nodeId: payoffId,\n            description: `Payoff in \"${node.title}\" has no linked setup`,\n            suggestion: 'Ensure this payoff is properly foreshadowed earlier',\n          });\n        }\n      }\n    }\n\n    return issues;\n  }\n\n  /**\n   * Check if a character could know about something at a given scene\n   */\n  async canCharacterKnow(\n    characterName: string,\n    informationNodeId: string,\n    atSceneOrder: number\n  ): Promise<boolean> {\n    // Get all scenes where character is present up to atSceneOrder\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    for (const scene of scenes) {\n      const metadata = scene.metadata as Frontmatter | undefined;\n      const sceneOrder = metadata?.scene_order ?? Infinity;\n\n      if (sceneOrder > atSceneOrder) continue;\n\n      const characters = metadata?.characters ?? [];\n      if (!characters.includes(characterName)) continue;\n\n      // Check if this scene connects to the information\n      const edges = await this.edgeRepo.findOutgoing(scene.nodeId);\n      if (edges.some((e) => e.targetId === informationNodeId)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","import { Command } from 'commander';\nimport { initContext, printTable } from '../utils.js';\nimport { MentionDetector } from '../../discovery/mention-detector.js';\nimport { MentionRanker } from '../../discovery/mention-ranker.js';\nimport { InteractiveApprover, batchApproveMentions } from '../interactive-approver.js';\nimport { parseIntSafe, parseFloatSafe } from '../../core/validation.js';\n\nexport const discoverCommand = new Command('discover')\n  .description('Find unlinked mentions')\n  .option('-n, --node <id>', 'Check specific node')\n  .option('--all', 'Check all nodes')\n  .option('-l, --limit <n>', 'Maximum mentions per node', '10')\n  .option('-t, --threshold <n>', 'Minimum confidence threshold', '0.3')\n  .option('--approve', 'Interactive approval mode')\n  .option('--batch <action>', 'Batch action: approve, reject, or defer')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      const limit = parseIntSafe(options.limit, ctx.config.search.defaultLimit);\n      const threshold = parseFloatSafe(options.threshold, ctx.config.discovery.confidenceThreshold);\n\n      const detector = new MentionDetector({\n        nodeRepository: ctx.nodeRepository,\n        vaultPath: ctx.vaultPath,\n      });\n\n      const ranker = new MentionRanker({\n        edgeRepository: ctx.edgeRepository,\n        graphEngine: ctx.graphEngine,\n      });\n\n      let nodesToCheck: Array<{ nodeId: string; path: string; title: string }> = [];\n\n      if (options.node) {\n        // Check specific node\n        let node = await ctx.nodeRepository.findByPath(options.node);\n        if (!node) {\n          const nodes = await ctx.nodeRepository.findByTitle(options.node);\n          node = nodes[0] ?? null;\n        }\n\n        if (!node) {\n          console.log(`Node not found: ${options.node}`);\n          ctx.connectionManager.close();\n          return;\n        }\n\n        nodesToCheck = [{ nodeId: node.nodeId, path: node.path, title: node.title }];\n      } else if (options.all) {\n        // Check all nodes\n        const allNodes = await ctx.nodeRepository.findAll();\n        nodesToCheck = allNodes.map((n) => ({ nodeId: n.nodeId, path: n.path, title: n.title }));\n      } else {\n        console.log('Specify --node <id> or --all to discover mentions.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      let totalMentions = 0;\n\n      for (const { nodeId, path, title } of nodesToCheck) {\n        // Detect mentions\n        const mentions = await detector.detectInNode(nodeId);\n\n        if (mentions.length === 0) continue;\n\n        // Rank mentions\n        const ranked = await ranker.rank(mentions);\n\n        // Filter by threshold\n        const filtered = ranked.filter((m) => m.confidence >= threshold);\n\n        if (filtered.length === 0) continue;\n\n        console.log(`\\n${title} (${path}):`);\n\n        const display = filtered.slice(0, limit);\n        const rows = display.map((m) => [\n          m.surfaceText,\n          m.targetTitle || m.targetId,\n          (m.confidence * 100).toFixed(0) + '%',\n          m.reasons?.join(', ') || '',\n        ]);\n\n        printTable(['Text', 'Target', 'Confidence', 'Reasons'], rows);\n\n        if (filtered.length > limit) {\n          console.log(`  ... and ${filtered.length - limit} more`);\n        }\n\n        totalMentions += filtered.length;\n\n        // Interactive or batch approval\n        if (display.length > 0) {\n          if (options.batch) {\n            // Batch mode\n            const action = options.batch.toLowerCase();\n            if (!['approve', 'reject', 'defer'].includes(action)) {\n              console.error(`Invalid batch action: ${action}. Use: approve, reject, or defer`);\n              ctx.connectionManager.close();\n              return;\n            }\n\n            // Batch mode approves ALL filtered mentions, not just displayed\n            const results = await batchApproveMentions(\n              filtered,\n              nodeId,\n              ctx.edgeRepository,\n              action as 'approve' | 'reject' | 'defer'\n            );\n\n            const approvedCount = results.filter((r) => r.action === 'approve').length;\n            if (approvedCount > 0) {\n              console.log(`  Batch ${action}: ${approvedCount} mention(s)`);\n            }\n          } else if (options.approve) {\n            // Interactive mode\n            const approver = new InteractiveApprover({\n              edgeRepository: ctx.edgeRepository,\n              sourceNodeId: nodeId,\n            });\n\n            if (!approver.isTTY()) {\n              console.warn(\n                '\\nNot running in interactive mode (non-TTY). Use --batch flag for non-interactive approval.'\n              );\n            } else {\n              console.log('\\nInteractive approval mode:');\n              const results = await approver.approveAll(display);\n\n              const approved = results.filter((r) => r.action === 'approve').length;\n              const rejected = results.filter((r) => r.action === 'reject').length;\n              const deferred = results.filter((r) => r.action === 'defer').length;\n\n              if (approved > 0 || rejected > 0 || deferred > 0) {\n                console.log(\n                  `\\nApproved: ${approved}, Rejected: ${rejected}, Deferred: ${deferred}`\n                );\n              }\n\n              // Check if user quit early\n              if (results.some((r) => r.action === 'quit')) {\n                console.log('Approval cancelled.');\n                ctx.connectionManager.close();\n                return;\n              }\n            }\n          }\n        }\n      }\n\n      if (totalMentions === 0) {\n        console.log('No unlinked mentions found.');\n      } else {\n        console.log(`\\nTotal mentions found: ${totalMentions}`);\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Discovery failed:', error);\n      process.exit(1);\n    }\n  });\n","import { NodeRepository } from '../storage/database/repositories/index.js';\nimport { findExclusionZones, type ExclusionZone } from '../parser/exclusions.js';\nimport { parseFrontmatter } from '../parser/frontmatter.js';\nimport { FileSystemError, ParseError } from '../core/errors.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport interface DetectedMention {\n  targetId: string;\n  targetTitle: string;\n  surfaceText: string;\n  spanStart: number;\n  spanEnd: number;\n  matchType: 'title' | 'alias';\n}\n\nexport interface MentionDetectorOptions {\n  nodeRepository: NodeRepository;\n  vaultPath?: string;\n}\n\n/**\n * Detects unlinked mentions of nodes in content\n * Following spec 8.1:\n * 1. Strip excluded zones (code, links, URLs, frontmatter)\n * 2. Match titles/aliases with boundary-aware rules\n * 3. Deduplicate overlapping (prefer longer matches)\n */\nexport class MentionDetector {\n  private nodeRepo: NodeRepository;\n  private vaultPath: string;\n  private titleIndex: Map<string, { nodeId: string; title: string }[]> = new Map();\n  private aliasIndex: Map<string, { nodeId: string; title: string; alias: string }[]> = new Map();\n\n  constructor(options: MentionDetectorOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.vaultPath = options.vaultPath || process.cwd();\n  }\n\n  /**\n   * Build the title/alias index for fast matching\n   */\n  async buildIndex(): Promise<void> {\n    this.titleIndex.clear();\n    this.aliasIndex.clear();\n\n    const nodes = await this.nodeRepo.findAll();\n\n    for (const node of nodes) {\n      // Index by title (case-insensitive)\n      const titleLower = node.title.toLowerCase();\n      if (!this.titleIndex.has(titleLower)) {\n        this.titleIndex.set(titleLower, []);\n      }\n      this.titleIndex.get(titleLower)?.push({ nodeId: node.nodeId, title: node.title });\n\n      // Index by aliases\n      const aliases = await this.nodeRepo.getAliases(node.nodeId);\n      for (const alias of aliases) {\n        const aliasLower = alias.toLowerCase();\n        if (!this.aliasIndex.has(aliasLower)) {\n          this.aliasIndex.set(aliasLower, []);\n        }\n        this.aliasIndex.get(aliasLower)?.push({\n          nodeId: node.nodeId,\n          title: node.title,\n          alias,\n        });\n      }\n    }\n  }\n\n  /**\n   * Detect mentions in a specific node\n   */\n  async detectInNode(nodeId: string): Promise<DetectedMention[]> {\n    // Ensure index is built\n    if (this.titleIndex.size === 0) {\n      await this.buildIndex();\n    }\n\n    const node = await this.nodeRepo.findById(nodeId);\n    if (!node) return [];\n\n    // Read file content\n    const filePath = path.join(this.vaultPath, node.path);\n\n    try {\n      if (!fs.existsSync(filePath)) {\n        throw new FileSystemError(`File not found: ${filePath}`, filePath);\n      }\n\n      const content = fs.readFileSync(filePath, 'utf-8');\n      return this.detectInContent(content, nodeId, node.path);\n    } catch (error) {\n      if (error instanceof FileSystemError) {\n        throw error;\n      }\n      throw new FileSystemError(\n        `Failed to read file for mention detection: ${error instanceof Error ? error.message : String(error)}`,\n        filePath\n      );\n    }\n  }\n\n  /**\n   * Detect mentions in content\n   */\n  detectInContent(content: string, sourceNodeId: string, sourcePath: string): DetectedMention[] {\n    // Parse frontmatter to get content offset\n    let contentStartOffset: number;\n    try {\n      const parsed = parseFrontmatter(content, sourcePath);\n      contentStartOffset = parsed.contentStartOffset;\n    } catch (error) {\n      throw new ParseError(\n        `Failed to parse frontmatter: ${error instanceof Error ? error.message : String(error)}`,\n        sourcePath\n      );\n    }\n\n    // Get exclusion zones\n    const exclusionZones = findExclusionZones(content, 0);\n\n    // Collect all potential matches\n    const allMatches: Array<DetectedMention & { start: number; end: number }> = [];\n\n    // Match titles\n    for (const [titleLower, nodes] of this.titleIndex) {\n      // Skip single character matches\n      if (titleLower.length < 2) continue;\n\n      // Skip if this is the source node\n      const isSourceNode = nodes.some((n) => n.nodeId === sourceNodeId);\n      if (isSourceNode) continue;\n\n      // Build boundary-aware regex\n      const pattern = this.buildBoundaryPattern(titleLower);\n      if (!pattern) continue;\n\n      const regex = new RegExp(pattern, 'gi');\n      let match;\n\n      while ((match = regex.exec(content)) !== null) {\n        if (match.index === undefined) continue;\n\n        const start = match.index;\n        const end = start + match[0].length;\n\n        // Skip if in exclusion zone\n        if (this.isInExclusionZone(start, end, exclusionZones)) continue;\n\n        // Skip if in frontmatter\n        if (start < contentStartOffset) continue;\n\n        for (const nodeInfo of nodes) {\n          allMatches.push({\n            targetId: nodeInfo.nodeId,\n            targetTitle: nodeInfo.title,\n            surfaceText: match[0],\n            spanStart: start,\n            spanEnd: end,\n            matchType: 'title',\n            start,\n            end,\n          });\n        }\n      }\n    }\n\n    // Match aliases\n    for (const [aliasLower, nodes] of this.aliasIndex) {\n      // Skip single character matches\n      if (aliasLower.length < 2) continue;\n\n      // Skip if this is the source node\n      const isSourceNode = nodes.some((n) => n.nodeId === sourceNodeId);\n      if (isSourceNode) continue;\n\n      // Build boundary-aware regex\n      const pattern = this.buildBoundaryPattern(aliasLower);\n      if (!pattern) continue;\n\n      const regex = new RegExp(pattern, 'gi');\n      let match;\n\n      while ((match = regex.exec(content)) !== null) {\n        if (match.index === undefined) continue;\n\n        const start = match.index;\n        const end = start + match[0].length;\n\n        // Skip if in exclusion zone\n        if (this.isInExclusionZone(start, end, exclusionZones)) continue;\n\n        // Skip if in frontmatter\n        if (start < contentStartOffset) continue;\n\n        for (const nodeInfo of nodes) {\n          allMatches.push({\n            targetId: nodeInfo.nodeId,\n            targetTitle: nodeInfo.title,\n            surfaceText: match[0],\n            spanStart: start,\n            spanEnd: end,\n            matchType: 'alias',\n            start,\n            end,\n          });\n        }\n      }\n    }\n\n    // Deduplicate overlapping matches (prefer longer)\n    return this.deduplicateMatches(allMatches);\n  }\n\n  /**\n   * Build a boundary-aware regex pattern\n   */\n  private buildBoundaryPattern(text: string): string | null {\n    // Escape regex special characters\n    const escaped = text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n    // Word boundary pattern that handles various contexts\n    // Matches when surrounded by non-word characters or at string boundaries\n    return `(?<![\\\\w])${escaped}(?![\\\\w])`;\n  }\n\n  /**\n   * Check if a range is in an exclusion zone\n   */\n  private isInExclusionZone(start: number, end: number, zones: ExclusionZone[]): boolean {\n    return zones.some((zone) => start < zone.end && end > zone.start);\n  }\n\n  /**\n   * Deduplicate overlapping matches, preferring longer matches\n   */\n  private deduplicateMatches(\n    matches: Array<DetectedMention & { start: number; end: number }>\n  ): DetectedMention[] {\n    if (matches.length === 0) return [];\n\n    // Sort by start position, then by length (descending)\n    matches.sort((a, b) => {\n      if (a.start !== b.start) return a.start - b.start;\n      return b.end - b.start - (a.end - a.start);\n    });\n\n    const result: DetectedMention[] = [];\n    let lastEnd = -1;\n\n    for (const match of matches) {\n      // Skip if this match overlaps with previous\n      if (match.start < lastEnd) continue;\n\n      result.push({\n        targetId: match.targetId,\n        targetTitle: match.targetTitle,\n        surfaceText: match.surfaceText,\n        spanStart: match.spanStart,\n        spanEnd: match.spanEnd,\n        matchType: match.matchType,\n      });\n\n      lastEnd = match.end;\n    }\n\n    return result;\n  }\n\n  /**\n   * Clear the index (call when nodes change)\n   */\n  clearIndex(): void {\n    this.titleIndex.clear();\n    this.aliasIndex.clear();\n  }\n}\n","import type { DetectedMention } from './mention-detector.js';\nimport type { ZettelScriptConfig } from '../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../core/types/index.js';\nimport { EdgeRepository } from '../storage/database/repositories/index.js';\nimport { GraphEngine } from '../core/graph/engine.js';\n\nexport interface RankedMention extends DetectedMention {\n  confidence: number;\n  reasons: string[];\n}\n\nexport interface MentionRankerOptions {\n  edgeRepository: EdgeRepository;\n  graphEngine: GraphEngine;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Ranks detected mentions by likelihood of being intentional\n * Following spec 8.1 ranking factors:\n * - Ambiguity penalty\n * - Graph locality (distance from source)\n * - Centrality (importance in graph)\n * - Frequency (how often this target is mentioned)\n */\nexport class MentionRanker {\n  private edgeRepo: EdgeRepository;\n  private graphEngine: GraphEngine;\n  private config: ZettelScriptConfig;\n\n  // Weighting factors from config\n  private weights: {\n    locality: number;\n    centrality: number;\n    frequency: number;\n    matchQuality: number;\n  };\n\n  private ambiguityPenalty: number;\n  private confidenceThreshold: number;\n  private expansionMaxDepth: number;\n  private expansionBudget: number;\n\n  constructor(options: MentionRankerOptions) {\n    this.edgeRepo = options.edgeRepository;\n    this.graphEngine = options.graphEngine;\n    this.config = options.config ?? DEFAULT_CONFIG;\n\n    // Initialize from config\n    this.weights = { ...this.config.discovery.weights };\n    this.ambiguityPenalty = this.config.discovery.ambiguityPenalty;\n    this.confidenceThreshold = this.config.discovery.confidenceThreshold;\n    this.expansionMaxDepth = this.config.discovery.expansionMaxDepth;\n    this.expansionBudget = this.config.discovery.expansionBudget;\n  }\n\n  /**\n   * Rank a list of detected mentions\n   */\n  async rank(mentions: DetectedMention[], sourceNodeId?: string): Promise<RankedMention[]> {\n    if (mentions.length === 0) return [];\n\n    // Get unique target IDs\n    const targetIds = [...new Set(mentions.map((m) => m.targetId))];\n\n    // Calculate centrality scores\n    const centralityScores = await this.calculateCentrality(targetIds);\n\n    // Calculate locality scores if source provided\n    const localityScores = sourceNodeId\n      ? await this.calculateLocality(sourceNodeId, targetIds)\n      : new Map<string, number>();\n\n    // Calculate frequency scores\n    const frequencyScores = await this.calculateFrequency(targetIds);\n\n    // Rank each mention\n    const ranked: RankedMention[] = [];\n\n    for (const mention of mentions) {\n      const reasons: string[] = [];\n      let score = 0;\n\n      // Match quality score\n      const matchQualityScore = this.calculateMatchQuality(mention);\n      score += matchQualityScore * this.weights.matchQuality;\n      if (matchQualityScore > 0.7) {\n        reasons.push('exact_match');\n      }\n\n      // Locality score\n      const localityScore = localityScores.get(mention.targetId) ?? 0.5;\n      score += localityScore * this.weights.locality;\n      if (localityScore > 0.7) {\n        reasons.push('nearby_in_graph');\n      }\n\n      // Centrality score\n      const centralityScore = centralityScores.get(mention.targetId) ?? 0.5;\n      score += centralityScore * this.weights.centrality;\n      if (centralityScore > 0.7) {\n        reasons.push('important_node');\n      }\n\n      // Frequency score\n      const frequencyScore = frequencyScores.get(mention.targetId) ?? 0.5;\n      score += frequencyScore * this.weights.frequency;\n      if (frequencyScore > 0.7) {\n        reasons.push('frequently_linked');\n      }\n\n      // Ambiguity penalty\n      const ambiguousTargets = mentions.filter(\n        (m) =>\n          m.surfaceText.toLowerCase() === mention.surfaceText.toLowerCase() &&\n          m.targetId !== mention.targetId\n      );\n      if (ambiguousTargets.length > 0) {\n        score *= this.ambiguityPenalty; // Reduce confidence for ambiguous matches\n        reasons.push('ambiguous');\n      }\n\n      ranked.push({\n        ...mention,\n        confidence: Math.min(1, Math.max(0, score)),\n        reasons,\n      });\n    }\n\n    // Sort by confidence (descending)\n    return ranked.sort((a, b) => b.confidence - a.confidence);\n  }\n\n  /**\n   * Calculate match quality based on how well the surface text matches\n   */\n  private calculateMatchQuality(mention: DetectedMention): number {\n    const surface = mention.surfaceText.toLowerCase();\n    const target = mention.targetTitle.toLowerCase();\n\n    // Exact match with original casing preserved\n    if (mention.surfaceText === mention.targetTitle) {\n      return 1.0;\n    }\n\n    // Case-insensitive exact match\n    if (surface === target) {\n      return 0.95;\n    }\n\n    // Alias match\n    if (mention.matchType === 'alias') {\n      return 0.85;\n    }\n\n    // Partial match (shouldn't happen with current detection, but handle it)\n    return 0.7;\n  }\n\n  /**\n   * Calculate centrality scores (based on incoming link count)\n   */\n  private async calculateCentrality(nodeIds: string[]): Promise<Map<string, number>> {\n    const scores = new Map<string, number>();\n\n    // Get max in-degree for normalization\n    let maxInDegree = 1;\n    const inDegrees = new Map<string, number>();\n\n    for (const nodeId of nodeIds) {\n      const incoming = await this.edgeRepo.findIncoming(nodeId);\n      const inDegree = incoming.length;\n      inDegrees.set(nodeId, inDegree);\n      maxInDegree = Math.max(maxInDegree, inDegree);\n    }\n\n    // Normalize scores\n    for (const nodeId of nodeIds) {\n      const inDegree = inDegrees.get(nodeId) ?? 0;\n      // Use log scale to prevent very popular nodes from dominating\n      scores.set(nodeId, Math.log(inDegree + 1) / Math.log(maxInDegree + 1));\n    }\n\n    return scores;\n  }\n\n  /**\n   * Calculate locality scores (graph distance from source)\n   */\n  private async calculateLocality(\n    sourceNodeId: string,\n    targetNodeIds: string[]\n  ): Promise<Map<string, number>> {\n    const scores = new Map<string, number>();\n\n    // Expand from source to find distances\n    const expansion = await this.graphEngine.expandGraph({\n      seedNodes: [{ nodeId: sourceNodeId, score: 1 }],\n      maxDepth: this.expansionMaxDepth,\n      budget: this.expansionBudget,\n      includeIncoming: true,\n    });\n\n    const distanceMap = new Map(expansion.map((e) => [e.nodeId, e.depth]));\n\n    for (const targetId of targetNodeIds) {\n      const distance = distanceMap.get(targetId);\n\n      if (distance === undefined) {\n        // Not connected - low locality score\n        scores.set(targetId, 0.1);\n      } else if (distance === 0) {\n        // Same node - shouldn't happen\n        scores.set(targetId, 0);\n      } else {\n        // Score decreases with distance\n        scores.set(targetId, 1 / distance);\n      }\n    }\n\n    return scores;\n  }\n\n  /**\n   * Calculate frequency scores (how often target is linked to)\n   */\n  private async calculateFrequency(nodeIds: string[]): Promise<Map<string, number>> {\n    const scores = new Map<string, number>();\n\n    // Count total incoming explicit links\n    let maxLinks = 1;\n    const linkCounts = new Map<string, number>();\n\n    for (const nodeId of nodeIds) {\n      const backlinks = await this.edgeRepo.findBacklinks(nodeId);\n      const count = backlinks.length;\n      linkCounts.set(nodeId, count);\n      maxLinks = Math.max(maxLinks, count);\n    }\n\n    // Normalize\n    for (const nodeId of nodeIds) {\n      const count = linkCounts.get(nodeId) ?? 0;\n      scores.set(nodeId, count / maxLinks);\n    }\n\n    return scores;\n  }\n\n  /**\n   * Filter mentions below a confidence threshold\n   */\n  filterByThreshold(mentions: RankedMention[], threshold?: number): RankedMention[] {\n    const thresh = threshold ?? this.confidenceThreshold;\n    return mentions.filter((m) => m.confidence >= thresh);\n  }\n\n  /**\n   * Group mentions by target\n   */\n  groupByTarget(mentions: RankedMention[]): Map<string, RankedMention[]> {\n    const groups = new Map<string, RankedMention[]>();\n\n    for (const mention of mentions) {\n      const existing = groups.get(mention.targetId) || [];\n      existing.push(mention);\n      groups.set(mention.targetId, existing);\n    }\n\n    return groups;\n  }\n}\n","import * as readline from 'node:readline';\nimport type { RankedMention } from '../discovery/mention-ranker.js';\nimport { EdgeRepository } from '../storage/database/repositories/index.js';\nimport { DatabaseError } from '../core/errors.js';\n\nexport type ApprovalAction = 'approve' | 'reject' | 'defer' | 'skip' | 'quit' | 'approveAll';\n\nexport interface ApprovalResult {\n  mention: RankedMention;\n  action: ApprovalAction;\n}\n\nexport interface InteractiveApproverOptions {\n  edgeRepository: EdgeRepository;\n  sourceNodeId: string;\n}\n\n/**\n * Interactive mention approver using readline\n * Supports commands: (y)es, (n)o, (d)efer, (a)ll, (s)kip, (q)uit\n */\nexport class InteractiveApprover {\n  private edgeRepo: EdgeRepository;\n  private sourceNodeId: string;\n  private rl: readline.Interface | null = null;\n\n  constructor(options: InteractiveApproverOptions) {\n    this.edgeRepo = options.edgeRepository;\n    this.sourceNodeId = options.sourceNodeId;\n  }\n\n  /**\n   * Check if running in a TTY environment\n   */\n  isTTY(): boolean {\n    return process.stdin.isTTY === true && process.stdout.isTTY === true;\n  }\n\n  /**\n   * Approve a single mention interactively\n   */\n  async approveMention(mention: RankedMention): Promise<ApprovalAction> {\n    if (!this.isTTY()) {\n      console.warn('Not running in interactive mode (non-TTY). Use --batch flag instead.');\n      return 'skip';\n    }\n\n    // Display mention info\n    console.log(`\\n  \"${mention.surfaceText}\" -> ${mention.targetTitle}`);\n    console.log(`  Confidence: ${(mention.confidence * 100).toFixed(0)}%`);\n    if (mention.reasons && mention.reasons.length > 0) {\n      console.log(`  Reasons: ${mention.reasons.join(', ')}`);\n    }\n\n    const action = await this.promptAction();\n    return action;\n  }\n\n  /**\n   * Approve multiple mentions interactively\n   */\n  async approveAll(mentions: RankedMention[]): Promise<ApprovalResult[]> {\n    const results: ApprovalResult[] = [];\n    let approveRemaining = false;\n\n    for (const mention of mentions) {\n      if (approveRemaining) {\n        // Auto-approve remaining\n        await this.createMentionEdge(mention);\n        results.push({ mention, action: 'approve' });\n        continue;\n      }\n\n      const action = await this.approveMention(mention);\n\n      switch (action) {\n        case 'approve':\n          await this.createMentionEdge(mention);\n          results.push({ mention, action: 'approve' });\n          break;\n\n        case 'approveAll':\n          await this.createMentionEdge(mention);\n          results.push({ mention, action: 'approve' });\n          approveRemaining = true;\n          break;\n\n        case 'reject':\n          results.push({ mention, action: 'reject' });\n          break;\n\n        case 'defer':\n          results.push({ mention, action: 'defer' });\n          break;\n\n        case 'skip':\n          results.push({ mention, action: 'skip' });\n          break;\n\n        case 'quit':\n          results.push({ mention, action: 'quit' });\n          this.close();\n          return results;\n      }\n    }\n\n    this.close();\n    return results;\n  }\n\n  /**\n   * Prompt user for action with retry limit\n   */\n  private async promptAction(): Promise<ApprovalAction> {\n    const maxRetries = 10;\n    let retries = 0;\n\n    while (retries < maxRetries) {\n      try {\n        const answer = await this.question('  Approve? (y)es/(n)o/(d)efer/(a)ll/(s)kip/(q)uit: ');\n        const action = this.parseAnswer(answer);\n        if (action) return action;\n        console.log('  Invalid input. Use y/n/d/a/s/q');\n        retries++;\n      } catch (error) {\n        this.close();\n        throw error;\n      }\n    }\n\n    // Default to skip after max retries\n    return 'skip';\n  }\n\n  /**\n   * Parse user answer into an action\n   */\n  private parseAnswer(answer: string): ApprovalAction | null {\n    const normalized = answer.toLowerCase().trim();\n\n    switch (normalized) {\n      case 'y':\n      case 'yes':\n        return 'approve';\n      case 'n':\n      case 'no':\n        return 'reject';\n      case 'd':\n      case 'defer':\n        return 'defer';\n      case 'a':\n      case 'all':\n        return 'approveAll';\n      case 's':\n      case 'skip':\n        return 'skip';\n      case 'q':\n      case 'quit':\n        return 'quit';\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Promisified readline question\n   */\n  private question(prompt: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n      if (!this.rl) {\n        this.rl = readline.createInterface({\n          input: process.stdin,\n          output: process.stdout,\n        });\n\n        this.rl.on('close', () => {\n          // Handle readline being closed externally\n        });\n\n        this.rl.on('error', (err) => {\n          reject(err);\n        });\n      }\n\n      this.rl.question(prompt, (answer) => {\n        resolve(answer);\n      });\n    });\n  }\n\n  /**\n   * Create a mention edge in the database\n   */\n  private async createMentionEdge(mention: RankedMention): Promise<void> {\n    try {\n      await this.edgeRepo.create({\n        sourceId: this.sourceNodeId,\n        targetId: mention.targetId,\n        edgeType: 'mention',\n        provenance: 'user_approved',\n        strength: mention.confidence,\n        attributes: {\n          surfaceText: mention.surfaceText,\n          spanStart: mention.spanStart,\n          spanEnd: mention.spanEnd,\n          approvedAt: new Date().toISOString(),\n        },\n      });\n    } catch (error) {\n      throw new DatabaseError(\n        `Failed to create mention edge: ${error instanceof Error ? error.message : String(error)}`,\n        {\n          sourceId: this.sourceNodeId,\n          targetId: mention.targetId,\n        }\n      );\n    }\n  }\n\n  /**\n   * Close the readline interface\n   */\n  close(): void {\n    if (this.rl) {\n      this.rl.close();\n      this.rl = null;\n    }\n  }\n}\n\n/**\n * Batch approve mentions without interaction\n */\nexport async function batchApproveMentions(\n  mentions: RankedMention[],\n  sourceNodeId: string,\n  edgeRepo: EdgeRepository,\n  action: 'approve' | 'reject' | 'defer'\n): Promise<ApprovalResult[]> {\n  const results: ApprovalResult[] = [];\n\n  for (const mention of mentions) {\n    if (action === 'approve') {\n      await edgeRepo.create({\n        sourceId: sourceNodeId,\n        targetId: mention.targetId,\n        edgeType: 'mention',\n        provenance: 'user_approved',\n        strength: mention.confidence,\n        attributes: {\n          surfaceText: mention.surfaceText,\n          spanStart: mention.spanStart,\n          spanEnd: mention.spanEnd,\n          approvedAt: new Date().toISOString(),\n        },\n      });\n    }\n\n    results.push({ mention, action });\n  }\n\n  return results;\n}\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { ContextAssembler } from '../../retrieval/context/assembler.js';\nimport type { RetrievalQuery } from '../../core/types/index.js';\n\nexport const retrieveCommand = new Command('retrieve')\n  .description('GraphRAG retrieval for a query')\n  .argument('<query>', 'The query to retrieve context for')\n  .option('-n, --max-results <n>', 'Maximum results', '10')\n  .option('-d, --depth <n>', 'Graph expansion depth', '2')\n  .option('-b, --budget <n>', 'Node expansion budget', '30')\n  .option('--no-semantic', 'Disable semantic search')\n  .option('--no-lexical', 'Disable lexical search')\n  .option('--no-graph', 'Disable graph expansion')\n  .option('-t, --type <types>', 'Filter by node types (comma-separated)')\n  .option('-v, --verbose', 'Show detailed provenance')\n  .action(async (queryText: string, options) => {\n    try {\n      const ctx = await initContext();\n\n      // Check if embeddings are configured\n      if (!ctx.config.embeddings.apiKey && ctx.config.embeddings.provider === 'openai') {\n        console.log('Note: OpenAI API key not configured. Semantic search disabled.');\n        console.log('Set OPENAI_API_KEY or configure in .zettelscript/config.yaml\\n');\n      }\n\n      const query: RetrievalQuery = {\n        text: queryText,\n        maxResults: parseInt(options.maxResults, 10),\n        expansion: {\n          maxDepth: parseInt(options.depth, 10),\n          budget: parseInt(options.budget, 10),\n        },\n      };\n\n      if (options.type) {\n        query.filters = {\n          nodeTypes: options.type.split(',').map((t: string) => t.trim()),\n        };\n      }\n\n      console.log(`Retrieving: \"${queryText}\"\\n`);\n\n      const assembler = new ContextAssembler({\n        nodeRepository: ctx.nodeRepository,\n        edgeRepository: ctx.edgeRepository,\n        chunkRepository: ctx.chunkRepository,\n        graphEngine: ctx.graphEngine,\n        config: ctx.config.retrieval,\n      });\n\n      const result = await assembler.retrieve(query);\n\n      if (result.chunks.length === 0) {\n        console.log('No relevant content found.');\n        console.log('\\nTips:');\n        console.log('  - Run \"zettel index\" to index your vault');\n        console.log('  - Try broader search terms');\n        console.log('  - Use \"zettel query stats\" to check indexed content');\n      } else {\n        // Show context\n        console.log('=== Retrieved Context ===\\n');\n        console.log(result.context);\n        console.log('\\n=== End Context ===\\n');\n\n        // Show provenance\n        if (options.verbose && result.provenance.length > 0) {\n          console.log('Sources:');\n          for (const p of result.provenance) {\n            const contribution = (p.contribution * 100).toFixed(0);\n            console.log(`  [${contribution}%] ${p.path}`);\n          }\n        } else {\n          console.log(`Sources: ${result.provenance.length} nodes`);\n        }\n\n        // Show match types\n        const matchTypes = new Map<string, number>();\n        for (const chunk of result.chunks) {\n          matchTypes.set(chunk.matchType, (matchTypes.get(chunk.matchType) || 0) + 1);\n        }\n\n        console.log('\\nMatch breakdown:');\n        for (const [type, count] of matchTypes) {\n          console.log(`  ${type}: ${count}`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Retrieval failed:', error);\n      process.exit(1);\n    }\n  });\n","import type { Edge, EdgeType, ZettelScriptConfig } from '../../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../../core/types/index.js';\nimport { EdgeRepository } from '../../storage/database/repositories/index.js';\n\nexport interface ExpansionOptions {\n  maxDepth: number;\n  budget: number;\n  edgeTypes: EdgeType[];\n  decayFactor: number;\n  includeIncoming: boolean;\n  scoreThreshold?: number;\n}\n\nexport interface ExpandedNode {\n  nodeId: string;\n  depth: number;\n  score: number;\n  path: string[];\n  edgeType: EdgeType | null;\n}\n\nexport interface GraphExpanderOptions {\n  edgeRepository: EdgeRepository;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Bounded graph expansion for GraphRAG retrieval\n *\n * Algorithm (from spec 7.3):\n * frontier = seed_nodes\n * for depth in 1..max_depth:\n *     if visited_count >= budget: break\n *     for node in frontier:\n *         for edge in outgoing_edges(node, allowed_types):\n *             score = current_score * edge_weight * decay^depth\n *             accumulated_scores[edge.target] = max(existing, score)\n *     frontier = newly_discovered_nodes\n */\nexport class GraphExpander {\n  private edgeRepo: EdgeRepository;\n  private config: ZettelScriptConfig;\n\n  constructor(options: GraphExpanderOptions | EdgeRepository) {\n    // Support both old and new constructor signature for backwards compatibility\n    if ('edgeRepository' in options) {\n      this.edgeRepo = options.edgeRepository;\n      this.config = options.config ?? DEFAULT_CONFIG;\n    } else {\n      this.edgeRepo = options;\n      this.config = DEFAULT_CONFIG;\n    }\n  }\n\n  /**\n   * Expand from seed nodes with bounded traversal\n   */\n  async expand(\n    seeds: Array<{ nodeId: string; score: number }>,\n    options: ExpansionOptions\n  ): Promise<ExpandedNode[]> {\n    const {\n      maxDepth,\n      budget,\n      edgeTypes,\n      decayFactor,\n      includeIncoming,\n      scoreThreshold = this.config.graph.scoreThreshold,\n    } = options;\n\n    if (seeds.length === 0) return [];\n\n    // Track accumulated scores and paths\n    const accumulated = new Map<string, ExpandedNode>();\n\n    // Initialize with seeds\n    let frontier = new Set<string>();\n    for (const seed of seeds) {\n      accumulated.set(seed.nodeId, {\n        nodeId: seed.nodeId,\n        depth: 0,\n        score: seed.score,\n        path: [seed.nodeId],\n        edgeType: null,\n      });\n      frontier.add(seed.nodeId);\n    }\n\n    // BFS with decay\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (accumulated.size >= budget) break;\n      if (frontier.size === 0) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (accumulated.size >= budget) break;\n\n        const current = accumulated.get(nodeId);\n        if (!current) continue;\n\n        // Get edges\n        const edges = await this.getEdges(nodeId, edgeTypes, includeIncoming);\n\n        for (const edge of edges) {\n          if (accumulated.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Calculate score with decay\n          const edgeWeight = edge.strength ?? 1.0;\n          const newScore = current.score * edgeWeight * Math.pow(decayFactor, depth);\n\n          // Skip if below threshold\n          if (newScore < scoreThreshold) continue;\n\n          const existing = accumulated.get(targetId);\n\n          if (!existing || newScore > existing.score) {\n            accumulated.set(targetId, {\n              nodeId: targetId,\n              depth,\n              score: newScore,\n              path: [...current.path, targetId],\n              edgeType: edge.edgeType as EdgeType,\n            });\n\n            if (!existing) {\n              newFrontier.add(targetId);\n            }\n          }\n        }\n      }\n\n      frontier = newFrontier;\n    }\n\n    // Convert to array and sort by score\n    return Array.from(accumulated.values()).sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Get edges for a node\n   */\n  private async getEdges(\n    nodeId: string,\n    edgeTypes: EdgeType[],\n    includeIncoming: boolean\n  ): Promise<Edge[]> {\n    const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n    if (!includeIncoming) {\n      return outgoing;\n    }\n\n    const incoming = await this.edgeRepo.findIncoming(nodeId, edgeTypes);\n    return [...outgoing, ...incoming];\n  }\n\n  /**\n   * Expand with prioritized edge types\n   * Some edge types are more valuable for retrieval\n   */\n  async expandPrioritized(\n    seeds: Array<{ nodeId: string; score: number }>,\n    options: ExpansionOptions,\n    edgeWeights: Partial<Record<EdgeType, number>>\n  ): Promise<ExpandedNode[]> {\n    const {\n      maxDepth,\n      budget,\n      edgeTypes,\n      decayFactor,\n      includeIncoming,\n      scoreThreshold = this.config.graph.scoreThreshold,\n    } = options;\n\n    if (seeds.length === 0) return [];\n\n    const accumulated = new Map<string, ExpandedNode>();\n\n    let frontier = new Set<string>();\n    for (const seed of seeds) {\n      accumulated.set(seed.nodeId, {\n        nodeId: seed.nodeId,\n        depth: 0,\n        score: seed.score,\n        path: [seed.nodeId],\n        edgeType: null,\n      });\n      frontier.add(seed.nodeId);\n    }\n\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (accumulated.size >= budget) break;\n      if (frontier.size === 0) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (accumulated.size >= budget) break;\n\n        const current = accumulated.get(nodeId);\n        if (!current) continue;\n\n        const edges = await this.getEdges(nodeId, edgeTypes, includeIncoming);\n\n        for (const edge of edges) {\n          if (accumulated.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Apply edge type weight\n          const typeWeight = edgeWeights[edge.edgeType as EdgeType] ?? 1.0;\n          const edgeWeight = (edge.strength ?? 1.0) * typeWeight;\n          const newScore = current.score * edgeWeight * Math.pow(decayFactor, depth);\n\n          if (newScore < scoreThreshold) continue;\n\n          const existing = accumulated.get(targetId);\n\n          if (!existing || newScore > existing.score) {\n            accumulated.set(targetId, {\n              nodeId: targetId,\n              depth,\n              score: newScore,\n              path: [...current.path, targetId],\n              edgeType: edge.edgeType as EdgeType,\n            });\n\n            if (!existing) {\n              newFrontier.add(targetId);\n            }\n          }\n        }\n      }\n\n      frontier = newFrontier;\n    }\n\n    return Array.from(accumulated.values()).sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Get expansion statistics\n   */\n  getExpansionStats(results: ExpandedNode[]): {\n    totalNodes: number;\n    maxDepth: number;\n    avgScore: number;\n    edgeTypeCounts: Record<string, number>;\n  } {\n    if (results.length === 0) {\n      return {\n        totalNodes: 0,\n        maxDepth: 0,\n        avgScore: 0,\n        edgeTypeCounts: {},\n      };\n    }\n\n    const edgeTypeCounts: Record<string, number> = {};\n    let totalScore = 0;\n    let maxDepth = 0;\n\n    for (const result of results) {\n      totalScore += result.score;\n      maxDepth = Math.max(maxDepth, result.depth);\n\n      if (result.edgeType) {\n        edgeTypeCounts[result.edgeType] = (edgeTypeCounts[result.edgeType] || 0) + 1;\n      }\n    }\n\n    return {\n      totalNodes: results.length,\n      maxDepth,\n      avgScore: totalScore / results.length,\n      edgeTypeCounts,\n    };\n  }\n}\n","/**\n * Reciprocal Rank Fusion (RRF) implementation\n *\n * Algorithm:\n * for each result in semantic_results:\n *     rrf_score += semantic_weight * (1 / (k + rank))\n * for each result in lexical_results:\n *     rrf_score += lexical_weight * (1 / (k + rank))\n * sort by rrf_score descending\n */\n\nexport interface RankedItem {\n  id: string;\n  score: number;\n  source: string;\n}\n\nexport interface FusionResult {\n  id: string;\n  score: number;\n  sources: string[];\n  ranks: Map<string, number>;\n}\n\nexport interface RRFOptions {\n  k?: number; // RRF constant (default 60)\n  weights?: Record<string, number>; // Weights per source\n}\n\n/**\n * Perform Reciprocal Rank Fusion on multiple result lists\n */\nexport function reciprocalRankFusion(\n  resultLists: Map<string, RankedItem[]>,\n  options: RRFOptions = {}\n): FusionResult[] {\n  const k = options.k ?? 60;\n  const weights = options.weights ?? {};\n\n  // Collect scores for each item\n  const scores = new Map<\n    string,\n    {\n      score: number;\n      sources: Set<string>;\n      ranks: Map<string, number>;\n    }\n  >();\n\n  for (const [source, items] of resultLists) {\n    const weight = weights[source] ?? 1.0;\n\n    for (let rank = 0; rank < items.length; rank++) {\n      const item = items[rank];\n      if (!item) continue;\n\n      const rrfScore = weight * (1 / (k + rank + 1)); // rank is 0-indexed, formula expects 1-indexed\n\n      const existing = scores.get(item.id);\n      if (existing) {\n        existing.score += rrfScore;\n        existing.sources.add(source);\n        existing.ranks.set(source, rank + 1);\n      } else {\n        scores.set(item.id, {\n          score: rrfScore,\n          sources: new Set([source]),\n          ranks: new Map([[source, rank + 1]]),\n        });\n      }\n    }\n  }\n\n  // Convert to results and sort\n  const results: FusionResult[] = [];\n  for (const [id, data] of scores) {\n    results.push({\n      id,\n      score: data.score,\n      sources: Array.from(data.sources),\n      ranks: data.ranks,\n    });\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Simple score combination (weighted average)\n */\nexport function weightedScoreFusion(\n  resultLists: Map<string, RankedItem[]>,\n  weights: Record<string, number>\n): FusionResult[] {\n  const scores = new Map<\n    string,\n    {\n      totalScore: number;\n      totalWeight: number;\n      sources: Set<string>;\n      ranks: Map<string, number>;\n    }\n  >();\n\n  for (const [source, items] of resultLists) {\n    const weight = weights[source] ?? 1.0;\n\n    for (let rank = 0; rank < items.length; rank++) {\n      const item = items[rank];\n      if (!item) continue;\n\n      const existing = scores.get(item.id);\n      if (existing) {\n        existing.totalScore += item.score * weight;\n        existing.totalWeight += weight;\n        existing.sources.add(source);\n        existing.ranks.set(source, rank + 1);\n      } else {\n        scores.set(item.id, {\n          totalScore: item.score * weight,\n          totalWeight: weight,\n          sources: new Set([source]),\n          ranks: new Map([[source, rank + 1]]),\n        });\n      }\n    }\n  }\n\n  const results: FusionResult[] = [];\n  for (const [id, data] of scores) {\n    results.push({\n      id,\n      score: data.totalScore / data.totalWeight,\n      sources: Array.from(data.sources),\n      ranks: data.ranks,\n    });\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Interleave results from multiple sources\n */\nexport function interleave(\n  resultLists: Map<string, RankedItem[]>,\n  maxResults: number\n): FusionResult[] {\n  const seen = new Set<string>();\n  const results: FusionResult[] = [];\n  const sources = Array.from(resultLists.keys());\n  const indices = new Map(sources.map((s) => [s, 0]));\n\n  while (results.length < maxResults) {\n    let added = false;\n\n    for (const source of sources) {\n      const items = resultLists.get(source) ?? [];\n      let idx = indices.get(source) ?? 0;\n\n      while (idx < items.length) {\n        const item = items[idx];\n        idx++;\n        indices.set(source, idx);\n\n        if (!item || seen.has(item.id)) continue;\n\n        seen.add(item.id);\n        results.push({\n          id: item.id,\n          score: item.score,\n          sources: [source],\n          ranks: new Map([[source, idx]]),\n        });\n        added = true;\n        break;\n      }\n\n      if (results.length >= maxResults) break;\n    }\n\n    if (!added) break;\n  }\n\n  return results;\n}\n\n/**\n * Combine fusion results with score boosting for items in multiple sources\n */\nexport function boostOverlap(results: FusionResult[], boostFactor: number = 1.2): FusionResult[] {\n  return results\n    .map((r) => ({\n      ...r,\n      score: r.score * Math.pow(boostFactor, r.sources.length - 1),\n    }))\n    .sort((a, b) => b.score - a.score);\n}\n","import type {\n  Chunk,\n  Node,\n  RetrievalQuery,\n  RetrievalResult,\n  EdgeType,\n} from '../../core/types/index.js';\nimport {\n  NodeRepository,\n  EdgeRepository,\n  ChunkRepository,\n} from '../../storage/database/repositories/index.js';\nimport type { GraphEngine } from '../../core/graph/engine.js';\nimport { GraphExpander, type ExpandedNode } from '../expansion/graph-expander.js';\nimport { reciprocalRankFusion, type RankedItem } from '../fusion/rrf.js';\n\nexport interface ContextAssemblerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  chunkRepository: ChunkRepository;\n  graphEngine: GraphEngine;\n  config: {\n    defaultMaxResults: number;\n    semanticWeight: number;\n    lexicalWeight: number;\n    graphWeight: number;\n    rrfK: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n}\n\ninterface ScoredChunk {\n  chunk: Chunk;\n  node: Node;\n  score: number;\n  matchType: 'semantic' | 'lexical' | 'graph';\n}\n\n/**\n * Assembles context from multiple retrieval strategies\n */\nexport class ContextAssembler {\n  private nodeRepo: NodeRepository;\n  private chunkRepo: ChunkRepository;\n  private expander: GraphExpander;\n  private config: ContextAssemblerOptions['config'];\n\n  constructor(options: ContextAssemblerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.chunkRepo = options.chunkRepository;\n    this.expander = new GraphExpander(options.edgeRepository);\n    this.config = options.config;\n  }\n\n  /**\n   * Main retrieval function\n   */\n  async retrieve(query: RetrievalQuery): Promise<RetrievalResult> {\n    const maxResults = query.maxResults ?? this.config.defaultMaxResults;\n\n    // Step 1: Seed retrieval (lexical for now, semantic when embeddings available)\n    const lexicalResults = await this.lexicalSearch(query.text, maxResults * 2);\n\n    // Step 2: Apply filters\n    const filteredLexical = await this.applyFilters(lexicalResults, query.filters);\n\n    // Step 3: Extract seed nodes\n    const seedNodes = this.extractSeeds(filteredLexical);\n\n    // Step 4: Graph expansion\n    const expansionOptions = {\n      maxDepth: query.expansion?.maxDepth ?? this.config.expansionMaxDepth,\n      budget: query.expansion?.budget ?? this.config.expansionBudget,\n      edgeTypes: (query.expansion?.edgeTypes ?? [\n        'explicit_link',\n        'sequence',\n        'hierarchy',\n      ]) as EdgeType[],\n      decayFactor: query.expansion?.decayFactor ?? 0.7,\n      includeIncoming: true,\n    };\n\n    const expandedNodes = await this.expander.expand(seedNodes, expansionOptions);\n\n    // Step 5: Fetch chunks for expanded nodes\n    const graphChunks = await this.fetchChunksForNodes(expandedNodes);\n\n    // Step 6: Fuse results\n    const fusedChunks = this.fuseResults(filteredLexical, graphChunks, maxResults);\n\n    // Step 7: Assemble context\n    const context = await this.assembleContext(fusedChunks);\n\n    // Step 8: Build provenance\n    const provenance = this.buildProvenance(fusedChunks);\n\n    return {\n      chunks: fusedChunks.map((sc) => ({\n        chunk: sc.chunk,\n        node: sc.node,\n        score: sc.score,\n        matchType: sc.matchType,\n      })),\n      context,\n      provenance,\n    };\n  }\n\n  /**\n   * Lexical search using FTS5\n   */\n  private async lexicalSearch(query: string, limit: number): Promise<ScoredChunk[]> {\n    const ftsResults = this.chunkRepo.searchBM25(query, limit);\n\n    if (ftsResults.length === 0) {\n      return [];\n    }\n\n    // Fetch full chunk and node data\n    const chunkIds = ftsResults.map((r) => r.chunkId);\n    const chunks = await this.chunkRepo.findByIds(chunkIds);\n    const chunkMap = new Map(chunks.map((c) => [c.chunkId, c]));\n\n    const nodeIds = [...new Set(ftsResults.map((r) => r.nodeId))];\n    const nodes = await this.nodeRepo.findByIds(nodeIds);\n    const nodeMap = new Map(nodes.map((n) => [n.nodeId, n]));\n\n    const results: ScoredChunk[] = [];\n\n    // Normalize scores\n    const maxScore = Math.max(...ftsResults.map((r) => Math.abs(r.score)));\n\n    for (const fts of ftsResults) {\n      const chunk = chunkMap.get(fts.chunkId);\n      const node = nodeMap.get(fts.nodeId);\n\n      if (chunk && node) {\n        results.push({\n          chunk,\n          node,\n          score: maxScore > 0 ? Math.abs(fts.score) / maxScore : 0.5,\n          matchType: 'lexical',\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Apply query filters\n   */\n  private async applyFilters(\n    chunks: ScoredChunk[],\n    filters?: RetrievalQuery['filters']\n  ): Promise<ScoredChunk[]> {\n    if (!filters) return chunks;\n\n    return chunks.filter((sc) => {\n      // Filter by node type\n      if (filters.nodeTypes && !filters.nodeTypes.includes(sc.node.type)) {\n        return false;\n      }\n\n      // Filter by excluded nodes\n      if (filters.excludeNodeIds?.includes(sc.node.nodeId)) {\n        return false;\n      }\n\n      // Filter by date range\n      if (filters.dateRange) {\n        const nodeDate = new Date(sc.node.updatedAt);\n        if (filters.dateRange.start && nodeDate < new Date(filters.dateRange.start)) {\n          return false;\n        }\n        if (filters.dateRange.end && nodeDate > new Date(filters.dateRange.end)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Extract seed nodes from initial results\n   */\n  private extractSeeds(chunks: ScoredChunk[]): Array<{ nodeId: string; score: number }> {\n    // Aggregate scores by node\n    const nodeScores = new Map<string, number>();\n\n    for (const sc of chunks) {\n      const current = nodeScores.get(sc.node.nodeId) ?? 0;\n      nodeScores.set(sc.node.nodeId, Math.max(current, sc.score));\n    }\n\n    return Array.from(nodeScores.entries())\n      .map(([nodeId, score]) => ({ nodeId, score }))\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 10); // Top 10 seeds\n  }\n\n  /**\n   * Fetch chunks for expanded nodes\n   */\n  private async fetchChunksForNodes(expanded: ExpandedNode[]): Promise<ScoredChunk[]> {\n    const results: ScoredChunk[] = [];\n\n    for (const exp of expanded) {\n      if (exp.depth === 0) continue; // Skip seeds, already have their chunks\n\n      const chunks = await this.chunkRepo.findByNodeId(exp.nodeId);\n      const node = await this.nodeRepo.findById(exp.nodeId);\n\n      if (!node) continue;\n\n      for (const chunk of chunks) {\n        results.push({\n          chunk,\n          node,\n          score: exp.score,\n          matchType: 'graph',\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Fuse lexical and graph results using RRF\n   */\n  private fuseResults(\n    lexical: ScoredChunk[],\n    graph: ScoredChunk[],\n    maxResults: number\n  ): ScoredChunk[] {\n    // Convert to ranked items\n    const lexicalItems: RankedItem[] = lexical.map((sc) => ({\n      id: sc.chunk.chunkId,\n      score: sc.score,\n      source: 'lexical',\n    }));\n\n    const graphItems: RankedItem[] = graph.map((sc) => ({\n      id: sc.chunk.chunkId,\n      score: sc.score,\n      source: 'graph',\n    }));\n\n    // Create chunk lookup\n    const chunkLookup = new Map<string, ScoredChunk>();\n    for (const sc of [...lexical, ...graph]) {\n      const existing = chunkLookup.get(sc.chunk.chunkId);\n      if (!existing || sc.score > existing.score) {\n        chunkLookup.set(sc.chunk.chunkId, sc);\n      }\n    }\n\n    // Perform RRF\n    const resultLists = new Map([\n      ['lexical', lexicalItems],\n      ['graph', graphItems],\n    ]);\n\n    const fused = reciprocalRankFusion(resultLists, {\n      k: this.config.rrfK,\n      weights: {\n        lexical: this.config.lexicalWeight,\n        graph: this.config.graphWeight,\n      },\n    });\n\n    // Map back to ScoredChunk\n    const results: ScoredChunk[] = [];\n    for (const f of fused.slice(0, maxResults)) {\n      const sc = chunkLookup.get(f.id);\n      if (sc) {\n        results.push({\n          ...sc,\n          score: f.score,\n          matchType: f.sources.length > 1 ? 'lexical' : (f.sources[0] as 'lexical' | 'graph'),\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Assemble context string from chunks\n   */\n  private async assembleContext(chunks: ScoredChunk[]): Promise<string> {\n    if (chunks.length === 0) {\n      return '';\n    }\n\n    // Group chunks by node for better organization\n    const nodeChunks = new Map<string, ScoredChunk[]>();\n    for (const sc of chunks) {\n      const existing = nodeChunks.get(sc.node.nodeId) ?? [];\n      existing.push(sc);\n      nodeChunks.set(sc.node.nodeId, existing);\n    }\n\n    const sections: string[] = [];\n\n    for (const [, nodeChunkList] of nodeChunks) {\n      const node = nodeChunkList[0]?.node;\n      if (!node) continue;\n\n      // Sort chunks by offset\n      nodeChunkList.sort((a, b) => a.chunk.offsetStart - b.chunk.offsetStart);\n\n      const chunkTexts = nodeChunkList.map((sc) => sc.chunk.text);\n      const combinedText = chunkTexts.join('\\n\\n');\n\n      sections.push(`## ${node.title}\\n\\n${combinedText}`);\n    }\n\n    return sections.join('\\n\\n---\\n\\n');\n  }\n\n  /**\n   * Build provenance information\n   */\n  private buildProvenance(chunks: ScoredChunk[]): RetrievalResult['provenance'] {\n    // Aggregate contribution by node\n    const nodeContributions = new Map<string, { path: string; score: number }>();\n\n    for (const sc of chunks) {\n      const existing = nodeContributions.get(sc.node.nodeId);\n      if (existing) {\n        existing.score += sc.score;\n      } else {\n        nodeContributions.set(sc.node.nodeId, {\n          path: sc.node.path,\n          score: sc.score,\n        });\n      }\n    }\n\n    // Normalize contributions\n    const totalScore = Array.from(nodeContributions.values()).reduce((sum, n) => sum + n.score, 0);\n\n    return Array.from(nodeContributions.entries())\n      .map(([nodeId, data]) => ({\n        nodeId,\n        path: data.path,\n        contribution: totalScore > 0 ? data.score / totalScore : 0,\n      }))\n      .sort((a, b) => b.contribution - a.contribution);\n  }\n}\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { ImpactAnalyzer } from '../../engine/manuscript/impact-analyzer.js';\nimport { RewriteOrchestrator } from '../../engine/manuscript/rewrite-orchestrator.js';\nimport {\n  createLLMProvider,\n  buildRewritePrompt,\n  type RewriteContext as LLMRewriteContext,\n} from '../../llm/index.js';\n\nexport const rewriteCommand = new Command('rewrite')\n  .description('Analyze and orchestrate scene rewrites')\n  .argument('<scene>', 'The scene to rewrite (path or title)')\n  .option('-g, --goal <goal>', 'Rewrite goal description')\n  .option('--analyze-only', 'Only show impact analysis, do not generate rewrite')\n  .option('--dry-run', 'Show what would change without applying')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (sceneIdentifier: string, options) => {\n    try {\n      const ctx = await initContext();\n\n      if (!ctx.config.manuscript.enabled) {\n        console.log('Manuscript mode not enabled.');\n        console.log('Enable with: zettel init --manuscript');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Find the scene node\n      let scene = await ctx.nodeRepository.findByPath(sceneIdentifier);\n      if (!scene) {\n        const nodes = await ctx.nodeRepository.findByTitle(sceneIdentifier);\n        scene = nodes.find((n) => n.type === 'scene') ?? nodes[0] ?? null;\n      }\n\n      if (!scene) {\n        console.log(`Scene not found: ${sceneIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      if (scene.type !== 'scene') {\n        console.log(`Warning: Node \"${scene.title}\" is type \"${scene.type}\", not \"scene\".`);\n      }\n\n      console.log(`Scene: ${scene.title} (${scene.path})\\n`);\n\n      // Impact analysis\n      const analyzer = new ImpactAnalyzer({\n        nodeRepository: ctx.nodeRepository,\n        edgeRepository: ctx.edgeRepository,\n        graphEngine: ctx.graphEngine,\n      });\n\n      console.log('Analyzing impact...\\n');\n      const impact = await analyzer.analyze(scene.nodeId);\n\n      // Display impact analysis\n      console.log('Impact Analysis:');\n      console.log(`  Direct dependencies:    ${impact.directImpact.length}`);\n      console.log(`  Transitive impact:      ${impact.transitiveImpact.length}`);\n      console.log(`  POV-related scenes:     ${impact.povImpact.length}`);\n      console.log(`  Timeline-adjacent:      ${impact.timelineImpact.length}`);\n      console.log(`  Affected characters:    ${impact.characterImpact.length}`);\n\n      if (options.verbose) {\n        if (impact.directImpact.length > 0) {\n          console.log('\\nDirect dependencies:');\n          const directNodes = await ctx.nodeRepository.findByIds(impact.directImpact);\n          for (const n of directNodes.slice(0, 10)) {\n            console.log(`  - ${n.title}`);\n          }\n        }\n\n        if (impact.povImpact.length > 0) {\n          console.log('\\nPOV-related scenes:');\n          const povNodes = await ctx.nodeRepository.findByIds(impact.povImpact);\n          for (const n of povNodes.slice(0, 10)) {\n            console.log(`  - ${n.title}`);\n          }\n        }\n\n        if (impact.characterImpact.length > 0) {\n          console.log('\\nAffected characters:');\n          for (const c of impact.characterImpact.slice(0, 10)) {\n            console.log(`  - ${c}`);\n          }\n        }\n      }\n\n      if (options.analyzeOnly) {\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Rewrite orchestration\n      if (!options.goal) {\n        console.log('\\nSpecify a rewrite goal with --goal \"<goal>\"');\n        console.log('Example: zettel rewrite \"Chapter 1\" --goal \"Add more tension\"');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`\\nRewrite goal: ${options.goal}\\n`);\n\n      const orchestrator = new RewriteOrchestrator({\n        nodeRepository: ctx.nodeRepository,\n        impact,\n      });\n\n      console.log('Gathering context for rewrite...\\n');\n      const context = await orchestrator.gatherContext(scene.nodeId, options.goal);\n\n      console.log('Context includes:');\n      console.log(`  - Scene content: ${context.sceneContent.length} chars`);\n      console.log(`  - Character context: ${context.characterContext.length} items`);\n      console.log(`  - Timeline context: ${context.timelineContext.length} items`);\n      console.log(`  - Related content: ${context.relatedContent.length} items`);\n\n      if (options.dryRun) {\n        console.log('\\n[Dry run] Would send to LLM for rewrite suggestions.');\n        console.log('Context would include the above information.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Try to create LLM provider\n      const llmProvider = createLLMProvider(ctx.config.llm);\n\n      if (!llmProvider) {\n        console.log('\\nLLM not configured. Add to config.yaml:');\n        console.log('  llm:');\n        console.log('    provider: openai  # or ollama');\n        console.log('    model: gpt-4');\n        console.log('    apiKey: your-api-key  # for openai');\n        console.log('\\nManual rewrite context has been gathered and displayed above.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Build rewrite context for LLM\n      const povChar = context.sceneMetadata?.pov;\n      const rewriteContext: LLMRewriteContext = {\n        sceneTitle: scene.title,\n        sceneContent: context.sceneContent,\n        goal: options.goal,\n        characterContext: context.characterContext.map((c) => ({\n          name: c.name,\n          details: c.description,\n        })),\n        timelineContext: context.timelineContext.map((t) => ({\n          title: t.title,\n          position: String(t.order),\n        })),\n        relatedContent: context.relatedContent.map((r) => ({\n          title: r.title,\n          excerpt: r.excerpt,\n        })),\n        ...(povChar && { povCharacter: povChar }),\n      };\n\n      console.log('\\nGenerating rewrite suggestions...\\n');\n\n      try {\n        const prompt = buildRewritePrompt(rewriteContext);\n        const suggestions = await llmProvider.complete(prompt);\n\n        console.log('Rewrite Suggestions:');\n        console.log('='.repeat(50));\n        console.log(suggestions);\n        console.log('='.repeat(50));\n      } catch (error) {\n        console.error('LLM request failed:', error instanceof Error ? error.message : error);\n        console.log('\\nManual rewrite context has been gathered and displayed above.');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Rewrite failed:', error);\n      process.exit(1);\n    }\n  });\n","import type { ImpactAnalysis, Frontmatter, ZettelScriptConfig } from '../../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../../core/types/index.js';\nimport { NodeRepository, EdgeRepository } from '../../storage/database/repositories/index.js';\nimport { GraphEngine } from '../../core/graph/engine.js';\n\nexport interface ImpactAnalyzerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  graphEngine: GraphEngine;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Analyzes the impact of changes to a scene\n */\nexport class ImpactAnalyzer {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private graphEngine: GraphEngine;\n  private config: ZettelScriptConfig;\n\n  constructor(options: ImpactAnalyzerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.graphEngine = options.graphEngine;\n    this.config = options.config ?? DEFAULT_CONFIG;\n  }\n\n  /**\n   * Analyze the impact of modifying a scene\n   */\n  async analyze(sceneNodeId: string): Promise<ImpactAnalysis> {\n    const scene = await this.nodeRepo.findById(sceneNodeId);\n    if (!scene) {\n      return {\n        directImpact: [],\n        transitiveImpact: [],\n        povImpact: [],\n        timelineImpact: [],\n        characterImpact: [],\n      };\n    }\n\n    const metadata = scene.metadata as Frontmatter | undefined;\n\n    // Direct impact: nodes directly linked to this scene\n    const directImpact = await this.getDirectImpact(sceneNodeId);\n\n    // Transitive impact: nodes reachable via graph expansion\n    const transitiveImpact = await this.getTransitiveImpact(sceneNodeId, directImpact);\n\n    // POV impact: other scenes with the same POV\n    const povImpact = metadata?.pov ? await this.getPovImpact(metadata.pov, sceneNodeId) : [];\n\n    // Timeline impact: adjacent scenes in timeline\n    const timelineImpact =\n      metadata?.scene_order !== undefined\n        ? await this.getTimelineImpact(metadata.scene_order, sceneNodeId)\n        : [];\n\n    // Character impact: characters whose knowledge might change\n    const characterImpact = await this.getCharacterImpact(sceneNodeId, metadata);\n\n    return {\n      directImpact,\n      transitiveImpact,\n      povImpact,\n      timelineImpact,\n      characterImpact,\n    };\n  }\n\n  /**\n   * Get directly linked nodes\n   */\n  private async getDirectImpact(nodeId: string): Promise<string[]> {\n    const outgoing = await this.edgeRepo.findOutgoing(nodeId);\n    const incoming = await this.edgeRepo.findIncoming(nodeId);\n\n    const impacted = new Set<string>();\n\n    for (const edge of outgoing) {\n      impacted.add(edge.targetId);\n    }\n\n    for (const edge of incoming) {\n      impacted.add(edge.sourceId);\n    }\n\n    return Array.from(impacted);\n  }\n\n  /**\n   * Get transitively impacted nodes via graph expansion\n   */\n  private async getTransitiveImpact(nodeId: string, directImpact: string[]): Promise<string[]> {\n    const expansion = await this.graphEngine.expandGraph({\n      seedNodes: [{ nodeId, score: 1 }],\n      maxDepth: this.config.impact.maxTransitiveDepth,\n      budget: this.config.impact.maxTransitiveBudget,\n      includeIncoming: true,\n    });\n\n    const directSet = new Set(directImpact);\n    directSet.add(nodeId);\n\n    // Return nodes that are transitively reachable but not direct\n    return expansion.filter((e) => e.depth > 1 && !directSet.has(e.nodeId)).map((e) => e.nodeId);\n  }\n\n  /**\n   * Get scenes with the same POV character\n   */\n  private async getPovImpact(povCharacter: string, excludeNodeId: string): Promise<string[]> {\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    return scenes\n      .filter((s) => {\n        const meta = s.metadata as Frontmatter | undefined;\n        return meta?.pov === povCharacter && s.nodeId !== excludeNodeId;\n      })\n      .map((s) => s.nodeId);\n  }\n\n  /**\n   * Get adjacent scenes in the timeline\n   */\n  private async getTimelineImpact(sceneOrder: number, excludeNodeId: string): Promise<string[]> {\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    // Get scenes within configured range of the current scene order\n    const range = this.config.impact.timelineRange;\n    return scenes\n      .filter((s) => {\n        const meta = s.metadata as Frontmatter | undefined;\n        const order = meta?.scene_order;\n        if (order === undefined || s.nodeId === excludeNodeId) return false;\n        return Math.abs(order - sceneOrder) <= range;\n      })\n      .map((s) => s.nodeId);\n  }\n\n  /**\n   * Get characters whose knowledge might be affected\n   */\n  private async getCharacterImpact(\n    sceneNodeId: string,\n    metadata: Frontmatter | undefined\n  ): Promise<string[]> {\n    const characters = new Set<string>();\n\n    // POV character\n    if (metadata?.pov) {\n      characters.add(metadata.pov);\n    }\n\n    // Characters listed in scene\n    if (metadata?.characters) {\n      for (const char of metadata.characters) {\n        characters.add(char);\n      }\n    }\n\n    // Characters linked from the scene\n    const links = await this.edgeRepo.findOutgoing(sceneNodeId);\n    for (const link of links) {\n      const targetNode = await this.nodeRepo.findById(link.targetId);\n      if (targetNode?.type === 'character') {\n        characters.add(targetNode.title);\n      }\n    }\n\n    return Array.from(characters);\n  }\n\n  /**\n   * Get detailed impact report\n   */\n  async getDetailedReport(sceneNodeId: string): Promise<{\n    impact: ImpactAnalysis;\n    summary: {\n      totalAffected: number;\n      directCount: number;\n      transitiveCount: number;\n      characterCount: number;\n      riskLevel: 'low' | 'medium' | 'high';\n    };\n    recommendations: string[];\n  }> {\n    const impact = await this.analyze(sceneNodeId);\n\n    const totalAffected = new Set([\n      ...impact.directImpact,\n      ...impact.transitiveImpact,\n      ...impact.povImpact,\n      ...impact.timelineImpact,\n    ]).size;\n\n    // Calculate risk level\n    let riskLevel: 'low' | 'medium' | 'high' = 'low';\n    if (totalAffected > 20 || impact.characterImpact.length > 5) {\n      riskLevel = 'high';\n    } else if (totalAffected > 10 || impact.characterImpact.length > 3) {\n      riskLevel = 'medium';\n    }\n\n    // Generate recommendations\n    const recommendations: string[] = [];\n\n    if (impact.povImpact.length > 3) {\n      recommendations.push('Review other scenes with the same POV for consistency');\n    }\n\n    if (impact.timelineImpact.length > 5) {\n      recommendations.push('Check timeline continuity with adjacent scenes');\n    }\n\n    if (impact.characterImpact.length > 0) {\n      recommendations.push(\n        `Verify character knowledge for: ${impact.characterImpact.slice(0, 3).join(', ')}`\n      );\n    }\n\n    if (impact.transitiveImpact.length > 10) {\n      recommendations.push('Large transitive impact - consider breaking change into smaller edits');\n    }\n\n    return {\n      impact,\n      summary: {\n        totalAffected,\n        directCount: impact.directImpact.length,\n        transitiveCount: impact.transitiveImpact.length,\n        characterCount: impact.characterImpact.length,\n        riskLevel,\n      },\n      recommendations,\n    };\n  }\n}\n","import type {\n  Node,\n  ImpactAnalysis,\n  Frontmatter,\n  ZettelScriptConfig,\n} from '../../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../../core/types/index.js';\nimport { NodeRepository } from '../../storage/database/repositories/index.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport interface RewriteContext {\n  sceneContent: string;\n  sceneMetadata: Frontmatter | null;\n  goal: string;\n  characterContext: Array<{ name: string; description: string; role: string }>;\n  timelineContext: Array<{ title: string; order: number; summary: string }>;\n  relatedContent: Array<{ title: string; type: string; excerpt: string }>;\n  constraints: string[];\n}\n\nexport interface RewriteOrchestratorOptions {\n  nodeRepository: NodeRepository;\n  impact: ImpactAnalysis;\n  vaultPath?: string;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Orchestrates scene rewrites by gathering context and managing constraints\n */\nexport class RewriteOrchestrator {\n  private nodeRepo: NodeRepository;\n  private impact: ImpactAnalysis;\n  private vaultPath: string;\n  private config: ZettelScriptConfig;\n\n  constructor(options: RewriteOrchestratorOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.impact = options.impact;\n    this.vaultPath = options.vaultPath || process.cwd();\n    this.config = options.config ?? DEFAULT_CONFIG;\n  }\n\n  /**\n   * Gather all context needed for a rewrite\n   */\n  async gatherContext(sceneNodeId: string, goal: string): Promise<RewriteContext> {\n    const scene = await this.nodeRepo.findById(sceneNodeId);\n    if (!scene) {\n      throw new Error(`Scene not found: ${sceneNodeId}`);\n    }\n\n    // Read scene content\n    const sceneContent = await this.readNodeContent(scene);\n    const sceneMetadata = scene.metadata as Frontmatter | null;\n\n    // Gather character context\n    const characterContext = await this.gatherCharacterContext(sceneNodeId, sceneMetadata);\n\n    // Gather timeline context\n    const timelineContext = await this.gatherTimelineContext(sceneMetadata?.scene_order);\n\n    // Gather related content\n    const relatedContent = await this.gatherRelatedContent(sceneNodeId);\n\n    // Build constraints\n    const constraints = this.buildConstraints(sceneMetadata);\n\n    return {\n      sceneContent,\n      sceneMetadata,\n      goal,\n      characterContext,\n      timelineContext,\n      relatedContent,\n      constraints,\n    };\n  }\n\n  /**\n   * Read content from a node's file\n   */\n  private async readNodeContent(node: Node): Promise<string> {\n    const filePath = path.join(this.vaultPath, node.path);\n    try {\n      return fs.readFileSync(filePath, 'utf-8');\n    } catch {\n      return '';\n    }\n  }\n\n  /**\n   * Gather context about characters in the scene\n   */\n  private async gatherCharacterContext(\n    _sceneNodeId: string,\n    sceneMetadata: Frontmatter | null\n  ): Promise<RewriteContext['characterContext']> {\n    const context: RewriteContext['characterContext'] = [];\n    const characterNames = new Set<string>();\n\n    // POV character\n    if (sceneMetadata?.pov) {\n      characterNames.add(sceneMetadata.pov);\n    }\n\n    // Listed characters\n    if (sceneMetadata?.characters) {\n      for (const char of sceneMetadata.characters) {\n        characterNames.add(char);\n      }\n    }\n\n    // Characters from impact analysis\n    for (const charName of this.impact.characterImpact) {\n      characterNames.add(charName);\n    }\n\n    // Fetch character nodes\n    for (const charName of characterNames) {\n      const nodes = await this.nodeRepo.findByTitle(charName);\n      const charNode = nodes.find((n) => n.type === 'character');\n\n      if (charNode) {\n        const charMeta = charNode.metadata as { description?: string } | undefined;\n        const content = await this.readNodeContent(charNode);\n\n        // Extract first paragraph as description\n        const firstPara = content.split('\\n\\n')[1]?.trim() || charMeta?.description || '';\n\n        context.push({\n          name: charNode.title,\n          description: firstPara.slice(0, 500),\n          role: sceneMetadata?.pov === charName ? 'POV' : 'present',\n        });\n      }\n    }\n\n    return context;\n  }\n\n  /**\n   * Gather context about adjacent scenes in timeline\n   */\n  private async gatherTimelineContext(\n    sceneOrder: number | undefined\n  ): Promise<RewriteContext['timelineContext']> {\n    if (sceneOrder === undefined) return [];\n\n    const context: RewriteContext['timelineContext'] = [];\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    // Get scenes within configured range of current (use half of impact range for context)\n    const range = Math.ceil(this.config.impact.timelineRange / 2);\n    const adjacentScenes = scenes\n      .filter((s) => {\n        const meta = s.metadata as Frontmatter | undefined;\n        const order = meta?.scene_order;\n        return order !== undefined && Math.abs(order - sceneOrder) <= range && order !== sceneOrder;\n      })\n      .sort((a, b) => {\n        const orderA = (a.metadata as Frontmatter | undefined)?.scene_order ?? 0;\n        const orderB = (b.metadata as Frontmatter | undefined)?.scene_order ?? 0;\n        return orderA - orderB;\n      });\n\n    for (const scene of adjacentScenes) {\n      const meta = scene.metadata as Frontmatter | undefined;\n      const content = await this.readNodeContent(scene);\n\n      // Extract summary (first paragraph after frontmatter)\n      const parts = content.split('---');\n      const body = parts.length > 2 ? parts.slice(2).join('---') : content;\n      const summary = body.trim().split('\\n\\n')[0]?.slice(0, 300) || '';\n\n      context.push({\n        title: scene.title,\n        order: meta?.scene_order ?? 0,\n        summary,\n      });\n    }\n\n    return context;\n  }\n\n  /**\n   * Gather related content from direct links\n   */\n  private async gatherRelatedContent(\n    _sceneNodeId: string\n  ): Promise<RewriteContext['relatedContent']> {\n    const content: RewriteContext['relatedContent'] = [];\n\n    // Get directly linked nodes (excluding characters, handled separately)\n    const directIds = this.impact.directImpact;\n    const nodes = await this.nodeRepo.findByIds(directIds);\n\n    for (const node of nodes.slice(0, 10)) {\n      // Limit to 10\n      if (node.type === 'character') continue;\n\n      const nodeContent = await this.readNodeContent(node);\n      const excerpt = nodeContent.trim().slice(0, 300);\n\n      content.push({\n        title: node.title,\n        type: node.type,\n        excerpt,\n      });\n    }\n\n    return content;\n  }\n\n  /**\n   * Build constraints based on metadata and impact\n   */\n  private buildConstraints(sceneMetadata: Frontmatter | null): string[] {\n    const constraints: string[] = [];\n\n    if (sceneMetadata?.pov) {\n      constraints.push(\n        `Maintain POV: ${sceneMetadata.pov} - only reveal information they would know`\n      );\n    }\n\n    if (sceneMetadata?.scene_order !== undefined) {\n      constraints.push(\n        `Timeline position: Scene ${sceneMetadata.scene_order} - maintain continuity with adjacent scenes`\n      );\n    }\n\n    if (sceneMetadata?.locations?.length) {\n      constraints.push(`Location: ${sceneMetadata.locations.join(', ')}`);\n    }\n\n    if (this.impact.characterImpact.length > 0) {\n      constraints.push(`Characters to consider: ${this.impact.characterImpact.join(', ')}`);\n    }\n\n    if (this.impact.povImpact.length > 5) {\n      constraints.push('This POV appears in many scenes - maintain character voice consistency');\n    }\n\n    return constraints;\n  }\n\n  /**\n   * Format context for LLM prompt\n   */\n  formatContextForPrompt(context: RewriteContext): string {\n    const sections: string[] = [];\n\n    // Goal\n    sections.push(`## Rewrite Goal\\n\\n${context.goal}`);\n\n    // Constraints\n    if (context.constraints.length > 0) {\n      sections.push(`## Constraints\\n\\n${context.constraints.map((c) => `- ${c}`).join('\\n')}`);\n    }\n\n    // Characters\n    if (context.characterContext.length > 0) {\n      const charSection = context.characterContext\n        .map((c) => `### ${c.name} (${c.role})\\n\\n${c.description}`)\n        .join('\\n\\n');\n      sections.push(`## Characters\\n\\n${charSection}`);\n    }\n\n    // Timeline\n    if (context.timelineContext.length > 0) {\n      const timelineSection = context.timelineContext\n        .map((t) => `### Scene ${t.order}: ${t.title}\\n\\n${t.summary}`)\n        .join('\\n\\n');\n      sections.push(`## Timeline Context\\n\\n${timelineSection}`);\n    }\n\n    // Related content\n    if (context.relatedContent.length > 0) {\n      const relatedSection = context.relatedContent\n        .map((r) => `### ${r.title} (${r.type})\\n\\n${r.excerpt}`)\n        .join('\\n\\n');\n      sections.push(`## Related Content\\n\\n${relatedSection}`);\n    }\n\n    // Current scene\n    sections.push(`## Current Scene Content\\n\\n${context.sceneContent}`);\n\n    return sections.join('\\n\\n---\\n\\n');\n  }\n\n  /**\n   * Get a summary of the rewrite context\n   */\n  getContextSummary(context: RewriteContext): {\n    characterCount: number;\n    timelineSceneCount: number;\n    relatedContentCount: number;\n    constraintCount: number;\n    totalContextLength: number;\n  } {\n    return {\n      characterCount: context.characterContext.length,\n      timelineSceneCount: context.timelineContext.length,\n      relatedContentCount: context.relatedContent.length,\n      constraintCount: context.constraints.length,\n      totalContextLength: JSON.stringify(context).length,\n    };\n  }\n}\n","/**\n * LLM Provider abstraction for rewrite suggestions\n */\n/* global fetch */\n\nimport { TextDecoder } from 'node:util';\nimport type { ZettelScriptConfig } from '../core/types/index.js';\n\nexport interface LLMOptions {\n  maxTokens?: number;\n  temperature?: number;\n}\n\nexport interface LLMProvider {\n  name: string;\n  modelName: string;\n  complete(prompt: string, options?: LLMOptions): Promise<string>;\n}\n\n/**\n * OpenAI-compatible LLM provider\n */\nexport class OpenAILLMProvider implements LLMProvider {\n  name = 'openai';\n  private apiKey: string;\n  private baseUrl: string;\n  private model: string;\n  private defaultMaxTokens: number;\n  private defaultTemperature: number;\n\n  constructor(config: ZettelScriptConfig['llm']) {\n    if (!config.apiKey) {\n      throw new Error('OpenAI API key is required');\n    }\n    this.apiKey = config.apiKey;\n    this.baseUrl = config.baseUrl ?? 'https://api.openai.com/v1';\n    this.model = config.model;\n    this.defaultMaxTokens = config.maxTokens ?? 2048;\n    this.defaultTemperature = config.temperature ?? 0.7;\n  }\n\n  get modelName(): string {\n    return this.model;\n  }\n\n  async complete(prompt: string, options?: LLMOptions): Promise<string> {\n    const maxTokens = options?.maxTokens ?? this.defaultMaxTokens;\n    const temperature = options?.temperature ?? this.defaultTemperature;\n\n    const response = await fetch(`${this.baseUrl}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.apiKey}`,\n      },\n      body: JSON.stringify({\n        model: this.model,\n        messages: [{ role: 'user', content: prompt }],\n        max_tokens: maxTokens,\n        temperature,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`OpenAI API error: ${response.status} - ${error}`);\n    }\n\n    const data = (await response.json()) as {\n      choices?: Array<{ message?: { content?: string } }>;\n    };\n\n    return data.choices?.[0]?.message?.content ?? '';\n  }\n}\n\nexport interface OllamaModelInfo {\n  contextLength: number;\n  parameterSize?: string;\n  family?: string;\n}\n\n/**\n * Check if Ollama is running\n */\nexport async function checkOllamaRunning(baseUrl = 'http://localhost:11434'): Promise<boolean> {\n  try {\n    const response = await fetch(`${baseUrl}/api/tags`, { method: 'GET' });\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * List models available in Ollama\n */\nexport async function listOllamaModels(baseUrl = 'http://localhost:11434'): Promise<string[]> {\n  try {\n    const response = await fetch(`${baseUrl}/api/tags`, { method: 'GET' });\n    if (!response.ok) return [];\n\n    const data = (await response.json()) as { models?: Array<{ name: string }> };\n    return data.models?.map((m) => m.name) ?? [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Check if a specific model is available in Ollama\n */\nexport async function checkOllamaModelExists(\n  model: string,\n  baseUrl = 'http://localhost:11434'\n): Promise<boolean> {\n  const models = await listOllamaModels(baseUrl);\n  // Normalize model names (ollama may store as \"qwen2.5:7b\" or \"qwen2.5:7b-instruct\")\n  const normalizedModel = model.toLowerCase();\n  return models.some((m) => {\n    const normalizedM = m.toLowerCase();\n    const modelBase = normalizedM.split(':')[0] ?? normalizedM;\n    return (\n      normalizedM === normalizedModel ||\n      normalizedM.startsWith(normalizedModel + '-') ||\n      normalizedModel.startsWith(modelBase)\n    );\n  });\n}\n\n/**\n * Pull/download a model from Ollama registry\n * Returns an async generator that yields progress updates\n */\nexport async function* pullOllamaModel(\n  model: string,\n  baseUrl = 'http://localhost:11434'\n): AsyncGenerator<{ status: string; completed?: number; total?: number }> {\n  const response = await fetch(`${baseUrl}/api/pull`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ name: model, stream: true }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`Failed to pull model: ${error}`);\n  }\n\n  if (!response.body) {\n    throw new Error('No response body from Ollama');\n  }\n\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n\n    buffer += decoder.decode(value, { stream: true });\n    const lines = buffer.split('\\n');\n    buffer = lines.pop() ?? '';\n\n    for (const line of lines) {\n      if (line.trim()) {\n        try {\n          const data = JSON.parse(line) as { status: string; completed?: number; total?: number };\n          yield data;\n        } catch {\n          // Skip malformed JSON\n        }\n      }\n    }\n  }\n\n  // Process any remaining data\n  if (buffer.trim()) {\n    try {\n      const data = JSON.parse(buffer) as { status: string; completed?: number; total?: number };\n      yield data;\n    } catch {\n      // Skip malformed JSON\n    }\n  }\n}\n\n/**\n * Query Ollama for model metadata\n */\nexport async function getOllamaModelInfo(\n  model: string,\n  baseUrl = 'http://localhost:11434'\n): Promise<OllamaModelInfo | null> {\n  try {\n    const response = await fetch(`${baseUrl}/api/show`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ name: model }),\n    });\n\n    if (!response.ok) return null;\n\n    const data = (await response.json()) as {\n      model_info?: Record<string, unknown>;\n      details?: { parameter_size?: string; family?: string };\n    };\n\n    // Context length is in model_info with key like \"llama.context_length\" or \"general.context_length\"\n    let contextLength = 2048; // fallback\n    if (data.model_info) {\n      for (const [key, value] of Object.entries(data.model_info)) {\n        if (key.includes('context_length') && typeof value === 'number') {\n          contextLength = value;\n          break;\n        }\n      }\n    }\n\n    const info: OllamaModelInfo = { contextLength };\n    if (data.details?.parameter_size) info.parameterSize = data.details.parameter_size;\n    if (data.details?.family) info.family = data.details.family;\n    return info;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Ollama LLM provider\n */\nexport class OllamaLLMProvider implements LLMProvider {\n  name = 'ollama';\n  private baseUrl: string;\n  private model: string;\n  private configuredMaxTokens: number | undefined;\n  private dynamicMaxTokens: number | undefined;\n  private defaultTemperature: number;\n  private modelInfoPromise: Promise<void> | null = null;\n\n  constructor(config: ZettelScriptConfig['llm']) {\n    this.baseUrl = config.baseUrl ?? 'http://localhost:11434';\n    this.model = config.model;\n    // Only set if explicitly configured - undefined means \"use dynamic\"\n    this.configuredMaxTokens = config.maxTokens;\n    this.defaultTemperature = config.temperature ?? 0.7;\n  }\n\n  get modelName(): string {\n    return this.model;\n  }\n\n  /**\n   * Lazy-load model info to get context length for dynamic max tokens\n   */\n  private async ensureModelInfo(): Promise<void> {\n    if (this.dynamicMaxTokens !== undefined) return;\n\n    if (!this.modelInfoPromise) {\n      this.modelInfoPromise = (async () => {\n        const info = await getOllamaModelInfo(this.model, this.baseUrl);\n        if (info) {\n          // Use 1/4 of context for output, capped at 8192\n          this.dynamicMaxTokens = Math.min(Math.floor(info.contextLength / 4), 8192);\n        } else {\n          // Fallback if we can't get model info\n          this.dynamicMaxTokens = 2048;\n        }\n      })();\n    }\n    await this.modelInfoPromise;\n  }\n\n  /**\n   * Get the effective max tokens (configured > dynamic > fallback)\n   */\n  private async getMaxTokens(override?: number): Promise<number> {\n    if (override !== undefined) return override;\n    if (this.configuredMaxTokens !== undefined) return this.configuredMaxTokens;\n\n    await this.ensureModelInfo();\n    return this.dynamicMaxTokens ?? 2048;\n  }\n\n  async complete(prompt: string, options?: LLMOptions): Promise<string> {\n    const temperature = options?.temperature ?? this.defaultTemperature;\n    const maxTokens = await this.getMaxTokens(options?.maxTokens);\n\n    const response = await fetch(`${this.baseUrl}/api/generate`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model: this.model,\n        prompt,\n        stream: false,\n        options: {\n          temperature,\n          num_predict: maxTokens,\n        },\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Ollama API error: ${response.status} - ${error}`);\n    }\n\n    const data = (await response.json()) as { response?: string };\n\n    return data.response ?? '';\n  }\n}\n\n/**\n * Create an LLM provider based on config\n * Returns null if provider is 'none' or not configured\n */\nexport function createLLMProvider(config: ZettelScriptConfig['llm']): LLMProvider | null {\n  if (config.provider === 'none') {\n    return null;\n  }\n\n  switch (config.provider) {\n    case 'openai':\n      if (!config.apiKey) {\n        return null;\n      }\n      return new OpenAILLMProvider(config);\n\n    case 'ollama':\n      return new OllamaLLMProvider(config);\n\n    default:\n      return null;\n  }\n}\n","/**\n * Prompt templates for LLM-assisted features\n */\n\nexport interface RewriteContext {\n  sceneTitle: string;\n  sceneContent: string;\n  goal: string;\n  characterContext: Array<{ name: string; details: string }>;\n  timelineContext: Array<{ title: string; position: string }>;\n  relatedContent: Array<{ title: string; excerpt: string }>;\n  povCharacter?: string;\n}\n\n/**\n * Build a prompt for scene rewrite suggestions\n */\nexport function buildRewritePrompt(context: RewriteContext): string {\n  const parts: string[] = [];\n\n  parts.push('You are a creative writing assistant helping to rewrite a scene from a manuscript.');\n  parts.push('');\n  parts.push('## Current Scene');\n  parts.push(`Title: ${context.sceneTitle}`);\n  if (context.povCharacter) {\n    parts.push(`POV Character: ${context.povCharacter}`);\n  }\n  parts.push('');\n  parts.push('Content:');\n  parts.push('```');\n  parts.push(context.sceneContent);\n  parts.push('```');\n  parts.push('');\n  parts.push(`## Rewrite Goal`);\n  parts.push(context.goal);\n  parts.push('');\n\n  if (context.characterContext.length > 0) {\n    parts.push('## Character Context');\n    for (const char of context.characterContext) {\n      parts.push(`### ${char.name}`);\n      parts.push(char.details);\n      parts.push('');\n    }\n  }\n\n  if (context.timelineContext.length > 0) {\n    parts.push('## Timeline Context');\n    for (const scene of context.timelineContext) {\n      parts.push(`- ${scene.title} (${scene.position})`);\n    }\n    parts.push('');\n  }\n\n  if (context.relatedContent.length > 0) {\n    parts.push('## Related Scenes');\n    for (const related of context.relatedContent.slice(0, 5)) {\n      parts.push(`### ${related.title}`);\n      parts.push(related.excerpt);\n      parts.push('');\n    }\n  }\n\n  parts.push('## Instructions');\n  parts.push(\n    'Based on the context above, provide specific suggestions for how to rewrite this scene to achieve the stated goal.'\n  );\n  parts.push('');\n  parts.push('Please provide:');\n  parts.push('1. A brief analysis of how the current scene could be improved');\n  parts.push('2. Specific suggestions for changes (what to add, remove, or modify)');\n  parts.push('3. An example of a rewritten opening paragraph or key section');\n  parts.push('');\n  parts.push('Maintain consistency with the established characters, timeline, and POV.');\n\n  return parts.join('\\n');\n}\n\n/**\n * Build a prompt for mention disambiguation\n */\nexport function buildDisambiguationPrompt(\n  surfaceText: string,\n  context: string,\n  candidates: Array<{ title: string; type: string; description?: string }>\n): string {\n  const parts: string[] = [];\n\n  parts.push('You are helping to identify which entity is being referenced in a piece of text.');\n  parts.push('');\n  parts.push('## Text containing the mention');\n  parts.push('```');\n  parts.push(context);\n  parts.push('```');\n  parts.push('');\n  parts.push(`The highlighted mention is: \"${surfaceText}\"`);\n  parts.push('');\n  parts.push('## Possible matches');\n  for (let i = 0; i < candidates.length; i++) {\n    const c = candidates[i];\n    if (c) {\n      parts.push(`${i + 1}. ${c.title} (${c.type})${c.description ? `: ${c.description}` : ''}`);\n    }\n  }\n  parts.push('');\n  parts.push(\n    'Which entity (1-' +\n      candidates.length +\n      ') is most likely being referenced? Respond with just the number.'\n  );\n\n  return parts.join('\\n');\n}\n\n/**\n * Build a prompt for continuity checking\n */\nexport function buildContinuityCheckPrompt(\n  scene1: { title: string; content: string; pov?: string },\n  scene2: { title: string; content: string; pov?: string }\n): string {\n  const parts: string[] = [];\n\n  parts.push(\n    'You are a continuity editor checking for consistency between two scenes in a manuscript.'\n  );\n  parts.push('');\n  parts.push('## Scene 1');\n  parts.push(`Title: ${scene1.title}`);\n  if (scene1.pov) parts.push(`POV: ${scene1.pov}`);\n  parts.push('```');\n  parts.push(scene1.content.slice(0, 2000));\n  if (scene1.content.length > 2000) parts.push('... [truncated]');\n  parts.push('```');\n  parts.push('');\n  parts.push('## Scene 2');\n  parts.push(`Title: ${scene2.title}`);\n  if (scene2.pov) parts.push(`POV: ${scene2.pov}`);\n  parts.push('```');\n  parts.push(scene2.content.slice(0, 2000));\n  if (scene2.content.length > 2000) parts.push('... [truncated]');\n  parts.push('```');\n  parts.push('');\n  parts.push('## Task');\n  parts.push('Identify any continuity issues between these scenes, such as:');\n  parts.push('- Character inconsistencies (different descriptions, abilities, or knowledge)');\n  parts.push('- Timeline problems');\n  parts.push('- Setting/location inconsistencies');\n  parts.push(\"- POV violations (character knowing things they shouldn't)\");\n  parts.push('');\n  parts.push(\n    'List each issue found with a brief explanation, or state \"No continuity issues found.\"'\n  );\n\n  return parts.join('\\n');\n}\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as readline from 'node:readline';\nimport { initContext, Spinner, printTable } from '../utils.js';\nimport { EntityExtractor, type ExtractedEntity } from '../../extraction/index.js';\nimport {\n  OllamaLLMProvider,\n  getOllamaModelInfo,\n  checkOllamaRunning,\n  checkOllamaModelExists,\n  pullOllamaModel,\n  listOllamaModels,\n} from '../../llm/provider.js';\nimport { nanoid } from 'nanoid';\nimport { stringify as stringifyYaml } from 'yaml';\n\n/**\n * Prompt user for yes/no confirmation\n */\nasync function promptYesNo(question: string): Promise<boolean> {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  return new Promise((resolve) => {\n    rl.question(`${question} (y/n) `, (answer) => {\n      rl.close();\n      resolve(answer.toLowerCase().startsWith('y'));\n    });\n  });\n}\n\n/**\n * Format bytes as human-readable string\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;\n}\n\nexport const extractCommand = new Command('extract')\n  .description('Extract entities (characters, locations, etc.) from prose')\n  .option('-f, --file <path>', 'Extract from specific file')\n  .option('--all', 'Extract from all markdown files')\n  .option('-m, --model <model>', 'Ollama model to use', 'qwen2.5:7b')\n  .option('--dry-run', 'Show what would be extracted without creating files')\n  .option('-o, --output <dir>', 'Output directory for entity files')\n  .option('-v, --verbose', 'Show detailed output (per-chunk progress)')\n  .option('-q, --quiet', 'Suppress output (exit code still reflects success)')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      // Determine files to process\n      let filesToProcess: string[] = [];\n\n      if (options.file) {\n        const filePath = path.isAbsolute(options.file)\n          ? options.file\n          : path.join(ctx.vaultPath, options.file);\n\n        if (!fs.existsSync(filePath)) {\n          console.error(`File not found: ${filePath}`);\n          process.exit(1);\n        }\n        filesToProcess = [filePath];\n      } else if (options.all) {\n        // Find all markdown files\n        const findMarkdown = (dir: string): string[] => {\n          const results: string[] = [];\n          const entries = fs.readdirSync(dir, { withFileTypes: true });\n\n          for (const entry of entries) {\n            const fullPath = path.join(dir, entry.name);\n\n            // Skip excluded patterns\n            if (\n              ctx.config.vault.excludePatterns.some((p) => {\n                const pattern = p.replace('**/', '').replace('/**', '');\n                return entry.name === pattern || fullPath.includes(pattern);\n              })\n            ) {\n              continue;\n            }\n\n            if (entry.isDirectory()) {\n              results.push(...findMarkdown(fullPath));\n            } else if (entry.name.endsWith('.md')) {\n              results.push(fullPath);\n            }\n          }\n          return results;\n        };\n\n        filesToProcess = findMarkdown(ctx.vaultPath);\n      } else {\n        console.log('Specify --file <path> or --all to extract entities.');\n        console.log('\\nExamples:');\n        console.log('  zettel extract --file book1.md');\n        console.log('  zettel extract --all');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      if (filesToProcess.length === 0) {\n        console.log('No markdown files found.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      if (!options.quiet) {\n        console.log(`Processing ${filesToProcess.length} file(s)...\\n`);\n      }\n\n      // Check Ollama is running\n      const ollamaRunning = await checkOllamaRunning();\n      if (!ollamaRunning) {\n        console.error('Error: Ollama is not running.');\n        console.error('\\nTo start Ollama:');\n        console.error('  1. Install from https://ollama.ai');\n        console.error('  2. Run: ollama serve');\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Check if model exists\n      const modelExists = await checkOllamaModelExists(options.model);\n      if (!modelExists) {\n        console.log(`Model '${options.model}' is not installed.`);\n\n        // Show available models\n        const availableModels = await listOllamaModels();\n        if (availableModels.length > 0) {\n          console.log('\\nInstalled models:');\n          for (const m of availableModels.slice(0, 10)) {\n            console.log(`  - ${m}`);\n          }\n          if (availableModels.length > 10) {\n            console.log(`  ... and ${availableModels.length - 10} more`);\n          }\n        }\n\n        console.log('');\n        const shouldDownload = await promptYesNo(`Download '${options.model}' now?`);\n\n        if (shouldDownload) {\n          console.log(`\\nDownloading ${options.model}...`);\n          let lastStatus = '';\n\n          try {\n            for await (const progress of pullOllamaModel(options.model)) {\n              // Show download progress\n              if (progress.status !== lastStatus) {\n                if (progress.completed !== undefined && progress.total !== undefined) {\n                  const percent = ((progress.completed / progress.total) * 100).toFixed(1);\n                  const completed = formatBytes(progress.completed);\n                  const total = formatBytes(progress.total);\n                  process.stdout.write(\n                    `\\r${progress.status}: ${completed} / ${total} (${percent}%)    `\n                  );\n                } else {\n                  process.stdout.write(`\\r${progress.status}...    `);\n                }\n                lastStatus = progress.status;\n              } else if (progress.completed !== undefined && progress.total !== undefined) {\n                const percent = ((progress.completed / progress.total) * 100).toFixed(1);\n                const completed = formatBytes(progress.completed);\n                const total = formatBytes(progress.total);\n                process.stdout.write(\n                  `\\r${progress.status}: ${completed} / ${total} (${percent}%)    `\n                );\n              }\n            }\n            console.log('\\nDownload complete!\\n');\n          } catch (err) {\n            console.error(\n              `\\nFailed to download model: ${err instanceof Error ? err.message : err}`\n            );\n            ctx.connectionManager.close();\n            process.exit(1);\n          }\n        } else {\n          // Suggest alternatives\n          console.log('\\n--- Recommended models for entity extraction ---');\n          console.log('');\n          console.log('  Good context + speed:');\n          console.log('    qwen2.5:7b        (~4.7 GB) - Default, good balance');\n          console.log('    llama3.1:8b       (~4.7 GB) - Strong general purpose');\n          console.log('    mistral:7b        (~4.1 GB) - Fast, good for structured output');\n          console.log('');\n          console.log('  Larger context (for big documents):');\n          console.log('    qwen2.5:14b       (~9.0 GB) - Better accuracy, slower');\n          console.log('    llama3.1:70b      (~40 GB)  - Best quality, needs GPU');\n          console.log('');\n          console.log('  Smaller/faster (less accurate):');\n          console.log('    qwen2.5:3b        (~2.0 GB) - Quick, limited context');\n          console.log('    phi3:mini         (~2.2 GB) - Lightweight option');\n\n          // If they have models installed, suggest using one\n          if (availableModels.length > 0) {\n            console.log('');\n            console.log('--- Or use one of your installed models ---');\n            console.log('');\n            for (const m of availableModels.slice(0, 5)) {\n              console.log(`  zettel extract --model ${m} --all`);\n            }\n          }\n\n          console.log('');\n          console.log('To download a model:');\n          console.log(`  ollama pull <model-name>`);\n          console.log('');\n          ctx.connectionManager.close();\n          return;\n        }\n      }\n\n      // Create LLM provider\n      const llmProvider = new OllamaLLMProvider({\n        provider: 'ollama',\n        model: options.model,\n        baseUrl: 'http://localhost:11434',\n      });\n\n      if (options.verbose) {\n        const modelInfo = await getOllamaModelInfo(options.model);\n        if (modelInfo) {\n          console.log(`Model: ${options.model}`);\n          console.log(`  Context length: ${modelInfo.contextLength}`);\n          console.log(\n            `  Max output tokens: ${Math.min(Math.floor(modelInfo.contextLength / 4), 8192)}`\n          );\n          if (modelInfo.parameterSize) console.log(`  Parameters: ${modelInfo.parameterSize}`);\n        }\n      }\n\n      // Determine output directory for bad-chunks.jsonl\n      const outputDir = options.output\n        ? path.isAbsolute(options.output)\n          ? options.output\n          : path.join(ctx.vaultPath, options.output)\n        : ctx.vaultPath;\n\n      const extractor = new EntityExtractor({\n        llmProvider,\n        chunkSize: 6000, // Smaller chunks for 3b model\n        outputDir,\n        verbose: options.verbose,\n        quiet: options.quiet,\n      });\n\n      const allEntities = new Map<string, ExtractedEntity>();\n      const entityToFiles = new Map<string, Set<string>>();\n\n      // Track combined stats across all files\n      let totalChunks = 0;\n      let totalStrict = 0;\n      let totalRepaired = 0;\n      let totalSalvaged = 0;\n      let totalFailed = 0;\n      let badChunksPath: string | undefined;\n\n      for (const filePath of filesToProcess) {\n        const relativePath = path.relative(ctx.vaultPath, filePath);\n        if (!options.quiet) {\n          console.log(`\\nExtracting from: ${relativePath}`);\n        }\n\n        const content = fs.readFileSync(filePath, 'utf-8');\n\n        // Skip very small files\n        if (content.length < 100) {\n          if (!options.quiet) {\n            console.log('  Skipped (too small)');\n          }\n          continue;\n        }\n\n        const spinner = options.quiet ? null : new Spinner('Analyzing...');\n        if (spinner) spinner.start();\n\n        const result = await extractor.extractFromText(content, (current, total) => {\n          if (spinner) spinner.update(`Chunk ${current}/${total}`);\n        });\n\n        if (spinner) spinner.stop();\n\n        // Accumulate stats\n        totalChunks += result.stats.total;\n        totalStrict += result.stats.strict;\n        totalRepaired += result.stats.repaired;\n        totalSalvaged += result.stats.salvaged;\n        totalFailed += result.stats.failed;\n        if (result.badChunksPath) badChunksPath = result.badChunksPath;\n\n        // Merge entities\n        for (const entity of result.entities) {\n          const key = entity.name.toLowerCase();\n          const existing = allEntities.get(key);\n\n          if (existing) {\n            existing.mentions += entity.mentions;\n            existing.aliases = [...new Set([...existing.aliases, ...entity.aliases])];\n            if (entity.description.length > existing.description.length) {\n              existing.description = entity.description;\n            }\n          } else {\n            allEntities.set(key, { ...entity });\n          }\n\n          // Track which files reference this entity\n          if (!entityToFiles.has(key)) {\n            entityToFiles.set(key, new Set());\n          }\n          entityToFiles.get(key)!.add(relativePath);\n        }\n\n        if (options.verbose && !options.quiet) {\n          console.log(`  Found ${result.entities.length} entities`);\n          for (const e of result.entities.slice(0, 10)) {\n            console.log(`    - ${e.name} (${e.type})`);\n          }\n          if (result.entities.length > 10) {\n            console.log(`    ... and ${result.entities.length - 10} more`);\n          }\n        }\n      }\n\n      // Print parsing stats summary\n      if (!options.quiet && totalChunks > 0) {\n        console.log('\\n--- Parsing Statistics ---');\n        console.log(`  Chunks processed: ${totalChunks}`);\n        console.log(`    - strict:   ${totalStrict}`);\n        console.log(`    - repaired: ${totalRepaired}`);\n        console.log(`    - salvaged: ${totalSalvaged}`);\n        console.log(`    - failed:   ${totalFailed}`);\n        if (badChunksPath) {\n          console.log(`  Failed chunks logged to: ${badChunksPath}`);\n        }\n      }\n\n      // Sort by mentions\n      const sortedEntities = Array.from(allEntities.values()).sort(\n        (a, b) => b.mentions - a.mentions\n      );\n\n      // Display results\n      if (!options.quiet) {\n        console.log('\\n' + '='.repeat(50));\n        console.log('Extracted Entities');\n        console.log('='.repeat(50) + '\\n');\n\n        // Group by type\n        const byType = new Map<string, ExtractedEntity[]>();\n        for (const entity of sortedEntities) {\n          const list = byType.get(entity.type) || [];\n          list.push(entity);\n          byType.set(entity.type, list);\n        }\n\n        for (const [type, entities] of byType) {\n          console.log(`\\n${type.toUpperCase()}S (${entities.length}):`);\n          const rows = entities\n            .slice(0, 15)\n            .map((e) => [\n              e.name,\n              e.aliases.slice(0, 3).join(', ') || '-',\n              e.mentions.toString(),\n              e.description.slice(0, 50) + (e.description.length > 50 ? '...' : ''),\n            ]);\n          printTable(['Name', 'Aliases', 'Refs', 'Description'], rows);\n\n          if (entities.length > 15) {\n            console.log(`  ... and ${entities.length - 15} more`);\n          }\n        }\n\n        console.log(`\\nTotal: ${sortedEntities.length} entities`);\n      }\n\n      // Create files if not dry run\n      if (!options.dryRun && sortedEntities.length > 0) {\n        const outputDir = options.output\n          ? path.isAbsolute(options.output)\n            ? options.output\n            : path.join(ctx.vaultPath, options.output)\n          : path.join(ctx.vaultPath, 'entities');\n\n        if (!options.quiet) {\n          console.log(`\\nCreating entity files in: ${path.relative(ctx.vaultPath, outputDir)}/`);\n        }\n\n        // Create directories\n        const dirs = ['characters', 'locations', 'objects', 'events'];\n        for (const dir of dirs) {\n          fs.mkdirSync(path.join(outputDir, dir), { recursive: true });\n        }\n\n        let created = 0;\n        for (const entity of sortedEntities) {\n          // Skip low-mention entities\n          if (entity.mentions < 2) continue;\n\n          const typeDir =\n            entity.type === 'character'\n              ? 'characters'\n              : entity.type === 'location'\n                ? 'locations'\n                : entity.type === 'object'\n                  ? 'objects'\n                  : 'events';\n\n          const fileName =\n            entity.name\n              .toLowerCase()\n              .replace(/[^a-z0-9]+/g, '-')\n              .replace(/^-|-$/g, '') + '.md';\n\n          const filePath = path.join(outputDir, typeDir, fileName);\n\n          // Skip if file already exists\n          if (fs.existsSync(filePath)) {\n            if (options.verbose && !options.quiet) {\n              console.log(`  Skipped (exists): ${typeDir}/${fileName}`);\n            }\n            continue;\n          }\n\n          // Create frontmatter\n          const frontmatter: Record<string, unknown> = {\n            id: nanoid(),\n            title: entity.name,\n            type: entity.type,\n          };\n\n          if (entity.aliases.length > 0) {\n            frontmatter.aliases = entity.aliases;\n          }\n\n          // Create file content\n          const content = `---\n${stringifyYaml(frontmatter).trim()}\n---\n\n# ${entity.name}\n\n${entity.description}\n\n## Appearances\n\n${Array.from(entityToFiles.get(entity.name.toLowerCase()) || [])\n  .map((f) => `- [[${path.basename(f, '.md')}]]`)\n  .join('\\n')}\n`;\n\n          fs.writeFileSync(filePath, content, 'utf-8');\n          created++;\n\n          if (options.verbose && !options.quiet) {\n            console.log(`  Created: ${typeDir}/${fileName}`);\n          }\n        }\n\n        if (!options.quiet) {\n          console.log(`\\nCreated ${created} entity files.`);\n          console.log('\\nNext steps:');\n          console.log('  zettel index     # Re-index to include new entities');\n          console.log('  zettel discover --all  # Find unlinked mentions');\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Extraction failed:', error);\n      process.exit(1);\n    }\n  });\n","/**\n * Entity extraction from prose using LLM\n *\n * Features:\n * - Multi-stage JSON parsing with repair and salvage\n * - Provenance tracking for each entity\n * - bad-chunks.jsonl for failed chunk diagnostics\n * - Summary output with parse statistics\n */\n\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport type { LLMProvider } from '../llm/provider.js';\nimport type { NodeType } from '../core/types/index.js';\nimport { parseJSONWithFallbacks, type ParseMode } from './json-parser.js';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface ExtractedEntity {\n  name: string;\n  type: NodeType;\n  aliases: string[];\n  description: string;\n  mentions: number;\n  // Provenance fields\n  parseMode: ParseMode;\n  chunkIndex: number;\n  islandIndex?: number | undefined;\n}\n\nexport interface ExtractionResult {\n  entities: ExtractedEntity[];\n  scenes: Array<{\n    title: string;\n    summary: string;\n    startOffset: number;\n    endOffset: number;\n    entities: string[];\n  }>;\n  stats: ChunkStats;\n  badChunksPath?: string | undefined;\n}\n\nexport interface EntityExtractorOptions {\n  llmProvider: LLMProvider;\n  chunkSize?: number;\n  overlapSize?: number;\n  maxTokens?: number;\n  outputDir?: string; // For bad-chunks.jsonl\n  verbose?: boolean;\n  quiet?: boolean;\n}\n\ninterface ChunkStats {\n  total: number;\n  strict: number;\n  repaired: number;\n  salvaged: number;\n  parsedEmpty: number;\n  failed: number;\n  entitiesByType: Record<string, number>;\n  entitiesByMode: Record<ParseMode, number>;\n}\n\ninterface BadChunkRecord {\n  chunkIndex: number;\n  phase: ParseMode;\n  error: string;\n  errors?: Partial<Record<ParseMode, string>> | undefined;\n  rawSnippet: string;\n  repairedSnippet?: string | undefined;\n  attemptedRepair: boolean;\n  islandsFound: number;\n  model: string;\n  extractorVersion: string;\n  timestamp: string;\n}\n\ninterface RawExtractionResponse {\n  characters?: unknown[];\n  locations?: unknown[];\n  objects?: unknown[];\n  events?: unknown[];\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst VERSION = '0.4.2';\n\nconst EXTRACTION_PROMPT = `You are an entity extractor for fiction manuscripts. Analyze the following text and extract all named entities.\n\nReturn ONLY valid JSON in this exact format (no markdown, no explanation):\n{\n  \"characters\": [\n    {\"name\": \"Full Name\", \"aliases\": [\"nickname\", \"title\"], \"description\": \"brief description\"}\n  ],\n  \"locations\": [\n    {\"name\": \"Location Name\", \"aliases\": [], \"description\": \"brief description\"}\n  ],\n  \"objects\": [\n    {\"name\": \"Object Name\", \"aliases\": [], \"description\": \"why it's significant\"}\n  ],\n  \"events\": [\n    {\"name\": \"Event Name\", \"aliases\": [], \"description\": \"what happened\"}\n  ]\n}\n\nRules:\n- Characters include people, animals, personified objects (like stuffed animals with names)\n- Locations include rooms, buildings, cities, any named place\n- Objects include significant items mentioned multiple times or plot-relevant\n- For aliases, include nicknames, titles, pronouns-as-names (\"Mom\" vs \"mother\")\n- Keep descriptions to one sentence\n- Only include entities that are NAMED or clearly identifiable\n- Do NOT include generic references (\"the door\" unless it's \"the basement door\" as a specific thing)\n\nTEXT TO ANALYZE:\n`;\n\n// Reserved for future LLM-based scene detection\nexport const SCENE_EXTRACTION_PROMPT = `Analyze this text and identify distinct scenes or chapters. A scene is a continuous unit of action in one location/time.\n\nReturn ONLY valid JSON (no markdown):\n{\n  \"scenes\": [\n    {\n      \"title\": \"Brief scene title\",\n      \"summary\": \"One sentence summary\",\n      \"characters\": [\"Character names present\"],\n      \"locations\": [\"Location names\"],\n      \"startMarker\": \"First few words of scene\",\n      \"endMarker\": \"Last few words of scene\"\n    }\n  ]\n}\n\nTEXT:\n`;\n\n// ============================================================================\n// Schema Validation\n// ============================================================================\n\nfunction isValidExtractionResponse(candidate: unknown): candidate is RawExtractionResponse {\n  if (typeof candidate !== 'object' || candidate === null) return false;\n  const obj = candidate as Record<string, unknown>;\n\n  const allowedKeys = ['characters', 'locations', 'objects', 'events'];\n  for (const key of allowedKeys) {\n    if (key in obj && !Array.isArray(obj[key])) return false;\n  }\n\n  // Must have at least one non-empty array\n  return allowedKeys.some((key) => Array.isArray(obj[key]) && (obj[key] as unknown[]).length > 0);\n}\n\nfunction isValidEntity(obj: unknown): boolean {\n  if (typeof obj !== 'object' || obj === null) return false;\n  const candidate = obj as Record<string, unknown>;\n  return typeof candidate.name === 'string' && candidate.name.trim().length > 0;\n}\n\n// ============================================================================\n// Normalization\n// ============================================================================\n\nfunction normalizeAliases(raw: unknown): string[] {\n  let aliases: string[];\n\n  if (typeof raw === 'string') {\n    aliases = [raw.trim()];\n  } else if (Array.isArray(raw)) {\n    aliases = raw.filter((s) => typeof s === 'string').map((s) => (s as string).trim());\n  } else {\n    aliases = [];\n  }\n\n  // Filter empties and dedupe (case-insensitive)\n  const seen = new Set<string>();\n  return aliases.filter((a) => {\n    if (!a) return false;\n    const lower = a.toLowerCase();\n    if (seen.has(lower)) return false;\n    seen.add(lower);\n    return true;\n  });\n}\n\nfunction normalizeDescription(raw: unknown): string {\n  return typeof raw === 'string' ? raw.trim() : '';\n}\n\n// ============================================================================\n// Entity Extractor\n// ============================================================================\n\nexport class EntityExtractor {\n  private llm: LLMProvider;\n  private chunkSize: number;\n  private overlapSize: number;\n  private maxTokens: number;\n  private outputDir: string;\n  private verbose: boolean;\n  private quiet: boolean;\n\n  constructor(options: EntityExtractorOptions) {\n    this.llm = options.llmProvider;\n    this.chunkSize = options.chunkSize ?? 8000;\n    this.overlapSize = options.overlapSize ?? 500;\n    this.maxTokens = options.maxTokens ?? 4096;\n    this.outputDir = options.outputDir ?? process.cwd();\n    this.verbose = options.verbose ?? false;\n    this.quiet = options.quiet ?? false;\n  }\n\n  /**\n   * Extract entities from a full manuscript\n   */\n  async extractFromText(\n    text: string,\n    onProgress?: (current: number, total: number) => void\n  ): Promise<ExtractionResult> {\n    const chunks = this.chunkText(text);\n    const allEntities = new Map<string, ExtractedEntity>();\n    const badChunks: BadChunkRecord[] = [];\n\n    const stats: ChunkStats = {\n      total: chunks.length,\n      strict: 0,\n      repaired: 0,\n      salvaged: 0,\n      parsedEmpty: 0,\n      failed: 0,\n      entitiesByType: {},\n      entitiesByMode: { strict: 0, repaired: 0, salvaged: 0 },\n    };\n\n    // Extract entities from each chunk\n    for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n      const chunk = chunks[chunkIndex];\n      if (!chunk) continue;\n      if (onProgress) onProgress(chunkIndex + 1, chunks.length);\n\n      try {\n        const response = await this.llm.complete(EXTRACTION_PROMPT + chunk.text, {\n          temperature: 0.1,\n          maxTokens: this.maxTokens,\n        });\n\n        const result = parseJSONWithFallbacks(response);\n\n        if (result.ok) {\n          let entitiesFromChunk = 0;\n\n          for (let islandIndex = 0; islandIndex < result.values.length; islandIndex++) {\n            const candidate = result.values[islandIndex];\n            if (!isValidExtractionResponse(candidate)) continue;\n\n            const entities = this.extractEntitiesFromCandidate(candidate, {\n              parseMode: result.mode,\n              chunkIndex,\n              islandIndex: result.mode === 'salvaged' ? islandIndex : undefined,\n            });\n\n            entitiesFromChunk += entities.length;\n            this.mergeEntities(allEntities, entities, stats);\n          }\n\n          if (entitiesFromChunk > 0) {\n            stats[result.mode]++;\n            if (this.verbose && !this.quiet) {\n              const extra =\n                result.mode === 'salvaged' && result.warnings\n                  ? ` (${result.warnings[0]})`\n                  : result.mode !== 'strict'\n                    ? ` (${result.mode})`\n                    : '';\n              console.log(\n                `Chunk ${chunkIndex + 1}/${chunks.length}: ${entitiesFromChunk} entities${extra}`\n              );\n            }\n          } else {\n            stats.parsedEmpty++;\n            if (this.verbose && !this.quiet) {\n              console.log(\n                `Chunk ${chunkIndex + 1}/${chunks.length}: 0 entities (parsed but empty)`\n              );\n            }\n          }\n        } else {\n          stats.failed++;\n          badChunks.push({\n            chunkIndex,\n            phase: result.mode,\n            error: result.error,\n            errors: result.errors,\n            rawSnippet: result.rawSnippet,\n            repairedSnippet: result.repairedSnippet,\n            attemptedRepair: result.attemptedRepair,\n            islandsFound: result.islandsFound,\n            model: this.llm.modelName,\n            extractorVersion: VERSION,\n            timestamp: new Date().toISOString(),\n          });\n\n          if (this.verbose && !this.quiet) {\n            console.log(\n              `Chunk ${chunkIndex + 1}/${chunks.length}: parse failed -> bad-chunks.jsonl`\n            );\n          }\n        }\n      } catch (error) {\n        stats.failed++;\n        if (!this.quiet) {\n          console.error(`Chunk ${chunkIndex + 1}/${chunks.length}: LLM error:`, error);\n        }\n      }\n    }\n\n    // Write bad chunks if any\n    let badChunksPath: string | undefined;\n    if (badChunks.length > 0) {\n      badChunksPath = await this.writeBadChunks(badChunks);\n    }\n\n    // Extract scene structure\n    const scenes = await this.extractScenes(text, chunks);\n\n    return {\n      entities: Array.from(allEntities.values()).sort((a, b) => b.mentions - a.mentions),\n      scenes,\n      stats,\n      badChunksPath,\n    };\n  }\n\n  /**\n   * Print extraction summary to console\n   */\n  printSummary(result: ExtractionResult): void {\n    if (this.quiet) return;\n\n    const { stats, badChunksPath, entities } = result;\n\n    console.log('\\nEntity extraction complete:');\n    console.log(`  Chunks processed: ${stats.total}`);\n    console.log('  Parse results:');\n    console.log(`    - strict:      ${stats.strict} chunks`);\n    console.log(`    - repaired:    ${stats.repaired} chunks`);\n    console.log(`    - salvaged:    ${stats.salvaged} chunks`);\n    console.log(`    - parsedEmpty: ${stats.parsedEmpty} chunks`);\n    console.log(`    - failed:      ${stats.failed} chunks`);\n\n    console.log(`  Entities extracted: ${entities.length}`);\n    for (const [type, count] of Object.entries(stats.entitiesByType)) {\n      console.log(`    - ${type}s: ${count}`);\n    }\n\n    if (badChunksPath) {\n      console.log(`\\n  Failed chunks logged to: ${badChunksPath}`);\n    }\n  }\n\n  private chunkText(text: string): Array<{ text: string; start: number; end: number }> {\n    const chunks: Array<{ text: string; start: number; end: number }> = [];\n    let start = 0;\n\n    while (start < text.length) {\n      let end = start + this.chunkSize;\n\n      // Try to break at paragraph boundary\n      if (end < text.length) {\n        const breakPoint = text.lastIndexOf('\\n\\n', end);\n        if (breakPoint > start + this.chunkSize / 2) {\n          end = breakPoint;\n        }\n      } else {\n        end = text.length;\n      }\n\n      chunks.push({\n        text: text.slice(start, end),\n        start,\n        end,\n      });\n\n      start = end - this.overlapSize;\n      if (start < 0) start = 0;\n      if (end >= text.length) break;\n    }\n\n    return chunks;\n  }\n\n  private extractEntitiesFromCandidate(\n    response: RawExtractionResponse,\n    provenance: { parseMode: ParseMode; chunkIndex: number; islandIndex?: number | undefined }\n  ): ExtractedEntity[] {\n    const entities: ExtractedEntity[] = [];\n\n    const typeMap: Array<{ key: keyof RawExtractionResponse; type: NodeType }> = [\n      { key: 'characters', type: 'character' },\n      { key: 'locations', type: 'location' },\n      { key: 'objects', type: 'object' },\n      { key: 'events', type: 'event' },\n    ];\n\n    for (const { key, type } of typeMap) {\n      const items = response[key];\n      if (!Array.isArray(items)) continue;\n\n      for (const item of items) {\n        if (!isValidEntity(item)) continue;\n\n        const raw = item as Record<string, unknown>;\n        entities.push({\n          name: (raw.name as string).trim(),\n          type,\n          aliases: normalizeAliases(raw.aliases),\n          description: normalizeDescription(raw.description),\n          mentions: 1,\n          parseMode: provenance.parseMode,\n          chunkIndex: provenance.chunkIndex,\n          islandIndex: provenance.islandIndex,\n        });\n      }\n    }\n\n    return entities;\n  }\n\n  private mergeEntities(\n    allEntities: Map<string, ExtractedEntity>,\n    newEntities: ExtractedEntity[],\n    stats: ChunkStats\n  ): void {\n    for (const entity of newEntities) {\n      const key = this.normalizeEntityKey(entity.name);\n      const existing = allEntities.get(key);\n\n      if (existing) {\n        // Merge: combine aliases, increment mentions\n        const combinedAliases = [...existing.aliases, ...entity.aliases];\n        const seen = new Set<string>();\n        existing.aliases = combinedAliases.filter((a) => {\n          const lower = a.toLowerCase();\n          if (seen.has(lower)) return false;\n          seen.add(lower);\n          return true;\n        });\n        existing.mentions += 1;\n        // Keep longer description\n        if (entity.description.length > existing.description.length) {\n          existing.description = entity.description;\n        }\n      } else {\n        allEntities.set(key, { ...entity });\n\n        // Update stats for new entity\n        stats.entitiesByType[entity.type] = (stats.entitiesByType[entity.type] || 0) + 1;\n        stats.entitiesByMode[entity.parseMode]++;\n      }\n    }\n  }\n\n  private async extractScenes(\n    _fullText: string,\n    chunks: Array<{ text: string; start: number; end: number }>\n  ): Promise<ExtractionResult['scenes']> {\n    const scenes: ExtractionResult['scenes'] = [];\n    const chapterRegex = /^#+\\s*(Chapter|Scene|Part)\\s*\\d*[:\\s]*.*/gim;\n\n    for (const chunk of chunks) {\n      const matches = chunk.text.matchAll(chapterRegex);\n      for (const match of matches) {\n        if (match.index !== undefined) {\n          scenes.push({\n            title: match[0].replace(/^#+\\s*/, '').trim(),\n            summary: '',\n            startOffset: chunk.start + match.index,\n            endOffset: chunk.start + match.index + 1000,\n            entities: [],\n          });\n        }\n      }\n    }\n\n    return scenes;\n  }\n\n  private normalizeEntityKey(name: string): string {\n    return name.toLowerCase().replace(/[^a-z0-9]/g, '');\n  }\n\n  private async writeBadChunks(badChunks: BadChunkRecord[]): Promise<string> {\n    const filePath = path.join(this.outputDir, 'extract-bad-chunks.jsonl');\n\n    const lines = badChunks.map((record) => JSON.stringify(record)).join('\\n');\n\n    await fs.promises.writeFile(filePath, lines + '\\n', 'utf-8');\n\n    return filePath;\n  }\n}\n","/**\n * Resilient JSON parser for LLM outputs\n *\n * Multi-stage fallback pipeline:\n * 1. Strict - Standard JSON.parse after cleanup\n * 2. Repair - Use jsonrepair library to fix common issues\n * 3. Salvage - Find and parse individual JSON islands\n */\n\nimport { jsonrepair } from 'jsonrepair';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type ParseMode = 'strict' | 'repaired' | 'salvaged';\n\nexport interface ParseSuccess {\n  ok: true;\n  mode: ParseMode;\n  values: unknown[]; // Always array (1 for strict/repair, N for salvage)\n  warnings?: string[] | undefined;\n}\n\nexport interface ParseFailure {\n  ok: false;\n  mode: ParseMode; // Last stage attempted\n  error: string;\n  errors?: Partial<Record<ParseMode, string>> | undefined;\n  rawSnippet: string;\n  repairedSnippet?: string | undefined;\n  attemptedRepair: boolean;\n  islandsFound: number;\n}\n\nexport type ParseResult = ParseSuccess | ParseFailure;\n\n// Internal helper types\ninterface StrictResult {\n  ok: boolean;\n  value?: unknown;\n  error?: string;\n}\n\ninterface RepairResult {\n  ok: boolean;\n  value?: unknown;\n  error?: string;\n  repairedText?: string;\n}\n\ninterface SalvageResult {\n  ok: boolean;\n  values?: unknown[] | undefined;\n  error?: string | undefined;\n  warnings?: string[] | undefined;\n  islandsFound: number;\n}\n\n// ============================================================================\n// Main Entry Point\n// ============================================================================\n\n/**\n * Parse JSON with multi-stage fallback\n *\n * Attempts strict parsing first, then repair, then salvage.\n * Returns parsed values with provenance metadata.\n */\nexport function parseJSONWithFallbacks(raw: string): ParseResult {\n  // Shared cleanup (runs once, before all stages)\n  const cleaned = cleanupRaw(raw);\n  const errors: Partial<Record<ParseMode, string>> = {};\n\n  // Stage 1: Strict\n  const strict = tryStrictParse(cleaned);\n  if (strict.ok && strict.value !== undefined) {\n    return { ok: true, mode: 'strict', values: [strict.value] };\n  }\n  if (strict.error) errors.strict = strict.error;\n\n  // Stage 2: Repair\n  const repaired = tryRepairParse(cleaned);\n  if (repaired.ok && repaired.value !== undefined) {\n    return { ok: true, mode: 'repaired', values: [repaired.value] };\n  }\n  if (repaired.error) errors.repaired = repaired.error;\n\n  // Stage 3: Salvage\n  const salvaged = trySalvageParse(cleaned);\n  if (salvaged.ok && salvaged.values && salvaged.values.length > 0) {\n    return {\n      ok: true,\n      mode: 'salvaged',\n      values: salvaged.values,\n      warnings: salvaged.warnings,\n    };\n  }\n\n  // All failed\n  return {\n    ok: false,\n    mode: 'salvaged',\n    error: salvaged.error ?? 'No valid JSON found',\n    errors,\n    rawSnippet: cleaned.slice(0, 500),\n    repairedSnippet: repaired.repairedText?.slice(0, 500),\n    attemptedRepair: true,\n    islandsFound: salvaged.islandsFound,\n  };\n}\n\n// ============================================================================\n// Cleanup\n// ============================================================================\n\n/**\n * Clean up raw LLM output before parsing\n * - Strip markdown fences\n * - Find outermost JSON boundaries\n */\nfunction cleanupRaw(raw: string): string {\n  let text = raw.trim();\n\n  // Strip markdown fences\n  if (text.startsWith('```')) {\n    text = text.replace(/^```(?:json)?\\n?/, '').replace(/\\n?```$/, '');\n  }\n\n  // Find outermost JSON boundaries\n  const objStart = text.indexOf('{');\n  const arrStart = text.indexOf('[');\n\n  // Determine which comes first\n  let start: number;\n  let closeChar: string;\n\n  if (objStart === -1 && arrStart === -1) {\n    return text; // No JSON structure found\n  } else if (objStart === -1) {\n    start = arrStart;\n    closeChar = ']';\n  } else if (arrStart === -1) {\n    start = objStart;\n    closeChar = '}';\n  } else if (objStart < arrStart) {\n    start = objStart;\n    closeChar = '}';\n  } else {\n    start = arrStart;\n    closeChar = ']';\n  }\n\n  const end = text.lastIndexOf(closeChar);\n  if (end > start) {\n    text = text.slice(start, end + 1);\n  }\n\n  return text;\n}\n\n// ============================================================================\n// Stage 1: Strict Parse\n// ============================================================================\n\nfunction tryStrictParse(text: string): StrictResult {\n  try {\n    const value = JSON.parse(text);\n    return { ok: true, value };\n  } catch (e) {\n    return {\n      ok: false,\n      error: e instanceof Error ? e.message : String(e),\n    };\n  }\n}\n\n// ============================================================================\n// Stage 2: Repair Parse\n// ============================================================================\n\nfunction tryRepairParse(text: string): RepairResult {\n  let repairedText: string | undefined;\n\n  try {\n    repairedText = jsonrepair(text);\n  } catch (e) {\n    return {\n      ok: false,\n      error: `Repair failed: ${e instanceof Error ? e.message : String(e)}`,\n    };\n  }\n\n  try {\n    const value = JSON.parse(repairedText);\n    return { ok: true, value, repairedText };\n  } catch (e) {\n    return {\n      ok: false,\n      error: `Parse after repair failed: ${e instanceof Error ? e.message : String(e)}`,\n      repairedText,\n    };\n  }\n}\n\n// ============================================================================\n// Stage 3: Salvage Parse\n// ============================================================================\n\nfunction trySalvageParse(text: string): SalvageResult {\n  const islands = findJSONIslands(text);\n  const values: unknown[] = [];\n  let failed = 0;\n\n  for (const island of islands) {\n    // Try strict first\n    const strict = tryStrictParse(island);\n    if (strict.ok && isNonEmptyObjectOrArray(strict.value)) {\n      values.push(strict.value);\n      continue;\n    }\n\n    // Try repair\n    const repaired = tryRepairParse(island);\n    if (repaired.ok && isNonEmptyObjectOrArray(repaired.value)) {\n      values.push(repaired.value);\n      continue;\n    }\n\n    failed++;\n  }\n\n  if (values.length > 0) {\n    const warnings: string[] = [];\n    if (islands.length > 1 || failed > 0) {\n      warnings.push(`salvage: used ${values.length}/${islands.length} islands`);\n    }\n    return {\n      ok: true,\n      values,\n      warnings: warnings.length > 0 ? warnings : undefined,\n      islandsFound: islands.length,\n    };\n  }\n\n  return {\n    ok: false,\n    error:\n      islands.length === 0\n        ? 'No JSON islands found'\n        : `All ${islands.length} islands failed to parse`,\n    islandsFound: islands.length,\n  };\n}\n\n/**\n * Find JSON islands (balanced {...} or [...] regions) in text\n *\n * Uses a string-aware scanner to avoid treating braces inside\n * quoted strings as structural boundaries.\n */\nfunction findJSONIslands(text: string): string[] {\n  const islands: string[] = [];\n  const stack: string[] = [];\n  let start = -1;\n  let inString = false;\n  let escapeNext = false;\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i]!;\n\n    // Handle escape sequences\n    if (escapeNext) {\n      escapeNext = false;\n      continue;\n    }\n    if (char === '\\\\' && inString) {\n      escapeNext = true;\n      continue;\n    }\n\n    // Handle string boundaries\n    if (char === '\"') {\n      inString = !inString;\n      continue;\n    }\n\n    // Skip everything inside strings\n    if (inString) continue;\n\n    // Handle structural braces\n    if (char === '{' || char === '[') {\n      if (stack.length === 0) start = i;\n      stack.push(char === '{' ? '}' : ']');\n    } else if (char === '}' || char === ']') {\n      if (stack.length > 0 && stack[stack.length - 1] === char) {\n        stack.pop();\n        if (stack.length === 0 && start !== -1) {\n          const island = text.slice(start, i + 1);\n          // Skip tiny islands (< 20 chars)\n          if (island.length >= 20) {\n            islands.push(island);\n          }\n          start = -1;\n        }\n      }\n    }\n  }\n\n  return islands;\n}\n\n/**\n * Check if a value is a non-empty object or array\n * Filters out primitives and empty containers\n */\nfunction isNonEmptyObjectOrArray(value: unknown): boolean {\n  if (Array.isArray(value)) return value.length > 0;\n  if (typeof value === 'object' && value !== null) {\n    return Object.keys(value).length > 0;\n  }\n  return false;\n}\n","import { Command } from 'commander';\nimport * as path from 'node:path';\nimport { findVaultRoot, Spinner } from '../utils.js';\nimport {\n  generateCharacters,\n  generateChapters,\n  generateLocations,\n  generateObjects,\n  generateLore,\n  generateTimeline,\n  generateArcs,\n  findKBFiles,\n  type GeneratorOptions,\n  type ChapterGeneratorOptions,\n  type GeneratorResult,\n} from '../../generators/index.js';\n\n/**\n * Resolve common options for generators\n */\nfunction resolveOptions(options: {\n  output?: string;\n  kb?: string;\n  arcLedger?: string;\n  worldRules?: string;\n  force?: boolean;\n  dryRun?: boolean;\n  verbose?: boolean;\n}): GeneratorOptions {\n  // Find vault root or use current directory\n  const vaultPath = findVaultRoot() || process.cwd();\n  const outputDir = options.output ? path.resolve(options.output) : vaultPath;\n\n  // Find KB files if not specified\n  const kbFiles = findKBFiles(vaultPath);\n\n  return {\n    outputDir,\n    kbPath: options.kb ? path.resolve(options.kb) : kbFiles.kb,\n    arcLedgerPath: options.arcLedger ? path.resolve(options.arcLedger) : kbFiles.arcLedger,\n    worldRulesPath: options.worldRules ? path.resolve(options.worldRules) : kbFiles.worldRules,\n    force: options.force || false,\n    dryRun: options.dryRun || false,\n    verbose: options.verbose || false,\n  };\n}\n\n/**\n * Print generator result\n */\nfunction printResult(result: GeneratorResult): void {\n  console.log(`\\n${result.summary}`);\n\n  if (result.errors.length > 0) {\n    console.log('\\nErrors:');\n    for (const err of result.errors.slice(0, 10)) {\n      console.log(`  ${err.file}: ${err.error}`);\n    }\n    if (result.errors.length > 10) {\n      console.log(`  ... and ${result.errors.length - 10} more`);\n    }\n  }\n}\n\n// Create the parent generate command\nexport const generateCommand = new Command('generate')\n  .description('Generate vault notes from knowledge base data')\n  .addHelpText(\n    'after',\n    `\nExamples:\n  zettel generate characters         Generate character notes\n  zettel generate all                Generate all note types\n  zettel generate chapters -m book.md  Split manuscript into chapters\n`\n  );\n\n// Characters subcommand\ngenerateCommand\n  .command('characters')\n  .description('Generate character notes from KB data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating character notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath) {\n        spinner.stop('Error: No KB file found. Specify with --kb option.');\n        process.exit(1);\n      }\n\n      const result = await generateCharacters(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Chapters subcommand\ngenerateCommand\n  .command('chapters')\n  .description('Split manuscript into chapter notes')\n  .requiredOption('-m, --manuscript <path>', 'Path to manuscript file')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-d, --chapters-dir <dir>', 'Subdirectory for chapters (default: Chapters)')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Splitting manuscript into chapters...');\n    spinner.start();\n\n    try {\n      const baseOpts = resolveOptions(options);\n      const chapterOpts: ChapterGeneratorOptions = {\n        ...baseOpts,\n        manuscriptPath: path.resolve(options.manuscript),\n        chaptersDir: options.chaptersDir,\n      };\n\n      const result = await generateChapters(chapterOpts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Locations subcommand\ngenerateCommand\n  .command('locations')\n  .description('Generate location notes from KB data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating location notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath) {\n        spinner.stop('Error: No KB file found. Specify with --kb option.');\n        process.exit(1);\n      }\n\n      const result = await generateLocations(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Objects subcommand\ngenerateCommand\n  .command('objects')\n  .description('Generate object/artifact notes from KB data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating object notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath) {\n        spinner.stop('Error: No KB file found. Specify with --kb option.');\n        process.exit(1);\n      }\n\n      const result = await generateObjects(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Lore subcommand\ngenerateCommand\n  .command('lore')\n  .description('Generate lore/world rules notes from KB and world-rules data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-w, --world-rules <path>', 'Path to world-rules.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating lore notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath && !opts.worldRulesPath) {\n        spinner.stop(\n          'Error: No KB or world-rules file found. Specify with --kb or --world-rules option.'\n        );\n        process.exit(1);\n      }\n\n      const result = await generateLore(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Timeline subcommand\ngenerateCommand\n  .command('timeline')\n  .description('Generate timeline event notes from KB data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating timeline notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath) {\n        spinner.stop('Error: No KB file found. Specify with --kb option.');\n        process.exit(1);\n      }\n\n      const result = await generateTimeline(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Arcs subcommand\ngenerateCommand\n  .command('arcs')\n  .description('Generate plot thread and character arc notes from arc-ledger')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-a, --arc-ledger <path>', 'Path to arc-ledger.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating arc notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.arcLedgerPath) {\n        spinner.stop('Error: No arc-ledger file found. Specify with --arc-ledger option.');\n        process.exit(1);\n      }\n\n      const result = await generateArcs(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// All subcommand - runs all generators\ngenerateCommand\n  .command('all')\n  .description('Run all generators in sequence')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-a, --arc-ledger <path>', 'Path to arc-ledger.json file')\n  .option('-w, --world-rules <path>', 'Path to world-rules.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Running all generators...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n      const results: GeneratorResult[] = [];\n\n      // Characters\n      if (opts.kbPath) {\n        spinner.update('Generating characters...');\n        results.push(await generateCharacters(opts));\n      }\n\n      // Locations\n      if (opts.kbPath) {\n        spinner.update('Generating locations...');\n        results.push(await generateLocations(opts));\n      }\n\n      // Objects\n      if (opts.kbPath) {\n        spinner.update('Generating objects...');\n        results.push(await generateObjects(opts));\n      }\n\n      // Timeline\n      if (opts.kbPath) {\n        spinner.update('Generating timeline...');\n        results.push(await generateTimeline(opts));\n      }\n\n      // Lore\n      if (opts.kbPath || opts.worldRulesPath) {\n        spinner.update('Generating lore...');\n        results.push(await generateLore(opts));\n      }\n\n      // Arcs\n      if (opts.arcLedgerPath) {\n        spinner.update('Generating arcs...');\n        results.push(await generateArcs(opts));\n      }\n\n      spinner.stop();\n\n      // Print summary\n      console.log('\\nGeneration complete:\\n');\n      for (const result of results) {\n        console.log(`  ${result.summary}`);\n      }\n\n      // Total errors\n      const totalErrors = results.reduce((sum, r) => sum + r.errors.length, 0);\n      if (totalErrors > 0) {\n        console.log(`\\nTotal errors: ${totalErrors}`);\n      }\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n","/**\n * Types for vault generators\n * These types define the structure of knowledge base data used to generate vault notes\n */\n\n// ============================================================================\n// KB Data Types - Generic versions without manuscript-specific content\n// ============================================================================\n\nexport interface KBCharacter {\n  id: string;\n  canonical_name: string;\n  aliases?: string[];\n  role: string;\n  chapters_present?: number[];\n  first_appearance?: number;\n  last_appearance?: number;\n  age?: number;\n  physical?: Record<string, unknown>;\n  personality?: string[];\n  abilities?: Record<string, unknown>;\n  equipment?: string[];\n  backstory?: Record<string, unknown>;\n  arc?: CharacterArc;\n  entry_state?: Record<string, unknown>;\n  exit_state?: Record<string, unknown>;\n  key_quote?: string;\n  final_words?: string;\n  coping_mechanism?: Record<string, unknown>;\n  relationship_to_protagonist?: string;\n}\n\nexport interface CharacterArc {\n  type: string;\n  description: string;\n  key_moments?: Array<{\n    chapter: number;\n    beat: string;\n    description: string;\n  }>;\n  resolution?: {\n    status: string;\n    chapter?: number;\n    key_line?: string;\n    mechanism?: string;\n  };\n}\n\nexport interface KBLocation {\n  id: string;\n  name: string;\n  type: string;\n  description?: string;\n  features?: string[];\n  chapters_seen?: number[];\n  first_appearance?: number;\n  realm?: 'real_world' | 'dimensional' | 'liminal' | 'unknown';\n}\n\nexport interface KBObject {\n  id: string;\n  name: string;\n  type: string;\n  description?: string;\n  properties?: string[];\n  significance?: string;\n  locked?: boolean;\n  holder?: string | null;\n  holders?: string[];\n  status?: string | null;\n}\n\nexport interface KBTimelineEvent {\n  id: string;\n  description: string;\n  chapter: number;\n  locked?: boolean;\n  significance?: string;\n}\n\nexport interface KBPlotThread {\n  id: string;\n  name: string;\n  type: string;\n  status: string;\n  chapters_touched?: number[];\n  expected_resolution?: string;\n  resolution_chapter?: number;\n  resolution_description?: string;\n}\n\nexport interface KBFact {\n  id: string;\n  fact: string;\n  source: string;\n  locked?: boolean;\n}\n\nexport interface KBNameNormalization {\n  canonical: string;\n  variants: string[];\n}\n\n// ============================================================================\n// Relationship Types\n// ============================================================================\n\nexport type RelationshipKind =\n  // charactercharacter\n  | 'ally'\n  | 'enemy'\n  | 'family'\n  | 'mentor'\n  | 'rival'\n  // characterlocation\n  | 'visits'\n  | 'resides'\n  // characterobject\n  | 'owns'\n  | 'holds'\n  | 'formerly_held'\n  // characterevent\n  | 'participated'\n  | 'witnessed'\n  // locationobject/event\n  | 'contains'\n  | 'occurred_at'\n  // generic\n  | 'co_occurrence'\n  | 'associated';\n\nexport interface KBRelationship {\n  sourceId: string;\n  targetId: string;\n  type: RelationshipKind;\n  description?: string;\n  chapters?: number[];\n}\n\nexport type EntityType = 'character' | 'location' | 'object' | 'event';\n\nexport interface ComputedRelationship {\n  targetId: string;\n  targetName: string;\n  targetType: EntityType;\n  relationshipType: RelationshipKind;\n  description?: string | undefined;\n  chapters?: number[] | undefined;\n  source: 'explicit' | 'inferred' | 'co_occurrence';\n  /** Wikilink target (e.g., \"Event-01-001\" for events) */\n  linkTarget?: string | undefined;\n  /** Optional display text for wikilink (e.g., \"Alpha arrives at the facility\") */\n  linkDisplay?: string | undefined;\n}\n\nexport interface KBData {\n  schema_version: string;\n  book_id: string;\n  series_id?: string;\n  kb_version?: string;\n  created_at?: string;\n  last_updated?: string;\n  source?: string;\n  characters: KBCharacter[];\n  locations: KBLocation[];\n  objects: KBObject[];\n  timeline: KBTimelineEvent[];\n  plot_threads?: KBPlotThread[];\n  facts?: KBFact[];\n  relationships?: KBRelationship[];\n  contradictions?: unknown[];\n  name_normalization?: KBNameNormalization[];\n  cross_reference?: Record<string, unknown>;\n}\n\n// ============================================================================\n// Arc Ledger Types\n// ============================================================================\n\nexport interface ArcLedgerCharacter {\n  character_id: string;\n  canonical_name: string;\n  entry_state?: Record<string, unknown>;\n  arc?: CharacterArc;\n  exit_state?: Record<string, unknown>;\n}\n\nexport interface ArcLedgerThread {\n  thread_id: string;\n  name: string;\n  type: string;\n  status: string;\n  chapters_touched?: number[];\n  resolution_chapter?: number;\n  resolution_description?: string;\n  expected_resolution?: string;\n  description?: string;\n}\n\nexport interface ArcLedger {\n  schema_version: string;\n  book_id: string;\n  series_id?: string;\n  last_updated?: string;\n  characters: ArcLedgerCharacter[];\n  threads: ArcLedgerThread[];\n  series_arc_tracking?: Record<string, unknown>;\n  locked_element_compliance?: Record<string, unknown>;\n}\n\n// ============================================================================\n// World Rules Types\n// ============================================================================\n\nexport interface WorldRule {\n  id: string;\n  name: string;\n  category: string;\n  description: string;\n  locked?: boolean;\n  examples?: string[];\n  exceptions?: string[];\n  source?: string;\n}\n\nexport interface WorldRulesData {\n  schema_version: string;\n  rules?: WorldRule[];\n  mechanics?: WorldRule[];\n  constraints?: WorldRule[];\n}\n\n// ============================================================================\n// Generator Options\n// ============================================================================\n\nexport interface GeneratorOptions {\n  /** Path to the output vault directory */\n  outputDir: string;\n  /** Path to the KB JSON file */\n  kbPath?: string | undefined;\n  /** Path to the arc-ledger JSON file */\n  arcLedgerPath?: string | undefined;\n  /** Path to the world-rules JSON file */\n  worldRulesPath?: string | undefined;\n  /** Whether to use database as source instead of JSON files */\n  fromDb?: boolean | undefined;\n  /** Dry run - don't write files, just show what would be created */\n  dryRun?: boolean | undefined;\n  /** Overwrite existing files */\n  force?: boolean | undefined;\n  /** Verbose output */\n  verbose?: boolean | undefined;\n  /** Include Related Entities section in generated notes */\n  includeRelatedEntities?: boolean | undefined;\n  /** Minimum shared chapters for co-occurrence relationships (default: 2) */\n  coOccurrenceThreshold?: number | undefined;\n}\n\nexport interface ChapterGeneratorOptions extends GeneratorOptions {\n  /** Path to the manuscript file */\n  manuscriptPath: string;\n  /** Output subdirectory for chapters */\n  chaptersDir?: string | undefined;\n}\n\nexport interface InjectLinksOptions {\n  /** Path to the vault directory */\n  vaultPath: string;\n  /** Dry run - show changes without modifying files */\n  dryRun?: boolean | undefined;\n  /** Entity names to create wikilinks for */\n  entities?: string[] | undefined;\n  /** Pattern to match files (glob) */\n  pattern?: string | undefined;\n  /** Verbose output */\n  verbose?: boolean | undefined;\n}\n\n// ============================================================================\n// Generator Results\n// ============================================================================\n\nexport interface GeneratorResult {\n  /** Files that were created */\n  created: string[];\n  /** Files that were skipped (already exist) */\n  skipped: string[];\n  /** Errors encountered */\n  errors: Array<{ file: string; error: string }>;\n  /** Summary message */\n  summary: string;\n}\n\nexport interface InjectLinksResult {\n  /** Files that were modified */\n  modified: string[];\n  /** Total links injected */\n  linksInjected: number;\n  /** Files that were skipped */\n  skipped: string[];\n  /** Errors encountered */\n  errors: Array<{ file: string; error: string }>;\n}\n\n// ============================================================================\n// Lock Level System\n// ============================================================================\n\nexport type LockLevel = 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';\n\nexport function getLockLevel(entity: { locked?: boolean; significance?: string }): LockLevel {\n  if (entity.locked) {\n    return 'CRITICAL';\n  }\n\n  const sig = entity.significance?.toLowerCase() || '';\n  if (sig.includes('critical') || sig.includes('essential')) {\n    return 'HIGH';\n  }\n  if (sig.includes('important') || sig.includes('significant')) {\n    return 'MEDIUM';\n  }\n  return 'LOW';\n}\n\n// ============================================================================\n// Realm Classification\n// ============================================================================\n\nexport type RealmType = 'real_world' | 'dimensional' | 'liminal' | 'unknown';\n\nconst DIMENSIONAL_KEYWORDS = ['dimension', 'portal', 'void', 'realm', 'prison', 'core', 'barrier'];\nconst LIMINAL_KEYWORDS = ['threshold', 'between', 'transition', 'edge', 'boundary'];\nconst REAL_WORLD_KEYWORDS = ['house', 'basement', 'bedroom', 'hospital', 'street', 'school', 'lab'];\n\nexport function classifyRealm(location: KBLocation): RealmType {\n  // Explicit type takes precedence\n  if (location.realm) {\n    return location.realm;\n  }\n\n  // Check type field\n  const locType = location.type?.toLowerCase() || '';\n  if (locType.includes('dimensional') || locType === 'dimensional_location') {\n    return 'dimensional';\n  }\n  if (locType.includes('real') || locType === 'real_world_location') {\n    return 'real_world';\n  }\n\n  // Heuristic keyword detection\n  const name = location.name.toLowerCase();\n  const desc = (location.description || '').toLowerCase();\n  const combined = `${name} ${desc}`;\n\n  for (const keyword of DIMENSIONAL_KEYWORDS) {\n    if (combined.includes(keyword)) {\n      return 'dimensional';\n    }\n  }\n\n  for (const keyword of LIMINAL_KEYWORDS) {\n    if (combined.includes(keyword)) {\n      return 'liminal';\n    }\n  }\n\n  for (const keyword of REAL_WORLD_KEYWORDS) {\n    if (combined.includes(keyword)) {\n      return 'real_world';\n    }\n  }\n\n  return 'unknown';\n}\n","/**\n * Shared utilities for vault generators\n */\n\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { stringify as stringifyYaml } from 'yaml';\nimport type { KBData, ArcLedger, WorldRulesData } from './types.js';\n\n// ============================================================================\n// Filename Sanitization\n// ============================================================================\n\n/**\n * Sanitize a string for use as a filename\n * Removes or replaces characters that are unsafe in filenames\n */\nexport function sanitizeFilename(name: string): string {\n  return (\n    name\n      // Replace Windows/Unix unsafe characters\n      .replace(/[<>:\"/\\\\|?*]/g, '')\n      // Replace multiple spaces with single space\n      .replace(/\\s+/g, ' ')\n      // Trim whitespace\n      .trim()\n      // Replace spaces with hyphens for cleaner URLs\n      .replace(/\\s/g, '-')\n      // Remove any remaining problematic characters\n      .replace(/[^\\w\\-().]/g, '')\n      // Collapse multiple hyphens\n      .replace(/-+/g, '-')\n      // Remove leading/trailing hyphens\n      .replace(/^-+|-+$/g, '')\n  );\n}\n\n/**\n * Generate a safe path for a note file\n */\nexport function generateNotePath(\n  outputDir: string,\n  subdir: string,\n  name: string,\n  extension: string = '.md'\n): string {\n  const safeFilename = sanitizeFilename(name);\n  return path.join(outputDir, subdir, `${safeFilename}${extension}`);\n}\n\n// ============================================================================\n// Frontmatter Building\n// ============================================================================\n\n/**\n * Build frontmatter YAML string from data\n */\nexport function buildFrontmatter(data: Record<string, unknown>): string {\n  // Filter out undefined/null values\n  const cleaned = Object.fromEntries(\n    Object.entries(data).filter(([, v]) => v !== undefined && v !== null)\n  );\n\n  if (Object.keys(cleaned).length === 0) {\n    return '';\n  }\n\n  return `---\\n${stringifyYaml(cleaned)}---\\n\\n`;\n}\n\n/**\n * Build a complete note with frontmatter and content\n */\nexport function buildNote(frontmatter: Record<string, unknown>, content: string): string {\n  const fm = buildFrontmatter(frontmatter);\n  return `${fm}${content}`;\n}\n\n// ============================================================================\n// KB Data Loading\n// ============================================================================\n\n/**\n * Load and parse a JSON file\n */\nexport function loadJson<T>(filePath: string): T {\n  const content = fs.readFileSync(filePath, 'utf-8');\n  return JSON.parse(content) as T;\n}\n\n/**\n * Load KB data from JSON file\n */\nexport function parseKBJson(kbPath: string): KBData {\n  return loadJson<KBData>(kbPath);\n}\n\n/**\n * Load arc ledger from JSON file\n */\nexport function parseArcLedger(arcLedgerPath: string): ArcLedger {\n  return loadJson<ArcLedger>(arcLedgerPath);\n}\n\n/**\n * Load world rules from JSON file\n */\nexport function parseWorldRules(worldRulesPath: string): WorldRulesData {\n  return loadJson<WorldRulesData>(worldRulesPath);\n}\n\n/**\n * Find KB files in a project directory\n */\nexport function findKBFiles(projectDir: string): {\n  kb?: string;\n  arcLedger?: string;\n  worldRules?: string;\n} {\n  const result: { kb?: string; arcLedger?: string; worldRules?: string } = {};\n\n  // Common paths for KB files\n  const kbPaths = [\n    path.join(projectDir, '.narrative-project', 'kb', 'kb.json'),\n    path.join(projectDir, 'kb', 'kb.json'),\n    path.join(projectDir, 'kb.json'),\n  ];\n\n  const arcLedgerPaths = [\n    path.join(projectDir, '.narrative-project', 'kb', 'arc-ledger.json'),\n    path.join(projectDir, 'kb', 'arc-ledger.json'),\n    path.join(projectDir, 'arc-ledger.json'),\n  ];\n\n  const worldRulesPaths = [\n    path.join(projectDir, '.narrative-project', 'kb', 'world-rules.json'),\n    path.join(projectDir, 'kb', 'world-rules.json'),\n    path.join(projectDir, 'world-rules.json'),\n  ];\n\n  for (const p of kbPaths) {\n    if (fs.existsSync(p)) {\n      result.kb = p;\n      break;\n    }\n  }\n\n  for (const p of arcLedgerPaths) {\n    if (fs.existsSync(p)) {\n      result.arcLedger = p;\n      break;\n    }\n  }\n\n  for (const p of worldRulesPaths) {\n    if (fs.existsSync(p)) {\n      result.worldRules = p;\n      break;\n    }\n  }\n\n  return result;\n}\n\n// ============================================================================\n// Entity Deduplication\n// ============================================================================\n\n/**\n * Case-insensitive entity tracker for deduplication\n */\nexport class EntityTracker {\n  private seen = new Map<string, string>(); // lowercase -> canonical\n\n  /**\n   * Check if an entity has been seen\n   */\n  has(name: string): boolean {\n    return this.seen.has(name.toLowerCase());\n  }\n\n  /**\n   * Add an entity to the tracker\n   * Returns false if already present\n   */\n  add(name: string): boolean {\n    const lower = name.toLowerCase();\n    if (this.seen.has(lower)) {\n      return false;\n    }\n    this.seen.set(lower, name);\n    return true;\n  }\n\n  /**\n   * Get the canonical name for an entity\n   */\n  getCanonical(name: string): string | undefined {\n    return this.seen.get(name.toLowerCase());\n  }\n\n  /**\n   * Get all tracked entities\n   */\n  getAll(): string[] {\n    return Array.from(this.seen.values());\n  }\n}\n\n// ============================================================================\n// File Writing Helpers\n// ============================================================================\n\n/**\n * Write a file, creating directories as needed\n * Returns true if file was written, false if skipped\n */\nexport async function writeNoteFile(\n  filePath: string,\n  content: string,\n  options: { force?: boolean | undefined; dryRun?: boolean | undefined } = {}\n): Promise<boolean> {\n  if (options.dryRun) {\n    console.log(`[DRY RUN] Would create: ${filePath}`);\n    return true;\n  }\n\n  // Check if file exists\n  if (!options.force && fs.existsSync(filePath)) {\n    return false;\n  }\n\n  // Create directory\n  const dir = path.dirname(filePath);\n  await fs.promises.mkdir(dir, { recursive: true });\n\n  // Write file\n  await fs.promises.writeFile(filePath, content, 'utf-8');\n  return true;\n}\n\n// ============================================================================\n// Markdown Helpers\n// ============================================================================\n\n/**\n * Create a wikilink\n */\nexport function wikilink(target: string, display?: string): string {\n  if (display && display !== target) {\n    return `[[${target}|${display}]]`;\n  }\n  return `[[${target}]]`;\n}\n\n/**\n * Create a list of wikilinks\n */\nexport function wikilinkList(items: string[]): string {\n  return items.map((item) => `- ${wikilink(item)}`).join('\\n');\n}\n\n/**\n * Format an array as a YAML-compatible list in frontmatter\n */\nexport function formatList(items: string[] | undefined): string[] | undefined {\n  if (!items || items.length === 0) {\n    return undefined;\n  }\n  return items;\n}\n\n/**\n * Format chapters as a readable string\n */\nexport function formatChapters(chapters: number[] | undefined): string {\n  if (!chapters || chapters.length === 0) {\n    return 'Unknown';\n  }\n  return chapters.join(', ');\n}\n\n/**\n * Create a section header\n */\nexport function section(title: string, level: number = 2): string {\n  const hashes = '#'.repeat(level);\n  return `${hashes} ${title}\\n\\n`;\n}\n\n/**\n * Create a blockquote\n */\nexport function blockquote(text: string): string {\n  return text\n    .split('\\n')\n    .map((line) => `> ${line}`)\n    .join('\\n');\n}\n\n/**\n * Format a key-value pair for display\n */\nexport function kvPair(key: string, value: unknown): string {\n  if (value === undefined || value === null) {\n    return '';\n  }\n  if (Array.isArray(value)) {\n    return `**${key}:** ${value.join(', ')}`;\n  }\n  return `**${key}:** ${value}`;\n}\n","/**\n * Relationship Engine\n * Computes relationships between entities from explicit data, field inference, and co-occurrence\n *\n * Features:\n * - Explicit relationships from kb.relationships[]\n * - Inferred relationships from entity fields (equipment, holder, etc.)\n * - Event-character inference (characters present in event chapter  participated)\n * - Event-location inference (locations present in event chapter  occurred_at)\n * - Object chapter derivation from existing relationship chapters\n * - Co-occurrence relationships from shared chapters\n */\n\nimport type {\n  KBData,\n  ComputedRelationship,\n  RelationshipKind,\n  EntityType,\n  KBTimelineEvent,\n} from './types.js';\n\nconst DEFAULT_CO_OCCURRENCE_THRESHOLD = 2;\n\ninterface EntityInfo {\n  id: string;\n  name: string;\n  type: EntityType;\n  chapters: number[];\n  /** Wikilink target (may differ from name for events) */\n  linkTarget: string;\n  /** Optional display text for wikilink */\n  linkDisplay?: string;\n}\n\n/**\n * Normalize a name for robust matching (handles whitespace, underscores, case)\n */\nfunction normalizeName(s: string): string {\n  return s.toLowerCase().replace(/\\s+/g, ' ').replace(/[_-]+/g, ' ').trim();\n}\n\n/**\n * Generate a filename for an event (e.g., \"Event-01-001\")\n */\nfunction getEventFilename(event: KBTimelineEvent): string {\n  const chapterStr = event.chapter.toString().padStart(2, '0');\n  const eventNum = event.id.replace(/[^0-9]/g, '').padStart(3, '0');\n  return `Event-${chapterStr}-${eventNum}`;\n}\n\n/**\n * Get a human-readable label for a relationship kind\n * @param kind The relationship kind\n * @param perspective 'out' for sourcetarget, 'in' for targetsource (inverse)\n */\nexport function labelFor(kind: RelationshipKind, perspective: 'out' | 'in'): string {\n  if (kind === 'co_occurrence') return 'co-occurrence';\n\n  if (perspective === 'out') {\n    switch (kind) {\n      case 'occurred_at':\n        return 'occurred at';\n      case 'formerly_held':\n        return 'formerly held';\n      default:\n        return kind.replace(/_/g, ' ');\n    }\n  }\n\n  // Incoming/inverse labels (readable from the other entity's perspective)\n  switch (kind) {\n    case 'visits':\n      return 'visited by';\n    case 'resides':\n      return 'resided by';\n    case 'owns':\n      return 'owned by';\n    case 'holds':\n      return 'held by';\n    case 'formerly_held':\n      return 'formerly held by';\n    case 'participated':\n      return 'participant';\n    case 'witnessed':\n      return 'witness';\n    case 'contains':\n      return 'contained in';\n    case 'occurred_at':\n      return 'site of';\n    default:\n      return kind.replace(/_/g, ' ');\n  }\n}\n\n/**\n * RelationshipEngine computes relationships between entities from multiple sources:\n * 1. Explicit relationships from kb.relationships[]\n * 2. Inferred relationships from entity fields (equipment, holder, etc.)\n * 3. Co-occurrence relationships from shared chapters\n */\nexport class RelationshipEngine {\n  private kb: KBData;\n  private entityIndex: Map<string, EntityInfo>;\n  private nameToId: Map<string, string>;\n  private coOccurrenceThreshold: number;\n\n  constructor(kb: KBData, coOccurrenceThreshold?: number) {\n    this.kb = kb;\n    this.coOccurrenceThreshold = coOccurrenceThreshold ?? DEFAULT_CO_OCCURRENCE_THRESHOLD;\n    this.entityIndex = new Map();\n    this.nameToId = new Map();\n    this.buildEntityIndex();\n  }\n\n  /**\n   * Build an index of all entities for quick lookup\n   */\n  private buildEntityIndex(): void {\n    // Index characters\n    for (const char of this.kb.characters) {\n      const info: EntityInfo = {\n        id: char.id,\n        name: char.canonical_name,\n        type: 'character',\n        chapters: char.chapters_present || [],\n        linkTarget: char.canonical_name,\n      };\n      this.entityIndex.set(char.id, info);\n      this.nameToId.set(normalizeName(char.canonical_name), char.id);\n      // Index aliases too\n      if (char.aliases) {\n        for (const alias of char.aliases) {\n          this.nameToId.set(normalizeName(alias), char.id);\n        }\n      }\n    }\n\n    // Index name normalization table if present\n    if (this.kb.name_normalization) {\n      for (const nn of this.kb.name_normalization) {\n        const canonId = this.nameToId.get(normalizeName(nn.canonical));\n        if (!canonId) continue;\n        for (const variant of nn.variants || []) {\n          this.nameToId.set(normalizeName(variant), canonId);\n        }\n      }\n    }\n\n    // Index locations\n    for (const loc of this.kb.locations) {\n      const info: EntityInfo = {\n        id: loc.id,\n        name: loc.name,\n        type: 'location',\n        chapters: loc.chapters_seen || [],\n        linkTarget: loc.name,\n      };\n      this.entityIndex.set(loc.id, info);\n      this.nameToId.set(normalizeName(loc.name), loc.id);\n    }\n\n    // Index objects\n    for (const obj of this.kb.objects) {\n      const info: EntityInfo = {\n        id: obj.id,\n        name: obj.name,\n        type: 'object',\n        chapters: [], // Objects don't have chapter info directly - derived later\n        linkTarget: obj.name,\n      };\n      this.entityIndex.set(obj.id, info);\n      this.nameToId.set(normalizeName(obj.name), obj.id);\n    }\n\n    // Index timeline events with proper link targets\n    for (const event of this.kb.timeline) {\n      const info: EntityInfo = {\n        id: event.id,\n        name: event.description,\n        type: 'event',\n        chapters: [event.chapter],\n        linkTarget: getEventFilename(event),\n        linkDisplay: event.description,\n      };\n      this.entityIndex.set(event.id, info);\n    }\n  }\n\n  /**\n   * Resolve a name or ID to an entity info\n   */\n  private resolveEntity(nameOrId: string): EntityInfo | undefined {\n    // Try direct ID lookup first\n    if (this.entityIndex.has(nameOrId)) {\n      return this.entityIndex.get(nameOrId);\n    }\n    // Try normalized name lookup\n    const id = this.nameToId.get(normalizeName(nameOrId));\n    if (id) {\n      return this.entityIndex.get(id);\n    }\n    return undefined;\n  }\n\n  /**\n   * Get all relationships for a given entity\n   */\n  getRelationshipsFor(entityId: string): ComputedRelationship[] {\n    const relationships: ComputedRelationship[] = [];\n    const seen = new Set<string>();\n\n    // 1. Extract explicit relationships\n    const explicit = this.getExplicitRelationships(entityId);\n    for (const rel of explicit) {\n      const key = `${rel.targetId}:${rel.relationshipType}`;\n      if (!seen.has(key)) {\n        seen.add(key);\n        relationships.push(rel);\n      }\n    }\n\n    // 2. Infer relationships from entity fields\n    const inferred = this.getInferredRelationships(entityId);\n    for (const rel of inferred) {\n      const key = `${rel.targetId}:${rel.relationshipType}`;\n      if (!seen.has(key)) {\n        seen.add(key);\n        relationships.push(rel);\n      }\n    }\n\n    // 3. Compute co-occurrence relationships\n    const coOccurrence = this.getCoOccurrenceRelationships(entityId);\n    for (const rel of coOccurrence) {\n      // Only add if we don't already have a more specific relationship\n      const hasExisting = relationships.some((r) => r.targetId === rel.targetId);\n      if (!hasExisting) {\n        relationships.push(rel);\n      }\n    }\n\n    return relationships;\n  }\n\n  /**\n   * Extract explicit relationships from kb.relationships[]\n   */\n  private getExplicitRelationships(entityId: string): ComputedRelationship[] {\n    const relationships: ComputedRelationship[] = [];\n\n    if (!this.kb.relationships) {\n      return relationships;\n    }\n\n    for (const rel of this.kb.relationships) {\n      let targetId: string | null = null;\n      let type = rel.type;\n\n      if (rel.sourceId === entityId) {\n        targetId = rel.targetId;\n      } else if (rel.targetId === entityId) {\n        // Reverse the relationship\n        targetId = rel.sourceId;\n        type = this.reverseRelationshipType(rel.type);\n      }\n\n      if (targetId) {\n        const targetInfo = this.resolveEntity(targetId);\n        if (targetInfo) {\n          relationships.push({\n            targetId: targetInfo.id,\n            targetName: targetInfo.name,\n            targetType: targetInfo.type,\n            relationshipType: type,\n            description: rel.description,\n            chapters: rel.chapters,\n            source: 'explicit',\n            linkTarget: targetInfo.linkTarget,\n            linkDisplay: targetInfo.linkDisplay,\n          });\n        }\n      }\n    }\n\n    return relationships;\n  }\n\n  /**\n   * Reverse a relationship type for bidirectional lookup\n   */\n  private reverseRelationshipType(type: RelationshipKind): RelationshipKind {\n    // Most relationships are symmetric or have obvious inverses\n    switch (type) {\n      case 'owns':\n      case 'holds':\n        return 'holds'; // object is held by\n      case 'formerly_held':\n        return 'formerly_held';\n      case 'mentor':\n        return 'mentor'; // mentee relationship\n      case 'contains':\n        return 'contains'; // contained by\n      case 'occurred_at':\n        return 'occurred_at';\n      default:\n        return type; // symmetric relationships\n    }\n  }\n\n  /**\n   * Infer relationships from entity fields\n   */\n  private getInferredRelationships(entityId: string): ComputedRelationship[] {\n    const relationships: ComputedRelationship[] = [];\n    const entity = this.entityIndex.get(entityId);\n\n    if (!entity) {\n      return relationships;\n    }\n\n    if (entity.type === 'character') {\n      // Character  equipment (owns)\n      const char = this.kb.characters.find((c) => c.id === entityId);\n      if (char?.equipment) {\n        for (const equipName of char.equipment) {\n          const objInfo = this.resolveEntity(equipName);\n          if (objInfo) {\n            relationships.push({\n              targetId: objInfo.id,\n              targetName: objInfo.name,\n              targetType: 'object',\n              relationshipType: 'owns',\n              source: 'inferred',\n              linkTarget: objInfo.linkTarget,\n              linkDisplay: objInfo.linkDisplay,\n            });\n          }\n        }\n      }\n\n      // Check all objects to see if any have this character as holder\n      for (const obj of this.kb.objects) {\n        if (obj.holder) {\n          const holderInfo = this.resolveEntity(obj.holder);\n          if (holderInfo?.id === entityId) {\n            const objEntityInfo = this.entityIndex.get(obj.id);\n            relationships.push({\n              targetId: obj.id,\n              targetName: obj.name,\n              targetType: 'object',\n              relationshipType: 'owns',\n              source: 'inferred',\n              linkTarget: objEntityInfo?.linkTarget || obj.name,\n              linkDisplay: objEntityInfo?.linkDisplay,\n            });\n          }\n        }\n      }\n\n      // Character  events (participated) based on shared chapters\n      for (const event of this.kb.timeline) {\n        if (char?.chapters_present?.includes(event.chapter)) {\n          const eventInfo = this.entityIndex.get(event.id);\n          if (eventInfo) {\n            relationships.push({\n              targetId: event.id,\n              targetName: event.description,\n              targetType: 'event',\n              relationshipType: 'participated',\n              chapters: [event.chapter],\n              source: 'inferred',\n              linkTarget: eventInfo.linkTarget,\n              linkDisplay: eventInfo.linkDisplay,\n            });\n          }\n        }\n      }\n    }\n\n    if (entity.type === 'object') {\n      // Object  holder (holds)\n      const obj = this.kb.objects.find((o) => o.id === entityId);\n      if (obj?.holder) {\n        const charInfo = this.resolveEntity(obj.holder);\n        if (charInfo) {\n          relationships.push({\n            targetId: charInfo.id,\n            targetName: charInfo.name,\n            targetType: 'character',\n            relationshipType: 'holds',\n            source: 'inferred',\n            linkTarget: charInfo.linkTarget,\n            linkDisplay: charInfo.linkDisplay,\n          });\n        }\n      }\n      // Object  previous holders (formerly_held)\n      if (obj?.holders) {\n        for (const holderName of obj.holders) {\n          // Skip current holder\n          if (obj.holder && normalizeName(holderName) === normalizeName(obj.holder)) continue;\n          const charInfo = this.resolveEntity(holderName);\n          if (charInfo) {\n            relationships.push({\n              targetId: charInfo.id,\n              targetName: charInfo.name,\n              targetType: 'character',\n              relationshipType: 'formerly_held',\n              source: 'inferred',\n              linkTarget: charInfo.linkTarget,\n              linkDisplay: charInfo.linkDisplay,\n            });\n          }\n        }\n      }\n    }\n\n    if (entity.type === 'event') {\n      // Event  locations (occurred_at) based on shared chapters\n      const event = this.kb.timeline.find((e) => e.id === entityId);\n      if (event) {\n        for (const loc of this.kb.locations) {\n          if (loc.chapters_seen?.includes(event.chapter)) {\n            const locInfo = this.entityIndex.get(loc.id);\n            if (locInfo) {\n              relationships.push({\n                targetId: loc.id,\n                targetName: loc.name,\n                targetType: 'location',\n                relationshipType: 'occurred_at',\n                chapters: [event.chapter],\n                source: 'inferred',\n                linkTarget: locInfo.linkTarget,\n                linkDisplay: locInfo.linkDisplay,\n              });\n            }\n          }\n        }\n\n        // Event  characters (participated) - inverse view\n        for (const char of this.kb.characters) {\n          if (char.chapters_present?.includes(event.chapter)) {\n            const charInfo = this.entityIndex.get(char.id);\n            if (charInfo) {\n              relationships.push({\n                targetId: char.id,\n                targetName: char.canonical_name,\n                targetType: 'character',\n                relationshipType: 'participated',\n                chapters: [event.chapter],\n                source: 'inferred',\n                linkTarget: charInfo.linkTarget,\n                linkDisplay: charInfo.linkDisplay,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (entity.type === 'location') {\n      // Location  events (occurred_at inverse - site of)\n      const loc = this.kb.locations.find((l) => l.id === entityId);\n      if (loc?.chapters_seen) {\n        for (const event of this.kb.timeline) {\n          if (loc.chapters_seen.includes(event.chapter)) {\n            const eventInfo = this.entityIndex.get(event.id);\n            if (eventInfo) {\n              relationships.push({\n                targetId: event.id,\n                targetName: event.description,\n                targetType: 'event',\n                relationshipType: 'occurred_at',\n                chapters: [event.chapter],\n                source: 'inferred',\n                linkTarget: eventInfo.linkTarget,\n                linkDisplay: eventInfo.linkDisplay,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return relationships;\n  }\n\n  /**\n   * Compute co-occurrence relationships based on shared chapters\n   */\n  private getCoOccurrenceRelationships(entityId: string): ComputedRelationship[] {\n    const relationships: ComputedRelationship[] = [];\n    const entity = this.entityIndex.get(entityId);\n\n    if (!entity || entity.chapters.length === 0) {\n      return relationships;\n    }\n\n    const entityChapters = new Set(entity.chapters);\n\n    // Check co-occurrence with all other entities\n    for (const [otherId, otherInfo] of this.entityIndex) {\n      if (otherId === entityId) continue;\n\n      // Use derived chapters for objects if they have none directly\n      let otherChapters = otherInfo.chapters;\n      if (otherInfo.type === 'object' && otherChapters.length === 0) {\n        otherChapters = this.deriveObjectChapters(otherId);\n      }\n\n      if (otherChapters.length === 0) continue;\n\n      // Calculate shared chapters\n      const sharedChapters = otherChapters.filter((ch) => entityChapters.has(ch));\n\n      if (sharedChapters.length >= this.coOccurrenceThreshold) {\n        relationships.push({\n          targetId: otherInfo.id,\n          targetName: otherInfo.name,\n          targetType: otherInfo.type,\n          relationshipType: 'co_occurrence',\n          chapters: sharedChapters.sort((a, b) => a - b),\n          source: 'co_occurrence',\n          linkTarget: otherInfo.linkTarget,\n          linkDisplay: otherInfo.linkDisplay,\n        });\n      }\n    }\n\n    return relationships;\n  }\n\n  /**\n   * Derive chapter presence for an object from holder relationships\n   */\n  private deriveObjectChapters(objectId: string): number[] {\n    const chapters = new Set<number>();\n    const obj = this.kb.objects.find((o) => o.id === objectId);\n    if (!obj) return [];\n\n    // Get chapters from current holder\n    if (obj.holder) {\n      const holderInfo = this.resolveEntity(obj.holder);\n      if (holderInfo) {\n        for (const ch of holderInfo.chapters) {\n          chapters.add(ch);\n        }\n      }\n    }\n\n    // Get chapters from previous holders\n    if (obj.holders) {\n      for (const holderName of obj.holders) {\n        const holderInfo = this.resolveEntity(holderName);\n        if (holderInfo) {\n          for (const ch of holderInfo.chapters) {\n            chapters.add(ch);\n          }\n        }\n      }\n    }\n\n    return Array.from(chapters).sort((a, b) => a - b);\n  }\n\n  /**\n   * Group relationships by entity type\n   */\n  groupByEntityType(\n    relationships: ComputedRelationship[]\n  ): Map<EntityType, ComputedRelationship[]> {\n    const grouped = new Map<EntityType, ComputedRelationship[]>();\n\n    for (const rel of relationships) {\n      const existing = grouped.get(rel.targetType) || [];\n      existing.push(rel);\n      grouped.set(rel.targetType, existing);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Group relationships by relationship kind\n   */\n  groupByType(\n    relationships: ComputedRelationship[]\n  ): Map<RelationshipKind, ComputedRelationship[]> {\n    const grouped = new Map<RelationshipKind, ComputedRelationship[]>();\n\n    for (const rel of relationships) {\n      const existing = grouped.get(rel.relationshipType) || [];\n      existing.push(rel);\n      grouped.set(rel.relationshipType, existing);\n    }\n\n    return grouped;\n  }\n}\n","/**\n * Related Entities Section Builder\n * Generates markdown sections for cross-linking between entities\n */\n\nimport type { ComputedRelationship, EntityType, RelationshipKind } from './types.js';\nimport { section, wikilink } from './utils.js';\n\n/**\n * Format chapter numbers for display\n */\nfunction formatChapterList(chapters: number[] | undefined): string {\n  if (!chapters || chapters.length === 0) {\n    return '';\n  }\n\n  // Detect ranges for cleaner display\n  const ranges: string[] = [];\n  let rangeStart = chapters[0]!;\n  let rangeEnd = chapters[0]!;\n\n  for (let i = 1; i <= chapters.length; i++) {\n    if (i < chapters.length && chapters[i] === rangeEnd + 1) {\n      rangeEnd = chapters[i]!;\n    } else {\n      if (rangeStart === rangeEnd) {\n        ranges.push(String(rangeStart));\n      } else if (rangeEnd === rangeStart + 1) {\n        ranges.push(`${rangeStart}, ${rangeEnd}`);\n      } else {\n        ranges.push(`${rangeStart}-${rangeEnd}`);\n      }\n      if (i < chapters.length) {\n        rangeStart = chapters[i]!;\n        rangeEnd = chapters[i]!;\n      }\n    }\n  }\n\n  return `Ch. ${ranges.join(', ')}`;\n}\n\n/**\n * Format a relationship type for display\n */\nfunction formatRelationshipType(type: RelationshipKind): string {\n  switch (type) {\n    case 'ally':\n      return 'ally';\n    case 'enemy':\n      return 'enemy';\n    case 'family':\n      return 'family';\n    case 'mentor':\n      return 'mentor';\n    case 'rival':\n      return 'rival';\n    case 'visits':\n      return 'visits';\n    case 'resides':\n      return 'residence';\n    case 'owns':\n      return 'owns';\n    case 'holds':\n      return 'held by';\n    case 'formerly_held':\n      return 'formerly held by';\n    case 'participated':\n      return 'participated';\n    case 'witnessed':\n      return 'witnessed';\n    case 'contains':\n      return 'contains';\n    case 'occurred_at':\n      return 'occurred at';\n    case 'co_occurrence':\n      return 'appears with';\n    case 'associated':\n      return 'associated';\n    default:\n      return type;\n  }\n}\n\n/**\n * Get the display name for an entity type section\n */\nfunction getEntityTypeSectionName(type: EntityType): string {\n  switch (type) {\n    case 'character':\n      return 'Characters';\n    case 'location':\n      return 'Locations';\n    case 'object':\n      return 'Objects';\n    case 'event':\n      return 'Events';\n    default:\n      return 'Other';\n  }\n}\n\n/**\n * Build a single relationship line\n */\nfunction buildRelationshipLine(rel: ComputedRelationship): string {\n  // Use linkTarget and linkDisplay if available (e.g., for events)\n  const link = rel.linkDisplay\n    ? wikilink(rel.linkTarget || rel.targetName, rel.linkDisplay)\n    : wikilink(rel.linkTarget || rel.targetName);\n  const relType = formatRelationshipType(rel.relationshipType);\n  const chapters = formatChapterList(rel.chapters);\n\n  let line = `- ${link}`;\n\n  // Add relationship type if it's not just co_occurrence\n  if (rel.relationshipType !== 'co_occurrence') {\n    line += ` - ${relType}`;\n  }\n\n  // Add chapter info if available\n  if (chapters) {\n    line += ` (${chapters})`;\n  }\n\n  return line;\n}\n\n/**\n * Build the Related Entities section for a note\n */\nexport function buildRelatedEntitiesSection(relationships: ComputedRelationship[]): string {\n  if (relationships.length === 0) {\n    return '';\n  }\n\n  const parts: string[] = [];\n  parts.push(section('Related Entities'));\n\n  // Group by entity type\n  const grouped = new Map<EntityType, ComputedRelationship[]>();\n  for (const rel of relationships) {\n    const existing = grouped.get(rel.targetType) || [];\n    existing.push(rel);\n    grouped.set(rel.targetType, existing);\n  }\n\n  // Order: characters, locations, objects, events\n  const typeOrder: EntityType[] = ['character', 'location', 'object', 'event'];\n\n  for (const entityType of typeOrder) {\n    const rels = grouped.get(entityType);\n    if (!rels || rels.length === 0) continue;\n\n    // Sort by relationship type (explicit/inferred first, then co_occurrence)\n    // Then by name alphabetically\n    rels.sort((a, b) => {\n      // Prioritize explicit and inferred over co_occurrence\n      const sourceOrder = { explicit: 0, inferred: 1, co_occurrence: 2 };\n      const sourceCompare = sourceOrder[a.source] - sourceOrder[b.source];\n      if (sourceCompare !== 0) return sourceCompare;\n\n      // Then alphabetically by name\n      return a.targetName.localeCompare(b.targetName);\n    });\n\n    parts.push(section(getEntityTypeSectionName(entityType), 3));\n    for (const rel of rels) {\n      parts.push(buildRelationshipLine(rel) + '\\n');\n    }\n    parts.push('\\n');\n  }\n\n  return parts.join('');\n}\n\n/**\n * Check if Related Entities section should be included\n * Returns true by default unless explicitly disabled\n */\nexport function shouldIncludeRelatedEntities(includeRelatedEntities?: boolean): boolean {\n  // Default to true if not specified\n  return includeRelatedEntities !== false;\n}\n","/**\n * Character Generator\n * Extracts character metadata from KB and creates character notes\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  KBCharacter,\n  KBData,\n  CharacterArc,\n} from './types.js';\nimport {\n  parseKBJson,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  wikilink,\n  section,\n  blockquote,\n  formatChapters,\n  formatList,\n  kvPair,\n} from './utils.js';\nimport { RelationshipEngine } from './relationships.js';\nimport { buildRelatedEntitiesSection, shouldIncludeRelatedEntities } from './related-entities.js';\n\nconst CHARACTERS_SUBDIR = 'Characters';\n\n/**\n * Build frontmatter for a character note\n */\nfunction buildCharacterFrontmatter(char: KBCharacter): Record<string, unknown> {\n  return {\n    id: char.id,\n    type: 'character',\n    title: char.canonical_name,\n    aliases: formatList(char.aliases),\n    role: char.role,\n    tags: buildTags(char),\n    first_appearance: char.first_appearance,\n    last_appearance: char.last_appearance,\n    chapters: formatList(char.chapters_present?.map(String)),\n    age: char.age,\n    arc_type: char.arc?.type,\n    arc_status: char.arc?.resolution?.status,\n  };\n}\n\n/**\n * Build tags based on character properties\n */\nfunction buildTags(char: KBCharacter): string[] {\n  const tags: string[] = ['character'];\n\n  // Role-based tags\n  const role = char.role.toLowerCase();\n  if (role.includes('protagonist')) {\n    tags.push('protagonist');\n  } else if (role.includes('antagonist')) {\n    tags.push('antagonist');\n  } else if (role.includes('supporting')) {\n    tags.push('supporting-character');\n  } else if (role.includes('mentor')) {\n    tags.push('mentor');\n  } else if (role.includes('minor')) {\n    tags.push('minor-character');\n  }\n\n  // Arc status tags\n  if (char.arc?.resolution?.status) {\n    const status = char.arc.resolution.status.toLowerCase();\n    if (status === 'resolved') {\n      tags.push('arc-resolved');\n    } else if (status === 'destroyed') {\n      tags.push('arc-destroyed');\n    } else if (status === 'setup') {\n      tags.push('arc-setup');\n    }\n  }\n\n  return tags;\n}\n\n/**\n * Build the content body for a character note\n */\nfunction buildCharacterContent(\n  char: KBCharacter,\n  relationshipEngine?: RelationshipEngine,\n  includeRelated?: boolean\n): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${char.canonical_name}\\n\\n`);\n\n  // Quick reference\n  parts.push(section('Overview'));\n  const overview: string[] = [];\n  overview.push(kvPair('Role', char.role));\n  if (char.age) {\n    overview.push(kvPair('Age', char.age));\n  }\n  if (char.chapters_present) {\n    overview.push(kvPair('Chapters', formatChapters(char.chapters_present)));\n  }\n  if (char.relationship_to_protagonist) {\n    overview.push(kvPair('Relationship', char.relationship_to_protagonist));\n  }\n  parts.push(overview.filter(Boolean).join('\\n') + '\\n\\n');\n\n  // Aliases\n  if (char.aliases && char.aliases.length > 0) {\n    parts.push(section('Aliases', 3));\n    parts.push(char.aliases.map((a) => `- ${a}`).join('\\n') + '\\n\\n');\n  }\n\n  // Physical description\n  if (char.physical && Object.keys(char.physical).length > 0) {\n    parts.push(section('Physical Description'));\n    for (const [key, value] of Object.entries(char.physical)) {\n      if (Array.isArray(value)) {\n        parts.push(`**${key}:**\\n`);\n        parts.push(value.map((v: unknown) => `- ${v}`).join('\\n') + '\\n\\n');\n      } else if (value) {\n        parts.push(`- **${key}:** ${value}\\n`);\n      }\n    }\n    parts.push('\\n');\n  }\n\n  // Personality\n  if (char.personality && char.personality.length > 0) {\n    parts.push(section('Personality'));\n    parts.push(char.personality.map((p) => `- ${p}`).join('\\n') + '\\n\\n');\n  }\n\n  // Abilities\n  if (char.abilities && Object.keys(char.abilities).length > 0) {\n    parts.push(section('Abilities'));\n    for (const [name, details] of Object.entries(char.abilities)) {\n      if (typeof details === 'object' && details !== null) {\n        const d = details as Record<string, unknown>;\n        parts.push(`### ${name}\\n`);\n        if (d.status) {\n          parts.push(`- **Status:** ${d.status}\\n`);\n        }\n        if (d.notes) {\n          parts.push(`- **Notes:** ${d.notes}\\n`);\n        }\n        parts.push('\\n');\n      } else {\n        parts.push(`- **${name}:** ${details}\\n`);\n      }\n    }\n    parts.push('\\n');\n  }\n\n  // Equipment\n  if (char.equipment && char.equipment.length > 0) {\n    parts.push(section('Equipment'));\n    parts.push(char.equipment.map((e) => `- ${wikilink(e)}`).join('\\n') + '\\n\\n');\n  }\n\n  // Related Entities\n  if (shouldIncludeRelatedEntities(includeRelated) && relationshipEngine) {\n    const relationships = relationshipEngine.getRelationshipsFor(char.id);\n    const relatedSection = buildRelatedEntitiesSection(relationships);\n    if (relatedSection) {\n      parts.push(relatedSection);\n    }\n  }\n\n  // Coping mechanism\n  if (char.coping_mechanism) {\n    parts.push(section('Coping Mechanism'));\n    const cm = char.coping_mechanism;\n    if (typeof cm === 'object') {\n      for (const [key, value] of Object.entries(cm)) {\n        parts.push(`- **${key}:** ${value}\\n`);\n      }\n    } else {\n      parts.push(`${cm}\\n`);\n    }\n    parts.push('\\n');\n  }\n\n  // Character arc\n  if (char.arc) {\n    parts.push(buildArcSection(char.arc));\n  }\n\n  // Key quote\n  if (char.key_quote) {\n    parts.push(section('Key Quote'));\n    parts.push(blockquote(char.key_quote) + '\\n\\n');\n  }\n\n  // Final words\n  if (char.final_words) {\n    parts.push(section('Final Words'));\n    parts.push(blockquote(char.final_words) + '\\n\\n');\n  }\n\n  // Backstory\n  if (char.backstory && Object.keys(char.backstory).length > 0) {\n    parts.push(section('Backstory'));\n    for (const [key, value] of Object.entries(char.backstory)) {\n      parts.push(`- **${key}:** ${value}\\n`);\n    }\n    parts.push('\\n');\n  }\n\n  // Entry state\n  if (char.entry_state && Object.keys(char.entry_state).length > 0) {\n    parts.push(section('Entry State'));\n    parts.push(formatStateObject(char.entry_state));\n  }\n\n  // Exit state\n  if (char.exit_state && Object.keys(char.exit_state).length > 0) {\n    parts.push(section('Exit State'));\n    parts.push(formatStateObject(char.exit_state));\n  }\n\n  return parts.join('');\n}\n\n/**\n * Build the arc section\n */\nfunction buildArcSection(arc: CharacterArc): string {\n  const parts: string[] = [];\n\n  parts.push(section('Character Arc'));\n  parts.push(`**Type:** ${arc.type}\\n\\n`);\n  parts.push(`${arc.description}\\n\\n`);\n\n  // Key moments\n  if (arc.key_moments && arc.key_moments.length > 0) {\n    parts.push(section('Key Moments', 3));\n    for (const moment of arc.key_moments) {\n      parts.push(`- **Chapter ${moment.chapter} - ${moment.beat}:** ${moment.description}\\n`);\n    }\n    parts.push('\\n');\n  }\n\n  // Resolution\n  if (arc.resolution) {\n    parts.push(section('Resolution', 3));\n    parts.push(`**Status:** ${arc.resolution.status}\\n\\n`);\n    if (arc.resolution.chapter) {\n      parts.push(`**Chapter:** ${arc.resolution.chapter}\\n\\n`);\n    }\n    if (arc.resolution.key_line) {\n      parts.push(blockquote(arc.resolution.key_line) + '\\n\\n');\n    }\n    if (arc.resolution.mechanism) {\n      parts.push(`*${arc.resolution.mechanism}*\\n\\n`);\n    }\n  }\n\n  return parts.join('');\n}\n\n/**\n * Format a state object (entry_state or exit_state)\n */\nfunction formatStateObject(state: Record<string, unknown>): string {\n  const lines: string[] = [];\n\n  for (const [key, value] of Object.entries(state)) {\n    if (value === undefined || value === null) continue;\n\n    if (Array.isArray(value)) {\n      lines.push(`- **${key}:**`);\n      for (const item of value) {\n        lines.push(`  - ${item}`);\n      }\n    } else if (typeof value === 'object') {\n      lines.push(`- **${key}:**`);\n      for (const [k, v] of Object.entries(value as Record<string, unknown>)) {\n        lines.push(`  - ${k}: ${v}`);\n      }\n    } else {\n      lines.push(`- **${key}:** ${value}`);\n    }\n  }\n\n  return lines.join('\\n') + '\\n\\n';\n}\n\n/**\n * Generate character notes from KB data\n */\nexport async function generateCharacters(options: GeneratorOptions): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.kbPath || 'unknown',\n      error: `Failed to load KB: ${error}`,\n    });\n    result.summary = 'Failed to load KB data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Create relationship engine for cross-linking\n  const relationshipEngine = new RelationshipEngine(kb, options.coOccurrenceThreshold);\n  const includeRelated = shouldIncludeRelatedEntities(options.includeRelatedEntities);\n\n  // Process each character\n  for (const char of kb.characters) {\n    const name = char.canonical_name;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate character: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, CHARACTERS_SUBDIR, name);\n      const frontmatter = buildCharacterFrontmatter(char);\n      const content = buildCharacterContent(char, relationshipEngine, includeRelated);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Characters: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n","/**\n * Chapter Generator\n * Splits a manuscript into individual chapter notes\n */\n\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport type { ChapterGeneratorOptions, GeneratorResult } from './types.js';\nimport { buildNote, writeNoteFile, sanitizeFilename } from './utils.js';\n\nconst CHAPTERS_SUBDIR = 'Chapters';\n\n// Chapter heading patterns\n// Matches: ## Chapter 1, ## Chapter 1: Title, ## Chapter 01, etc.\nconst CHAPTER_REGEX = /^##\\s*Chapter\\s+(\\d+)(?:\\s*[:\\-]\\s*(.+))?$/im;\n\n// Alternative patterns for different manuscript styles\nconst ALT_CHAPTER_PATTERNS = [\n  /^#\\s*Chapter\\s+(\\d+)(?:\\s*[:\\-]\\s*(.+))?$/im, // Single hash\n  /^###\\s*Chapter\\s+(\\d+)(?:\\s*[:\\-]\\s*(.+))?$/im, // Triple hash\n  /^Chapter\\s+(\\d+)(?:\\s*[:\\-]\\s*(.+))?$/im, // No hash\n  /^##\\s+(\\d+)\\.?\\s+(.+)$/im, // ## 1. Title\n];\n\ninterface ChapterData {\n  number: number;\n  title: string | null;\n  content: string;\n  startLine: number;\n  endLine: number;\n}\n\n/**\n * Parse manuscript content into chapters\n */\nfunction parseChapters(content: string): ChapterData[] {\n  const lines = content.split('\\n');\n  const chapters: ChapterData[] = [];\n  let currentChapter: ChapterData | null = null;\n  let contentLines: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i] ?? '';\n\n    // Try to match chapter heading\n    let match = line.match(CHAPTER_REGEX);\n\n    // Try alternative patterns if primary doesn't match\n    if (!match) {\n      for (const pattern of ALT_CHAPTER_PATTERNS) {\n        match = line.match(pattern);\n        if (match) break;\n      }\n    }\n\n    if (match) {\n      // Save previous chapter\n      if (currentChapter) {\n        currentChapter.content = contentLines.join('\\n').trim();\n        currentChapter.endLine = i - 1;\n        chapters.push(currentChapter);\n      }\n\n      // Start new chapter\n      const chapterNum = parseInt(match[1] ?? '0', 10);\n      const chapterTitle = match[2]?.trim() ?? null;\n\n      currentChapter = {\n        number: chapterNum,\n        title: chapterTitle,\n        content: '',\n        startLine: i,\n        endLine: i,\n      };\n      contentLines = [];\n    } else if (currentChapter) {\n      contentLines.push(line);\n    }\n  }\n\n  // Save last chapter\n  if (currentChapter) {\n    currentChapter.content = contentLines.join('\\n').trim();\n    currentChapter.endLine = lines.length - 1;\n    chapters.push(currentChapter);\n  }\n\n  return chapters;\n}\n\n/**\n * Build frontmatter for a chapter note\n */\nfunction buildChapterFrontmatter(chapter: ChapterData): Record<string, unknown> {\n  return {\n    type: 'scene',\n    title: chapter.title || `Chapter ${chapter.number}`,\n    chapter: chapter.number,\n    scene_order: chapter.number,\n    tags: ['chapter'],\n  };\n}\n\n/**\n * Build the content for a chapter note\n */\nfunction buildChapterContent(chapter: ChapterData): string {\n  const parts: string[] = [];\n\n  // Title\n  const title = chapter.title\n    ? `# Chapter ${chapter.number}: ${chapter.title}`\n    : `# Chapter ${chapter.number}`;\n  parts.push(title + '\\n\\n');\n\n  // Chapter content\n  parts.push(chapter.content);\n\n  return parts.join('');\n}\n\n/**\n * Generate a filename for a chapter\n */\nfunction getChapterFilename(chapter: ChapterData): string {\n  const numStr = chapter.number.toString().padStart(2, '0');\n  if (chapter.title) {\n    const safeTitle = sanitizeFilename(chapter.title);\n    return `Chapter-${numStr}-${safeTitle}`;\n  }\n  return `Chapter-${numStr}`;\n}\n\n/**\n * Generate chapter notes from a manuscript file\n */\nexport async function generateChapters(options: ChapterGeneratorOptions): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load manuscript\n  let manuscript: string;\n  try {\n    manuscript = fs.readFileSync(options.manuscriptPath, 'utf-8');\n  } catch (error) {\n    result.errors.push({\n      file: options.manuscriptPath,\n      error: `Failed to read manuscript: ${error}`,\n    });\n    result.summary = 'Failed to read manuscript';\n    return result;\n  }\n\n  // Parse chapters\n  const chapters = parseChapters(manuscript);\n\n  if (chapters.length === 0) {\n    result.summary = 'No chapters found in manuscript';\n    return result;\n  }\n\n  if (options.verbose) {\n    console.log(`Found ${chapters.length} chapters in manuscript`);\n  }\n\n  // Output directory for chapters\n  const chaptersDir = options.chaptersDir || CHAPTERS_SUBDIR;\n\n  // Process each chapter\n  for (const chapter of chapters) {\n    try {\n      const filename = getChapterFilename(chapter);\n      const filePath = path.join(options.outputDir, chaptersDir, `${filename}.md`);\n\n      const frontmatter = buildChapterFrontmatter(chapter);\n      const content = buildChapterContent(chapter);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: `Chapter ${chapter.number}`,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Chapters: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n\n/**\n * Analyze a manuscript and return chapter info without generating files\n */\nexport function analyzeManuscript(manuscriptPath: string): {\n  chapters: Array<{ number: number; title: string | null; lines: number }>;\n  totalLines: number;\n} {\n  const content = fs.readFileSync(manuscriptPath, 'utf-8');\n  const chapters = parseChapters(content);\n  const totalLines = content.split('\\n').length;\n\n  return {\n    chapters: chapters.map((ch) => ({\n      number: ch.number,\n      title: ch.title,\n      lines: ch.endLine - ch.startLine + 1,\n    })),\n    totalLines,\n  };\n}\n","/**\n * Location Generator\n * Creates location notes from KB data with realm classification\n */\n\nimport type { GeneratorOptions, GeneratorResult, KBLocation, KBData, RealmType } from './types.js';\nimport {\n  parseKBJson,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n  formatChapters,\n  formatList,\n  kvPair,\n} from './utils.js';\nimport { classifyRealm } from './types.js';\nimport { RelationshipEngine } from './relationships.js';\nimport { buildRelatedEntitiesSection, shouldIncludeRelatedEntities } from './related-entities.js';\n\nconst LOCATIONS_SUBDIR = 'Locations';\n\n/**\n * Build frontmatter for a location note\n */\nfunction buildLocationFrontmatter(loc: KBLocation): Record<string, unknown> {\n  const realm = classifyRealm(loc);\n\n  return {\n    id: loc.id,\n    type: 'location',\n    title: loc.name,\n    location_type: loc.type,\n    realm: realm,\n    tags: buildTags(loc, realm),\n    first_appearance: loc.first_appearance,\n    chapters: formatList(loc.chapters_seen?.map(String)),\n  };\n}\n\n/**\n * Build tags based on location properties\n */\nfunction buildTags(loc: KBLocation, realm: RealmType): string[] {\n  const tags: string[] = ['location'];\n\n  // Realm-based tags\n  switch (realm) {\n    case 'dimensional':\n      tags.push('dimensional');\n      break;\n    case 'real_world':\n      tags.push('real-world');\n      break;\n    case 'liminal':\n      tags.push('liminal');\n      break;\n  }\n\n  // Type-based tags\n  const locType = loc.type.toLowerCase().replace(/[_\\s]+/g, '-');\n  if (locType && !tags.includes(locType)) {\n    tags.push(locType);\n  }\n\n  return tags;\n}\n\n/**\n * Build the content body for a location note\n */\nfunction buildLocationContent(\n  loc: KBLocation,\n  relationshipEngine?: RelationshipEngine,\n  includeRelated?: boolean\n): string {\n  const parts: string[] = [];\n  const realm = classifyRealm(loc);\n\n  // Title\n  parts.push(`# ${loc.name}\\n\\n`);\n\n  // Overview section\n  parts.push(section('Overview'));\n  const overview: string[] = [];\n  overview.push(kvPair('Type', loc.type.replace(/_/g, ' ')));\n  overview.push(kvPair('Realm', formatRealmName(realm)));\n  if (loc.first_appearance) {\n    overview.push(kvPair('First Appearance', `Chapter ${loc.first_appearance}`));\n  }\n  if (loc.chapters_seen) {\n    overview.push(kvPair('Chapters', formatChapters(loc.chapters_seen)));\n  }\n  parts.push(overview.filter(Boolean).join('\\n') + '\\n\\n');\n\n  // Description\n  if (loc.description) {\n    parts.push(section('Description'));\n    parts.push(loc.description + '\\n\\n');\n  }\n\n  // Features\n  if (loc.features && loc.features.length > 0) {\n    parts.push(section('Features'));\n    parts.push(loc.features.map((f) => `- ${f}`).join('\\n') + '\\n\\n');\n  }\n\n  // Related Entities\n  if (shouldIncludeRelatedEntities(includeRelated) && relationshipEngine) {\n    const relationships = relationshipEngine.getRelationshipsFor(loc.id);\n    const relatedSection = buildRelatedEntitiesSection(relationships);\n    if (relatedSection) {\n      parts.push(relatedSection);\n    }\n  }\n\n  // Realm-specific sections\n  if (realm === 'dimensional') {\n    parts.push(section('Dimensional Properties'));\n    parts.push('*This location exists in a dimensional space.*\\n\\n');\n    parts.push('- [ ] Portal access documented\\n');\n    parts.push('- [ ] Time dilation effects noted\\n');\n    parts.push('- [ ] Environmental hazards catalogued\\n\\n');\n  }\n\n  // Connections placeholder\n  parts.push(section('Connections'));\n  parts.push('*Characters and events associated with this location:*\\n\\n');\n  parts.push('```dataview\\n');\n  parts.push(`LIST FROM \"\"\\n`);\n  parts.push(`WHERE contains(locations, \"${loc.name}\")\\n`);\n  parts.push('```\\n\\n');\n\n  return parts.join('');\n}\n\n/**\n * Format realm name for display\n */\nfunction formatRealmName(realm: RealmType): string {\n  switch (realm) {\n    case 'real_world':\n      return 'Real World';\n    case 'dimensional':\n      return 'Dimensional';\n    case 'liminal':\n      return 'Liminal Space';\n    case 'unknown':\n      return 'Unknown';\n  }\n}\n\n/**\n * Generate location notes from KB data\n */\nexport async function generateLocations(options: GeneratorOptions): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.kbPath || 'unknown',\n      error: `Failed to load KB: ${error}`,\n    });\n    result.summary = 'Failed to load KB data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Create relationship engine for cross-linking\n  const relationshipEngine = new RelationshipEngine(kb, options.coOccurrenceThreshold);\n  const includeRelated = shouldIncludeRelatedEntities(options.includeRelatedEntities);\n\n  // Process each location\n  for (const loc of kb.locations) {\n    const name = loc.name;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate location: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, LOCATIONS_SUBDIR, name);\n      const frontmatter = buildLocationFrontmatter(loc);\n      const content = buildLocationContent(loc, relationshipEngine, includeRelated);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Locations: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n","/**\n * Object Generator\n * Creates object/artifact notes from KB data with lock level system\n */\n\nimport type { GeneratorOptions, GeneratorResult, KBObject, KBData, LockLevel } from './types.js';\nimport {\n  parseKBJson,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n  wikilink,\n  kvPair,\n} from './utils.js';\nimport { getLockLevel } from './types.js';\nimport { RelationshipEngine } from './relationships.js';\nimport { buildRelatedEntitiesSection, shouldIncludeRelatedEntities } from './related-entities.js';\n\nconst OBJECTS_SUBDIR = 'Objects';\n\n/**\n * Build frontmatter for an object note\n */\nfunction buildObjectFrontmatter(obj: KBObject): Record<string, unknown> {\n  const lockLevel = getLockLevel(obj);\n\n  return {\n    id: obj.id,\n    type: 'object',\n    title: obj.name,\n    object_type: obj.type,\n    lock_level: lockLevel,\n    locked: obj.locked || false,\n    tags: buildTags(obj, lockLevel),\n    holder: obj.holder || undefined,\n    status: obj.status || undefined,\n  };\n}\n\n/**\n * Build tags based on object properties\n */\nfunction buildTags(obj: KBObject, lockLevel: LockLevel): string[] {\n  const tags: string[] = ['object'];\n\n  // Type-based tags\n  const objType = obj.type.toLowerCase().replace(/[_\\s]+/g, '-');\n  if (objType && !tags.includes(objType)) {\n    tags.push(objType);\n  }\n\n  // Lock level tags\n  if (lockLevel === 'CRITICAL') {\n    tags.push('critical-item');\n  } else if (lockLevel === 'HIGH') {\n    tags.push('important-item');\n  }\n\n  // Locked status\n  if (obj.locked) {\n    tags.push('locked');\n  }\n\n  return tags;\n}\n\n/**\n * Get lock level icon\n */\nfunction getLockIcon(lockLevel: LockLevel): string {\n  switch (lockLevel) {\n    case 'CRITICAL':\n      return '';\n    case 'HIGH':\n      return '';\n    case 'MEDIUM':\n      return '';\n    case 'LOW':\n      return '';\n  }\n}\n\n/**\n * Build the content body for an object note\n */\nfunction buildObjectContent(\n  obj: KBObject,\n  relationshipEngine?: RelationshipEngine,\n  includeRelated?: boolean\n): string {\n  const parts: string[] = [];\n  const lockLevel = getLockLevel(obj);\n  const lockIcon = getLockIcon(lockLevel);\n\n  // Title with lock indicator\n  parts.push(`# ${obj.name} ${obj.locked ? lockIcon : ''}\\n\\n`);\n\n  // Overview section\n  parts.push(section('Overview'));\n  const overview: string[] = [];\n  overview.push(kvPair('Type', obj.type.replace(/_/g, ' ')));\n  overview.push(kvPair('Lock Level', `${lockLevel} ${lockIcon}`));\n  if (obj.holder) {\n    overview.push(kvPair('Current Holder', wikilink(obj.holder)));\n  }\n  if (obj.holders && obj.holders.length > 0) {\n    const holderLinks = obj.holders.map((h) => wikilink(h)).join(', ');\n    overview.push(kvPair('Holders', holderLinks));\n  }\n  if (obj.status) {\n    overview.push(kvPair('Status', obj.status));\n  }\n  parts.push(overview.filter(Boolean).join('\\n') + '\\n\\n');\n\n  // Description\n  if (obj.description) {\n    parts.push(section('Description'));\n    parts.push(obj.description + '\\n\\n');\n  }\n\n  // Properties\n  if (obj.properties && obj.properties.length > 0) {\n    parts.push(section('Properties'));\n    parts.push(obj.properties.map((p) => `- ${p}`).join('\\n') + '\\n\\n');\n  }\n\n  // Significance\n  if (obj.significance) {\n    parts.push(section('Significance'));\n    parts.push(obj.significance + '\\n\\n');\n  }\n\n  // Related Entities\n  if (shouldIncludeRelatedEntities(includeRelated) && relationshipEngine) {\n    const relationships = relationshipEngine.getRelationshipsFor(obj.id);\n    const relatedSection = buildRelatedEntitiesSection(relationships);\n    if (relatedSection) {\n      parts.push(relatedSection);\n    }\n  }\n\n  // Lock warning for critical items\n  if (lockLevel === 'CRITICAL') {\n    parts.push(section('Continuity Lock', 3));\n    parts.push('>  **This item is locked for continuity.**\\n');\n    parts.push('> Any changes to this item may affect established story elements.\\n\\n');\n  }\n\n  // Connections placeholder\n  parts.push(section('Appearances'));\n  parts.push('*Scenes and events involving this object:*\\n\\n');\n  parts.push('```dataview\\n');\n  parts.push(`LIST FROM \"\"\\n`);\n  parts.push(`WHERE contains(file.outlinks, this.file.link)\\n`);\n  parts.push('```\\n\\n');\n\n  return parts.join('');\n}\n\n/**\n * Generate object notes from KB data\n */\nexport async function generateObjects(options: GeneratorOptions): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.kbPath || 'unknown',\n      error: `Failed to load KB: ${error}`,\n    });\n    result.summary = 'Failed to load KB data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Create relationship engine for cross-linking\n  const relationshipEngine = new RelationshipEngine(kb, options.coOccurrenceThreshold);\n  const includeRelated = shouldIncludeRelatedEntities(options.includeRelatedEntities);\n\n  // Process each object\n  for (const obj of kb.objects) {\n    const name = obj.name;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate object: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, OBJECTS_SUBDIR, name);\n      const frontmatter = buildObjectFrontmatter(obj);\n      const content = buildObjectContent(obj, relationshipEngine, includeRelated);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Objects: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n","/**\n * Lore Generator\n * Creates world rules and mechanics notes from KB data\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  KBData,\n  KBFact,\n  WorldRulesData,\n  WorldRule,\n} from './types.js';\nimport {\n  parseKBJson,\n  parseWorldRules,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n  blockquote,\n} from './utils.js';\n\nconst LORE_SUBDIR = 'Lore';\n\n/**\n * Build frontmatter for a lore note (world rule)\n */\nfunction buildRuleFrontmatter(rule: WorldRule): Record<string, unknown> {\n  return {\n    id: rule.id,\n    type: 'concept',\n    title: rule.name,\n    category: rule.category,\n    locked: rule.locked || false,\n    tags: buildRuleTags(rule),\n  };\n}\n\n/**\n * Build tags for a world rule\n */\nfunction buildRuleTags(rule: WorldRule): string[] {\n  const tags: string[] = ['lore', 'world-rule'];\n\n  // Category tag\n  const category = rule.category.toLowerCase().replace(/[_\\s]+/g, '-');\n  if (category && !tags.includes(category)) {\n    tags.push(category);\n  }\n\n  // Locked status\n  if (rule.locked) {\n    tags.push('locked');\n  }\n\n  return tags;\n}\n\n/**\n * Build content for a world rule note\n */\nfunction buildRuleContent(rule: WorldRule): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${rule.name}\\n\\n`);\n\n  // Category badge\n  parts.push(`**Category:** ${rule.category}\\n\\n`);\n\n  // Locked indicator\n  if (rule.locked) {\n    parts.push('>  **This rule is locked for continuity.**\\n\\n');\n  }\n\n  // Description\n  parts.push(section('Description'));\n  parts.push(rule.description + '\\n\\n');\n\n  // Examples\n  if (rule.examples && rule.examples.length > 0) {\n    parts.push(section('Examples'));\n    parts.push(rule.examples.map((e) => `- ${e}`).join('\\n') + '\\n\\n');\n  }\n\n  // Exceptions\n  if (rule.exceptions && rule.exceptions.length > 0) {\n    parts.push(section('Exceptions'));\n    parts.push(rule.exceptions.map((e) => `- ${e}`).join('\\n') + '\\n\\n');\n  }\n\n  // Source\n  if (rule.source) {\n    parts.push(section('Source', 3));\n    parts.push(`*${rule.source}*\\n\\n`);\n  }\n\n  return parts.join('');\n}\n\n/**\n * Build frontmatter for a fact note\n */\nfunction buildFactFrontmatter(fact: KBFact): Record<string, unknown> {\n  return {\n    id: fact.id,\n    type: 'concept',\n    title: extractFactTitle(fact.fact),\n    source: fact.source,\n    locked: fact.locked || false,\n    tags: ['lore', 'fact', fact.locked ? 'locked' : undefined].filter(Boolean),\n  };\n}\n\n/**\n * Extract a short title from a fact\n */\nfunction extractFactTitle(fact: string): string {\n  // Take first 50 chars or up to first period\n  const firstSentence = fact.split('.')[0];\n  if (firstSentence && firstSentence.length <= 60) {\n    return firstSentence;\n  }\n  return fact.slice(0, 50) + '...';\n}\n\n/**\n * Build content for a fact note\n */\nfunction buildFactContent(fact: KBFact): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${extractFactTitle(fact.fact)}\\n\\n`);\n\n  // Locked indicator\n  if (fact.locked) {\n    parts.push('>  **This fact is locked for continuity.**\\n\\n');\n  }\n\n  // The fact\n  parts.push(section('Fact'));\n  parts.push(blockquote(fact.fact) + '\\n\\n');\n\n  // Source\n  parts.push(section('Source', 3));\n  parts.push(`*${fact.source}*\\n\\n`);\n\n  return parts.join('');\n}\n\n/**\n * Generate lore notes from KB and world rules data\n */\nexport async function generateLore(options: GeneratorOptions): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Load world rules if available\n  if (options.worldRulesPath) {\n    try {\n      const worldRules = parseWorldRules(options.worldRulesPath);\n      await processWorldRules(worldRules, options, result, tracker);\n    } catch (error) {\n      result.errors.push({\n        file: options.worldRulesPath,\n        error: `Failed to load world rules: ${error}`,\n      });\n    }\n  }\n\n  // Load KB data for facts\n  if (options.kbPath) {\n    try {\n      const kb = parseKBJson(options.kbPath);\n      await processKBFacts(kb, options, result, tracker);\n    } catch (error) {\n      result.errors.push({\n        file: options.kbPath,\n        error: `Failed to load KB: ${error}`,\n      });\n    }\n  }\n\n  if (!options.kbPath && !options.worldRulesPath) {\n    result.summary = 'No KB or world rules path provided';\n    return result;\n  }\n\n  result.summary = `Lore: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n\n/**\n * Process world rules and generate notes\n */\nasync function processWorldRules(\n  worldRules: WorldRulesData,\n  options: GeneratorOptions,\n  result: GeneratorResult,\n  tracker: EntityTracker\n): Promise<void> {\n  const allRules: WorldRule[] = [\n    ...(worldRules.rules || []),\n    ...(worldRules.mechanics || []),\n    ...(worldRules.constraints || []),\n  ];\n\n  for (const rule of allRules) {\n    const name = rule.name;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate rule: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, LORE_SUBDIR, name);\n      const frontmatter = buildRuleFrontmatter(rule);\n      const content = buildRuleContent(rule);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n}\n\n/**\n * Process KB facts and generate notes\n */\nasync function processKBFacts(\n  kb: KBData,\n  options: GeneratorOptions,\n  result: GeneratorResult,\n  tracker: EntityTracker\n): Promise<void> {\n  const facts = kb.facts || [];\n\n  for (const fact of facts) {\n    const name = fact.id;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate fact: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, `${LORE_SUBDIR}/Facts`, name);\n      const frontmatter = buildFactFrontmatter(fact);\n      const content = buildFactContent(fact);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n}\n","/**\n * Timeline Generator\n * Creates timeline event notes from KB data\n */\n\nimport type { GeneratorOptions, GeneratorResult, KBTimelineEvent, KBData } from './types.js';\nimport {\n  parseKBJson,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n} from './utils.js';\nimport { RelationshipEngine } from './relationships.js';\nimport { buildRelatedEntitiesSection, shouldIncludeRelatedEntities } from './related-entities.js';\n\nconst TIMELINE_SUBDIR = 'Timeline';\n\n/**\n * Build frontmatter for a timeline event note\n */\nfunction buildEventFrontmatter(event: KBTimelineEvent): Record<string, unknown> {\n  return {\n    id: event.id,\n    type: 'event',\n    title: formatEventTitle(event),\n    chapter: event.chapter,\n    locked: event.locked || false,\n    tags: buildTags(event),\n    timeline_position: `chapter-${event.chapter}`,\n  };\n}\n\n/**\n * Format a title for the event\n */\nfunction formatEventTitle(event: KBTimelineEvent): string {\n  // Create a title from the description\n  const desc = event.description;\n\n  // If short enough, use directly\n  if (desc.length <= 60) {\n    return desc;\n  }\n\n  // Otherwise truncate\n  return desc.slice(0, 57) + '...';\n}\n\n/**\n * Build tags based on event properties\n */\nfunction buildTags(event: KBTimelineEvent): string[] {\n  const tags: string[] = ['event', 'timeline'];\n\n  // Chapter tag\n  tags.push(`chapter-${event.chapter}`);\n\n  // Locked status\n  if (event.locked) {\n    tags.push('locked');\n  }\n\n  // Significance-based tags\n  const sig = event.significance?.toLowerCase() || '';\n  if (sig.includes('critical')) {\n    tags.push('critical-event');\n  }\n\n  return tags;\n}\n\n/**\n * Build the content body for a timeline event note\n */\nfunction buildEventContent(\n  event: KBTimelineEvent,\n  relationshipEngine?: RelationshipEngine,\n  includeRelated?: boolean\n): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${event.description}\\n\\n`);\n\n  // Locked indicator\n  if (event.locked) {\n    parts.push('>  **This event is locked for continuity.**\\n\\n');\n  }\n\n  // Event details\n  parts.push(section('Event Details'));\n  parts.push(`**Chapter:** ${event.chapter}\\n\\n`);\n\n  if (event.significance) {\n    parts.push(`**Significance:** ${event.significance}\\n\\n`);\n  }\n\n  // Description (expanded)\n  parts.push(section('Description'));\n  parts.push(event.description + '\\n\\n');\n\n  // Related Entities\n  if (shouldIncludeRelatedEntities(includeRelated) && relationshipEngine) {\n    const relationships = relationshipEngine.getRelationshipsFor(event.id);\n    const relatedSection = buildRelatedEntitiesSection(relationships);\n    if (relatedSection) {\n      parts.push(relatedSection);\n    }\n  }\n\n  // Connections placeholder\n  parts.push(section('Related Notes'));\n  parts.push('*Characters, locations, and objects involved in this event:*\\n\\n');\n  parts.push('```dataview\\n');\n  parts.push(`LIST FROM \"\"\\n`);\n  parts.push(`WHERE contains(file.outlinks, this.file.link)\\n`);\n  parts.push('```\\n\\n');\n\n  // Timeline context\n  parts.push(section('Timeline Context'));\n  parts.push('```dataview\\n');\n  parts.push('TABLE chapter as \"Chapter\", description as \"Event\"\\n');\n  parts.push('FROM #timeline\\n');\n  parts.push(\n    `WHERE chapter >= ${Math.max(1, event.chapter - 1)} AND chapter <= ${event.chapter + 1}\\n`\n  );\n  parts.push('SORT chapter ASC\\n');\n  parts.push('```\\n\\n');\n\n  return parts.join('');\n}\n\n/**\n * Generate a filename for a timeline event\n */\nfunction getEventFilename(event: KBTimelineEvent): string {\n  const chapterStr = event.chapter.toString().padStart(2, '0');\n  const eventNum = event.id.replace(/[^0-9]/g, '').padStart(3, '0');\n  return `Event-${chapterStr}-${eventNum}`;\n}\n\n/**\n * Generate timeline event notes from KB data\n */\nexport async function generateTimeline(options: GeneratorOptions): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.kbPath || 'unknown',\n      error: `Failed to load KB: ${error}`,\n    });\n    result.summary = 'Failed to load KB data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Create relationship engine for cross-linking\n  const relationshipEngine = new RelationshipEngine(kb, options.coOccurrenceThreshold);\n  const includeRelated = shouldIncludeRelatedEntities(options.includeRelatedEntities);\n\n  // Sort events by chapter\n  const sortedEvents = [...kb.timeline].sort((a, b) => a.chapter - b.chapter);\n\n  // Process each event\n  for (const event of sortedEvents) {\n    const eventId = event.id;\n\n    // Skip duplicates\n    if (!tracker.add(eventId)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate event: ${eventId}`);\n      }\n      continue;\n    }\n\n    try {\n      const filename = getEventFilename(event);\n      const filePath = generateNotePath(options.outputDir, TIMELINE_SUBDIR, filename);\n      const frontmatter = buildEventFrontmatter(event);\n      const content = buildEventContent(event, relationshipEngine, includeRelated);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: eventId,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Timeline: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n\n/**\n * Generate a timeline index MOC\n */\nexport async function generateTimelineIndex(options: GeneratorOptions): Promise<string | null> {\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch {\n    return null;\n  }\n\n  const parts: string[] = [];\n\n  parts.push('# Timeline Index\\n\\n');\n  parts.push('A chronological view of events.\\n\\n');\n\n  // Group events by chapter\n  const eventsByChapter = new Map<number, KBTimelineEvent[]>();\n  for (const event of kb.timeline) {\n    const chapter = event.chapter;\n    if (!eventsByChapter.has(chapter)) {\n      eventsByChapter.set(chapter, []);\n    }\n    eventsByChapter.get(chapter)!.push(event);\n  }\n\n  // Sort chapters\n  const sortedChapters = Array.from(eventsByChapter.keys()).sort((a, b) => a - b);\n\n  for (const chapter of sortedChapters) {\n    const events = eventsByChapter.get(chapter)!;\n    parts.push(`## Chapter ${chapter}\\n\\n`);\n\n    for (const event of events) {\n      const lockIcon = event.locked ? ' ' : '';\n      parts.push(`- ${event.description}${lockIcon}\\n`);\n    }\n    parts.push('\\n');\n  }\n\n  return parts.join('');\n}\n","/**\n * Arc Generator\n * Converts arc-ledger data into plot structure notes\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  ArcLedger,\n  ArcLedgerThread,\n  ArcLedgerCharacter,\n} from './types.js';\nimport {\n  parseArcLedger,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n  wikilink,\n  formatChapters,\n} from './utils.js';\n\nconst ARCS_SUBDIR = 'Arcs';\n\n/**\n * Build frontmatter for a plot thread note\n */\nfunction buildThreadFrontmatter(thread: ArcLedgerThread): Record<string, unknown> {\n  return {\n    id: thread.thread_id,\n    type: 'concept',\n    title: thread.name,\n    thread_type: thread.type,\n    status: thread.status,\n    tags: buildThreadTags(thread),\n    chapters: thread.chapters_touched,\n    resolution_chapter: thread.resolution_chapter,\n  };\n}\n\n/**\n * Build tags for a plot thread\n */\nfunction buildThreadTags(thread: ArcLedgerThread): string[] {\n  const tags: string[] = ['arc', 'plot-thread'];\n\n  // Type tag\n  const threadType = thread.type.toLowerCase().replace(/[_\\s]+/g, '-');\n  if (threadType && !tags.includes(threadType)) {\n    tags.push(threadType);\n  }\n\n  // Status tag\n  const status = thread.status.toLowerCase();\n  tags.push(`status-${status}`);\n\n  return tags;\n}\n\n/**\n * Build content for a plot thread note\n */\nfunction buildThreadContent(thread: ArcLedgerThread): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${thread.name}\\n\\n`);\n\n  // Status banner\n  const statusIcon = getStatusIcon(thread.status);\n  parts.push(`> ${statusIcon} **Status:** ${thread.status.toUpperCase()}\\n\\n`);\n\n  // Overview\n  parts.push(section('Overview'));\n  parts.push(`**Type:** ${thread.type.replace(/_/g, ' ')}\\n\\n`);\n\n  if (thread.description) {\n    parts.push(thread.description + '\\n\\n');\n  }\n\n  // Chapters\n  if (thread.chapters_touched && thread.chapters_touched.length > 0) {\n    parts.push(section('Chapters'));\n    parts.push(`**Chapters Touched:** ${formatChapters(thread.chapters_touched)}\\n\\n`);\n  }\n\n  // Resolution\n  if (thread.resolution_chapter || thread.resolution_description) {\n    parts.push(section('Resolution'));\n    if (thread.resolution_chapter) {\n      parts.push(`**Chapter:** ${thread.resolution_chapter}\\n\\n`);\n    }\n    if (thread.resolution_description) {\n      parts.push(thread.resolution_description + '\\n\\n');\n    }\n  }\n\n  // Expected resolution (for unresolved threads)\n  if (thread.expected_resolution && thread.status !== 'resolved') {\n    parts.push(section('Expected Resolution'));\n    parts.push(`*Expected in: ${thread.expected_resolution}*\\n\\n`);\n  }\n\n  // Related content\n  parts.push(section('Related Notes'));\n  parts.push('```dataview\\n');\n  parts.push('LIST FROM #arc\\n');\n  parts.push(\n    `WHERE contains(file.outlinks, this.file.link) OR contains(tags, \"${thread.thread_id}\")\\n`\n  );\n  parts.push('```\\n\\n');\n\n  return parts.join('');\n}\n\n/**\n * Build frontmatter for a character arc note\n */\nfunction buildCharacterArcFrontmatter(char: ArcLedgerCharacter): Record<string, unknown> {\n  const arc = char.arc;\n  return {\n    id: `arc-${char.character_id}`,\n    type: 'concept',\n    title: `${char.canonical_name}'s Arc`,\n    character: char.canonical_name,\n    arc_type: arc?.type,\n    status: arc?.resolution?.status || 'in_progress',\n    tags: ['arc', 'character-arc', `character-${char.character_id.replace(/_/g, '-')}`],\n    resolution_chapter: arc?.resolution?.chapter,\n  };\n}\n\n/**\n * Build content for a character arc note\n */\nfunction buildCharacterArcContent(char: ArcLedgerCharacter): string {\n  const parts: string[] = [];\n  const arc = char.arc;\n\n  // Title\n  parts.push(`# ${char.canonical_name}'s Arc\\n\\n`);\n\n  // Link to character\n  parts.push(`**Character:** ${wikilink(char.canonical_name)}\\n\\n`);\n\n  // Arc type and description\n  if (arc) {\n    parts.push(section('Arc Overview'));\n    parts.push(`**Type:** ${arc.type.replace(/_/g, ' ')}\\n\\n`);\n    if (arc.description) {\n      parts.push(arc.description + '\\n\\n');\n    }\n  }\n\n  // Entry state\n  if (char.entry_state && Object.keys(char.entry_state).length > 0) {\n    parts.push(section('Entry State'));\n    parts.push(formatStateForArc(char.entry_state));\n  }\n\n  // Key moments\n  if (arc?.key_moments && arc.key_moments.length > 0) {\n    parts.push(section('Key Moments'));\n    for (const moment of arc.key_moments) {\n      parts.push(`### Chapter ${moment.chapter}: ${moment.beat.replace(/_/g, ' ')}\\n`);\n      parts.push(`${moment.description}\\n\\n`);\n    }\n  }\n\n  // Resolution\n  if (arc?.resolution) {\n    parts.push(section('Resolution'));\n    const res = arc.resolution;\n    const statusIcon = getStatusIcon(res.status);\n    parts.push(`${statusIcon} **Status:** ${res.status}\\n\\n`);\n    if (res.chapter) {\n      parts.push(`**Chapter:** ${res.chapter}\\n\\n`);\n    }\n    if (res.key_line) {\n      parts.push(`> \"${res.key_line}\"\\n\\n`);\n    }\n    if (res.mechanism) {\n      parts.push(`*${res.mechanism}*\\n\\n`);\n    }\n  }\n\n  // Exit state\n  if (char.exit_state && Object.keys(char.exit_state).length > 0) {\n    parts.push(section('Exit State'));\n    parts.push(formatStateForArc(char.exit_state));\n  }\n\n  return parts.join('');\n}\n\n/**\n * Format a state object for arc display\n */\nfunction formatStateForArc(state: Record<string, unknown>): string {\n  const lines: string[] = [];\n\n  for (const [key, value] of Object.entries(state)) {\n    if (value === undefined || value === null) continue;\n    if (key === 'locked' || key === 'lock_reference' || key === 'source') continue;\n\n    if (Array.isArray(value)) {\n      lines.push(`**${key}:**`);\n      for (const item of value) {\n        lines.push(`- ${item}`);\n      }\n    } else {\n      lines.push(`**${key}:** ${value}`);\n    }\n  }\n\n  return lines.join('\\n') + '\\n\\n';\n}\n\n/**\n * Get status icon\n */\nfunction getStatusIcon(status: string): string {\n  const s = status.toLowerCase();\n  if (s === 'resolved' || s === 'compliant' || s === 'fulfilled') {\n    return '';\n  }\n  if (s === 'destroyed') {\n    return '';\n  }\n  if (s === 'setup' || s === 'unresolved') {\n    return '';\n  }\n  if (s === 'in_progress') {\n    return '';\n  }\n  return '';\n}\n\n/**\n * Generate arc notes from arc-ledger data\n */\nexport async function generateArcs(options: GeneratorOptions): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load arc ledger\n  let arcLedger: ArcLedger;\n  try {\n    if (!options.arcLedgerPath) {\n      throw new Error('Arc ledger path is required');\n    }\n    arcLedger = parseArcLedger(options.arcLedgerPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.arcLedgerPath || 'unknown',\n      error: `Failed to load arc ledger: ${error}`,\n    });\n    result.summary = 'Failed to load arc ledger data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Process plot threads\n  if (arcLedger.threads) {\n    for (const thread of arcLedger.threads) {\n      const name = thread.name;\n\n      if (!tracker.add(name)) {\n        if (options.verbose) {\n          console.log(`Skipping duplicate thread: ${name}`);\n        }\n        continue;\n      }\n\n      try {\n        const filePath = generateNotePath(options.outputDir, `${ARCS_SUBDIR}/Threads`, name);\n        const frontmatter = buildThreadFrontmatter(thread);\n        const content = buildThreadContent(thread);\n        const note = buildNote(frontmatter, content);\n\n        const written = await writeNoteFile(filePath, note, {\n          force: options.force,\n          dryRun: options.dryRun,\n        });\n\n        if (written) {\n          result.created.push(filePath);\n          if (options.verbose) {\n            console.log(`Created: ${filePath}`);\n          }\n        } else {\n          result.skipped.push(filePath);\n          if (options.verbose) {\n            console.log(`Skipped (exists): ${filePath}`);\n          }\n        }\n      } catch (error) {\n        result.errors.push({\n          file: name,\n          error: `${error}`,\n        });\n      }\n    }\n  }\n\n  // Process character arcs\n  if (arcLedger.characters) {\n    for (const char of arcLedger.characters) {\n      // Only process characters with arcs\n      if (!char.arc) continue;\n\n      const arcName = `${char.canonical_name}'s Arc`;\n\n      if (!tracker.add(arcName)) {\n        if (options.verbose) {\n          console.log(`Skipping duplicate character arc: ${arcName}`);\n        }\n        continue;\n      }\n\n      try {\n        const filePath = generateNotePath(options.outputDir, `${ARCS_SUBDIR}/Characters`, arcName);\n        const frontmatter = buildCharacterArcFrontmatter(char);\n        const content = buildCharacterArcContent(char);\n        const note = buildNote(frontmatter, content);\n\n        const written = await writeNoteFile(filePath, note, {\n          force: options.force,\n          dryRun: options.dryRun,\n        });\n\n        if (written) {\n          result.created.push(filePath);\n          if (options.verbose) {\n            console.log(`Created: ${filePath}`);\n          }\n        } else {\n          result.skipped.push(filePath);\n          if (options.verbose) {\n            console.log(`Skipped (exists): ${filePath}`);\n          }\n        }\n      } catch (error) {\n        result.errors.push({\n          file: arcName,\n          error: `${error}`,\n        });\n      }\n    }\n  }\n\n  result.summary = `Arcs: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n","/**\n * Link Injection\n * Post-processor that adds wikilinks to notes based on entity names\n * Carefully avoids frontmatter, code blocks, existing links, and headers\n */\n\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport type { InjectLinksOptions, InjectLinksResult, KBData } from './types.js';\nimport { parseKBJson } from './utils.js';\n\n// ============================================================================\n// Simple Glob Implementation\n// ============================================================================\n\ninterface GlobOptions {\n  ignore?: string[];\n}\n\n/**\n * Simple glob pattern matching for file discovery\n */\nasync function glob(\n  basePath: string,\n  pattern: string,\n  options: GlobOptions = {}\n): Promise<string[]> {\n  const results: string[] = [];\n  const ignore = options.ignore || [];\n\n  // Convert glob pattern to regex\n  // Handle **/*.md to match both root files and nested files\n  let regexPattern = pattern\n    .replace(/\\*\\*/g, '{{GLOBSTAR}}')\n    .replace(/\\*/g, '[^/]*')\n    .replace(/\\?/g, '.')\n    .replace(/{{GLOBSTAR}}\\//g, '(?:.*\\\\/)?') // **/ matches zero or more dirs\n    .replace(/{{GLOBSTAR}}/g, '.*');\n  const regex = new RegExp(`^${regexPattern}$`);\n\n  async function walk(dir: string): Promise<void> {\n    let entries;\n    try {\n      entries = await fs.promises.readdir(dir, { withFileTypes: true });\n    } catch {\n      return;\n    }\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      const relativePath = path.relative(basePath, fullPath).replace(/\\\\/g, '/');\n\n      // Check ignore patterns\n      let shouldIgnore = false;\n      for (const ignorePattern of ignore) {\n        const ignoreRegex = ignorePattern\n          .replace(/\\*\\*/g, '{{GLOBSTAR}}')\n          .replace(/\\*/g, '[^/]*')\n          .replace(/{{GLOBSTAR}}/g, '.*');\n        if (new RegExp(`^${ignoreRegex}$`).test(relativePath)) {\n          shouldIgnore = true;\n          break;\n        }\n      }\n\n      if (shouldIgnore) continue;\n\n      if (entry.isDirectory()) {\n        await walk(fullPath);\n      } else if (entry.isFile()) {\n        if (regex.test(relativePath)) {\n          results.push(fullPath);\n        }\n      }\n    }\n  }\n\n  await walk(basePath);\n  return results;\n}\n\n// ============================================================================\n// Protected Regions\n// ============================================================================\n\n// Regions to avoid when injecting links\ninterface ProtectedRegion {\n  start: number;\n  end: number;\n  type: 'frontmatter' | 'code_block' | 'inline_code' | 'existing_link' | 'header';\n}\n\n/**\n * Find all protected regions in a document where we shouldn't inject links\n */\nfunction findProtectedRegions(content: string): ProtectedRegion[] {\n  const regions: ProtectedRegion[] = [];\n\n  // Frontmatter (must be at start of document)\n  const frontmatterMatch = content.match(/^---\\r?\\n[\\s\\S]*?\\r?\\n---\\r?\\n?/);\n  if (frontmatterMatch) {\n    regions.push({\n      start: 0,\n      end: frontmatterMatch[0].length,\n      type: 'frontmatter',\n    });\n  }\n\n  // Code blocks (fenced with ``` or ~~~)\n  const codeBlockRegex = /```[\\s\\S]*?```|~~~[\\s\\S]*?~~~/g;\n  let match;\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'code_block',\n    });\n  }\n\n  // Inline code\n  const inlineCodeRegex = /`[^`\\n]+`/g;\n  while ((match = inlineCodeRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'inline_code',\n    });\n  }\n\n  // Existing wikilinks\n  const wikilinkRegex = /\\[\\[[^\\]]+\\]\\]/g;\n  while ((match = wikilinkRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'existing_link',\n    });\n  }\n\n  // Markdown links\n  const markdownLinkRegex = /\\[([^\\]]+)\\]\\([^)]+\\)/g;\n  while ((match = markdownLinkRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'existing_link',\n    });\n  }\n\n  // Headers (don't link inside headers)\n  const headerRegex = /^#{1,6}\\s+.+$/gm;\n  while ((match = headerRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'header',\n    });\n  }\n\n  return regions.sort((a, b) => a.start - b.start);\n}\n\n/**\n * Check if a position is within any protected region\n */\nfunction isProtected(position: number, length: number, regions: ProtectedRegion[]): boolean {\n  const end = position + length;\n  for (const region of regions) {\n    // Check if our range overlaps with the protected region\n    if (position < region.end && end > region.start) {\n      return true;\n    }\n    // Early exit if we've passed all relevant regions\n    if (region.start > end) {\n      break;\n    }\n  }\n  return false;\n}\n\n/**\n * Create a case-insensitive regex for an entity name\n * Handles word boundaries properly\n */\nfunction createEntityRegex(name: string): RegExp {\n  // Escape special regex characters\n  const escaped = name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Match whole words only, case insensitive\n  return new RegExp(`\\\\b(${escaped})\\\\b`, 'gi');\n}\n\ninterface Replacement {\n  start: number;\n  end: number;\n  original: string;\n  replacement: string;\n}\n\n/**\n * Find all positions where an entity should be linked\n */\nfunction findEntityMatches(\n  content: string,\n  entityName: string,\n  protectedRegions: ProtectedRegion[]\n): Replacement[] {\n  const replacements: Replacement[] = [];\n  const regex = createEntityRegex(entityName);\n  let match;\n\n  while ((match = regex.exec(content)) !== null) {\n    const start = match.index;\n    const original = match[0];\n    const length = original.length;\n\n    // Skip if in protected region\n    if (isProtected(start, length, protectedRegions)) {\n      continue;\n    }\n\n    replacements.push({\n      start,\n      end: start + length,\n      original,\n      replacement: `[[${entityName}|${original}]]`,\n    });\n  }\n\n  return replacements;\n}\n\n/**\n * Apply replacements to content, working from end to start to maintain positions\n */\nfunction applyReplacements(content: string, replacements: Replacement[]): string {\n  // Sort by position descending so we can replace from end to start\n  const sorted = [...replacements].sort((a, b) => b.start - a.start);\n\n  let result = content;\n  for (const rep of sorted) {\n    result = result.slice(0, rep.start) + rep.replacement + result.slice(rep.end);\n  }\n\n  return result;\n}\n\n/**\n * Inject wikilinks into a single file\n */\nfunction injectLinksInFile(\n  content: string,\n  entities: Map<string, string[]> // canonical name -> aliases\n): { content: string; linksInjected: number } {\n  const protectedRegions = findProtectedRegions(content);\n  const allReplacements: Replacement[] = [];\n  const linkedPositions = new Set<string>(); // Track positions we've already linked\n\n  // Process each entity and its aliases\n  for (const [canonical, aliases] of entities) {\n    // Process canonical name first\n    const canonicalMatches = findEntityMatches(content, canonical, protectedRegions);\n    for (const match of canonicalMatches) {\n      const posKey = `${match.start}-${match.end}`;\n      if (!linkedPositions.has(posKey)) {\n        // For canonical name, use simple link\n        match.replacement = `[[${canonical}]]`;\n        allReplacements.push(match);\n        linkedPositions.add(posKey);\n      }\n    }\n\n    // Process aliases\n    for (const alias of aliases) {\n      if (alias.toLowerCase() === canonical.toLowerCase()) continue;\n\n      const aliasMatches = findEntityMatches(content, alias, protectedRegions);\n      for (const match of aliasMatches) {\n        const posKey = `${match.start}-${match.end}`;\n        if (!linkedPositions.has(posKey)) {\n          // Check if this position overlaps with any existing replacement\n          const overlaps = allReplacements.some((r) => match.start < r.end && match.end > r.start);\n          if (!overlaps) {\n            // For alias, link to canonical with display text\n            match.replacement = `[[${canonical}|${match.original}]]`;\n            allReplacements.push(match);\n            linkedPositions.add(posKey);\n          }\n        }\n      }\n    }\n  }\n\n  // Remove overlapping replacements (keep first occurrence)\n  const nonOverlapping = removeOverlaps(allReplacements);\n\n  const newContent = applyReplacements(content, nonOverlapping);\n  return {\n    content: newContent,\n    linksInjected: nonOverlapping.length,\n  };\n}\n\n/**\n * Remove overlapping replacements, keeping the first one found\n */\nfunction removeOverlaps(replacements: Replacement[]): Replacement[] {\n  if (replacements.length <= 1) return replacements;\n\n  // Sort by start position\n  const sorted = [...replacements].sort((a, b) => a.start - b.start);\n  const first = sorted[0];\n  if (!first) return [];\n\n  const result: Replacement[] = [first];\n\n  for (let i = 1; i < sorted.length; i++) {\n    const current = sorted[i];\n    const last = result[result.length - 1];\n\n    // If current doesn't overlap with last kept replacement, keep it\n    if (current && last && current.start >= last.end) {\n      result.push(current);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Build entity map from KB data\n */\nfunction buildEntityMap(kb: KBData): Map<string, string[]> {\n  const entities = new Map<string, string[]>();\n\n  // Add characters\n  for (const char of kb.characters) {\n    entities.set(char.canonical_name, char.aliases || []);\n  }\n\n  // Add locations\n  for (const loc of kb.locations) {\n    entities.set(loc.name, []);\n  }\n\n  // Add objects\n  for (const obj of kb.objects) {\n    entities.set(obj.name, []);\n  }\n\n  // Add name normalization if available\n  if (kb.name_normalization) {\n    for (const norm of kb.name_normalization) {\n      if (entities.has(norm.canonical)) {\n        const existing = entities.get(norm.canonical)!;\n        const combined = [...new Set([...existing, ...norm.variants])];\n        entities.set(norm.canonical, combined);\n      } else {\n        entities.set(norm.canonical, norm.variants);\n      }\n    }\n  }\n\n  return entities;\n}\n\n/**\n * Inject wikilinks into all matching files in a vault\n */\nexport async function injectLinks(options: InjectLinksOptions): Promise<InjectLinksResult> {\n  const result: InjectLinksResult = {\n    modified: [],\n    linksInjected: 0,\n    skipped: [],\n    errors: [],\n  };\n\n  // Build entity map\n  let entities: Map<string, string[]>;\n\n  if (options.entities) {\n    // Use provided entity list\n    entities = new Map();\n    for (const entity of options.entities) {\n      entities.set(entity, []);\n    }\n  } else {\n    // Try to find KB file\n    const kbPaths = [\n      path.join(options.vaultPath, '.narrative-project', 'kb', 'kb.json'),\n      path.join(options.vaultPath, 'kb', 'kb.json'),\n      path.join(options.vaultPath, 'kb.json'),\n    ];\n\n    let kbPath: string | null = null;\n    for (const p of kbPaths) {\n      if (fs.existsSync(p)) {\n        kbPath = p;\n        break;\n      }\n    }\n\n    if (kbPath) {\n      try {\n        const kb = parseKBJson(kbPath);\n        entities = buildEntityMap(kb);\n      } catch (error) {\n        result.errors.push({\n          file: kbPath,\n          error: `Failed to load KB: ${error}`,\n        });\n        return result;\n      }\n    } else {\n      result.errors.push({\n        file: options.vaultPath,\n        error: 'No entity list provided and no KB file found',\n      });\n      return result;\n    }\n  }\n\n  if (entities.size === 0) {\n    return result;\n  }\n\n  // Find files to process\n  const pattern = options.pattern || '**/*.md';\n  const files = await glob(options.vaultPath, pattern, {\n    ignore: ['**/node_modules/**', '**/.git/**', '**/.zettelscript/**'],\n  });\n\n  // Process each file\n  for (const file of files) {\n    try {\n      const content = fs.readFileSync(file, 'utf-8');\n      const { content: newContent, linksInjected } = injectLinksInFile(content, entities);\n\n      if (linksInjected > 0) {\n        if (options.dryRun) {\n          console.log(`[DRY RUN] Would modify: ${file} (+${linksInjected} links)`);\n          result.modified.push(file);\n          result.linksInjected += linksInjected;\n        } else {\n          await fs.promises.writeFile(file, newContent, 'utf-8');\n          result.modified.push(file);\n          result.linksInjected += linksInjected;\n          if (options.verbose) {\n            console.log(`Modified: ${file} (+${linksInjected} links)`);\n          }\n        }\n      } else {\n        result.skipped.push(file);\n      }\n    } catch (error) {\n      result.errors.push({\n        file,\n        error: `${error}`,\n      });\n    }\n  }\n\n  return result;\n}\n\n/**\n * Preview link injection without modifying files\n */\nexport async function previewLinkInjection(\n  options: InjectLinksOptions\n): Promise<Map<string, Array<{ original: string; linked: string; position: number }>>> {\n  const previews = new Map<string, Array<{ original: string; linked: string; position: number }>>();\n\n  // Build entity map (same logic as injectLinks)\n  let entities: Map<string, string[]>;\n\n  if (options.entities) {\n    entities = new Map();\n    for (const entity of options.entities) {\n      entities.set(entity, []);\n    }\n  } else {\n    const kbPaths = [\n      path.join(options.vaultPath, '.narrative-project', 'kb', 'kb.json'),\n      path.join(options.vaultPath, 'kb', 'kb.json'),\n      path.join(options.vaultPath, 'kb.json'),\n    ];\n\n    let kbPath: string | null = null;\n    for (const p of kbPaths) {\n      if (fs.existsSync(p)) {\n        kbPath = p;\n        break;\n      }\n    }\n\n    if (kbPath) {\n      const kb = parseKBJson(kbPath);\n      entities = buildEntityMap(kb);\n    } else {\n      return previews;\n    }\n  }\n\n  // Find files\n  const pattern = options.pattern || '**/*.md';\n  const files = await glob(options.vaultPath, pattern, {\n    ignore: ['**/node_modules/**', '**/.git/**', '**/.zettelscript/**'],\n  });\n\n  // Collect preview info for each file\n  for (const file of files) {\n    const content = fs.readFileSync(file, 'utf-8');\n    const protectedRegions = findProtectedRegions(content);\n    const filePreview: Array<{ original: string; linked: string; position: number }> = [];\n\n    for (const [canonical, aliases] of entities) {\n      const allNames = [canonical, ...aliases];\n      for (const name of allNames) {\n        const matches = findEntityMatches(content, name, protectedRegions);\n        for (const match of matches) {\n          const linked =\n            name.toLowerCase() === canonical.toLowerCase()\n              ? `[[${canonical}]]`\n              : `[[${canonical}|${match.original}]]`;\n          filePreview.push({\n            original: match.original,\n            linked,\n            position: match.start,\n          });\n        }\n      }\n    }\n\n    if (filePreview.length > 0) {\n      previews.set(\n        file,\n        filePreview.sort((a, b) => a.position - b.position)\n      );\n    }\n  }\n\n  return previews;\n}\n","import { Command } from 'commander';\nimport * as path from 'node:path';\nimport { findVaultRoot, Spinner } from '../utils.js';\nimport {\n  injectLinks,\n  previewLinkInjection,\n  type InjectLinksOptions,\n} from '../../generators/index.js';\n\nexport const injectLinksCommand = new Command('inject-links')\n  .description('Add wikilinks to notes based on entity names from KB')\n  .option('-p, --path <dir>', 'Vault path (default: current vault)')\n  .option('-g, --pattern <glob>', 'File pattern to process (default: **/*.md)')\n  .option('-e, --entities <names...>', 'Specific entity names to link')\n  .option('-n, --dry-run', 'Show changes without modifying files')\n  .option('--preview', 'Show detailed preview of all changes')\n  .option('-v, --verbose', 'Show detailed output')\n  .addHelpText(\n    'after',\n    `\nExamples:\n  zettel inject-links                    # Process all .md files using KB entities\n  zettel inject-links -n                 # Dry run to see what would change\n  zettel inject-links --preview          # Show detailed preview of all changes\n  zettel inject-links -e \"Ryan\" \"Kevin\"  # Only link specific entities\n  zettel inject-links -g \"Chapters/*.md\" # Only process chapter files\n`\n  )\n  .action(async (options) => {\n    try {\n      // Resolve vault path\n      const vaultPath = options.path\n        ? path.resolve(options.path)\n        : findVaultRoot() || process.cwd();\n\n      const opts: InjectLinksOptions = {\n        vaultPath,\n        pattern: options.pattern,\n        entities: options.entities,\n        dryRun: options.dryRun || options.preview,\n        verbose: options.verbose,\n      };\n\n      // Preview mode shows detailed changes\n      if (options.preview) {\n        console.log('Previewing link injection...\\n');\n\n        const previews = await previewLinkInjection(opts);\n\n        if (previews.size === 0) {\n          console.log('No links to inject.');\n          return;\n        }\n\n        for (const [file, changes] of previews) {\n          const relativePath = path.relative(vaultPath, file);\n          console.log(`\\n${relativePath} (${changes.length} links):`);\n\n          for (const change of changes.slice(0, 10)) {\n            console.log(`  ${change.original}  ${change.linked}`);\n          }\n\n          if (changes.length > 10) {\n            console.log(`  ... and ${changes.length - 10} more`);\n          }\n        }\n\n        console.log(\n          `\\nTotal: ${previews.size} files, ${Array.from(previews.values()).reduce((sum, c) => sum + c.length, 0)} links`\n        );\n        console.log('\\nRun without --preview to apply changes.');\n        return;\n      }\n\n      // Normal operation\n      const spinner = new Spinner('Injecting links...');\n      spinner.start();\n\n      const result = await injectLinks(opts);\n\n      spinner.stop();\n\n      // Print results\n      if (opts.dryRun) {\n        console.log('\\n[DRY RUN] Would modify:');\n      } else {\n        console.log('\\nLink injection complete:');\n      }\n\n      console.log(`  Files modified: ${result.modified.length}`);\n      console.log(`  Links injected: ${result.linksInjected}`);\n      console.log(`  Files skipped:  ${result.skipped.length}`);\n\n      if (result.errors.length > 0) {\n        console.log(`\\nErrors (${result.errors.length}):`);\n        for (const err of result.errors.slice(0, 5)) {\n          console.log(`  ${err.file}: ${err.error}`);\n        }\n        if (result.errors.length > 5) {\n          console.log(`  ... and ${result.errors.length - 5} more`);\n        }\n      }\n\n      if (opts.verbose && result.modified.length > 0) {\n        console.log('\\nModified files:');\n        for (const file of result.modified) {\n          const relativePath = path.relative(vaultPath, file);\n          console.log(`  ${relativePath}`);\n        }\n      }\n    } catch (error) {\n      console.error(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n","import { Command } from 'commander';\nimport process from 'node:process';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport open from 'open';\nimport { initContext, getZettelScriptDir, printTable } from '../utils.js';\nimport type { Constellation } from '../../storage/database/repositories/index.js';\nimport { createVisualizeServer, type VisualizeServer } from '../server/visualize-server.js';\nimport { PROTOCOL_VERSION } from '../server/ws-protocol.js';\nimport { shouldRenderEdge, type EdgeType } from '../../core/types/index.js';\nimport { computeDoctorStats, type DoctorStats } from './doctor.js';\nimport type { FocusBundle } from '../../discovery/focus-bundle.js';\n\n// Node type colors (Modern Palette)\nexport const typeColors: Record<string, string> = {\n  note: '#94a3b8', // Slate 400\n  scene: '#a78bfa', // Violet 400\n  character: '#34d399', // Emerald 400\n  location: '#60a5fa', // Blue 400\n  object: '#fbbf24', // Amber 400\n  event: '#f87171', // Red 400\n  concept: '#f472b6', // Pink 400\n  moc: '#fb923c', // Orange 400\n  timeline: '#818cf8', // Indigo 400\n  draft: '#52525b', // Zinc 600\n  ghost: '#64748b', // Slate 500 (for ghost nodes)\n};\n\n// Edge type styling configuration\nexport const edgeStyles: Record<string, { color: string; dash: number[]; label: string }> = {\n  explicit_link: { color: '#22d3ee', dash: [], label: 'Links to' }, // Cyan\n  backlink: { color: '#a78bfa', dash: [5, 5], label: 'Backlinks' }, // Violet\n  sequence: { color: '#34d399', dash: [], label: 'Sequence' }, // Emerald\n  hierarchy: { color: '#fbbf24', dash: [], label: 'Hierarchy' }, // Amber\n  participation: { color: '#f472b6', dash: [], label: 'Participation' }, // Pink\n  pov_visible_to: { color: '#60a5fa', dash: [3, 3], label: 'POV Visible' }, // Blue\n  causes: { color: '#f87171', dash: [], label: 'Causes' }, // Red\n  setup_payoff: { color: '#fb923c', dash: [], label: 'Setup/Payoff' }, // Orange\n  semantic: { color: '#94a3b8', dash: [2, 2], label: 'Semantic' }, // Gray (accepted wormholes)\n  semantic_suggestion: { color: '#64748b', dash: [3, 3], label: 'Wormhole' }, // Slate 500 (pending wormholes)\n  mention: { color: '#2dd4bf', dash: [2, 2], label: 'Mention' }, // Teal\n  alias: { color: '#818cf8', dash: [4, 2], label: 'Alias' }, // Indigo\n  ghost_ref: { color: '#64748b', dash: [2, 2], label: 'Ghost Reference' }, // Slate 500\n};\n\nexport interface GraphNode {\n  id: string;\n  name: string;\n  type: string;\n  val: number;\n  color: string;\n  path: string;\n  metadata: Record<string, unknown>;\n  updatedAtMs?: number | undefined; // Epoch ms for heat vision\n  isGhost?: boolean;\n  sourceIds?: string[];\n  referenceCount?: number;\n  mostRecentRef?: string | undefined;\n}\n\nexport interface WebSocketConfig {\n  enabled: boolean;\n  port: number;\n  token: string;\n  protocolVersion: string;\n}\n\nexport interface GraphLink {\n  source: string;\n  target: string;\n  type: string;\n  strength?: number;\n  provenance?: string;\n}\n\nexport interface GraphData {\n  nodes: GraphNode[];\n  links: GraphLink[];\n}\n\nexport interface PathData {\n  paths: Array<{\n    path: string[];\n    edges: string[];\n    hopCount: number;\n    score: number;\n  }>;\n  fromId: string;\n  toId: string;\n  fromLabel: string;\n  toLabel: string;\n}\n\nexport function generateVisualizationHtml(\n  graphData: GraphData,\n  nodeTypeColors: Record<string, string>,\n  constellation?: Constellation | null,\n  pathData?: PathData | null,\n  wsConfig?: WebSocketConfig | null,\n  statusData?: DoctorStats | null,\n  focusBundle?: FocusBundle | null\n): string {\n  const constellationState = constellation ? JSON.stringify(constellation) : 'null';\n  const pathDataJson = pathData ? JSON.stringify(pathData) : 'null';\n  const wsConfigJson = wsConfig ? JSON.stringify(wsConfig) : 'null';\n  const statusDataJson = statusData ? JSON.stringify(statusData) : 'null';\n  const focusBundleJson = focusBundle ? JSON.stringify(focusBundle) : 'null';\n  return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>ZettelScript Atlas</title>\n  <style>\n    :root {\n      --bg: #0f172a;\n      --panel-bg: rgba(30, 41, 59, 0.7);\n      --border: rgba(148, 163, 184, 0.2);\n      --text-main: #f1f5f9;\n      --text-muted: #94a3b8;\n      --accent: #38bdf8;\n    }\n    body { margin: 0; font-family: 'Inter', system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text-main); overflow: hidden; }\n\n    #graph { width: 100vw; height: 100vh; cursor: crosshair; }\n\n    /* Glassmorphism Panels */\n    .panel {\n      background: var(--panel-bg);\n      backdrop-filter: blur(12px);\n      -webkit-backdrop-filter: blur(12px);\n      border: 1px solid var(--border);\n      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);\n      border-radius: 12px;\n      padding: 16px;\n      position: absolute;\n      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n\n    /* Breadcrumb Navigation */\n    #breadcrumbs {\n      top: 20px;\n      left: 50%;\n      transform: translateX(-50%);\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      padding: 8px 16px;\n      opacity: 0;\n      pointer-events: none;\n    }\n    #breadcrumbs.active { opacity: 1; pointer-events: auto; }\n\n    .nav-btn {\n      background: rgba(15, 23, 42, 0.6);\n      border: 1px solid var(--border);\n      color: var(--text-muted);\n      width: 32px;\n      height: 32px;\n      border-radius: 6px;\n      cursor: pointer;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      transition: all 0.2s;\n      font-size: 1rem;\n    }\n    .nav-btn:hover:not(:disabled) { background: rgba(56, 189, 248, 0.2); color: var(--accent); border-color: var(--accent); }\n    .nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }\n\n    .breadcrumb-trail {\n      display: flex;\n      align-items: center;\n      gap: 4px;\n      max-width: 400px;\n      overflow-x: auto;\n      scrollbar-width: none;\n    }\n    .breadcrumb-trail::-webkit-scrollbar { display: none; }\n\n    .breadcrumb-item {\n      padding: 4px 10px;\n      border-radius: 4px;\n      font-size: 0.85rem;\n      cursor: pointer;\n      white-space: nowrap;\n      color: var(--text-muted);\n      transition: all 0.2s;\n    }\n    .breadcrumb-item:hover { background: rgba(255,255,255,0.1); color: var(--text-main); }\n    .breadcrumb-item.current { color: var(--accent); font-weight: 600; }\n    .breadcrumb-sep { color: var(--text-muted); opacity: 0.5; }\n\n    /* Sidebar */\n    #sidebar {\n      top: 20px;\n      right: 20px;\n      width: 320px;\n      max-height: calc(100vh - 40px);\n      overflow-y: auto;\n      transform: translateX(400px);\n      opacity: 0;\n    }\n    #sidebar.active { transform: translateX(0); opacity: 1; }\n    #sidebar::-webkit-scrollbar { width: 6px; }\n    #sidebar::-webkit-scrollbar-track { background: transparent; }\n    #sidebar::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.3); border-radius: 3px; }\n\n    .node-header { padding-bottom: 12px; border-bottom: 1px solid var(--border); margin-bottom: 12px; }\n    .node-title { margin: 0; font-size: 1.25rem; font-weight: 600; line-height: 1.3; color: var(--text-main); }\n    .node-badge {\n      display: inline-block; margin-top: 8px; padding: 4px 8px;\n      border-radius: 99px; font-size: 0.75rem; font-weight: 700;\n      text-transform: uppercase; letter-spacing: 0.05em;\n      color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.3);\n    }\n\n    .meta-grid { display: grid; gap: 12px; }\n    .meta-item { display: flex; flex-direction: column; gap: 4px; }\n    .meta-key { font-size: 0.75rem; text-transform: uppercase; color: var(--text-muted); font-weight: 600; }\n    .meta-val { font-size: 0.9rem; color: var(--text-main); word-break: break-word; line-height: 1.5; }\n\n    code {\n      background: rgba(0, 0, 0, 0.3);\n      padding: 2px 6px;\n      border-radius: 4px;\n      font-family: 'JetBrains Mono', monospace;\n      font-size: 0.85em;\n    }\n\n    /* Connections Section */\n    .connections-section {\n      margin-top: 16px;\n      padding-top: 16px;\n      border-top: 1px solid var(--border);\n    }\n    .connections-title {\n      font-size: 0.8rem;\n      font-weight: 700;\n      color: var(--text-muted);\n      text-transform: uppercase;\n      margin-bottom: 12px;\n      letter-spacing: 0.05em;\n    }\n    .connection-group {\n      margin-bottom: 12px;\n    }\n    .connection-group-header {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      font-size: 0.75rem;\n      color: var(--text-muted);\n      margin-bottom: 6px;\n      text-transform: uppercase;\n    }\n    .connection-group-icon {\n      font-size: 0.9rem;\n    }\n    .connection-group-count {\n      background: rgba(255,255,255,0.1);\n      padding: 1px 6px;\n      border-radius: 10px;\n      font-size: 0.7rem;\n    }\n    .connected-node {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      padding: 6px 8px;\n      margin: 2px 0;\n      border-radius: 6px;\n      cursor: pointer;\n      transition: all 0.2s;\n    }\n    .connected-node:hover {\n      background: rgba(56, 189, 248, 0.15);\n    }\n    .connected-node-dot {\n      width: 8px;\n      height: 8px;\n      border-radius: 50%;\n      flex-shrink: 0;\n    }\n    .connected-node-name {\n      font-size: 0.85rem;\n      color: var(--text-main);\n      flex: 1;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap;\n    }\n    .connected-node-type {\n      font-size: 0.7rem;\n      color: var(--text-muted);\n      text-transform: lowercase;\n    }\n\n    /* Controls & Legend */\n    #controls {\n      top: 20px;\n      left: 20px;\n      max-width: 250px;\n      max-height: calc(100vh - 40px);\n      overflow-y: auto;\n    }\n    #controls::-webkit-scrollbar { width: 6px; }\n    #controls::-webkit-scrollbar-track { background: transparent; }\n    #controls::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.3); border-radius: 3px; }\n\n    .search-wrapper { position: relative; margin-bottom: 16px; }\n    input[type=\"text\"] {\n      width: 100%;\n      background: rgba(15, 23, 42, 0.6);\n      border: 1px solid var(--border);\n      color: var(--text-main);\n      padding: 10px 12px;\n      border-radius: 8px;\n      outline: none;\n      box-sizing: border-box;\n      transition: border-color 0.2s;\n    }\n    input[type=\"text\"]:focus { border-color: var(--accent); }\n\n    .legend-title { font-size: 0.8rem; font-weight: 700; color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase; }\n    .legend-grid { display: grid; grid-template-columns: 1fr; gap: 4px; }\n    .legend-item {\n      display: flex; align-items: center; gap: 10px;\n      font-size: 0.85rem; cursor: pointer; padding: 4px 8px;\n      border-radius: 6px; transition: background 0.2s;\n      user-select: none;\n    }\n    .legend-item:hover { background: rgba(255,255,255,0.05); }\n    .legend-item.hidden { opacity: 0.4; }\n    .legend-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }\n\n    /* Edge Type Filter */\n    .filter-section {\n      margin-top: 16px;\n      padding-top: 16px;\n      border-top: 1px solid var(--border);\n    }\n    .edge-legend-item {\n      display: flex;\n      align-items: center;\n      gap: 10px;\n      font-size: 0.8rem;\n      cursor: pointer;\n      padding: 4px 8px;\n      border-radius: 6px;\n      transition: background 0.2s;\n      user-select: none;\n    }\n    .edge-legend-item:hover { background: rgba(255,255,255,0.05); }\n    .edge-legend-item.hidden { opacity: 0.4; }\n    .edge-line {\n      width: 20px;\n      height: 2px;\n      border-radius: 1px;\n    }\n\n    /* Keyboard shortcuts hint */\n    .shortcuts-hint {\n      margin-top: 16px;\n      padding-top: 12px;\n      border-top: 1px solid var(--border);\n      font-size: 0.75rem;\n      color: var(--text-muted);\n      text-align: center;\n      line-height: 1.6;\n    }\n    kbd {\n      background: rgba(0, 0, 0, 0.3);\n      padding: 2px 5px;\n      border-radius: 3px;\n      font-family: 'JetBrains Mono', monospace;\n      font-size: 0.7rem;\n    }\n\n    /* Ghost nodes controls */\n    .ghost-controls {\n      margin-top: 16px;\n      padding-top: 16px;\n      border-top: 1px solid var(--border);\n    }\n    .toggle-item {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      font-size: 0.85rem;\n      cursor: pointer;\n      padding: 4px 0;\n    }\n    .toggle-item input[type=\"checkbox\"] {\n      accent-color: var(--accent);\n      width: 16px;\n      height: 16px;\n    }\n    .threshold-control {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      margin-top: 8px;\n      font-size: 0.8rem;\n      color: var(--text-muted);\n    }\n    .threshold-control input[type=\"range\"] {\n      flex: 1;\n      accent-color: var(--accent);\n    }\n    .threshold-val {\n      min-width: 20px;\n      text-align: center;\n      color: var(--text-main);\n    }\n    .ghost-count {\n      font-size: 0.75rem;\n      color: var(--text-muted);\n      margin-top: 4px;\n    }\n\n    /* Heat Vision controls */\n    .heat-controls {\n      margin-top: 16px;\n      padding-top: 16px;\n      border-top: 1px solid var(--border);\n    }\n    .heat-legend {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      margin-top: 12px;\n      padding: 8px;\n      background: rgba(0, 0, 0, 0.2);\n      border-radius: 6px;\n    }\n    .heat-legend-bar {\n      flex: 1;\n      height: 8px;\n      border-radius: 4px;\n      background: linear-gradient(to right, #3b82f6, #fbbf24, #ef4444);\n    }\n    .heat-legend-label {\n      font-size: 0.7rem;\n      color: var(--text-muted);\n      min-width: 40px;\n    }\n    .heat-legend-label:last-child {\n      text-align: right;\n    }\n\n    /* Ghost sidebar action */\n    .ghost-action {\n      margin-top: 16px;\n      padding-top: 16px;\n      border-top: 1px solid var(--border);\n    }\n    .create-note-btn {\n      width: 100%;\n      background: rgba(56, 189, 248, 0.2);\n      border: 1px solid var(--accent);\n      color: var(--accent);\n      padding: 10px 16px;\n      border-radius: 8px;\n      cursor: pointer;\n      font-size: 0.9rem;\n      font-weight: 600;\n      transition: all 0.2s;\n    }\n    .create-note-btn:hover {\n      background: rgba(56, 189, 248, 0.3);\n    }\n    .ghost-info {\n      font-size: 0.8rem;\n      color: var(--text-muted);\n      margin-top: 8px;\n      line-height: 1.4;\n    }\n\n    /* Constellation controls */\n    .constellation-section {\n      margin-top: 16px;\n      padding-top: 16px;\n      border-top: 1px solid var(--border);\n    }\n    .save-constellation-btn {\n      width: 100%;\n      background: rgba(251, 146, 60, 0.2);\n      border: 1px solid #fb923c;\n      color: #fb923c;\n      padding: 8px 12px;\n      border-radius: 6px;\n      cursor: pointer;\n      font-size: 0.85rem;\n      font-weight: 600;\n      transition: all 0.2s;\n    }\n    .save-constellation-btn:hover {\n      background: rgba(251, 146, 60, 0.3);\n    }\n    .constellation-name {\n      font-size: 0.8rem;\n      color: var(--text-muted);\n      margin-top: 8px;\n      text-align: center;\n    }\n    .constellation-name strong {\n      color: #fb923c;\n    }\n\n    /* Path Finder Panel */\n    #path-panel {\n      bottom: 20px;\n      left: 20px;\n      max-width: 400px;\n      display: none;\n    }\n    #path-panel.active {\n      display: block;\n    }\n    .path-header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      margin-bottom: 12px;\n    }\n    .path-title {\n      font-size: 0.9rem;\n      font-weight: 600;\n      color: var(--text-main);\n    }\n    .path-close-btn {\n      background: none;\n      border: none;\n      color: var(--text-muted);\n      cursor: pointer;\n      font-size: 1.2rem;\n      padding: 4px;\n    }\n    .path-close-btn:hover {\n      color: var(--text-main);\n    }\n    .path-selector {\n      display: flex;\n      flex-direction: column;\n      gap: 8px;\n      margin-bottom: 12px;\n    }\n    .path-option {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      padding: 8px 12px;\n      border-radius: 6px;\n      cursor: pointer;\n      transition: all 0.2s;\n      border: 1px solid var(--border);\n      background: rgba(15, 23, 42, 0.4);\n    }\n    .path-option:hover {\n      background: rgba(56, 189, 248, 0.1);\n      border-color: var(--accent);\n    }\n    .path-option.selected {\n      background: rgba(251, 191, 36, 0.2);\n      border-color: #fbbf24;\n    }\n    .path-option-num {\n      width: 24px;\n      height: 24px;\n      border-radius: 50%;\n      background: rgba(255, 255, 255, 0.1);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      font-size: 0.8rem;\n      font-weight: 600;\n    }\n    .path-option.selected .path-option-num {\n      background: #fbbf24;\n      color: #000;\n    }\n    .path-option-info {\n      flex: 1;\n    }\n    .path-option-route {\n      font-size: 0.8rem;\n      color: var(--text-main);\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n    .path-option-meta {\n      font-size: 0.7rem;\n      color: var(--text-muted);\n    }\n    .path-show-all {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      padding: 8px;\n      font-size: 0.85rem;\n      color: var(--text-muted);\n    }\n    .path-show-all input[type=\"checkbox\"] {\n      accent-color: var(--accent);\n    }\n\n    /* Backlog Panel */\n    .backlog-panel {\n      bottom: 20px;\n      right: 20px;\n      width: 280px;\n      max-height: 400px;\n    }\n    .backlog-header {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      cursor: pointer;\n      padding-bottom: 8px;\n      border-bottom: 1px solid var(--border);\n    }\n    .backlog-toggle {\n      transition: transform 0.2s;\n      font-size: 0.7rem;\n      color: var(--text-muted);\n    }\n    .backlog-panel:not(.expanded) .backlog-toggle {\n      transform: rotate(-90deg);\n    }\n    .backlog-panel:not(.expanded) .backlog-content {\n      display: none;\n    }\n    .backlog-sort {\n      margin-left: auto;\n      background: rgba(15, 23, 42, 0.6);\n      border: 1px solid var(--border);\n      color: var(--text-muted);\n      padding: 2px 6px;\n      border-radius: 4px;\n      font-size: 0.7rem;\n      cursor: pointer;\n    }\n    .backlog-search {\n      margin: 8px 0;\n    }\n    .backlog-search input {\n      width: 100%;\n      background: rgba(15, 23, 42, 0.6);\n      border: 1px solid var(--border);\n      color: var(--text-main);\n      padding: 6px 8px;\n      border-radius: 4px;\n      font-size: 0.8rem;\n      box-sizing: border-box;\n    }\n    .backlog-list {\n      max-height: 280px;\n      overflow-y: auto;\n    }\n    .backlog-row {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      padding: 6px 4px;\n      border-radius: 4px;\n      transition: background 0.2s;\n    }\n    .backlog-row:hover {\n      background: rgba(56, 189, 248, 0.1);\n    }\n    .backlog-row.pending {\n      opacity: 0.6;\n    }\n    .backlog-row-main {\n      flex: 1;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      cursor: pointer;\n      overflow: hidden;\n    }\n    .backlog-title {\n      flex: 1;\n      font-size: 0.85rem;\n      color: var(--text-main);\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n    .backlog-badges {\n      display: flex;\n      gap: 4px;\n      flex-shrink: 0;\n    }\n    .backlog-ref-count {\n      background: rgba(56, 189, 248, 0.2);\n      color: var(--accent);\n      padding: 1px 5px;\n      border-radius: 10px;\n      font-size: 0.7rem;\n      font-weight: 600;\n    }\n    .backlog-recency {\n      color: var(--text-muted);\n      font-size: 0.7rem;\n    }\n    .backlog-create-btn {\n      width: 24px;\n      height: 24px;\n      border-radius: 50%;\n      background: rgba(56, 189, 248, 0.2);\n      border: 1px solid var(--accent);\n      color: var(--accent);\n      cursor: pointer;\n      font-size: 1rem;\n      line-height: 1;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      flex-shrink: 0;\n    }\n    .backlog-create-btn:hover:not(:disabled) {\n      background: rgba(56, 189, 248, 0.3);\n    }\n    .backlog-create-btn:disabled {\n      opacity: 0.4;\n      cursor: not-allowed;\n    }\n    .backlog-more {\n      padding: 8px 4px;\n      font-size: 0.75rem;\n      color: var(--text-muted);\n      text-align: center;\n    }\n\n    /* Create Panel Modal */\n    .create-panel {\n      position: fixed;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      background: rgba(15, 23, 42, 0.8);\n      display: none;\n      align-items: center;\n      justify-content: center;\n      z-index: 1000;\n    }\n    .create-panel.active {\n      display: flex;\n    }\n    .create-panel-inner {\n      width: 340px;\n      position: relative;\n    }\n    .create-panel-header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      padding-bottom: 12px;\n      border-bottom: 1px solid var(--border);\n      margin-bottom: 16px;\n    }\n    .create-panel-body {\n      display: flex;\n      flex-direction: column;\n      gap: 12px;\n    }\n    .create-field {\n      display: flex;\n      flex-direction: column;\n      gap: 4px;\n    }\n    .create-field span {\n      font-size: 0.8rem;\n      color: var(--text-muted);\n    }\n    .create-field input,\n    .create-field select {\n      background: rgba(15, 23, 42, 0.6);\n      border: 1px solid var(--border);\n      color: var(--text-main);\n      padding: 8px 10px;\n      border-radius: 6px;\n      font-size: 0.9rem;\n    }\n    .create-field input:focus,\n    .create-field select:focus {\n      border-color: var(--accent);\n      outline: none;\n    }\n    .create-panel-footer {\n      display: flex;\n      justify-content: flex-end;\n      gap: 8px;\n      margin-top: 16px;\n      padding-top: 16px;\n      border-top: 1px solid var(--border);\n    }\n    .create-cancel-btn {\n      background: none;\n      border: 1px solid var(--border);\n      color: var(--text-muted);\n      padding: 8px 16px;\n      border-radius: 6px;\n      cursor: pointer;\n    }\n    .create-cancel-btn:hover {\n      background: rgba(255, 255, 255, 0.05);\n    }\n    .create-submit-btn {\n      background: rgba(56, 189, 248, 0.2);\n      border: 1px solid var(--accent);\n      color: var(--accent);\n      padding: 8px 16px;\n      border-radius: 6px;\n      cursor: pointer;\n      font-weight: 600;\n    }\n    .create-submit-btn:hover {\n      background: rgba(56, 189, 248, 0.3);\n    }\n\n    /* Health Status Panel */\n    #status-panel {\n      position: fixed;\n      bottom: 20px;\n      left: 20px;\n      min-width: 200px;\n      max-width: 300px;\n      z-index: 1000;\n    }\n    #status-panel .panel-header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      cursor: pointer;\n      padding: 8px 12px;\n      border-radius: 8px;\n      background: var(--panel-bg);\n      backdrop-filter: blur(12px);\n      border: 1px solid var(--border);\n    }\n    #status-panel .panel-header:hover {\n      background: rgba(30, 41, 59, 0.9);\n    }\n    #status-panel .panel-content {\n      margin-top: 8px;\n      padding: 12px;\n      border-radius: 8px;\n      background: var(--panel-bg);\n      backdrop-filter: blur(12px);\n      border: 1px solid var(--border);\n      display: none;\n    }\n    #status-panel.expanded .panel-content {\n      display: block;\n    }\n    #status-panel .status-row {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      margin-bottom: 8px;\n      font-size: 0.85rem;\n    }\n    #status-panel .status-row:last-child {\n      margin-bottom: 0;\n    }\n    #status-panel .status-label {\n      color: var(--text-muted);\n    }\n    #status-panel .status-value {\n      font-weight: 500;\n    }\n    #status-panel .status-ok { color: #34d399; }\n    #status-panel .status-warn { color: #fbbf24; }\n    #status-panel .status-fail { color: #f87171; }\n    #status-panel .status-badge {\n      display: inline-flex;\n      align-items: center;\n      gap: 4px;\n      padding: 2px 8px;\n      border-radius: 4px;\n      font-size: 0.75rem;\n      font-weight: 600;\n    }\n    #status-panel .badge-ok {\n      background: rgba(52, 211, 153, 0.2);\n      color: #34d399;\n    }\n    #status-panel .badge-warn {\n      background: rgba(251, 191, 36, 0.2);\n      color: #fbbf24;\n    }\n    #status-panel .badge-fail {\n      background: rgba(248, 113, 113, 0.2);\n      color: #f87171;\n    }\n    #status-panel .mode-toggle {\n      display: flex;\n      gap: 4px;\n      margin-top: 12px;\n      padding-top: 12px;\n      border-top: 1px solid var(--border);\n    }\n    #status-panel .mode-btn {\n      flex: 1;\n      padding: 6px 12px;\n      border: 1px solid var(--border);\n      border-radius: 6px;\n      background: transparent;\n      color: var(--text-muted);\n      cursor: pointer;\n      font-size: 0.8rem;\n      transition: all 0.2s;\n    }\n    #status-panel .mode-btn:hover {\n      background: rgba(56, 189, 248, 0.1);\n      color: var(--text-main);\n    }\n    #status-panel .mode-btn.active {\n      background: rgba(56, 189, 248, 0.2);\n      color: var(--accent);\n      border-color: var(--accent);\n    }\n    #status-panel .help-link {\n      display: block;\n      margin-top: 12px;\n      padding-top: 8px;\n      border-top: 1px solid var(--border);\n      color: var(--text-muted);\n      font-size: 0.75rem;\n      text-decoration: none;\n    }\n    #status-panel .help-link code {\n      background: rgba(0,0,0,0.3);\n      padding: 2px 6px;\n      border-radius: 4px;\n      font-family: monospace;\n    }\n\n    /* WebSocket Status Indicator */\n    .ws-status {\n      position: fixed;\n      top: 20px;\n      right: 350px;\n      width: 10px;\n      height: 10px;\n      border-radius: 50%;\n      transition: all 0.3s;\n    }\n    .ws-status.connected {\n      background: #34d399;\n      box-shadow: 0 0 8px #34d399;\n    }\n    .ws-status.disconnected {\n      background: #fbbf24;\n      box-shadow: 0 0 8px #fbbf24;\n      animation: pulse 1.5s infinite;\n    }\n    .ws-status.error {\n      background: #f87171;\n      box-shadow: 0 0 8px #f87171;\n    }\n\n    /* Upgrade Banner */\n    #upgrade-banner {\n      position: fixed;\n      top: 80px;\n      left: 50%;\n      transform: translateX(-50%);\n      max-width: 500px;\n      padding: 16px 20px;\n      background: rgba(56, 189, 248, 0.1);\n      backdrop-filter: blur(12px);\n      border: 1px solid rgba(56, 189, 248, 0.3);\n      border-radius: 12px;\n      z-index: 1002;\n      display: none;\n    }\n    #upgrade-banner.show {\n      display: block;\n      animation: slideDown 0.3s ease;\n    }\n    @keyframes slideDown {\n      from { opacity: 0; transform: translateX(-50%) translateY(-20px); }\n      to { opacity: 1; transform: translateX(-50%) translateY(0); }\n    }\n    #upgrade-banner h3 {\n      margin: 0 0 8px 0;\n      font-size: 1rem;\n      color: var(--accent);\n    }\n    #upgrade-banner p {\n      margin: 0 0 12px 0;\n      font-size: 0.9rem;\n      color: var(--text-main);\n      line-height: 1.4;\n    }\n    #upgrade-banner .banner-actions {\n      display: flex;\n      gap: 8px;\n    }\n    #upgrade-banner .banner-btn {\n      padding: 8px 16px;\n      border-radius: 6px;\n      font-size: 0.85rem;\n      cursor: pointer;\n      transition: all 0.2s;\n    }\n    #upgrade-banner .banner-btn-primary {\n      background: var(--accent);\n      color: var(--bg);\n      border: none;\n      font-weight: 600;\n    }\n    #upgrade-banner .banner-btn-primary:hover {\n      background: #7dd3fc;\n    }\n    #upgrade-banner .banner-btn-secondary {\n      background: transparent;\n      border: 1px solid var(--border);\n      color: var(--text-muted);\n    }\n    #upgrade-banner .banner-btn-secondary:hover {\n      border-color: var(--text-main);\n      color: var(--text-main);\n    }\n\n    /* Toast Notifications */\n    .toast {\n      position: fixed;\n      bottom: 80px;\n      left: 50%;\n      transform: translateX(-50%) translateY(20px);\n      background: var(--panel-bg);\n      backdrop-filter: blur(12px);\n      border: 1px solid var(--border);\n      padding: 10px 20px;\n      border-radius: 8px;\n      font-size: 0.9rem;\n      opacity: 0;\n      transition: all 0.3s;\n      z-index: 1001;\n    }\n    .toast.show {\n      opacity: 1;\n      transform: translateX(-50%) translateY(0);\n    }\n    .toast-error {\n      border-color: #f87171;\n      color: #f87171;\n    }\n    .toast-warning {\n      border-color: #fbbf24;\n      color: #fbbf24;\n    }\n    .toast-success {\n      border-color: #34d399;\n      color: #34d399;\n    }\n\n    @keyframes pulse {\n      0%, 100% { opacity: 1; }\n      50% { opacity: 0.5; }\n    }\n\n    /* Suggestions Panel */\n    #suggestions-panel {\n      position: fixed;\n      top: 20px;\n      right: 350px;\n      width: 320px;\n      max-height: calc(100vh - 40px);\n      overflow-y: auto;\n      z-index: 100;\n    }\n    #suggestions-panel::-webkit-scrollbar { width: 6px; }\n    #suggestions-panel::-webkit-scrollbar-track { background: transparent; }\n    #suggestions-panel::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.3); border-radius: 3px; }\n\n    .suggestions-header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      cursor: pointer;\n      padding-bottom: 12px;\n      border-bottom: 1px solid var(--border);\n    }\n    .suggestions-header h3 {\n      margin: 0;\n      font-size: 1rem;\n      font-weight: 600;\n      color: var(--text-main);\n    }\n    .suggestions-toggle {\n      color: var(--text-muted);\n      font-size: 0.8rem;\n    }\n\n    .suggestion-section {\n      margin-top: 12px;\n    }\n    .suggestion-section-header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      padding: 8px 0;\n      cursor: pointer;\n    }\n    .suggestion-section-header:hover {\n      color: var(--accent);\n    }\n    .suggestion-section-title {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      font-size: 0.9rem;\n      font-weight: 500;\n    }\n    .suggestion-count {\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      min-width: 20px;\n      height: 20px;\n      padding: 0 6px;\n      border-radius: 10px;\n      background: rgba(56, 189, 248, 0.2);\n      color: var(--accent);\n      font-size: 0.75rem;\n      font-weight: 600;\n    }\n    .suggestion-section-toggle {\n      color: var(--text-muted);\n      font-size: 0.8rem;\n      transition: transform 0.2s;\n    }\n    .suggestion-section.collapsed .suggestion-section-toggle {\n      transform: rotate(-90deg);\n    }\n    .suggestion-section.collapsed .suggestion-list {\n      display: none;\n    }\n\n    .suggestion-list {\n      margin-top: 8px;\n    }\n    .suggestion-item {\n      padding: 8px 10px;\n      margin-bottom: 6px;\n      border-radius: 6px;\n      background: rgba(15, 23, 42, 0.4);\n      border: 1px solid transparent;\n      cursor: pointer;\n      transition: all 0.2s;\n    }\n    .suggestion-item:hover {\n      background: rgba(56, 189, 248, 0.1);\n      border-color: var(--border);\n    }\n    .suggestion-item.active {\n      background: rgba(56, 189, 248, 0.15);\n      border-color: var(--accent);\n    }\n\n    .suggestion-item-title {\n      font-size: 0.85rem;\n      color: var(--text-main);\n      margin-bottom: 4px;\n    }\n    .suggestion-item-meta {\n      font-size: 0.75rem;\n      color: var(--text-muted);\n    }\n    .suggestion-score {\n      display: inline-block;\n      padding: 1px 6px;\n      border-radius: 4px;\n      background: rgba(52, 211, 153, 0.2);\n      color: #34d399;\n      font-size: 0.7rem;\n      margin-right: 6px;\n    }\n\n    /* Candidate link specific */\n    .candidate-link-row {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n    }\n    .candidate-link-info {\n      flex: 1;\n      min-width: 0;\n    }\n    .candidate-link-arrow {\n      color: var(--text-muted);\n      margin: 0 4px;\n    }\n    .candidate-from, .candidate-to {\n      display: inline;\n      max-width: 100px;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap;\n    }\n    .candidate-to.ghost {\n      font-style: italic;\n      color: #64748b;\n    }\n\n    .approve-btn {\n      padding: 4px 8px;\n      border: 1px solid rgba(52, 211, 153, 0.5);\n      border-radius: 4px;\n      background: rgba(52, 211, 153, 0.1);\n      color: #34d399;\n      font-size: 0.7rem;\n      cursor: pointer;\n      transition: all 0.2s;\n      white-space: nowrap;\n    }\n    .approve-btn:hover {\n      background: rgba(52, 211, 153, 0.2);\n      border-color: #34d399;\n    }\n    .approve-btn.copied {\n      background: rgba(52, 211, 153, 0.3);\n      border-color: #34d399;\n    }\n\n    .batch-copy-btn {\n      padding: 4px 10px;\n      border: 1px solid var(--border);\n      border-radius: 4px;\n      background: rgba(15, 23, 42, 0.6);\n      color: var(--text-muted);\n      font-size: 0.75rem;\n      cursor: pointer;\n      transition: all 0.2s;\n    }\n    .batch-copy-btn:hover {\n      background: rgba(56, 189, 248, 0.1);\n      color: var(--accent);\n      border-color: var(--accent);\n    }\n    .batch-copy-btn:disabled {\n      opacity: 0.5;\n      cursor: not-allowed;\n    }\n\n    /* Orphan specific */\n    .orphan-severity {\n      display: inline-block;\n      padding: 1px 6px;\n      border-radius: 4px;\n      font-size: 0.7rem;\n      margin-right: 6px;\n    }\n    .orphan-severity.high {\n      background: rgba(248, 113, 113, 0.2);\n      color: #f87171;\n    }\n    .orphan-severity.med {\n      background: rgba(251, 191, 36, 0.2);\n      color: #fbbf24;\n    }\n    .orphan-severity.low {\n      background: rgba(148, 163, 184, 0.2);\n      color: #94a3b8;\n    }\n\n    /* Empty state */\n    .suggestion-empty {\n      padding: 12px;\n      text-align: center;\n      color: var(--text-muted);\n      font-size: 0.8rem;\n    }\n    .suggestion-empty code {\n      display: block;\n      margin-top: 8px;\n      padding: 6px 10px;\n      background: rgba(0,0,0,0.3);\n      border-radius: 4px;\n      font-family: monospace;\n      font-size: 0.75rem;\n      color: var(--accent);\n    }\n\n    /* Tooltip for reasons */\n    .suggestion-reasons {\n      margin-top: 4px;\n      font-size: 0.7rem;\n      color: var(--text-muted);\n      font-style: italic;\n    }\n  </style>\n  <script src=\"https://unpkg.com/force-graph\"></script>\n</head>\n<body>\n  <div id=\"breadcrumbs\" class=\"panel\">\n    <button class=\"nav-btn\" id=\"btn-back\" onclick=\"goBack()\" disabled title=\"Go back (Alt+Left)\">&#8592;</button>\n    <button class=\"nav-btn\" id=\"btn-forward\" onclick=\"goForward()\" disabled title=\"Go forward (Alt+Right)\">&#8594;</button>\n    <div class=\"breadcrumb-trail\" id=\"breadcrumb-trail\"></div>\n  </div>\n\n  <div id=\"controls\" class=\"panel\">\n    <div class=\"search-wrapper\">\n      <input type=\"text\" id=\"search\" placeholder=\"Search nodes... (/)\" oninput=\"searchNode(this.value)\">\n    </div>\n    <div class=\"legend-title\">Filter by Node Type</div>\n    <div class=\"legend-grid\" id=\"legend\"></div>\n\n    <div class=\"filter-section\">\n      <div class=\"legend-title\">Filter by Edge Type</div>\n      <div class=\"legend-grid\" id=\"edge-legend\"></div>\n    </div>\n\n    <div class=\"ghost-controls\" id=\"ghost-controls\">\n      <div class=\"legend-title\">Ghost Nodes</div>\n      <label class=\"toggle-item\">\n        <input type=\"checkbox\" id=\"show-ghosts\" checked onchange=\"toggleGhosts()\">\n        <span>Show unresolved links</span>\n      </label>\n      <div class=\"threshold-control\" id=\"threshold-container\">\n        <span>Min refs:</span>\n        <input type=\"range\" id=\"ghost-threshold\" min=\"1\" max=\"10\" value=\"1\"\n               oninput=\"updateGhostThreshold(this.value)\">\n        <span class=\"threshold-val\" id=\"threshold-val\">1</span>\n      </div>\n      <div class=\"ghost-count\" id=\"ghost-count\"></div>\n    </div>\n\n    <div class=\"heat-controls\" id=\"heat-controls\">\n      <div class=\"legend-title\">Heat Vision</div>\n      <label class=\"toggle-item\">\n        <input type=\"checkbox\" id=\"heat-toggle\" onchange=\"toggleHeat()\">\n        <span>Show recency</span>\n      </label>\n      <div class=\"threshold-control\">\n        <span>Window:</span>\n        <input type=\"range\" id=\"heat-window-slider\" min=\"7\" max=\"180\" value=\"30\"\n               oninput=\"updateHeatWindow(this.value)\">\n        <span class=\"threshold-val\" id=\"heat-window-val\">30 days</span>\n      </div>\n      <label class=\"toggle-item\" id=\"heat-auto-label\">\n        <input type=\"checkbox\" id=\"heat-auto\" checked onchange=\"toggleHeatAuto()\">\n        <span>Auto (vault activity)</span>\n      </label>\n      <div class=\"heat-legend\" id=\"heat-legend\" style=\"display: none;\">\n        <span class=\"heat-legend-label\" id=\"heat-legend-cold\">>= 30d</span>\n        <div class=\"heat-legend-bar\"></div>\n        <span class=\"heat-legend-label\">now</span>\n      </div>\n    </div>\n\n    <div class=\"constellation-section\">\n      <div class=\"legend-title\">Constellations</div>\n      <button class=\"save-constellation-btn\" onclick=\"showSaveConstellationDialog()\">\n        Save Current View\n      </button>\n      <div class=\"constellation-name\" id=\"constellation-name\"></div>\n    </div>\n\n    <div class=\"shortcuts-hint\">\n      <kbd>/</kbd> Search &nbsp; <kbd>Esc</kbd> Close<br>\n      <kbd>Alt+&#8592;</kbd> Back &nbsp; <kbd>Alt+&#8594;</kbd> Forward\n    </div>\n  </div>\n\n  <div id=\"graph\"></div>\n\n  <div id=\"sidebar\" class=\"panel\">\n    <div class=\"node-header\">\n      <h2 class=\"node-title\" id=\"sb-title\"></h2>\n      <span class=\"node-badge\" id=\"sb-type\"></span>\n    </div>\n    <div id=\"sb-content\" class=\"meta-grid\"></div>\n    <div id=\"sb-connections\" class=\"connections-section\"></div>\n  </div>\n\n  <div id=\"path-panel\" class=\"panel\">\n    <div class=\"path-header\">\n      <span class=\"path-title\" id=\"path-title\">Paths</span>\n      <button class=\"path-close-btn\" onclick=\"closePathPanel()\">&times;</button>\n    </div>\n    <div class=\"path-selector\" id=\"path-selector\"></div>\n    <label class=\"path-show-all\">\n      <input type=\"checkbox\" id=\"path-show-all\" onchange=\"toggleShowAllPaths()\">\n      <span>Show all paths</span>\n    </label>\n  </div>\n\n  <!-- Backlog Panel -->\n  <div id=\"backlog-panel\" class=\"panel backlog-panel\">\n    <div class=\"backlog-header\" onclick=\"toggleBacklog()\">\n      <span class=\"backlog-toggle\">&#9660;</span>\n      <span class=\"legend-title\">Unresolved (<span id=\"backlog-count\">0</span>)</span>\n      <select id=\"backlog-sort\" class=\"backlog-sort\" onclick=\"event.stopPropagation()\" onchange=\"setBacklogSort(this.value)\">\n        <option value=\"importance\">Importance</option>\n        <option value=\"refs\">Most referenced</option>\n        <option value=\"recent\">Most recent</option>\n        <option value=\"alpha\">Alphabetical</option>\n      </select>\n    </div>\n    <div class=\"backlog-content\">\n      <div class=\"backlog-search\">\n        <input type=\"text\" placeholder=\"Filter...\" oninput=\"filterBacklog(this.value)\">\n      </div>\n      <div id=\"backlog-list\" class=\"backlog-list\"></div>\n    </div>\n  </div>\n\n  <!-- Create Panel Modal -->\n  <div id=\"create-panel\" class=\"create-panel\">\n    <div class=\"create-panel-inner panel\">\n      <div class=\"create-panel-header\">\n        <span class=\"legend-title\">Create Note</span>\n        <button class=\"path-close-btn\" onclick=\"hideCreatePanel()\">&times;</button>\n      </div>\n      <div class=\"create-panel-body\">\n        <label class=\"create-field\">\n          <span>Title</span>\n          <input type=\"text\" id=\"create-title\" placeholder=\"Note title\">\n        </label>\n        <label class=\"create-field\">\n          <span>Folder</span>\n          <select id=\"create-folder\"></select>\n        </label>\n      </div>\n      <div class=\"create-panel-footer\">\n        <button class=\"create-cancel-btn\" onclick=\"hideCreatePanel()\">Cancel</button>\n        <button class=\"create-submit-btn\" onclick=\"submitCreate()\">Create</button>\n      </div>\n    </div>\n  </div>\n\n  <!-- Upgrade Banner (first-run) -->\n  <div id=\"upgrade-banner\">\n    <h3>New: Focus-first view</h3>\n    <p>Suggestion edges (mentions, pending wormholes) are now hidden by default for a cleaner graph. Toggle <strong>Classic mode</strong> in the Status panel to see all edges.</p>\n    <div class=\"banner-actions\">\n      <button class=\"banner-btn banner-btn-secondary\" onclick=\"dismissUpgradeBanner()\">Got it</button>\n      <button class=\"banner-btn banner-btn-primary\" onclick=\"switchToClassicFromBanner()\">Switch to Classic</button>\n    </div>\n  </div>\n\n  <!-- Health Status Panel -->\n  <div id=\"status-panel\" class=\"panel\">\n    <div class=\"panel-header\" onclick=\"toggleStatusPanel()\">\n      <span id=\"status-header-text\">Status</span>\n      <span id=\"status-toggle-icon\"></span>\n    </div>\n    <div class=\"panel-content\">\n      <div class=\"status-row\">\n        <span class=\"status-label\">Mode</span>\n        <span id=\"status-mode\" class=\"status-value\"></span>\n      </div>\n      <div class=\"status-row\">\n        <span class=\"status-label\">Nodes</span>\n        <span id=\"status-nodes\" class=\"status-value\"></span>\n      </div>\n      <div class=\"status-row\">\n        <span class=\"status-label\">Edges</span>\n        <span id=\"status-edges\" class=\"status-value\"></span>\n      </div>\n      <div class=\"status-row\">\n        <span class=\"status-label\">Embeddings</span>\n        <span id=\"status-embeddings\" class=\"status-value\"></span>\n      </div>\n      <div class=\"status-row\">\n        <span class=\"status-label\">Wormholes</span>\n        <span id=\"status-wormholes\" class=\"status-value\"></span>\n      </div>\n      <div class=\"mode-toggle\">\n        <button id=\"mode-focus-btn\" class=\"mode-btn\" onclick=\"setVisualizationMode('focus')\">Focus</button>\n        <button id=\"mode-classic-btn\" class=\"mode-btn\" onclick=\"setVisualizationMode('classic')\">Classic</button>\n      </div>\n      <span class=\"help-link\">Run <code>zs doctor</code> for details</span>\n    </div>\n  </div>\n\n  <!-- WebSocket Status Indicator -->\n  <div id=\"ws-status\" class=\"ws-status disconnected\" title=\"Disconnected\"></div>\n\n  <!-- Suggestions Panel -->\n  <div id=\"suggestions-panel\" class=\"panel\" style=\"display: none;\">\n    <div class=\"suggestions-header\" onclick=\"toggleSuggestionsPanel()\">\n      <h3>Suggestions</h3>\n      <span class=\"suggestions-toggle\" id=\"suggestions-toggle-icon\"></span>\n    </div>\n\n    <!-- Related Notes Section -->\n    <div class=\"suggestion-section\" id=\"related-section\">\n      <div class=\"suggestion-section-header\" onclick=\"toggleSuggestionSection('related')\">\n        <span class=\"suggestion-section-title\">\n          Related Notes <span class=\"suggestion-count\" id=\"related-count\">0</span>\n        </span>\n        <span class=\"suggestion-section-toggle\"></span>\n      </div>\n      <div class=\"suggestion-list\" id=\"related-list\"></div>\n    </div>\n\n    <!-- Candidate Links Section -->\n    <div class=\"suggestion-section\" id=\"links-section\">\n      <div class=\"suggestion-section-header\" onclick=\"toggleSuggestionSection('links')\">\n        <span class=\"suggestion-section-title\">\n          Candidate Links <span class=\"suggestion-count\" id=\"links-count\">0</span>\n        </span>\n        <span class=\"suggestion-section-toggle\"></span>\n      </div>\n      <div style=\"display: flex; justify-content: flex-end; margin-top: 4px;\">\n        <button class=\"batch-copy-btn\" id=\"batch-copy-btn\" onclick=\"batchCopyApproveCommands(event)\">\n          Copy All\n        </button>\n      </div>\n      <div class=\"suggestion-list\" id=\"links-list\"></div>\n    </div>\n\n    <!-- Orphans Section -->\n    <div class=\"suggestion-section\" id=\"orphans-section\">\n      <div class=\"suggestion-section-header\" onclick=\"toggleSuggestionSection('orphans')\">\n        <span class=\"suggestion-section-title\">\n          Orphans <span class=\"suggestion-count\" id=\"orphans-count\">0</span>\n        </span>\n        <span class=\"suggestion-section-toggle\"></span>\n      </div>\n      <div class=\"suggestion-list\" id=\"orphans-list\"></div>\n    </div>\n  </div>\n\n  <script>\n    const data = ${JSON.stringify(graphData)};\n    const typeColors = ${JSON.stringify(nodeTypeColors)};\n    const edgeStyles = ${JSON.stringify(edgeStyles)};\n    const loadedConstellation = ${constellationState};\n    const pathData = ${pathDataJson};\n    const wsConfig = ${wsConfigJson};\n    const statusData = ${statusDataJson};\n    const focusBundle = ${focusBundleJson};\n\n    // Status panel state\n    let statusPanelExpanded = false;\n\n    function toggleStatusPanel() {\n      const panel = document.getElementById('status-panel');\n      const icon = document.getElementById('status-toggle-icon');\n      statusPanelExpanded = !statusPanelExpanded;\n      panel.classList.toggle('expanded', statusPanelExpanded);\n      icon.textContent = statusPanelExpanded ? '' : '';\n    }\n\n    function updateStatusPanel() {\n      if (!statusData) {\n        document.getElementById('status-panel').style.display = 'none';\n        return;\n      }\n\n      // Mode\n      document.getElementById('status-mode').textContent = statusData.visualization.mode;\n\n      // Nodes/Edges\n      document.getElementById('status-nodes').textContent = statusData.index.nodeCount;\n      const { A, B, C } = statusData.index.edgesByLayer;\n      const hiddenCount = statusData.visualization.totalEdgeCount - statusData.visualization.filteredEdgeCount;\n      document.getElementById('status-edges').innerHTML =\n        statusData.visualization.mode === 'focus' && hiddenCount > 0\n          ? \\`\\${statusData.visualization.filteredEdgeCount} <span style=\"color:var(--text-muted)\">(\\${hiddenCount} hidden)</span>\\`\n          : statusData.index.edgeCount;\n\n      // Embeddings\n      const embEl = document.getElementById('status-embeddings');\n      const embLevel = statusData.embeddings.level;\n      const embPct = statusData.embeddings.coverage.toFixed(0);\n      const badgeClass = embLevel === 'ok' ? 'badge-ok' : embLevel === 'warn' ? 'badge-warn' : 'badge-fail';\n      embEl.innerHTML = \\`<span class=\"status-badge \\${badgeClass}\">\\${embLevel.toUpperCase()} \\${embPct}%</span>\\`;\n\n      // Wormholes\n      const whEl = document.getElementById('status-wormholes');\n      if (statusData.wormholes.enabled) {\n        whEl.innerHTML = \\`<span style=\"color:#34d399\">\\${statusData.wormholes.count} edges</span>\\`;\n      } else {\n        whEl.innerHTML = \\`<span style=\"color:#fbbf24\">disabled</span>\\`;\n      }\n\n      // Mode buttons\n      document.getElementById('mode-focus-btn').classList.toggle('active', statusData.visualization.mode === 'focus');\n      document.getElementById('mode-classic-btn').classList.toggle('active', statusData.visualization.mode === 'classic');\n\n      // Header badge\n      const headerText = document.getElementById('status-header-text');\n      if (embLevel === 'fail') {\n        headerText.innerHTML = 'Status <span class=\"status-badge badge-fail\">!</span>';\n      } else if (embLevel === 'warn') {\n        headerText.innerHTML = 'Status <span class=\"status-badge badge-warn\">!</span>';\n      } else {\n        headerText.textContent = 'Status';\n      }\n    }\n\n    function setVisualizationMode(mode) {\n      // Note: This just updates UI state. The actual mode switch requires\n      // re-running the visualize command with different config.\n      // Show a toast indicating how to switch modes\n      showToast(\\`To switch to \\${mode} mode, update config: visualization.mode: \"\\${mode}\"\\`, 'info', 5000);\n    }\n\n    // Initialize status panel on load\n    setTimeout(updateStatusPanel, 100);\n\n    // Upgrade banner logic\n    const UPGRADE_BANNER_KEY = 'zs-upgrade-banner-dismissed';\n    const CURRENT_VERSION = statusData ? statusData.version : '0.4.1';\n\n    function shouldShowUpgradeBanner() {\n      if (!statusData) return false;\n      if (statusData.visualization.mode !== 'focus') return false;\n\n      const dismissed = localStorage.getItem(UPGRADE_BANNER_KEY);\n      if (!dismissed) return true;\n\n      // Check if dismissed for older version\n      try {\n        const { version } = JSON.parse(dismissed);\n        // Simple version comparison - show if current is newer\n        return version !== CURRENT_VERSION;\n      } catch {\n        return true;\n      }\n    }\n\n    function dismissUpgradeBanner() {\n      localStorage.setItem(UPGRADE_BANNER_KEY, JSON.stringify({\n        version: CURRENT_VERSION,\n        dismissedAt: new Date().toISOString()\n      }));\n      document.getElementById('upgrade-banner').classList.remove('show');\n    }\n\n    function switchToClassicFromBanner() {\n      dismissUpgradeBanner();\n      showToast('To switch to Classic mode: edit .zettelscript/config.yaml  visualization.mode: \"classic\"', 'info', 6000);\n    }\n\n    // Show upgrade banner if conditions met\n    setTimeout(() => {\n      if (shouldShowUpgradeBanner()) {\n        document.getElementById('upgrade-banner').classList.add('show');\n      }\n    }, 500);\n\n    // Pre-compute adjacency index for O(1) lookups\n    const adjacency = {};\n    const nodeMap = {};\n    const ghostIdMap = {}; // Track ghost -> new node ID mappings\n    data.nodes.forEach(n => {\n      nodeMap[n.id] = n;\n      adjacency[n.id] = { outgoing: [], incoming: [] };\n    });\n    data.links.forEach(link => {\n      const srcId = typeof link.source === 'object' ? link.source.id : link.source;\n      const tgtId = typeof link.target === 'object' ? link.target.id : link.target;\n      if (adjacency[srcId]) adjacency[srcId].outgoing.push({ nodeId: tgtId, type: link.type, link });\n      if (adjacency[tgtId]) adjacency[tgtId].incoming.push({ nodeId: srcId, type: link.type, link });\n    });\n\n    // State\n    const hiddenTypes = new Set();\n    const hiddenEdgeTypes = new Set();\n    const highlightNodes = new Set();\n    const highlightLinks = new Set();\n    let hoverNode = null;\n    let selectedNode = null;\n    let showGhosts = true;\n    let ghostThreshold = 1;\n\n    // Navigation history\n    const navHistory = [];\n    let navIndex = -1;\n\n    // WebSocket state\n    let ws = null;\n    let wsSessionNonce = null;\n    let wsConnected = false;\n    let wsReconnectAttempts = 0;\n    const wsMaxReconnectAttempts = 10;\n    let wsPatchSeq = 0;\n    const pendingCreates = new Set();\n\n    // ========================================================================\n    // Heat Vision State & Functions\n    // ========================================================================\n\n    const MS_PER_DAY = 86400000;\n    const HEAT_STORAGE_KEYS = {\n      enabled: 'zs-heat-enabled',\n      autoMode: 'zs-heat-auto',\n      manualWindow: 'zs-heat-window',\n    };\n\n    let heatEnabled = false;\n    let heatAutoMode = true;\n    let heatManualWindowDays = 30;\n    let computedWindowDays = 30;\n\n    function loadHeatSettings() {\n      heatEnabled = localStorage.getItem(HEAT_STORAGE_KEYS.enabled) === 'true';\n      heatAutoMode = localStorage.getItem(HEAT_STORAGE_KEYS.autoMode) !== 'false';\n\n      const parsed = parseInt(localStorage.getItem(HEAT_STORAGE_KEYS.manualWindow) || '', 10);\n      heatManualWindowDays = (Number.isNaN(parsed) || parsed < 7 || parsed > 180) ? 30 : parsed;\n    }\n\n    function saveHeatSettings() {\n      localStorage.setItem(HEAT_STORAGE_KEYS.enabled, String(heatEnabled));\n      localStorage.setItem(HEAT_STORAGE_KEYS.autoMode, String(heatAutoMode));\n      localStorage.setItem(HEAT_STORAGE_KEYS.manualWindow, String(heatManualWindowDays));\n    }\n\n    function getEffectiveWindow() {\n      return heatAutoMode ? computedWindowDays : heatManualWindowDays;\n    }\n\n    function computeAutoWindow(nodes) {\n      const now = Date.now();\n      const ages = nodes\n        .filter(n => n.updatedAtMs && !n.isGhost)\n        .map(n => Math.max(0, (now - n.updatedAtMs) / MS_PER_DAY))\n        .sort((a, b) => a - b);\n\n      if (ages.length < 10) return 30;\n\n      const idx = Math.floor((ages.length - 1) * 0.85);\n      const p85Value = ages[idx];\n\n      return Math.round(Math.min(Math.max(p85Value, 7), 180));\n    }\n\n    function computeHeat(nodes, windowDays) {\n      const now = Date.now();\n\n      for (const node of nodes) {\n        if (!node.updatedAtMs || node.isGhost) {\n          node.heat = 0;\n          continue;\n        }\n        const ageDays = Math.max(0, (now - node.updatedAtMs) / MS_PER_DAY);\n        node.heat = 1 - Math.min(Math.max(ageDays / windowDays, 0), 1);\n      }\n    }\n\n    function recomputeHeatAndRedraw() {\n      if (heatEnabled) {\n        computeHeat(data.nodes, getEffectiveWindow());\n      }\n      if (Graph) Graph.refresh();\n    }\n\n    function initHeatVision() {\n      loadHeatSettings();\n\n      // Compute auto window on load (for UI display), even if heat is disabled\n      if (heatAutoMode) {\n        computedWindowDays = computeAutoWindow(data.nodes);\n      }\n\n      // Only compute heat values if enabled\n      if (heatEnabled) {\n        computeHeat(data.nodes, getEffectiveWindow());\n      }\n\n      updateHeatUI();\n    }\n\n    function toggleHeat() {\n      heatEnabled = document.getElementById('heat-toggle').checked;\n      saveHeatSettings();\n\n      if (heatEnabled && !data.nodes.some(n => n.heat !== undefined && n.heat > 0)) {\n        computeHeat(data.nodes, getEffectiveWindow());\n      }\n\n      updateHeatUI();\n      recomputeHeatAndRedraw();\n    }\n\n    function updateHeatWindow(val) {\n      heatManualWindowDays = parseInt(val, 10);\n      document.getElementById('heat-window-val').innerText = val + ' days';\n      saveHeatSettings();\n      recomputeHeatAndRedraw();\n    }\n\n    function toggleHeatAuto() {\n      heatAutoMode = document.getElementById('heat-auto').checked;\n\n      if (heatAutoMode) {\n        computedWindowDays = computeAutoWindow(data.nodes);\n        document.getElementById('heat-window-slider').value = computedWindowDays;\n        document.getElementById('heat-window-val').innerText = computedWindowDays + ' days';\n      } else {\n        document.getElementById('heat-window-slider').value = heatManualWindowDays;\n        document.getElementById('heat-window-val').innerText = heatManualWindowDays + ' days';\n      }\n\n      saveHeatSettings();\n      updateHeatUI();\n      recomputeHeatAndRedraw();\n    }\n\n    function updateHeatUI() {\n      const toggle = document.getElementById('heat-toggle');\n      const slider = document.getElementById('heat-window-slider');\n      const autoCheckbox = document.getElementById('heat-auto');\n      const autoLabel = document.getElementById('heat-auto-label');\n      const sliderVal = document.getElementById('heat-window-val');\n\n      if (toggle) toggle.checked = heatEnabled;\n      if (autoCheckbox) autoCheckbox.checked = heatAutoMode;\n\n      const effectiveWindow = getEffectiveWindow();\n      if (slider) {\n        slider.disabled = !heatEnabled || heatAutoMode;\n        slider.value = effectiveWindow;\n      }\n      if (sliderVal) {\n        sliderVal.innerText = effectiveWindow + ' days';\n      }\n      if (autoCheckbox) {\n        autoCheckbox.disabled = !heatEnabled;\n      }\n      if (autoLabel) {\n        autoLabel.style.opacity = heatEnabled ? '1' : '0.5';\n      }\n\n      // Update legend\n      updateHeatLegend();\n    }\n\n    function updateHeatLegend() {\n      const legend = document.getElementById('heat-legend');\n      if (!legend) return;\n\n      if (!heatEnabled) {\n        legend.style.display = 'none';\n        return;\n      }\n\n      legend.style.display = 'flex';\n      const windowLabel = document.getElementById('heat-legend-cold');\n      if (windowLabel) {\n        windowLabel.innerText = '>= ' + getEffectiveWindow() + 'd';\n      }\n    }\n\n    // Ghost node functions\n    function toggleGhosts() {\n      showGhosts = document.getElementById('show-ghosts').checked;\n      updateGhostCount();\n      updateGraphVisibility();\n    }\n\n    function updateGhostThreshold(val) {\n      ghostThreshold = parseInt(val, 10);\n      document.getElementById('threshold-val').innerText = val;\n      updateGhostCount();\n      updateGraphVisibility();\n    }\n\n    function updateGhostCount() {\n      const ghostNodes = data.nodes.filter(n => n.isGhost);\n      const visibleGhosts = ghostNodes.filter(n => showGhosts && (n.referenceCount || 1) >= ghostThreshold);\n      const countEl = document.getElementById('ghost-count');\n      if (ghostNodes.length === 0) {\n        document.getElementById('ghost-controls').style.display = 'none';\n      } else {\n        countEl.innerText = \\`Showing \\${visibleGhosts.length} of \\${ghostNodes.length} ghost nodes\\`;\n      }\n    }\n\n    function isGhostVisible(node) {\n      if (!node.isGhost) return true;\n      return showGhosts && (node.referenceCount || 1) >= ghostThreshold;\n    }\n\n    // Path highlighting state\n    let selectedPathIndex = 0;\n    let showAllPaths = false;\n    const pathNodes = new Set();\n    const pathLinks = new Set();\n    const pathNodeOrder = new Map(); // nodeId -> order number in selected path\n\n    // Path highlighting functions\n    function initPathPanel() {\n      if (!pathData || !pathData.paths || pathData.paths.length === 0) return;\n\n      const panel = document.getElementById('path-panel');\n      const title = document.getElementById('path-title');\n      const selector = document.getElementById('path-selector');\n\n      panel.classList.add('active');\n      title.innerText = \\`\\${pathData.fromLabel}  \\${pathData.toLabel}\\`;\n\n      // Build path options\n      let html = '';\n      pathData.paths.forEach((p, i) => {\n        const route = p.path.map(id => {\n          const node = nodeMap[id];\n          return node ? node.name : id.slice(0, 8);\n        });\n        const shortRoute = route.length > 4\n          ? route[0] + '  ...  ' + route[route.length - 1]\n          : route.join('  ');\n\n        html += \\`\n          <div class=\"path-option \\${i === 0 ? 'selected' : ''}\" onclick=\"selectPath(\\${i})\" data-index=\"\\${i}\">\n            <div class=\"path-option-num\">\\${i + 1}</div>\n            <div class=\"path-option-info\">\n              <div class=\"path-option-route\">\\${shortRoute}</div>\n              <div class=\"path-option-meta\">\\${p.hopCount} hops  score \\${p.score.toFixed(1)}</div>\n            </div>\n          </div>\\`;\n      });\n      selector.innerHTML = html;\n\n      // Select first path\n      selectPath(0);\n    }\n\n    function selectPath(index) {\n      selectedPathIndex = index;\n\n      // Update UI\n      document.querySelectorAll('.path-option').forEach((el, i) => {\n        el.classList.toggle('selected', i === index);\n      });\n\n      updatePathHighlight();\n    }\n\n    function toggleShowAllPaths() {\n      showAllPaths = document.getElementById('path-show-all').checked;\n      updatePathHighlight();\n    }\n\n    function closePathPanel() {\n      const panel = document.getElementById('path-panel');\n      panel.classList.remove('active');\n      pathNodes.clear();\n      pathLinks.clear();\n      pathNodeOrder.clear();\n      updateGraphVisibility();\n    }\n\n    function updatePathHighlight() {\n      pathNodes.clear();\n      pathLinks.clear();\n      pathNodeOrder.clear();\n\n      if (!pathData || !pathData.paths || pathData.paths.length === 0) return;\n\n      if (showAllPaths) {\n        // Highlight all paths\n        pathData.paths.forEach((p, pathIdx) => {\n          p.path.forEach((nodeId, nodeIdx) => {\n            pathNodes.add(nodeId);\n            if (pathIdx === selectedPathIndex) {\n              pathNodeOrder.set(nodeId, nodeIdx + 1);\n            }\n          });\n          // Add edges\n          for (let i = 0; i < p.path.length - 1; i++) {\n            pathLinks.add(\\`\\${p.path[i]}->\\${p.path[i+1]}\\`);\n          }\n        });\n      } else {\n        // Highlight only selected path\n        const p = pathData.paths[selectedPathIndex];\n        if (p) {\n          p.path.forEach((nodeId, nodeIdx) => {\n            pathNodes.add(nodeId);\n            pathNodeOrder.set(nodeId, nodeIdx + 1);\n          });\n          for (let i = 0; i < p.path.length - 1; i++) {\n            pathLinks.add(\\`\\${p.path[i]}->\\${p.path[i+1]}\\`);\n          }\n        }\n      }\n\n      // Pin path nodes to prevent layout wiggle\n      data.nodes.forEach(n => {\n        if (pathNodes.has(n.id)) {\n          n.fx = n.x;\n          n.fy = n.y;\n        } else {\n          n.fx = undefined;\n          n.fy = undefined;\n        }\n      });\n\n      updateGraphVisibility();\n    }\n\n    function isOnPath(nodeId) {\n      return pathNodes.has(nodeId);\n    }\n\n    function isPathEdge(srcId, tgtId) {\n      return pathLinks.has(\\`\\${srcId}->\\${tgtId}\\`) || pathLinks.has(\\`\\${tgtId}->\\${srcId}\\`);\n    }\n\n    // Navigation functions\n    function navigateToNode(nodeId, addToHistory = true) {\n      const node = nodeMap[nodeId];\n      if (!node) return;\n\n      // Unhide type if hidden\n      if (hiddenTypes.has(node.type)) {\n        hiddenTypes.delete(node.type);\n        updateLegendUI();\n      }\n\n      // Update history\n      if (addToHistory) {\n        // Remove any forward history\n        navHistory.splice(navIndex + 1);\n        navHistory.push(nodeId);\n        navIndex = navHistory.length - 1;\n      }\n\n      selectedNode = node;\n      showSidebar(node);\n      updateBreadcrumbs();\n\n      // Center and zoom\n      Graph.centerAt(node.x, node.y, 1000);\n      Graph.zoom(6, 2000);\n\n      // Highlight\n      highlightNodes.clear();\n      highlightLinks.clear();\n      highlightNodes.add(node);\n      data.links.forEach(link => {\n        const srcId = typeof link.source === 'object' ? link.source.id : link.source;\n        const tgtId = typeof link.target === 'object' ? link.target.id : link.target;\n        if (srcId === node.id || tgtId === node.id) {\n          highlightLinks.add(link);\n          highlightNodes.add(nodeMap[srcId]);\n          highlightNodes.add(nodeMap[tgtId]);\n        }\n      });\n      hoverNode = node;\n      updateGraphVisibility();\n    }\n\n    function goBack() {\n      if (navIndex > 0) {\n        navIndex--;\n        navigateToNode(navHistory[navIndex], false);\n      }\n    }\n\n    function goForward() {\n      if (navIndex < navHistory.length - 1) {\n        navIndex++;\n        navigateToNode(navHistory[navIndex], false);\n      }\n    }\n\n    function updateBreadcrumbs() {\n      const panel = document.getElementById('breadcrumbs');\n      const trail = document.getElementById('breadcrumb-trail');\n      const btnBack = document.getElementById('btn-back');\n      const btnForward = document.getElementById('btn-forward');\n\n      if (navHistory.length === 0) {\n        panel.classList.remove('active');\n        return;\n      }\n\n      panel.classList.add('active');\n      btnBack.disabled = navIndex <= 0;\n      btnForward.disabled = navIndex >= navHistory.length - 1;\n\n      // Show last 5 items max\n      const startIdx = Math.max(0, navHistory.length - 5);\n      const visibleHistory = navHistory.slice(startIdx);\n      const offset = startIdx;\n\n      trail.innerHTML = visibleHistory.map((nodeId, i) => {\n        const node = nodeMap[nodeId];\n        const actualIndex = i + offset;\n        const isCurrent = actualIndex === navIndex;\n        const name = node ? node.name : nodeId;\n        return \\`<span class=\"breadcrumb-item \\${isCurrent ? 'current' : ''}\" onclick=\"jumpToBreadcrumb(\\${actualIndex})\">\\${name}</span>\\` +\n          (i < visibleHistory.length - 1 ? '<span class=\"breadcrumb-sep\">/</span>' : '');\n      }).join('');\n    }\n\n    function jumpToBreadcrumb(index) {\n      if (index >= 0 && index < navHistory.length) {\n        navIndex = index;\n        navigateToNode(navHistory[index], false);\n      }\n    }\n\n    // Node type filter\n    function toggleType(type) {\n      if (hiddenTypes.has(type)) {\n        hiddenTypes.delete(type);\n      } else {\n        hiddenTypes.add(type);\n      }\n      updateGraphVisibility();\n      updateLegendUI();\n    }\n\n    // Edge type filter\n    function toggleEdgeType(type) {\n      if (hiddenEdgeTypes.has(type)) {\n        hiddenEdgeTypes.delete(type);\n      } else {\n        hiddenEdgeTypes.add(type);\n      }\n      updateGraphVisibility();\n      updateEdgeLegendUI();\n    }\n\n    function updateLegendUI() {\n      const legend = document.getElementById('legend');\n      legend.innerHTML = '';\n      Object.entries(typeColors).forEach(([type, color]) => {\n        // Skip ghost type - it has its own controls\n        if (type === 'ghost') return;\n        const item = document.createElement('div');\n        item.className = \\`legend-item \\${hiddenTypes.has(type) ? 'hidden' : ''}\\`;\n        item.onclick = () => toggleType(type);\n        item.innerHTML = \\`<div class=\"legend-dot\" style=\"background: \\${color}; color: \\${color}\"></div>\\${type.charAt(0).toUpperCase() + type.slice(1)}\\`;\n        legend.appendChild(item);\n      });\n    }\n\n    function updateEdgeLegendUI() {\n      const legend = document.getElementById('edge-legend');\n      legend.innerHTML = '';\n      Object.entries(edgeStyles).forEach(([type, style]) => {\n        // Skip ghost_ref - it's controlled by ghost toggle\n        if (type === 'ghost_ref') return;\n        const item = document.createElement('div');\n        item.className = \\`edge-legend-item \\${hiddenEdgeTypes.has(type) ? 'hidden' : ''}\\`;\n        item.onclick = () => toggleEdgeType(type);\n        const dashStyle = style.dash.length > 0\n          ? \\`background: repeating-linear-gradient(90deg, \\${style.color} 0px, \\${style.color} \\${style.dash[0]}px, transparent \\${style.dash[0]}px, transparent \\${style.dash[0] + style.dash[1]}px)\\`\n          : \\`background: \\${style.color}\\`;\n        item.innerHTML = \\`<div class=\"edge-line\" style=\"\\${dashStyle}\"></div>\\${style.label}\\`;\n        legend.appendChild(item);\n      });\n    }\n\n    // Initial Legend\n    updateLegendUI();\n    updateEdgeLegendUI();\n    updateGhostCount();\n\n    // Apply loaded constellation state\n    function applyConstellationState() {\n      if (!loadedConstellation) return;\n\n      // Apply hidden node types\n      if (loadedConstellation.hiddenNodeTypes) {\n        loadedConstellation.hiddenNodeTypes.forEach(t => hiddenTypes.add(t));\n      }\n\n      // Apply hidden edge types\n      if (loadedConstellation.hiddenEdgeTypes) {\n        loadedConstellation.hiddenEdgeTypes.forEach(t => hiddenEdgeTypes.add(t));\n      }\n\n      // Apply ghost settings\n      showGhosts = loadedConstellation.showGhosts !== false;\n      ghostThreshold = loadedConstellation.ghostThreshold || 1;\n      document.getElementById('show-ghosts').checked = showGhosts;\n      document.getElementById('ghost-threshold').value = ghostThreshold;\n      document.getElementById('threshold-val').innerText = ghostThreshold;\n\n      // Update UI\n      updateLegendUI();\n      updateEdgeLegendUI();\n      updateGhostCount();\n\n      // Show constellation name\n      const nameEl = document.getElementById('constellation-name');\n      nameEl.innerHTML = \\`Viewing: <strong>\\${loadedConstellation.name}</strong>\\`;\n    }\n\n    // Apply constellation state before graph init\n    applyConstellationState();\n\n    // Save constellation dialog\n    function showSaveConstellationDialog() {\n      const name = prompt('Enter constellation name:');\n      if (!name || !name.trim()) return;\n\n      const state = {\n        hiddenNodeTypes: Array.from(hiddenTypes),\n        hiddenEdgeTypes: Array.from(hiddenEdgeTypes),\n        showGhosts,\n        ghostThreshold,\n        cameraX: Graph ? Graph.centerAt().x : null,\n        cameraY: Graph ? Graph.centerAt().y : null,\n        cameraZoom: Graph ? Graph.zoom() : null,\n      };\n\n      const stateJson = JSON.stringify(state);\n      const cmd = \\`zs constellation save \"\\${name.trim()}\" --state '\\${stateJson}'\\`;\n\n      // Try to copy to clipboard\n      navigator.clipboard.writeText(cmd).then(() => {\n        alert(\\`Run this command to save the constellation:\\\\n\\\\n\\${cmd}\\\\n\\\\n(Copied to clipboard)\\`);\n      }).catch(() => {\n        alert(\\`Run this command to save the constellation:\\\\n\\\\n\\${cmd}\\`);\n      });\n    }\n\n    // ========================================================================\n    // WebSocket Client for Live Updates\n    // ========================================================================\n\n    function initWebSocket() {\n      if (!wsConfig || !wsConfig.enabled) return;\n\n      const url = \\`ws://127.0.0.1:\\${wsConfig.port}\\`;\n      console.log('[WS] Connecting to', url);\n\n      ws = new WebSocket(url);\n\n      ws.onopen = () => {\n        console.log('[WS] Connected, sending hello');\n        ws.send(JSON.stringify({\n          type: 'hello',\n          protocolVersion: wsConfig.protocolVersion,\n          atlasVersion: '2.0.0',\n          token: wsConfig.token,\n        }));\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const msg = JSON.parse(event.data);\n          handleWsMessage(msg);\n        } catch (e) {\n          console.error('[WS] Failed to parse message:', e);\n        }\n      };\n\n      ws.onclose = (event) => {\n        console.log('[WS] Disconnected:', event.code, event.reason);\n        wsConnected = false;\n        wsSessionNonce = null;\n        updateConnectionStatus('disconnected');\n\n        // Attempt reconnect with exponential backoff\n        if (wsReconnectAttempts < wsMaxReconnectAttempts) {\n          const delay = Math.min(1000 * Math.pow(2, wsReconnectAttempts), 30000);\n          wsReconnectAttempts++;\n          console.log(\\`[WS] Reconnecting in \\${delay}ms (attempt \\${wsReconnectAttempts})\\`);\n          setTimeout(initWebSocket, delay);\n        }\n      };\n\n      ws.onerror = (error) => {\n        console.error('[WS] Error:', error);\n      };\n    }\n\n    function handleWsMessage(msg) {\n      switch (msg.type) {\n        case 'hello_ok':\n          wsConnected = true;\n          wsSessionNonce = msg.sessionNonce;\n          wsReconnectAttempts = 0;\n          console.log('[WS] Authenticated, features:', msg.features);\n          updateConnectionStatus('connected');\n          break;\n\n        case 'hello_error':\n          console.error('[WS] Auth failed:', msg.error);\n          updateConnectionStatus('error');\n          break;\n\n        case 'create_ack':\n          handleCreateAck(msg);\n          break;\n\n        case 'patch':\n          handlePatch(msg);\n          break;\n\n        case 'error':\n          handleWsError(msg);\n          break;\n\n        case 'sync_response':\n          handleSyncResponse(msg);\n          break;\n\n        case 'pong':\n          // Heartbeat response\n          break;\n\n        default:\n          console.log('[WS] Unknown message type:', msg.type);\n      }\n    }\n\n    function handleCreateAck(msg) {\n      if (msg.status === 'pending') {\n        console.log('[WS] Create pending for ghost:', msg.ghostId);\n      } else if (msg.status === 'success') {\n        console.log('[WS] Create succeeded for ghost:', msg.ghostId);\n        pendingCreates.delete(msg.ghostId);\n        hideCreatePanel();\n      } else if (msg.status === 'error') {\n        console.error('[WS] Create failed for ghost:', msg.ghostId);\n        pendingCreates.delete(msg.ghostId);\n        revertGhostState(msg.ghostId);\n      }\n      updateBacklogRow(msg.ghostId);\n    }\n\n    function handlePatch(msg) {\n      // Ignore out-of-order patches\n      if (msg.patchSeq <= wsPatchSeq) {\n        console.log('[WS] Ignoring out-of-order patch:', msg.patchSeq, 'current:', wsPatchSeq);\n        return;\n      }\n      wsPatchSeq = msg.patchSeq;\n\n      console.log('[WS] Applying patch:', msg.patchSeq, 'ops:', msg.ops.length);\n\n      for (const op of msg.ops) {\n        switch (op.op) {\n          case 'node_replace':\n            applyNodeReplace(op);\n            break;\n          case 'edge_replace':\n            applyEdgeReplace(op);\n            break;\n          case 'node_remove':\n            applyNodeRemove(op);\n            break;\n          case 'edge_remove':\n            applyEdgeRemove(op);\n            break;\n        }\n      }\n\n      // Refresh the graph visualization\n      updateGraphVisibility();\n      updateBacklog();\n    }\n\n    function applyNodeReplace(op) {\n      const ghostNode = nodeMap[op.ghostId];\n      if (!ghostNode) {\n        console.warn('[WS] Ghost node not found:', op.ghostId);\n        return;\n      }\n\n      // Store mapping\n      ghostIdMap[op.ghostId] = op.newNodeId;\n\n      // Preserve position\n      const x = ghostNode.x;\n      const y = ghostNode.y;\n      const vx = ghostNode.vx || 0;\n      const vy = ghostNode.vy || 0;\n\n      // Update node in place\n      ghostNode.id = op.newNodeId;\n      ghostNode.name = op.label;\n      ghostNode.path = op.filePath;\n      ghostNode.type = op.type;\n      ghostNode.color = typeColors[op.type] || '#94a3b8';\n      ghostNode.isGhost = false;\n      ghostNode.isPending = false;\n      delete ghostNode.sourceIds;\n      delete ghostNode.referenceCount;\n      delete ghostNode.mostRecentRef;\n\n      // Set updatedAtMs for heat vision (newly created nodes are \"hot\")\n      ghostNode.updatedAtMs = op.updatedAt ? new Date(op.updatedAt).getTime() : Date.now();\n\n      // Compute heat for this node if heat vision is enabled\n      if (heatEnabled) {\n        const ageDays = Math.max(0, (Date.now() - ghostNode.updatedAtMs) / MS_PER_DAY);\n        const windowDays = getEffectiveWindow();\n        ghostNode.heat = 1 - Math.min(Math.max(ageDays / windowDays, 0), 1);\n      }\n\n      // Preserve position\n      ghostNode.x = x;\n      ghostNode.y = y;\n      ghostNode.vx = vx;\n      ghostNode.vy = vy;\n\n      // Update nodeMap with new ID\n      delete nodeMap[op.ghostId];\n      nodeMap[op.newNodeId] = ghostNode;\n\n      // Update adjacency\n      adjacency[op.newNodeId] = adjacency[op.ghostId] || { outgoing: [], incoming: [] };\n      delete adjacency[op.ghostId];\n\n      // Unpin after brief delay\n      setTimeout(() => {\n        if (ghostNode.fx != null) {\n          ghostNode.fx = undefined;\n          ghostNode.fy = undefined;\n        }\n      }, 800);\n\n      console.log('[WS] Replaced ghost', op.ghostId, 'with node', op.newNodeId, op.linkedExisting ? '(linked to existing)' : '');\n    }\n\n    function applyEdgeReplace(op) {\n      // Find and update edge\n      for (const link of data.links) {\n        const srcId = typeof link.source === 'object' ? link.source.id : link.source;\n        const tgtId = typeof link.target === 'object' ? link.target.id : link.target;\n\n        // Check if this is a ghost_ref edge that should be replaced\n        if (link.type === 'ghost_ref' || link.type === 'pending_link') {\n          const oldTargetId = ghostIdMap[tgtId] ? tgtId : null;\n          if (oldTargetId && srcId === op.fromId) {\n            link.type = op.type;\n            link.edgeId = op.newEdgeId;\n            if (typeof link.target === 'object') {\n              link.target.id = op.toId;\n            } else {\n              link.target = op.toId;\n            }\n            console.log('[WS] Replaced edge from', op.fromId, 'to', op.toId);\n            break;\n          }\n        }\n      }\n    }\n\n    function applyNodeRemove(op) {\n      const node = nodeMap[op.nodeId];\n      if (node) {\n        const idx = data.nodes.indexOf(node);\n        if (idx !== -1) {\n          data.nodes.splice(idx, 1);\n        }\n        delete nodeMap[op.nodeId];\n        delete adjacency[op.nodeId];\n      }\n    }\n\n    function applyEdgeRemove(op) {\n      const idx = data.links.findIndex(l => l.edgeId === op.edgeId);\n      if (idx !== -1) {\n        data.links.splice(idx, 1);\n      }\n    }\n\n    function handleWsError(msg) {\n      console.error('[WS] Server error:', msg.message);\n      if (msg.ghostId) {\n        pendingCreates.delete(msg.ghostId);\n        revertGhostState(msg.ghostId);\n        showToast('Error: ' + msg.message, 'error');\n      }\n    }\n\n    function handleSyncResponse(msg) {\n      console.log('[WS] Sync response:', msg.unresolvedList.length, 'ghosts,', msg.recentCreations.length, 'recent');\n      // Update ghost ID mappings from recent creations\n      for (const creation of msg.recentCreations) {\n        ghostIdMap[creation.ghostId] = creation.newNodeId;\n      }\n      updateBacklog();\n    }\n\n    function updateConnectionStatus(status) {\n      const indicator = document.getElementById('ws-status');\n      if (!indicator) return;\n\n      indicator.className = 'ws-status ' + status;\n      indicator.title = status === 'connected' ? 'Live updates active'\n        : status === 'disconnected' ? 'Disconnected - reconnecting...'\n        : 'Connection error';\n    }\n\n    function revertGhostState(ghostId) {\n      const node = nodeMap[ghostId];\n      if (!node) return;\n\n      // Revert styling\n      node.isPending = false;\n\n      // Unpin\n      node.fx = undefined;\n      node.fy = undefined;\n\n      // Revert edges\n      for (const link of data.links) {\n        const tgtId = typeof link.target === 'object' ? link.target.id : link.target;\n        if (tgtId === ghostId && link.type === 'pending_link') {\n          link.type = 'ghost_ref';\n        }\n      }\n\n      updateGraphVisibility();\n    }\n\n    // ========================================================================\n    // Create Panel UI\n    // ========================================================================\n\n    let createPanelTarget = null;\n\n    function showCreatePanel(ghostId, title, sourceNodeId) {\n      if (!wsConnected) {\n        showToast('Not connected to server', 'error');\n        return;\n      }\n\n      if (pendingCreates.has(ghostId)) {\n        showToast('Create already in progress', 'warning');\n        return;\n      }\n\n      createPanelTarget = { ghostId, title, sourceNodeId };\n\n      const panel = document.getElementById('create-panel');\n      const titleInput = document.getElementById('create-title');\n      const folderSelect = document.getElementById('create-folder');\n\n      titleInput.value = title;\n\n      // Populate folder dropdown (could be enhanced with actual folders)\n      folderSelect.innerHTML = '<option value=\"\">Root</option>';\n\n      panel.classList.add('active');\n      titleInput.focus();\n      titleInput.select();\n    }\n\n    function hideCreatePanel() {\n      const panel = document.getElementById('create-panel');\n      panel.classList.remove('active');\n      createPanelTarget = null;\n    }\n\n    function submitCreate() {\n      if (!createPanelTarget || !wsConnected) return;\n\n      const titleInput = document.getElementById('create-title');\n      const folderSelect = document.getElementById('create-folder');\n\n      const title = titleInput.value.trim();\n      if (!title) {\n        showToast('Title is required', 'warning');\n        return;\n      }\n\n      const { ghostId, sourceNodeId } = createPanelTarget;\n\n      // Mark as pending\n      pendingCreates.add(ghostId);\n      const node = nodeMap[ghostId];\n      if (node) {\n        node.isPending = true;\n        // Pin at current position\n        node.fx = node.x;\n        node.fy = node.y;\n      }\n\n      // Update edge types to pending\n      for (const link of data.links) {\n        const tgtId = typeof link.target === 'object' ? link.target.id : link.target;\n        if (tgtId === ghostId && link.type === 'ghost_ref') {\n          link.type = 'pending_link';\n        }\n      }\n\n      updateGraphVisibility();\n      updateBacklogRow(ghostId);\n\n      // Send create request\n      ws.send(JSON.stringify({\n        type: 'create_from_ghost',\n        sessionNonce: wsSessionNonce,\n        ghostId: ghostId,\n        title: title,\n        sourceNodeId: sourceNodeId,\n        targetFolder: folderSelect.value || undefined,\n      }));\n\n      hideCreatePanel();\n    }\n\n    function showToast(message, type = 'info') {\n      const toast = document.createElement('div');\n      toast.className = 'toast toast-' + type;\n      toast.textContent = message;\n      document.body.appendChild(toast);\n\n      setTimeout(() => toast.classList.add('show'), 10);\n      setTimeout(() => {\n        toast.classList.remove('show');\n        setTimeout(() => toast.remove(), 300);\n      }, 3000);\n    }\n\n    // ========================================================================\n    // Sidebar Backlog\n    // ========================================================================\n\n    let backlogExpanded = localStorage.getItem('backlogExpanded') !== 'false';\n    let backlogSort = localStorage.getItem('backlogSort') || 'importance';\n    let backlogSearch = '';\n\n    function initBacklog() {\n      const backlogPanel = document.getElementById('backlog-panel');\n      if (!backlogPanel) return;\n\n      // Restore state\n      if (backlogExpanded) {\n        backlogPanel.classList.add('expanded');\n      }\n\n      updateBacklog();\n    }\n\n    function toggleBacklog() {\n      const backlogPanel = document.getElementById('backlog-panel');\n      backlogExpanded = !backlogExpanded;\n      backlogPanel.classList.toggle('expanded', backlogExpanded);\n      localStorage.setItem('backlogExpanded', backlogExpanded);\n    }\n\n    function setBacklogSort(sort) {\n      backlogSort = sort;\n      localStorage.setItem('backlogSort', sort);\n      updateBacklog();\n    }\n\n    function filterBacklog(query) {\n      backlogSearch = query.toLowerCase();\n      updateBacklog();\n    }\n\n    function updateBacklog() {\n      const list = document.getElementById('backlog-list');\n      const countEl = document.getElementById('backlog-count');\n      if (!list) return;\n\n      // Get ghost nodes\n      let ghosts = data.nodes.filter(n => n.isGhost && !ghostIdMap[n.id]);\n\n      // Apply search filter\n      if (backlogSearch) {\n        ghosts = ghosts.filter(g => g.name.toLowerCase().includes(backlogSearch));\n      }\n\n      // Sort\n      ghosts = sortGhosts(ghosts, backlogSort);\n\n      // Update count\n      if (countEl) {\n        countEl.textContent = ghosts.length;\n      }\n\n      // Render list\n      list.innerHTML = ghosts.slice(0, 10).map(ghost => {\n        const isPending = pendingCreates.has(ghost.id);\n        const recency = formatRecency(ghost.mostRecentRef || ghost.metadata?.firstSeen);\n        const refCount = ghost.referenceCount || (ghost.sourceIds ? ghost.sourceIds.length : 0);\n\n        return \\`\n          <div class=\"backlog-row \\${isPending ? 'pending' : ''}\" data-ghost-id=\"\\${ghost.id}\">\n            <div class=\"backlog-row-main\" onclick=\"focusGhost('\\${ghost.id}')\">\n              <span class=\"backlog-title\">\\${escapeHtml(ghost.name)}</span>\n              <span class=\"backlog-badges\">\n                <span class=\"backlog-ref-count\">\\${refCount}</span>\n                <span class=\"backlog-recency\">\\${recency}</span>\n              </span>\n            </div>\n            <button class=\"backlog-create-btn\" onclick=\"event.stopPropagation(); showCreatePanelFromBacklog('\\${ghost.id}')\"\n                    \\${isPending || !wsConnected ? 'disabled' : ''}>\n              \\${isPending ? '...' : '+'}\n            </button>\n          </div>\n        \\`;\n      }).join('');\n\n      if (ghosts.length > 10) {\n        list.innerHTML += \\`<div class=\"backlog-more\">and \\${ghosts.length - 10} more...</div>\\`;\n      }\n    }\n\n    function updateBacklogRow(ghostId) {\n      const row = document.querySelector(\\`.backlog-row[data-ghost-id=\"\\${ghostId}\"]\\`);\n      if (!row) return;\n\n      const isPending = pendingCreates.has(ghostId);\n      row.classList.toggle('pending', isPending);\n\n      const btn = row.querySelector('.backlog-create-btn');\n      if (btn) {\n        btn.disabled = isPending || !wsConnected;\n        btn.textContent = isPending ? '...' : '+';\n      }\n    }\n\n    function sortGhosts(ghosts, sortBy) {\n      switch (sortBy) {\n        case 'importance':\n          return ghosts.sort((a, b) => calculateImportance(b) - calculateImportance(a));\n        case 'refs':\n          return ghosts.sort((a, b) => (b.referenceCount || 0) - (a.referenceCount || 0));\n        case 'recent':\n          return ghosts.sort((a, b) => {\n            const aTime = a.mostRecentRef || a.metadata?.firstSeen || '';\n            const bTime = b.mostRecentRef || b.metadata?.firstSeen || '';\n            return bTime.localeCompare(aTime);\n          });\n        case 'alpha':\n          return ghosts.sort((a, b) => a.name.localeCompare(b.name));\n        default:\n          return ghosts;\n      }\n    }\n\n    function calculateImportance(ghost) {\n      const refCount = ghost.referenceCount || (ghost.sourceIds ? ghost.sourceIds.length : 0);\n      const refWeight = 2 * Math.log2(1 + refCount);\n      const recencyScore = getRecencyScore(ghost.mostRecentRef || ghost.metadata?.firstSeen);\n      return refWeight + recencyScore;\n    }\n\n    function getRecencyScore(timestamp) {\n      if (!timestamp) return 0;\n      const now = Date.now();\n      const then = new Date(timestamp).getTime();\n      const daysDiff = (now - then) / (1000 * 60 * 60 * 24);\n\n      if (daysDiff <= 7) return 1.0;\n      if (daysDiff <= 30) return 0.5;\n      if (daysDiff <= 90) return 0.25;\n      return 0.1;\n    }\n\n    function formatRecency(timestamp) {\n      if (!timestamp) return '';\n      const now = Date.now();\n      const then = new Date(timestamp).getTime();\n      const diff = now - then;\n\n      const minutes = Math.floor(diff / 60000);\n      const hours = Math.floor(diff / 3600000);\n      const days = Math.floor(diff / 86400000);\n      const weeks = Math.floor(days / 7);\n      const months = Math.floor(days / 30);\n\n      if (minutes < 60) return minutes + 'm';\n      if (hours < 24) return hours + 'h';\n      if (days < 7) return days + 'd';\n      if (weeks < 4) return weeks + 'w';\n      return months + 'mo';\n    }\n\n    function focusGhost(ghostId) {\n      const node = nodeMap[ghostId];\n      if (!node) return;\n\n      navigateToNode(ghostId);\n    }\n\n    function showCreatePanelFromBacklog(ghostId) {\n      const node = nodeMap[ghostId];\n      if (!node) return;\n\n      const sourceId = node.sourceIds && node.sourceIds[0] ? node.sourceIds[0] : '';\n      showCreatePanel(ghostId, node.name, sourceId);\n    }\n\n    function escapeHtml(str) {\n      const div = document.createElement('div');\n      div.textContent = str;\n      return div.innerHTML;\n    }\n\n    // ========================================================================\n    // Centroid Anchoring for Ghost Nodes\n    // ========================================================================\n\n    function initGhostCentroids() {\n      // Set initial positions for ghost nodes at centroid of their referencers\n      for (const node of data.nodes) {\n        if (!node.isGhost) continue;\n\n        const refs = (node.sourceIds || [])\n          .map(id => nodeMap[id])\n          .filter(n => n && n.x != null);\n\n        if (refs.length > 0) {\n          node.x = refs.reduce((sum, n) => sum + n.x, 0) / refs.length;\n          node.y = refs.reduce((sum, n) => sum + n.y, 0) / refs.length;\n        }\n\n        // Cache referencer nodes\n        node._refNodes = refs;\n      }\n    }\n\n    function centroidTetherForce(strength = 0.03) {\n      let ghosts = [];\n\n      function force(alpha) {\n        const effectiveAlpha = Math.max(alpha, 0.1);\n\n        for (const ghost of ghosts) {\n          // Skip if pinned\n          if (ghost.fx != null || ghost.fy != null) continue;\n\n          // Use cached refs\n          const refs = ghost._refNodes;\n          if (!refs || refs.length === 0) continue;\n\n          // Calculate centroid\n          let cx = 0, cy = 0, validCount = 0;\n          for (const ref of refs) {\n            if (ref.x != null && ref.y != null) {\n              cx += ref.x;\n              cy += ref.y;\n              validCount++;\n            }\n          }\n          if (validCount === 0) continue;\n          cx /= validCount;\n          cy /= validCount;\n\n          // Clamp delta to prevent slingshots\n          const maxDelta = 50;\n          const dx = Math.max(-maxDelta, Math.min(maxDelta, cx - ghost.x));\n          const dy = Math.max(-maxDelta, Math.min(maxDelta, cy - ghost.y));\n\n          ghost.vx = (ghost.vx || 0) + dx * strength * effectiveAlpha;\n          ghost.vy = (ghost.vy || 0) + dy * strength * effectiveAlpha;\n        }\n      }\n\n      force.initialize = (nodes) => {\n        ghosts = nodes.filter(n => n.isGhost);\n        // Cache referencer node references\n        for (const ghost of ghosts) {\n          ghost._refNodes = (ghost.sourceIds || [])\n            .map(id => nodeMap[id])\n            .filter(n => n != null);\n        }\n      };\n\n      return force;\n    }\n\n    function refreshGhostRefCache() {\n      for (const node of data.nodes) {\n        if (!node.isGhost) continue;\n        node._refNodes = (node.sourceIds || [])\n          .map(id => nodeMap[id])\n          .filter(n => n != null);\n      }\n    }\n\n    // Init Graph\n    const Graph = ForceGraph()\n      (document.getElementById('graph'))\n      .graphData(data)\n      .nodeId('id')\n      .nodeLabel('name')\n      .nodeColor(node => hiddenTypes.has(node.type) ? 'rgba(0,0,0,0)' : node.color)\n      .nodeVal('val')\n      .nodeRelSize(4)\n      .linkWidth(link => highlightLinks.has(link) ? 3 : 1.5)\n      .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)\n      .linkDirectionalParticleWidth(3)\n      .linkLineDash(link => {\n        const style = edgeStyles[link.type];\n        return style ? style.dash : [];\n      })\n      .linkColor(link => {\n        if (hiddenEdgeTypes.has(link.type)) return 'rgba(0,0,0,0)';\n        if (highlightLinks.has(link)) return '#38bdf8';\n        const style = edgeStyles[link.type];\n        return style ? style.color : 'rgba(148, 163, 184, 0.3)';\n      })\n      .backgroundColor('#0f172a')\n      .onNodeHover(node => {\n        if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;\n\n        highlightNodes.clear();\n        highlightLinks.clear();\n        if (node) {\n          highlightNodes.add(node);\n          data.links.forEach(link => {\n            const srcId = typeof link.source === 'object' ? link.source.id : link.source;\n            const tgtId = typeof link.target === 'object' ? link.target.id : link.target;\n            if (srcId === node.id || tgtId === node.id) {\n              highlightLinks.add(link);\n              highlightNodes.add(nodeMap[srcId]);\n              highlightNodes.add(nodeMap[tgtId]);\n            }\n          });\n        }\n\n        hoverNode = node || null;\n        updateGraphVisibility();\n      })\n      .onNodeClick(node => {\n        navigateToNode(node.id);\n      })\n      .onBackgroundClick(() => {\n        document.getElementById('sidebar').classList.remove('active');\n        selectedNode = null;\n        highlightNodes.clear();\n        highlightLinks.clear();\n        hoverNode = null;\n        updateGraphVisibility();\n      });\n\n    // Physics\n    Graph.d3Force('charge').strength(-150);\n    Graph.d3Force('link').distance(70);\n\n    // Add centroid tether force for ghost nodes\n    Graph.d3Force('centroidTether', centroidTetherForce(0.03));\n\n    // Initialize ghost node positions at centroid before simulation starts\n    initGhostCentroids();\n\n    // Apply camera position from constellation after graph initializes\n    if (loadedConstellation && loadedConstellation.cameraX != null && loadedConstellation.cameraY != null) {\n      setTimeout(() => {\n        Graph.centerAt(loadedConstellation.cameraX, loadedConstellation.cameraY, 0);\n        if (loadedConstellation.cameraZoom) {\n          Graph.zoom(loadedConstellation.cameraZoom, 0);\n        }\n      }, 500);\n    }\n\n    // Initialize path panel if path data is available\n    setTimeout(() => {\n      initPathPanel();\n    }, 100);\n\n    // Initialize WebSocket connection if enabled\n    setTimeout(() => {\n      initWebSocket();\n      initBacklog();\n      initHeatVision();\n    }, 200);\n\n    function updateGraphVisibility() {\n      const pathMode = pathNodes.size > 0;\n\n      Graph.nodeCanvasObject((node, ctx, globalScale) => {\n        // Skip hidden types\n        if (hiddenTypes.has(node.type)) return;\n        // Skip invisible ghost nodes\n        if (node.isGhost && !isGhostVisible(node)) return;\n\n        const label = node.name;\n        const fontSize = 12/globalScale;\n        const isHighlighted = highlightNodes.size === 0 || highlightNodes.has(node);\n        const isSelected = selectedNode && selectedNode.id === node.id;\n        const nodeOnPath = isOnPath(node.id);\n        const radius = Math.sqrt(node.val) * 4;\n\n        // In path mode, fade non-path nodes\n        const pathFade = pathMode && !nodeOnPath;\n\n        // Ghost node rendering\n        if (node.isGhost) {\n          const isPending = node.isPending || pendingCreates.has(node.id);\n\n          // Pulse effect for pending state\n          let pulseScale = 1;\n          if (isPending) {\n            const pulse = (Date.now() % 1000) / 1000;\n            pulseScale = 1 + 0.1 * Math.sin(pulse * Math.PI * 2);\n          }\n\n          const effectiveRadius = radius * pulseScale;\n\n          // Dashed outline circle (or solid cyan for pending)\n          if (isPending) {\n            ctx.setLineDash([]);\n            ctx.strokeStyle = '#38bdf8';\n            ctx.lineWidth = 2 / globalScale;\n          } else {\n            ctx.setLineDash([4 / globalScale, 4 / globalScale]);\n            ctx.strokeStyle = pathFade ? 'rgba(100, 116, 139, 0.3)' : '#64748b';\n            ctx.lineWidth = 1.5 / globalScale;\n          }\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, effectiveRadius, 0, 2 * Math.PI);\n          ctx.fillStyle = isPending\n            ? 'rgba(56, 189, 248, 0.15)'\n            : (pathFade\n              ? 'rgba(148, 163, 184, 0.05)'\n              : (isHighlighted ? 'rgba(148, 163, 184, 0.2)' : 'rgba(148, 163, 184, 0.1)'));\n          ctx.fill();\n          ctx.stroke();\n          ctx.setLineDash([]);\n\n          // Icon in center (spinner for pending, + for normal)\n          ctx.font = \\`bold \\${fontSize * 1.5}px Sans-Serif\\`;\n          ctx.textAlign = 'center';\n          ctx.textBaseline = 'middle';\n          if (isPending) {\n            ctx.fillStyle = '#38bdf8';\n            ctx.fillText('...', node.x, node.y);\n          } else {\n            ctx.fillStyle = pathFade\n              ? 'rgba(148, 163, 184, 0.2)'\n              : (isHighlighted ? 'rgba(148, 163, 184, 0.8)' : 'rgba(148, 163, 184, 0.5)');\n            ctx.fillText('+', node.x, node.y);\n          }\n\n          // Selection ring\n          if (hoverNode === node || isSelected) {\n            ctx.setLineDash([]);\n            ctx.strokeStyle = isSelected ? '#38bdf8' : '#94a3b8';\n            ctx.lineWidth = (isSelected ? 3 : 2) / globalScale;\n            ctx.beginPath();\n            ctx.arc(node.x, node.y, effectiveRadius + 2 / globalScale, 0, 2 * Math.PI);\n            ctx.stroke();\n          }\n\n          // Label for ghost nodes\n          if (!pathFade && (globalScale > 2.5 || (isHighlighted && highlightNodes.size > 0))) {\n            ctx.font = \\`\\${fontSize}px Sans-Serif\\`;\n            const textWidth = ctx.measureText(label).width;\n            const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2);\n\n            ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';\n            ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] - effectiveRadius - 2, bckgDimensions[0], bckgDimensions[1]);\n\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = isPending ? '#38bdf8' : (isHighlighted ? '#94a3b8' : 'rgba(148, 163, 184, 0.4)');\n            ctx.fillText(label, node.x, node.y - bckgDimensions[1]/2 - effectiveRadius - 2);\n          }\n          return;\n        }\n\n        // Heat glow (drawn BEFORE node fill so it appears as halo behind)\n        // Skip if: heat disabled, node is highlighted (path/selection takes precedence), heat below threshold\n        const shouldShowHeat = heatEnabled && node.heat > 0.05 && !nodeOnPath && !isSelected && !(hoverNode === node);\n        if (shouldShowHeat) {\n          const glowRadius = radius + (node.heat * 8);\n          const glowAlpha = node.heat * 0.4;\n\n          const gradient = ctx.createRadialGradient(\n            node.x, node.y, radius,\n            node.x, node.y, glowRadius\n          );\n          gradient.addColorStop(0, \\`rgba(255, 100, 50, \\${glowAlpha})\\`);\n          gradient.addColorStop(1, 'rgba(255, 100, 50, 0)');\n\n          ctx.fillStyle = gradient;\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, glowRadius, 0, 2 * Math.PI);\n          ctx.fill();\n        }\n\n        // Regular node rendering\n        ctx.beginPath();\n        ctx.arc(node.x, node.y, radius, 0, 2 * Math.PI, false);\n\n        if (pathFade) {\n          ctx.fillStyle = convertHexToRGBA(node.color, 0.15);\n        } else if (nodeOnPath) {\n          ctx.fillStyle = node.color;\n        } else {\n          ctx.fillStyle = isHighlighted ? node.color : convertHexToRGBA(node.color, 0.2);\n        }\n        ctx.fill();\n\n        // Gold outline for path nodes\n        if (nodeOnPath) {\n          ctx.strokeStyle = '#fbbf24';\n          ctx.lineWidth = 3 / globalScale;\n          ctx.stroke();\n        }\n\n        // Ring for selected/hovered (on top of path outline)\n        if (hoverNode === node || isSelected) {\n          ctx.strokeStyle = isSelected ? '#38bdf8' : '#fff';\n          ctx.lineWidth = (isSelected ? 3 : 2) / globalScale;\n          ctx.stroke();\n        }\n\n        // Path order number\n        if (nodeOnPath && pathNodeOrder.has(node.id)) {\n          const orderNum = pathNodeOrder.get(node.id);\n          const numSize = fontSize * 0.8;\n          ctx.font = \\`bold \\${numSize}px Sans-Serif\\`;\n          ctx.textAlign = 'center';\n          ctx.textBaseline = 'middle';\n\n          // Circle background for number\n          const numRadius = numSize * 0.7;\n          ctx.beginPath();\n          ctx.arc(node.x + radius + numRadius, node.y - radius - numRadius, numRadius, 0, 2 * Math.PI);\n          ctx.fillStyle = '#fbbf24';\n          ctx.fill();\n\n          ctx.fillStyle = '#000';\n          ctx.fillText(orderNum, node.x + radius + numRadius, node.y - radius - numRadius);\n        }\n\n        // Text Label\n        const showLabel = !pathFade && (globalScale > 2.5 || nodeOnPath || (isHighlighted && highlightNodes.size > 0));\n        if (showLabel) {\n          ctx.font = \\`\\${fontSize}px Sans-Serif\\`;\n          const textWidth = ctx.measureText(label).width;\n          const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2);\n\n          ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';\n          ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] - radius - 2, bckgDimensions[0], bckgDimensions[1]);\n\n          ctx.textAlign = 'center';\n          ctx.textBaseline = 'middle';\n          ctx.fillStyle = nodeOnPath ? '#fbbf24' : (isHighlighted ? '#fff' : 'rgba(255,255,255,0.4)');\n          ctx.fillText(label, node.x, node.y - bckgDimensions[1]/2 - radius - 2);\n        }\n      });\n\n      Graph.linkVisibility(link => {\n        const srcNode = typeof link.source === 'object' ? link.source : nodeMap[link.source];\n        const tgtNode = typeof link.target === 'object' ? link.target : nodeMap[link.target];\n        if (!srcNode || !tgtNode) return false;\n        if (hiddenTypes.has(srcNode.type) || hiddenTypes.has(tgtNode.type)) return false;\n        if (hiddenEdgeTypes.has(link.type)) return false;\n        // Hide ghost reference edges when ghost is not visible\n        if (link.type === 'ghost_ref') {\n          const ghostNode = srcNode.isGhost ? srcNode : tgtNode;\n          if (!isGhostVisible(ghostNode)) return false;\n        }\n        return true;\n      });\n\n      // Update link colors and widths for path mode\n      Graph.linkColor(link => {\n        if (hiddenEdgeTypes.has(link.type)) return 'rgba(0,0,0,0)';\n        if (highlightLinks.has(link)) return '#38bdf8';\n\n        const srcId = typeof link.source === 'object' ? link.source.id : link.source;\n        const tgtId = typeof link.target === 'object' ? link.target.id : link.target;\n\n        if (pathMode) {\n          if (isPathEdge(srcId, tgtId)) {\n            return '#fbbf24'; // Gold for path edges\n          }\n          return 'rgba(148, 163, 184, 0.1)'; // Faded for non-path edges\n        }\n\n        const style = edgeStyles[link.type];\n        return style ? style.color : 'rgba(148, 163, 184, 0.3)';\n      });\n\n      Graph.linkWidth(link => {\n        if (highlightLinks.has(link)) return 3;\n\n        const srcId = typeof link.source === 'object' ? link.source.id : link.source;\n        const tgtId = typeof link.target === 'object' ? link.target.id : link.target;\n\n        if (pathMode && isPathEdge(srcId, tgtId)) {\n          return 3;\n        }\n        return 1.5;\n      });\n    }\n\n    function buildConnectionsUI(node) {\n      const adj = adjacency[node.id];\n      if (!adj) return '';\n\n      // Group connections by edge type\n      const outgoingByType = {};\n      const incomingByType = {};\n\n      adj.outgoing.forEach(conn => {\n        const targetNode = nodeMap[conn.nodeId];\n        if (!targetNode) return;\n        if (!outgoingByType[conn.type]) outgoingByType[conn.type] = [];\n        outgoingByType[conn.type].push(targetNode);\n      });\n\n      adj.incoming.forEach(conn => {\n        const sourceNode = nodeMap[conn.nodeId];\n        if (!sourceNode) return;\n        if (!incomingByType[conn.type]) incomingByType[conn.type] = [];\n        incomingByType[conn.type].push(sourceNode);\n      });\n\n      const totalConnections = adj.outgoing.length + adj.incoming.length;\n      if (totalConnections === 0) return '';\n\n      let html = '<div class=\"connections-title\">Connections</div>';\n\n      // Helper to render a connection group\n      const renderGroup = (label, icon, nodes, edgeType) => {\n        if (!nodes || nodes.length === 0) return '';\n        const style = edgeStyles[edgeType] || { color: '#94a3b8', label: edgeType };\n        return \\`\n          <div class=\"connection-group\">\n            <div class=\"connection-group-header\">\n              <span class=\"connection-group-icon\">\\${icon}</span>\n              <span>\\${label}</span>\n              <span class=\"connection-group-count\">\\${nodes.length}</span>\n            </div>\n            \\${nodes.map(n => \\`\n              <div class=\"connected-node\" onclick=\"navigateToNode('\\${n.id}')\">\n                <div class=\"connected-node-dot\" style=\"background: \\${n.color}\"></div>\n                <span class=\"connected-node-name\">\\${n.name}</span>\n                <span class=\"connected-node-type\">\\${n.type}</span>\n              </div>\n            \\`).join('')}\n          </div>\n        \\`;\n      };\n\n      // Outgoing connections (Links to)\n      Object.entries(outgoingByType).forEach(([type, nodes]) => {\n        const style = edgeStyles[type] || { label: type };\n        html += renderGroup(style.label + ' (out)', '', nodes, type);\n      });\n\n      // Incoming connections (Backlinks from)\n      Object.entries(incomingByType).forEach(([type, nodes]) => {\n        const style = edgeStyles[type] || { label: type };\n        html += renderGroup(style.label + ' (in)', '', nodes, type);\n      });\n\n      return html;\n    }\n\n    function showSidebar(node) {\n      const sb = document.getElementById('sidebar');\n      document.getElementById('sb-title').innerText = node.name;\n\n      const typeEl = document.getElementById('sb-type');\n      typeEl.innerText = node.isGhost ? 'ghost (unresolved)' : node.type;\n      typeEl.style.backgroundColor = node.color;\n\n      const content = document.getElementById('sb-content');\n      let html = '';\n\n      // Ghost node sidebar\n      if (node.isGhost) {\n        const refCount = node.referenceCount || (node.sourceIds ? node.sourceIds.length : 0);\n        html = \\`\n          <div class=\"meta-item\">\n            <span class=\"meta-key\">Status</span>\n            <span class=\"meta-val\">Unresolved wikilink</span>\n          </div>\n          <div class=\"meta-item\">\n            <span class=\"meta-key\">References</span>\n            <span class=\"meta-val\">\\${refCount} note\\${refCount === 1 ? '' : 's'} link to this</span>\n          </div>\n          <div class=\"ghost-action\">\n            <button class=\"create-note-btn\" onclick=\"createNoteFromGhost('\\${node.name.replace(/'/g, \"\\\\\\\\'\")}')\">\n              + Create Note\n            </button>\n            <div class=\"ghost-info\">\n              Click to create a new note with this title. The link will be resolved automatically on the next index.\n            </div>\n          </div>\\`;\n\n        content.innerHTML = html;\n\n        // Show which nodes reference this ghost\n        const connectionsEl = document.getElementById('sb-connections');\n        if (node.sourceIds && node.sourceIds.length > 0) {\n          let connHtml = '<div class=\"connections-title\">Referenced By</div>';\n          connHtml += '<div class=\"connection-group\">';\n          node.sourceIds.forEach(srcId => {\n            const srcNode = nodeMap[srcId];\n            if (srcNode) {\n              connHtml += \\`\n                <div class=\"connected-node\" onclick=\"navigateToNode('\\${srcNode.id}')\">\n                  <div class=\"connected-node-dot\" style=\"background: \\${srcNode.color}\"></div>\n                  <span class=\"connected-node-name\">\\${srcNode.name}</span>\n                  <span class=\"connected-node-type\">\\${srcNode.type}</span>\n                </div>\\`;\n            }\n          });\n          connHtml += '</div>';\n          connectionsEl.innerHTML = connHtml;\n        } else {\n          connectionsEl.innerHTML = '';\n        }\n\n        sb.classList.add('active');\n        return;\n      }\n\n      // Regular node sidebar\n      html = \\`\n        <div class=\"meta-item\">\n          <span class=\"meta-key\">Location</span>\n          <span class=\"meta-val\"><code>\\${node.path}</code></span>\n        </div>\\`;\n\n      // Add \"Last updated\" when heat vision is enabled\n      if (heatEnabled && node.updatedAtMs) {\n        const ageDays = Math.max(0, (Date.now() - node.updatedAtMs) / MS_PER_DAY);\n        const updatedDate = new Date(node.updatedAtMs);\n        const dateStr = updatedDate.toISOString().split('T')[0];\n        let relativeStr;\n        if (ageDays < 1) {\n          relativeStr = 'today';\n        } else if (ageDays < 2) {\n          relativeStr = '1 day ago';\n        } else if (ageDays < 30) {\n          relativeStr = Math.floor(ageDays) + ' days ago';\n        } else if (ageDays < 60) {\n          relativeStr = '1 month ago';\n        } else if (ageDays < 365) {\n          relativeStr = Math.floor(ageDays / 30) + ' months ago';\n        } else {\n          relativeStr = Math.floor(ageDays / 365) + ' year' + (ageDays >= 730 ? 's' : '') + ' ago';\n        }\n        html += \\`\n          <div class=\"meta-item\">\n            <span class=\"meta-key\">Last updated</span>\n            <span class=\"meta-val\">\\${relativeStr} (\\${dateStr})</span>\n          </div>\\`;\n      }\n\n      if (node.metadata) {\n        const priority = ['id', 'tags', 'aliases', 'role'];\n        const sortedKeys = Object.keys(node.metadata).sort((a, b) => {\n          const ai = priority.indexOf(a);\n          const bi = priority.indexOf(b);\n          if (ai !== -1 && bi !== -1) return ai - bi;\n          if (ai !== -1) return -1;\n          if (bi !== -1) return 1;\n          return a.localeCompare(b);\n        });\n\n        sortedKeys.forEach(key => {\n          if (['title', 'type'].includes(key)) return;\n          const val = node.metadata[key];\n          if (!val && val !== 0) return;\n\n          let displayVal = val;\n          if (Array.isArray(val)) {\n            displayVal = val.map(v => \\`<code>\\${v}</code>\\`).join(' ');\n          } else if (typeof val === 'object') {\n            displayVal = JSON.stringify(val);\n          }\n\n          html += \\`\n            <div class=\"meta-item\">\n              <span class=\"meta-key\">\\${key.replace(/_/g, ' ')}</span>\n              <span class=\"meta-val\">\\${displayVal}</span>\n            </div>\\`;\n        });\n      }\n\n      content.innerHTML = html;\n\n      // Build connections UI\n      const connectionsEl = document.getElementById('sb-connections');\n      connectionsEl.innerHTML = buildConnectionsUI(node);\n\n      sb.classList.add('active');\n    }\n\n    // Ghost node creation handler\n    function createNoteFromGhost(ghostName) {\n      // Find the ghost node\n      const ghostNode = data.nodes.find(n => n.isGhost && n.name === ghostName);\n      if (!ghostNode) {\n        console.error('Ghost node not found:', ghostName);\n        return;\n      }\n\n      // If WebSocket connected, use live creation\n      if (wsConnected) {\n        const sourceId = ghostNode.sourceIds && ghostNode.sourceIds[0] ? ghostNode.sourceIds[0] : '';\n        showCreatePanel(ghostNode.id, ghostName, sourceId);\n      } else {\n        // Fallback to CLI command\n        alert('Note creation requested for: ' + ghostName + '\\\\n\\\\nTo create this note, run:\\\\n  zs create \"' + ghostName + '\"\\\\n\\\\nOr create the file manually in your vault.');\n      }\n    }\n\n    function searchNode(query) {\n      if (!query) return;\n      const node = data.nodes.find(n => n.name.toLowerCase().includes(query.toLowerCase()));\n      if (node) {\n        navigateToNode(node.id);\n      }\n    }\n\n    // Keyboard shortcuts\n    document.addEventListener('keydown', (e) => {\n      // Alt+Left: Go back\n      if (e.altKey && e.key === 'ArrowLeft') {\n        e.preventDefault();\n        goBack();\n      }\n      // Alt+Right: Go forward\n      if (e.altKey && e.key === 'ArrowRight') {\n        e.preventDefault();\n        goForward();\n      }\n      // Escape: Close sidebar\n      if (e.key === 'Escape') {\n        document.getElementById('sidebar').classList.remove('active');\n        selectedNode = null;\n        highlightNodes.clear();\n        highlightLinks.clear();\n        hoverNode = null;\n        updateGraphVisibility();\n      }\n      // /: Focus search\n      if (e.key === '/' && document.activeElement.tagName !== 'INPUT') {\n        e.preventDefault();\n        document.getElementById('search').focus();\n      }\n    });\n\n    // ========================================================================\n    // Suggestions Panel\n    // ========================================================================\n\n    let suggestionsPanelExpanded = true;\n    let activeSuggestionId = null;\n    let previewEdge = null;\n\n    function initSuggestionsPanel() {\n      if (!focusBundle) {\n        document.getElementById('suggestions-panel').style.display = 'none';\n        return;\n      }\n\n      const panel = document.getElementById('suggestions-panel');\n      panel.style.display = 'block';\n\n      // Render each section\n      renderRelatedNotes();\n      renderCandidateLinks();\n      renderOrphans();\n    }\n\n    function toggleSuggestionsPanel() {\n      const icon = document.getElementById('suggestions-toggle-icon');\n      suggestionsPanelExpanded = !suggestionsPanelExpanded;\n      icon.textContent = suggestionsPanelExpanded ? '' : '';\n\n      // Toggle all sections\n      document.querySelectorAll('.suggestion-section').forEach(section => {\n        section.style.display = suggestionsPanelExpanded ? 'block' : 'none';\n      });\n    }\n\n    function toggleSuggestionSection(sectionName) {\n      const section = document.getElementById(sectionName + '-section');\n      section.classList.toggle('collapsed');\n    }\n\n    function renderRelatedNotes() {\n      const list = document.getElementById('related-list');\n      const countEl = document.getElementById('related-count');\n      const notes = focusBundle?.suggestions?.relatedNotes || [];\n\n      countEl.textContent = notes.length;\n\n      if (notes.length === 0) {\n        // Empty state with health context\n        const health = focusBundle?.health;\n        let message = 'No related notes found for this view.';\n        let command = '';\n\n        if (health?.embeddings?.level === 'fail' || health?.embeddings?.level === 'warn') {\n          message = 'Embeddings incomplete.';\n          command = 'zs embed compute';\n        }\n\n        list.innerHTML = \\`\n          <div class=\"suggestion-empty\">\n            \\${message}\n            \\${command ? \\`<code>\\${command}</code>\\` : ''}\n          </div>\n        \\`;\n        return;\n      }\n\n      list.innerHTML = notes.map(note => \\`\n        <div class=\"suggestion-item\" data-node-id=\"\\${note.nodeId}\" onclick=\"handleRelatedNoteClick('\\${note.nodeId}')\">\n          <div class=\"suggestion-item-title\">\\${escapeHtml(note.title)}</div>\n          <div class=\"suggestion-item-meta\">\n            <span class=\"suggestion-score\">\\${(note.score * 100).toFixed(0)}%</span>\n            \\${note.isInView ? '<span style=\"color: var(--accent);\">in view</span>' : ''}\n          </div>\n          \\${note.reasons.length > 0 ? \\`<div class=\"suggestion-reasons\">\\${escapeHtml(note.reasons[0])}</div>\\` : ''}\n        </div>\n      \\`).join('');\n    }\n\n    function renderCandidateLinks() {\n      const list = document.getElementById('links-list');\n      const countEl = document.getElementById('links-count');\n      const batchBtn = document.getElementById('batch-copy-btn');\n      const links = focusBundle?.suggestions?.candidateLinks || [];\n\n      countEl.textContent = links.length;\n      batchBtn.disabled = links.length === 0;\n\n      if (links.length === 0) {\n        list.innerHTML = \\`\n          <div class=\"suggestion-empty\">\n            No link suggestions for this view.\n          </div>\n        \\`;\n        return;\n      }\n\n      list.innerHTML = links.map(link => \\`\n        <div class=\"suggestion-item\" data-suggestion-id=\"\\${link.suggestionId}\" onclick=\"handleCandidateLinkClick('\\${link.suggestionId}', '\\${link.fromId}', '\\${link.toId}')\">\n          <div class=\"candidate-link-row\">\n            <div class=\"candidate-link-info\">\n              <div class=\"suggestion-item-title\">\n                <span class=\"candidate-from\">\\${escapeHtml(link.fromTitle)}</span>\n                <span class=\"candidate-link-arrow\"></span>\n                <span class=\"candidate-to \\${link.toIsGhost ? 'ghost' : ''}\">\\${escapeHtml(link.toTitle)}</span>\n              </div>\n              <div class=\"suggestion-item-meta\">\n                <span class=\"suggestion-score\">\\${(link.confidence * 100).toFixed(0)}%</span>\n                <span>\\${link.source}</span>\n              </div>\n            </div>\n            <button class=\"approve-btn\" data-suggestion-id=\"\\${link.suggestionId}\" onclick=\"handleApprove(event, '\\${link.suggestionId}')\">\n              Approve\n            </button>\n          </div>\n          \\${link.reasons.length > 0 ? \\`<div class=\"suggestion-reasons\">\\${escapeHtml(link.reasons[0])}</div>\\` : ''}\n        </div>\n      \\`).join('');\n    }\n\n    function renderOrphans() {\n      const list = document.getElementById('orphans-list');\n      const countEl = document.getElementById('orphans-count');\n      const orphans = focusBundle?.suggestions?.orphans || [];\n\n      countEl.textContent = orphans.length;\n\n      if (orphans.length === 0) {\n        list.innerHTML = \\`\n          <div class=\"suggestion-empty\">\n            No orphans detected. Your notes are well-connected!\n          </div>\n        \\`;\n        return;\n      }\n\n      list.innerHTML = orphans.map(orphan => \\`\n        <div class=\"suggestion-item\" data-node-id=\"\\${orphan.nodeId}\" onclick=\"handleOrphanClick('\\${orphan.nodeId}')\">\n          <div class=\"suggestion-item-title\">\\${escapeHtml(orphan.title)}</div>\n          <div class=\"suggestion-item-meta\">\n            <span class=\"orphan-severity \\${orphan.severity}\">\\${orphan.severity}</span>\n            <span>\\${orphan.percentile.toFixed(0)}th percentile</span>\n          </div>\n          \\${orphan.reasons.length > 0 ? \\`<div class=\"suggestion-reasons\">\\${escapeHtml(orphan.reasons[0])}</div>\\` : ''}\n        </div>\n      \\`).join('');\n    }\n\n    function handleRelatedNoteClick(nodeId) {\n      clearActiveSuggestion();\n\n      // Highlight the node\n      if (nodeMap[nodeId]) {\n        activeSuggestionId = nodeId;\n        markSuggestionActive(nodeId, 'related');\n        highlightSuggestionNodes([nodeId]);\n      } else {\n        // Node not in current view - could navigate\n        showToast('Note not in current view', 'info');\n      }\n    }\n\n    function handleCandidateLinkClick(suggestionId, fromId, toId) {\n      clearActiveSuggestion();\n\n      activeSuggestionId = suggestionId;\n      markSuggestionActive(suggestionId, 'links');\n\n      // Highlight both nodes\n      const nodeIds = [];\n      if (nodeMap[fromId]) nodeIds.push(fromId);\n      if (nodeMap[toId]) nodeIds.push(toId);\n\n      highlightSuggestionNodes(nodeIds);\n\n      // Show preview edge (dashed line between nodes)\n      if (nodeMap[fromId] && nodeMap[toId]) {\n        showPreviewEdge(fromId, toId);\n      }\n    }\n\n    function handleOrphanClick(nodeId) {\n      clearActiveSuggestion();\n\n      if (nodeMap[nodeId]) {\n        activeSuggestionId = nodeId;\n        markSuggestionActive(nodeId, 'orphans');\n        highlightSuggestionNodes([nodeId]);\n      }\n    }\n\n    function markSuggestionActive(id, section) {\n      // Clear all active states\n      document.querySelectorAll('.suggestion-item.active').forEach(el => {\n        el.classList.remove('active');\n      });\n\n      // Mark the clicked item as active\n      const sectionEl = document.getElementById(section + '-list');\n      const item = sectionEl.querySelector(\\`[data-\\${section === 'links' ? 'suggestion' : 'node'}-id=\"\\${id}\"]\\`);\n      if (item) {\n        item.classList.add('active');\n      }\n    }\n\n    function highlightSuggestionNodes(nodeIds) {\n      // Clear existing highlights\n      highlightNodes.clear();\n      highlightLinks.clear();\n\n      // Add new highlights\n      nodeIds.forEach(id => highlightNodes.add(id));\n\n      // Refresh the graph\n      Graph.refresh();\n    }\n\n    function showPreviewEdge(fromId, toId) {\n      // Store preview edge for rendering\n      previewEdge = { source: fromId, target: toId };\n      Graph.refresh();\n    }\n\n    function clearActiveSuggestion() {\n      activeSuggestionId = null;\n      previewEdge = null;\n\n      // Clear visual states\n      document.querySelectorAll('.suggestion-item.active').forEach(el => {\n        el.classList.remove('active');\n      });\n\n      highlightNodes.clear();\n      highlightLinks.clear();\n      Graph.refresh();\n    }\n\n    function handleApprove(event, suggestionId) {\n      event.stopPropagation();\n\n      // Build command from template\n      const template = focusBundle?.actions?.approve?.template || 'zs approve --suggestion-id {suggestionId} --json';\n      const command = template.replace('{suggestionId}', suggestionId);\n\n      // Copy to clipboard\n      navigator.clipboard.writeText(command).then(() => {\n        showToast('Command copied', 'success');\n\n        // Visual feedback\n        const btn = event.target;\n        const originalText = btn.textContent;\n        btn.textContent = 'Copied ';\n        btn.classList.add('copied');\n\n        setTimeout(() => {\n          btn.textContent = originalText;\n          btn.classList.remove('copied');\n        }, 2000);\n      }).catch(err => {\n        showToast('Failed to copy command', 'error');\n        console.error('Copy failed:', err);\n      });\n    }\n\n    function batchCopyApproveCommands(event) {\n      event.stopPropagation();\n\n      const links = focusBundle?.suggestions?.candidateLinks || [];\n      if (links.length === 0) return;\n\n      const template = focusBundle?.actions?.approve?.template || 'zs approve --suggestion-id {suggestionId} --json';\n      const commands = links.map(link =>\n        template.replace('{suggestionId}', link.suggestionId)\n      ).join('\\\\n');\n\n      navigator.clipboard.writeText(commands).then(() => {\n        showToast(\\`Copied \\${links.length} approve commands\\`, 'success');\n\n        // Visual feedback\n        const btn = event.target;\n        const originalText = btn.textContent;\n        btn.textContent = 'Copied ';\n        setTimeout(() => {\n          btn.textContent = originalText;\n        }, 2000);\n      }).catch(err => {\n        showToast('Failed to copy commands', 'error');\n        console.error('Copy failed:', err);\n      });\n    }\n\n    function escapeHtml(text) {\n      const div = document.createElement('div');\n      div.textContent = text;\n      return div.innerHTML;\n    }\n\n    // Initialize suggestions panel after graph is ready\n    setTimeout(initSuggestionsPanel, 200);\n\n    // Helper\n    function convertHexToRGBA(hex, opacity) {\n      let c;\n      if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){\n          c= hex.substring(1).split('');\n          if(c.length== 3){\n              c= [c[0], c[0], c[1], c[1], c[2], c[2]];\n          }\n          c= '0x'+c.join('');\n          return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+opacity+')';\n      }\n      return hex;\n    }\n  </script>\n</body>\n</html>\n  `;\n}\n\nexport const visualizeCommand = new Command('visualize')\n  .alias('viz')\n  .description('Visualize the knowledge graph in the browser')\n  .option('-o, --output <path>', 'Custom output path for the HTML file')\n  .option('--no-open', 'Do not open the browser automatically')\n  .option('-l, --live', 'Enable live updates via WebSocket (allows creating notes from ghosts)')\n  .option('-c, --constellation <name>', 'Load a saved constellation view')\n  .option('--list-constellations', 'List all saved constellations')\n  .option('--path-from <node>', 'Starting node for path highlighting (title or path)')\n  .option('--path-to <node>', 'Ending node for path highlighting (title or path)')\n  .option('--path-k <n>', 'Number of paths to compute', '3')\n  .action(\n    async (options: {\n      output?: string;\n      open?: boolean;\n      live?: boolean;\n      constellation?: string;\n      listConstellations?: boolean;\n      pathFrom?: string;\n      pathTo?: string;\n      pathK?: string;\n    }) => {\n      try {\n        const ctx = await initContext();\n\n        // Handle --list-constellations\n        if (options.listConstellations) {\n          const constellations = await ctx.constellationRepository.findAll();\n          if (constellations.length === 0) {\n            console.log('No constellations saved yet.');\n            console.log('\\nTo save one, open the visualizer and click \"Save Current View\".');\n          } else {\n            const rows = constellations.map((c) => [\n              c.name,\n              c.description || '-',\n              new Date(c.updatedAt).toLocaleDateString(),\n            ]);\n            printTable(['Name', 'Description', 'Updated'], rows);\n          }\n          ctx.connectionManager.close();\n          return;\n        }\n\n        // Load constellation if specified\n        let constellation: Constellation | null = null;\n        if (options.constellation) {\n          constellation = await ctx.constellationRepository.findByName(options.constellation);\n          if (!constellation) {\n            console.error(`Constellation \"${options.constellation}\" not found.`);\n            console.log('\\nAvailable constellations:');\n            const all = await ctx.constellationRepository.findAll();\n            if (all.length === 0) {\n              console.log('  (none)');\n            } else {\n              all.forEach((c) => console.log(`  - ${c.name}`));\n            }\n            ctx.connectionManager.close();\n            process.exit(1);\n          }\n          console.log(`Loading constellation \"${constellation.name}\"...`);\n        }\n\n        console.log('Generating graph data...');\n\n        // 1. Fetch Data\n        const nodes = await ctx.nodeRepository.findAll();\n        const edges = await ctx.edgeRepository.findAll();\n        const ghostNodeData = await ctx.unresolvedLinkRepository.getGhostNodesWithRecency();\n\n        // 2. Calculate degree centrality\n        const nodeWeights = new Map<string, number>();\n        edges.forEach((e) => {\n          nodeWeights.set(e.sourceId, (nodeWeights.get(e.sourceId) || 0) + 1);\n          nodeWeights.set(e.targetId, (nodeWeights.get(e.targetId) || 0) + 1);\n        });\n\n        // 3. Prepare Graph Data Structure\n        const graphNodes: GraphNode[] = nodes.map((n) => ({\n          id: n.nodeId,\n          name: n.title,\n          type: n.type,\n          val: Math.max(1, Math.min(10, (nodeWeights.get(n.nodeId) || 0) / 2)),\n          color: typeColors[n.type] || '#94a3b8',\n          path: n.path,\n          metadata: n.metadata as Record<string, unknown>,\n          updatedAtMs: n.updatedAt ? new Date(n.updatedAt).getTime() : undefined,\n        }));\n\n        // Filter edges based on visualization mode (focus vs classic)\n        const vizMode = ctx.config.visualization.mode;\n        const filteredEdges = edges.filter((e) =>\n          shouldRenderEdge(e.edgeType as EdgeType, vizMode)\n        );\n\n        if (vizMode === 'focus' && edges.length !== filteredEdges.length) {\n          console.log(\n            `Focus mode: showing ${filteredEdges.length}/${edges.length} edges (Layer C edges hidden)`\n          );\n        }\n\n        const graphLinks: GraphLink[] = filteredEdges.map((e) => ({\n          source: e.sourceId,\n          target: e.targetId,\n          type: e.edgeType,\n          strength: e.strength ?? 1.0,\n          provenance: e.provenance,\n        }));\n\n        // 4. Add ghost nodes (unresolved links)\n        const nodeIdSet = new Set(nodes.map((n) => n.nodeId));\n        for (const ghost of ghostNodeData) {\n          // Skip if target text is empty\n          if (!ghost.targetText.trim()) continue;\n\n          const ghostId = `ghost:${ghost.targetText}`;\n\n          // Create ghost node\n          graphNodes.push({\n            id: ghostId,\n            name: ghost.targetText,\n            type: 'ghost',\n            val: Math.max(1, Math.min(5, ghost.referenceCount)),\n            color: typeColors['ghost'] ?? '#64748b',\n            path: '',\n            metadata: {\n              referenceCount: ghost.referenceCount,\n              firstSeen: ghost.firstSeen,\n            },\n            isGhost: true,\n            sourceIds: ghost.sourceIds.filter((id) => nodeIdSet.has(id)),\n            referenceCount: ghost.referenceCount,\n            mostRecentRef: ghost.mostRecentRef,\n          });\n\n          // Create edges from source nodes to ghost\n          for (const sourceId of ghost.sourceIds) {\n            if (nodeIdSet.has(sourceId)) {\n              graphLinks.push({\n                source: sourceId,\n                target: ghostId,\n                type: 'ghost_ref',\n                strength: 0.3,\n                provenance: 'unresolved_link',\n              });\n            }\n          }\n        }\n\n        const graphData: GraphData = {\n          nodes: graphNodes,\n          links: graphLinks,\n        };\n\n        if (ghostNodeData.length > 0) {\n          console.log(`Found ${ghostNodeData.length} unresolved links (ghost nodes)`);\n        }\n\n        // 5. Compute paths if requested\n        let computedPathData: PathData | null = null;\n        if (options.pathFrom && options.pathTo) {\n          console.log('Computing paths...');\n\n          // Resolve from node\n          let fromNode = await ctx.nodeRepository.findByPath(options.pathFrom);\n          if (!fromNode) {\n            const byTitle = await ctx.nodeRepository.findByTitle(options.pathFrom);\n            fromNode = byTitle[0] ?? null;\n          }\n          if (!fromNode) {\n            const byAlias = await ctx.nodeRepository.findByTitleOrAlias(options.pathFrom);\n            fromNode = byAlias[0] ?? null;\n          }\n\n          // Resolve to node\n          let toNode = await ctx.nodeRepository.findByPath(options.pathTo);\n          if (!toNode) {\n            const byTitle = await ctx.nodeRepository.findByTitle(options.pathTo);\n            toNode = byTitle[0] ?? null;\n          }\n          if (!toNode) {\n            const byAlias = await ctx.nodeRepository.findByTitleOrAlias(options.pathTo);\n            toNode = byAlias[0] ?? null;\n          }\n\n          if (fromNode && toNode) {\n            const k = parseInt(options.pathK || '3', 10);\n            const { paths } = await ctx.graphEngine.findKShortestPaths(\n              fromNode.nodeId,\n              toNode.nodeId,\n              { k, edgeTypes: ['explicit_link', 'sequence', 'causes', 'semantic'] }\n            );\n\n            if (paths.length > 0) {\n              computedPathData = {\n                paths: paths.map((p) => ({\n                  path: p.path,\n                  edges: p.edges,\n                  hopCount: p.hopCount,\n                  score: p.score,\n                })),\n                fromId: fromNode.nodeId,\n                toId: toNode.nodeId,\n                fromLabel: fromNode.title,\n                toLabel: toNode.title,\n              };\n              console.log(\n                `Found ${paths.length} path(s) from \"${fromNode.title}\" to \"${toNode.title}\"`\n              );\n            } else {\n              console.log(`No paths found from \"${fromNode.title}\" to \"${toNode.title}\"`);\n            }\n          } else {\n            if (!fromNode) console.error(`Could not find node: \"${options.pathFrom}\"`);\n            if (!toNode) console.error(`Could not find node: \"${options.pathTo}\"`);\n          }\n        }\n\n        // 6. Start WebSocket server if live mode enabled\n        let wsConfig: WebSocketConfig | null = null;\n        let wsServer: VisualizeServer | null = null;\n\n        if (options.live) {\n          console.log('Starting live update server...');\n          const { server, info } = await createVisualizeServer(ctx, {\n            onClose: () => {\n              console.log('\\nBrowser disconnected. Server stopped.');\n              ctx.connectionManager.close();\n              process.exit(0);\n            },\n          });\n          wsServer = server;\n          wsConfig = {\n            enabled: true,\n            port: info.port,\n            token: info.token,\n            protocolVersion: PROTOCOL_VERSION,\n          };\n          console.log(`Live updates enabled on port ${info.port}`);\n        }\n\n        // 7. Compute health stats for status panel\n        const statusData = await computeDoctorStats(ctx);\n\n        // 8. Generate HTML\n        const htmlContent = generateVisualizationHtml(\n          graphData,\n          typeColors,\n          constellation,\n          computedPathData,\n          wsConfig,\n          statusData\n        );\n\n        // 9. Write Output\n        const outputDir = options.output\n          ? path.dirname(options.output)\n          : getZettelScriptDir(ctx.vaultPath);\n\n        if (!fs.existsSync(outputDir)) {\n          fs.mkdirSync(outputDir, { recursive: true });\n        }\n\n        const outputPath = options.output || path.join(outputDir, 'graph.html');\n        fs.writeFileSync(outputPath, htmlContent, 'utf-8');\n\n        console.log(`\\nGraph visualization generated at: ${outputPath}`);\n\n        // 10. Open Browser\n        if (options.open) {\n          console.log('Opening in default browser...');\n          await open(outputPath);\n        }\n\n        // 11. Keep process alive if live mode, otherwise close\n        if (options.live && wsServer) {\n          console.log('\\nLive mode active. Press Ctrl+C to stop.');\n\n          // Handle graceful shutdown\n          const shutdown = async () => {\n            console.log('\\nShutting down...');\n            if (wsServer) {\n              await wsServer.stop();\n            }\n            ctx.connectionManager.close();\n            process.exit(0);\n          };\n\n          process.on('SIGINT', shutdown);\n          process.on('SIGTERM', shutdown);\n\n          // Keep process alive\n          await new Promise(() => {});\n        } else {\n          ctx.connectionManager.close();\n        }\n      } catch (error) {\n        console.error('Visualization failed:', error);\n        process.exit(1);\n      }\n    }\n  );\n","/**\n * WebSocket Server for Ghost Nodes v2\n *\n * Provides live graph updates for the visualizer, enabling seamless\n * ghost node creation without page reload.\n */\n\nimport { createServer, type Server, type IncomingMessage } from 'node:http';\nimport { WebSocketServer, WebSocket, type RawData } from 'ws';\nimport { nanoid } from 'nanoid';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { stringify as stringifyYaml } from 'yaml';\nimport type { CLIContext } from '../utils.js';\nimport {\n  PROTOCOL_VERSION,\n  parseClientMessage,\n  serializeServerMessage,\n  isValidPath,\n  generateToken,\n  generateSessionNonce,\n  type ServerToClientMessage,\n  type HelloMessage,\n  type CreateFromGhostMessage,\n  type SyncRequestMessage,\n  type PatchOp,\n  type GhostNodeInfo,\n} from './ws-protocol.js';\n\n// Token validity period (10 minutes)\nconst TOKEN_VALIDITY_MS = 10 * 60 * 1000;\n\n// Grace period for reconnection after disconnect\nconst RECONNECT_GRACE_MS = 30 * 1000;\n\nexport interface VisualizeServerOptions {\n  ctx: CLIContext;\n  onClose?: (() => void) | undefined;\n}\n\nexport interface ServerInfo {\n  port: number;\n  token: string;\n  tokenExpiry: number;\n}\n\ninterface ClientSession {\n  ws: WebSocket;\n  sessionId: string;\n  sessionNonce: string;\n  authenticated: boolean;\n  lastActivity: number;\n  patchSeq: number;\n  pendingCreates: Set<string>;\n}\n\n/**\n * WebSocket server for live graph updates\n */\nexport class VisualizeServer {\n  private server: Server;\n  private wss: WebSocketServer;\n  private ctx: CLIContext;\n  private token: string;\n  private tokenExpiry: number;\n  private sessions: Map<string, ClientSession> = new Map();\n  private recentCreations: Map<string, { newNodeId: string; title: string; createdAt: string }> =\n    new Map();\n  private onClose?: () => void;\n\n  constructor(options: VisualizeServerOptions) {\n    this.ctx = options.ctx;\n    if (options.onClose !== undefined) {\n      this.onClose = options.onClose;\n    }\n\n    // Generate auth token\n    this.token = generateToken();\n    this.tokenExpiry = Date.now() + TOKEN_VALIDITY_MS;\n\n    // Create HTTP server (bound to localhost only)\n    this.server = createServer();\n\n    // Create WebSocket server\n    this.wss = new WebSocketServer({\n      server: this.server,\n      verifyClient: (info, callback) => {\n        const valid = this.verifyClient(info);\n        callback(valid);\n      },\n    });\n\n    this.setupWebSocket();\n  }\n\n  /**\n   * Verify client connection before upgrade\n   */\n  private verifyClient(info: { origin?: string; req: IncomingMessage }): boolean {\n    // Check origin header (allow localhost variants)\n    const origin = info.origin || info.req.headers.origin;\n    if (origin) {\n      const validOrigins = [\n        'file://',\n        'null', // file:// protocol sends \"null\" as origin\n        'http://localhost',\n        'http://127.0.0.1',\n        'https://localhost',\n        'https://127.0.0.1',\n      ];\n\n      const originValid = validOrigins.some((v) => origin === v || origin.startsWith(v + ':'));\n\n      if (!originValid) {\n        console.error(`[WS] Rejected connection from origin: ${origin}`);\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Set up WebSocket event handlers\n   */\n  private setupWebSocket(): void {\n    this.wss.on('connection', (ws, req) => {\n      const clientAddr = req.socket.remoteAddress;\n      console.log(`[WS] New connection from ${clientAddr}`);\n\n      // Create pending session\n      const sessionId = nanoid();\n      const session: ClientSession = {\n        ws,\n        sessionId,\n        sessionNonce: '',\n        authenticated: false,\n        lastActivity: Date.now(),\n        patchSeq: 0,\n        pendingCreates: new Set(),\n      };\n\n      this.sessions.set(sessionId, session);\n\n      ws.on('message', (data) => {\n        this.handleMessage(sessionId, data);\n      });\n\n      ws.on('close', () => {\n        console.log(`[WS] Connection closed: ${sessionId}`);\n        this.sessions.delete(sessionId);\n\n        // If no sessions left, trigger onClose after grace period\n        if (this.sessions.size === 0) {\n          setTimeout(() => {\n            if (this.sessions.size === 0 && this.onClose) {\n              this.onClose();\n            }\n          }, RECONNECT_GRACE_MS);\n        }\n      });\n\n      ws.on('error', (err) => {\n        console.error(`[WS] Error on session ${sessionId}:`, err);\n      });\n\n      // Set a timeout for authentication\n      setTimeout(() => {\n        const s = this.sessions.get(sessionId);\n        if (s && !s.authenticated) {\n          console.log(`[WS] Auth timeout for session ${sessionId}`);\n          ws.close(4001, 'Authentication timeout');\n          this.sessions.delete(sessionId);\n        }\n      }, 10000);\n    });\n  }\n\n  /**\n   * Handle incoming WebSocket message\n   */\n  private handleMessage(sessionId: string, data: RawData): void {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    const message = parseClientMessage(data.toString());\n    if (!message) {\n      this.sendError(session, 'Invalid message format');\n      return;\n    }\n\n    session.lastActivity = Date.now();\n\n    switch (message.type) {\n      case 'hello':\n        this.handleHello(session, message);\n        break;\n\n      case 'create_from_ghost':\n        this.handleCreateFromGhost(session, message);\n        break;\n\n      case 'sync_request':\n        this.handleSyncRequest(session, message);\n        break;\n\n      case 'ping':\n        this.send(session, { type: 'pong' });\n        break;\n\n      default:\n        this.sendError(session, `Unknown message type: ${(message as { type: string }).type}`);\n    }\n  }\n\n  /**\n   * Handle hello handshake\n   */\n  private handleHello(session: ClientSession, message: HelloMessage): void {\n    // Check token\n    if (message.token !== this.token) {\n      this.send(session, {\n        type: 'hello_error',\n        error: 'Invalid authentication token',\n        code: 'invalid_token',\n      });\n      session.ws.close(4003, 'Invalid token');\n      return;\n    }\n\n    // Check token expiry\n    if (Date.now() > this.tokenExpiry) {\n      this.send(session, {\n        type: 'hello_error',\n        error: 'Token has expired',\n        code: 'invalid_token',\n      });\n      session.ws.close(4003, 'Token expired');\n      return;\n    }\n\n    // Check protocol version (major version must match)\n    const clientMajor = message.protocolVersion.split('.')[0];\n    const serverMajor = PROTOCOL_VERSION.split('.')[0];\n    if (clientMajor !== serverMajor) {\n      this.send(session, {\n        type: 'hello_error',\n        error: `Protocol version mismatch: server=${PROTOCOL_VERSION}, client=${message.protocolVersion}`,\n        code: 'protocol_mismatch',\n      });\n      session.ws.close(4002, 'Protocol mismatch');\n      return;\n    }\n\n    // Generate session nonce\n    session.sessionNonce = generateSessionNonce();\n    session.authenticated = true;\n\n    console.log(`[WS] Session ${session.sessionId} authenticated`);\n\n    this.send(session, {\n      type: 'hello_ok',\n      protocolVersion: PROTOCOL_VERSION,\n      sessionId: session.sessionId,\n      sessionNonce: session.sessionNonce,\n      features: {\n        ghostCreate: true,\n        patch: true,\n      },\n    });\n  }\n\n  /**\n   * Handle ghost creation request\n   */\n  private async handleCreateFromGhost(\n    session: ClientSession,\n    message: CreateFromGhostMessage\n  ): Promise<void> {\n    // Validate session\n    if (!session.authenticated) {\n      this.sendError(session, 'Not authenticated');\n      return;\n    }\n\n    if (message.sessionNonce !== session.sessionNonce) {\n      this.sendError(session, 'Invalid session nonce');\n      return;\n    }\n\n    // Validate path\n    if (!isValidPath(message.targetFolder)) {\n      this.sendError(session, 'Invalid target folder path', message.ghostId);\n      return;\n    }\n\n    // Prevent duplicate creates\n    if (session.pendingCreates.has(message.ghostId)) {\n      this.sendError(session, 'Create already in progress', message.ghostId);\n      return;\n    }\n\n    session.pendingCreates.add(message.ghostId);\n\n    // Send ack\n    this.send(session, {\n      type: 'create_ack',\n      ghostId: message.ghostId,\n      status: 'pending',\n    });\n\n    try {\n      // Check for existing note with same title\n      const existingNodes = await this.ctx.nodeRepository.findByTitleOrAlias(message.title);\n\n      if (existingNodes.length > 0) {\n        // Link to existing note instead of creating new one\n        const existingNode = existingNodes[0]!;\n        await this.handleLinkToExisting(session, message, existingNode);\n        return;\n      }\n\n      // Create the note\n      await this.createNoteFromGhost(session, message);\n    } catch (error) {\n      console.error(`[WS] Error creating ghost:`, error);\n      this.sendError(\n        session,\n        error instanceof Error ? error.message : 'Unknown error',\n        message.ghostId\n      );\n    } finally {\n      session.pendingCreates.delete(message.ghostId);\n    }\n  }\n\n  /**\n   * Create a new note from a ghost node\n   */\n  private async createNoteFromGhost(\n    session: ClientSession,\n    message: CreateFromGhostMessage\n  ): Promise<void> {\n    const { title, targetFolder, ghostId } = message;\n\n    // Determine output path\n    const folder = targetFolder || '';\n    const filename = this.sanitizeFilename(title) + '.md';\n    const relativePath = folder ? path.join(folder, filename) : filename;\n    const absolutePath = path.join(this.ctx.vaultPath, relativePath);\n\n    // Ensure directory exists\n    const dir = path.dirname(absolutePath);\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n    }\n\n    // Generate stable node ID\n    const nodeId = nanoid();\n    const now = new Date().toISOString();\n\n    // Create frontmatter\n    const frontmatter = {\n      id: nodeId,\n      type: 'note',\n      title: title,\n      created: now,\n    };\n\n    // Create file content\n    const content = `---\\n${stringifyYaml(frontmatter)}---\\n\\n# ${title}\\n\\n`;\n\n    // Write file\n    fs.writeFileSync(absolutePath, content, 'utf-8');\n\n    // Insert node into database\n    const node = await this.ctx.nodeRepository.create({\n      type: 'note',\n      title: title,\n      path: relativePath,\n      createdAt: now,\n      updatedAt: now,\n      metadata: { id: nodeId },\n    });\n\n    // Convert unresolved links to explicit_link edges\n    const convertedEdges = await this.convertUnresolvedLinks(ghostId, node.nodeId, title);\n\n    // Build patch operations\n    const ops: PatchOp[] = [];\n\n    // Node replace operation\n    ops.push({\n      op: 'node_replace',\n      ghostId: ghostId,\n      newNodeId: node.nodeId,\n      label: title,\n      filePath: relativePath,\n      type: 'note',\n      createdAt: now,\n      updatedAt: now,\n    });\n\n    // Edge replace operations\n    for (const edge of convertedEdges) {\n      ops.push({\n        op: 'edge_replace',\n        newEdgeId: edge.edgeId,\n        fromId: edge.sourceId,\n        toId: edge.targetId,\n        type: edge.edgeType,\n      });\n    }\n\n    // Track recent creation\n    this.recentCreations.set(ghostId, {\n      newNodeId: node.nodeId,\n      title: title,\n      createdAt: now,\n    });\n\n    // Send patch to all connected clients\n    this.broadcast({\n      type: 'patch',\n      patchSeq: ++session.patchSeq,\n      ops,\n    });\n\n    // Send success ack\n    this.send(session, {\n      type: 'create_ack',\n      ghostId: ghostId,\n      status: 'success',\n    });\n\n    console.log(`[WS] Created note \"${title}\" at ${relativePath}`);\n  }\n\n  /**\n   * Handle linking ghost to an existing node\n   */\n  private async handleLinkToExisting(\n    session: ClientSession,\n    message: CreateFromGhostMessage,\n    existingNode: {\n      nodeId: string;\n      title: string;\n      path: string;\n      type: string;\n      createdAt: string;\n      updatedAt: string;\n    }\n  ): Promise<void> {\n    const { ghostId, title } = message;\n\n    // Convert unresolved links to explicit_link edges\n    const convertedEdges = await this.convertUnresolvedLinks(ghostId, existingNode.nodeId, title);\n\n    // Build patch operations\n    const ops: PatchOp[] = [];\n\n    // Node replace operation with linkedExisting flag\n    ops.push({\n      op: 'node_replace',\n      ghostId: ghostId,\n      newNodeId: existingNode.nodeId,\n      label: existingNode.title,\n      filePath: existingNode.path,\n      type: existingNode.type,\n      createdAt: existingNode.createdAt,\n      updatedAt: existingNode.updatedAt,\n      linkedExisting: true,\n    });\n\n    // Edge replace operations\n    for (const edge of convertedEdges) {\n      ops.push({\n        op: 'edge_replace',\n        newEdgeId: edge.edgeId,\n        fromId: edge.sourceId,\n        toId: edge.targetId,\n        type: edge.edgeType,\n      });\n    }\n\n    // Track recent creation (even though it's linking to existing)\n    this.recentCreations.set(ghostId, {\n      newNodeId: existingNode.nodeId,\n      title: existingNode.title,\n      createdAt: new Date().toISOString(),\n    });\n\n    // Broadcast patch\n    this.broadcast({\n      type: 'patch',\n      patchSeq: ++session.patchSeq,\n      ops,\n    });\n\n    // Send success ack\n    this.send(session, {\n      type: 'create_ack',\n      ghostId: ghostId,\n      status: 'success',\n    });\n\n    console.log(`[WS] Linked ghost \"${title}\" to existing node \"${existingNode.title}\"`);\n  }\n\n  /**\n   * Convert unresolved links for a ghost to explicit_link edges\n   */\n  private async convertUnresolvedLinks(\n    ghostId: string,\n    targetNodeId: string,\n    targetText: string\n  ): Promise<Array<{ edgeId: string; sourceId: string; targetId: string; edgeType: string }>> {\n    const edges: Array<{ edgeId: string; sourceId: string; targetId: string; edgeType: string }> =\n      [];\n\n    // Get unresolved links for this target text\n    const ghostNodes = await this.ctx.unresolvedLinkRepository.getGhostNodes();\n    const ghostNode = ghostNodes.find(\n      (g) =>\n        `ghost:${g.targetText}` === ghostId ||\n        g.targetText.toLowerCase() === targetText.toLowerCase()\n    );\n\n    if (!ghostNode) {\n      return edges;\n    }\n\n    // Create explicit_link edges for each source\n    for (const sourceId of ghostNode.sourceIds) {\n      const edge = await this.ctx.edgeRepository.create({\n        sourceId: sourceId,\n        targetId: targetNodeId,\n        edgeType: 'explicit_link',\n        provenance: 'explicit',\n        attributes: {\n          convertedFrom: 'unresolved_link',\n          originalGhostId: ghostId,\n        },\n      });\n\n      edges.push({\n        edgeId: edge.edgeId,\n        sourceId: edge.sourceId,\n        targetId: edge.targetId,\n        edgeType: edge.edgeType,\n      });\n    }\n\n    // Note: We don't delete unresolved_links here as the background indexer\n    // will handle that on the next reindex. This ensures eventual consistency.\n\n    return edges;\n  }\n\n  /**\n   * Handle sync request (for reconnection)\n   */\n  private async handleSyncRequest(\n    session: ClientSession,\n    message: SyncRequestMessage\n  ): Promise<void> {\n    if (!session.authenticated) {\n      this.sendError(session, 'Not authenticated');\n      return;\n    }\n\n    if (message.sessionNonce !== session.sessionNonce) {\n      this.sendError(session, 'Invalid session nonce');\n      return;\n    }\n\n    // Get current unresolved links\n    const ghostNodes = await this.ctx.unresolvedLinkRepository.getGhostNodes();\n\n    const unresolvedList: GhostNodeInfo[] = ghostNodes.map((g) => ({\n      ghostId: `ghost:${g.targetText}`,\n      title: g.targetText,\n      referenceCount: g.referenceCount,\n      sourceIds: g.sourceIds,\n      firstSeen: g.firstSeen,\n    }));\n\n    // Get recent creations from this session\n    const recentCreations = Array.from(this.recentCreations.entries()).map(([ghostId, info]) => ({\n      ghostId,\n      newNodeId: info.newNodeId,\n      title: info.title,\n      createdAt: info.createdAt,\n    }));\n\n    this.send(session, {\n      type: 'sync_response',\n      unresolvedList,\n      recentCreations,\n    });\n  }\n\n  /**\n   * Sanitize a filename\n   */\n  private sanitizeFilename(name: string): string {\n    return name\n      .replace(/[<>:\"/\\\\|?*]/g, '') // Remove invalid characters\n      .replace(/\\s+/g, ' ') // Normalize whitespace\n      .trim()\n      .slice(0, 200); // Limit length\n  }\n\n  /**\n   * Send a message to a specific session\n   */\n  private send(session: ClientSession, message: ServerToClientMessage): void {\n    if (session.ws.readyState === WebSocket.OPEN) {\n      session.ws.send(serializeServerMessage(message));\n    }\n  }\n\n  /**\n   * Send an error message\n   */\n  private sendError(session: ClientSession, message: string, ghostId?: string): void {\n    const errorMsg: { type: 'error'; message: string; ghostId?: string } = {\n      type: 'error',\n      message,\n    };\n    if (ghostId !== undefined) {\n      errorMsg.ghostId = ghostId;\n    }\n    this.send(session, errorMsg);\n  }\n\n  /**\n   * Broadcast a message to all authenticated sessions\n   */\n  private broadcast(message: ServerToClientMessage): void {\n    for (const session of this.sessions.values()) {\n      if (session.authenticated) {\n        this.send(session, message);\n      }\n    }\n  }\n\n  /**\n   * Start the server\n   */\n  async start(): Promise<ServerInfo> {\n    return new Promise((resolve, reject) => {\n      // Bind to localhost only on port 0 for auto-selection\n      this.server.listen(0, '127.0.0.1', () => {\n        const addr = this.server.address();\n        if (typeof addr === 'object' && addr) {\n          const port = addr.port;\n          console.log(`[WS] Server listening on 127.0.0.1:${port}`);\n          resolve({\n            port,\n            token: this.token,\n            tokenExpiry: this.tokenExpiry,\n          });\n        } else {\n          reject(new Error('Failed to get server address'));\n        }\n      });\n\n      this.server.on('error', (err) => {\n        reject(err);\n      });\n    });\n  }\n\n  /**\n   * Stop the server\n   */\n  async stop(): Promise<void> {\n    return new Promise((resolve) => {\n      // Close all WebSocket connections\n      for (const session of this.sessions.values()) {\n        session.ws.close(1000, 'Server shutting down');\n      }\n      this.sessions.clear();\n\n      // Close WebSocket server\n      this.wss.close(() => {\n        // Close HTTP server\n        this.server.close(() => {\n          console.log('[WS] Server stopped');\n          resolve();\n        });\n      });\n    });\n  }\n\n  /**\n   * Refresh the auth token\n   */\n  refreshToken(): string {\n    this.token = generateToken();\n    this.tokenExpiry = Date.now() + TOKEN_VALIDITY_MS;\n    return this.token;\n  }\n}\n\n/**\n * Create and start a visualize server\n */\nexport async function createVisualizeServer(\n  ctx: CLIContext,\n  options?: { onClose?: () => void }\n): Promise<{ server: VisualizeServer; info: ServerInfo }> {\n  const server = new VisualizeServer({\n    ctx,\n    onClose: options?.onClose,\n  });\n\n  const info = await server.start();\n  return { server, info };\n}\n","/**\n * WebSocket Protocol Types for Ghost Nodes v2\n *\n * Defines the message format for communication between the visualizer\n * client (browser) and the ZettelScript server.\n */\n\nimport { randomBytes } from 'node:crypto';\n\n// Protocol version for compatibility checking\nexport const PROTOCOL_VERSION = '1.0.0';\n\n// ============================================================================\n// Base Message Types\n// ============================================================================\n\nexport interface BaseMessage {\n  type: string;\n}\n\nexport interface ClientMessage extends BaseMessage {\n  sessionNonce?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface ServerMessage extends BaseMessage {}\n\n// ============================================================================\n// Handshake Messages\n// ============================================================================\n\nexport interface HelloMessage extends ClientMessage {\n  type: 'hello';\n  protocolVersion: string;\n  atlasVersion: string;\n  token: string;\n}\n\nexport interface HelloOkMessage extends ServerMessage {\n  type: 'hello_ok';\n  protocolVersion: string;\n  sessionId: string;\n  sessionNonce: string;\n  features: {\n    ghostCreate: boolean;\n    patch: boolean;\n  };\n}\n\nexport interface HelloErrorMessage extends ServerMessage {\n  type: 'hello_error';\n  error: string;\n  code: 'invalid_token' | 'protocol_mismatch' | 'origin_mismatch';\n}\n\n// ============================================================================\n// Ghost Creation Messages\n// ============================================================================\n\nexport interface CreateFromGhostMessage extends ClientMessage {\n  type: 'create_from_ghost';\n  sessionNonce: string;\n  ghostId: string;\n  title: string;\n  sourceNodeId: string;\n  targetFolder?: string;\n  templateName?: string;\n}\n\nexport interface CreateAckMessage extends ServerMessage {\n  type: 'create_ack';\n  ghostId: string;\n  status: 'pending' | 'success' | 'error';\n}\n\n// ============================================================================\n// Patch Messages\n// ============================================================================\n\nexport type PatchOp = NodeReplaceOp | EdgeReplaceOp | NodeRemoveOp | EdgeRemoveOp;\n\nexport interface NodeReplaceOp {\n  op: 'node_replace';\n  ghostId: string;\n  newNodeId: string;\n  label: string;\n  filePath: string;\n  type: string;\n  createdAt: string;\n  updatedAt: string;\n  linkedExisting?: boolean;\n}\n\nexport interface EdgeReplaceOp {\n  op: 'edge_replace';\n  oldEdgeId?: string;\n  newEdgeId: string;\n  fromId: string;\n  toId: string;\n  type: string;\n}\n\nexport interface NodeRemoveOp {\n  op: 'node_remove';\n  nodeId: string;\n}\n\nexport interface EdgeRemoveOp {\n  op: 'edge_remove';\n  edgeId: string;\n}\n\nexport interface PatchMessage extends ServerMessage {\n  type: 'patch';\n  patchSeq: number;\n  ops: PatchOp[];\n}\n\n// ============================================================================\n// Error & Progress Messages\n// ============================================================================\n\nexport interface ErrorMessage extends ServerMessage {\n  type: 'error';\n  ghostId?: string;\n  message: string;\n  code?: string;\n}\n\nexport interface IndexProgressMessage extends ServerMessage {\n  type: 'index_progress';\n  phase: 'creating' | 'indexing' | 'complete';\n  percent: number;\n}\n\n// ============================================================================\n// Sync Messages (for reconnection)\n// ============================================================================\n\nexport interface SyncRequestMessage extends ClientMessage {\n  type: 'sync_request';\n  sessionNonce: string;\n}\n\nexport interface SyncResponseMessage extends ServerMessage {\n  type: 'sync_response';\n  unresolvedList: GhostNodeInfo[];\n  recentCreations: RecentCreation[];\n}\n\nexport interface GhostNodeInfo {\n  ghostId: string;\n  title: string;\n  referenceCount: number;\n  sourceIds: string[];\n  firstSeen: string;\n  mostRecentRef?: string;\n}\n\nexport interface RecentCreation {\n  ghostId: string;\n  newNodeId: string;\n  title: string;\n  createdAt: string;\n}\n\n// ============================================================================\n// Connection Status Messages\n// ============================================================================\n\nexport interface PingMessage extends ClientMessage {\n  type: 'ping';\n}\n\nexport interface PongMessage extends ServerMessage {\n  type: 'pong';\n}\n\n// ============================================================================\n// Union Types\n// ============================================================================\n\nexport type ClientToServerMessage =\n  | HelloMessage\n  | CreateFromGhostMessage\n  | SyncRequestMessage\n  | PingMessage;\n\nexport type ServerToClientMessage =\n  | HelloOkMessage\n  | HelloErrorMessage\n  | CreateAckMessage\n  | PatchMessage\n  | ErrorMessage\n  | IndexProgressMessage\n  | SyncResponseMessage\n  | PongMessage;\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Parse a client message from JSON string\n */\nexport function parseClientMessage(data: string): ClientToServerMessage | null {\n  try {\n    const parsed = JSON.parse(data);\n    if (typeof parsed !== 'object' || !parsed.type) {\n      return null;\n    }\n    return parsed as ClientToServerMessage;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Serialize a server message to JSON string\n */\nexport function serializeServerMessage(message: ServerToClientMessage): string {\n  return JSON.stringify(message);\n}\n\n/**\n * Validate that a path does not contain path traversal attempts\n */\nexport function isValidPath(targetFolder: string | undefined): boolean {\n  if (!targetFolder) return true;\n\n  // Reject absolute paths\n  if (targetFolder.startsWith('/') || /^[a-zA-Z]:/.test(targetFolder)) {\n    return false;\n  }\n\n  // Reject path traversal\n  if (targetFolder.includes('..')) {\n    return false;\n  }\n\n  // Reject hidden directories\n  if (targetFolder.startsWith('.') || targetFolder.includes('/.')) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Generate a cryptographically secure token\n */\nexport function generateToken(): string {\n  return randomBytes(32).toString('hex');\n}\n\n/**\n * Generate a session nonce\n */\nexport function generateSessionNonce(): string {\n  return randomBytes(16).toString('hex');\n}\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { dirname } from 'node:path';\nimport { initContext, getZettelScriptDir, getDbPath } from '../utils.js';\nimport type { CLIContext } from '../utils.js';\nimport { getEdgeLayer, type EdgeType } from '../../core/types/index.js';\nimport { getCircuitBreaker, CircuitState } from '../../core/circuit-breaker.js';\n\n// ============================================================================\n// Version from package.json\n// ============================================================================\n\nexport function getVersionFromPath(packageJsonPath: string): string {\n  try {\n    const content = fs.readFileSync(packageJsonPath, 'utf-8');\n    const pkg = JSON.parse(content) as { version?: string };\n    return pkg.version ?? 'unknown';\n  } catch {\n    return 'unknown';\n  }\n}\n\nexport function getVersion(): string {\n  const __filename = fileURLToPath(import.meta.url);\n  const __dirname = dirname(__filename);\n  const packageJsonPath = path.join(__dirname, '..', '..', '..', 'package.json');\n  return getVersionFromPath(packageJsonPath);\n}\n\n// ============================================================================\n// Health Status Types (reusable by Atlas and other commands)\n// ============================================================================\n\nexport type HealthLevel = 'ok' | 'warn' | 'fail';\n\nexport interface EmbeddingHealth {\n  level: HealthLevel;\n  total: number;\n  embedded: number;\n  coverage: number; // 0-100\n  pending: number;\n  errorCount: number;\n  lastError?: string;\n  model?: string;\n}\n\nexport interface WormholeHealth {\n  enabled: boolean;\n  count: number;\n  threshold: number;\n  disabledReason?: string;\n}\n\nexport interface IndexHealth {\n  lastIndexTime?: Date;\n  nodeCount: number;\n  edgeCount: number;\n  edgesByLayer: { A: number; B: number; C: number };\n  dbPath: string;\n  dbSizeBytes: number;\n}\n\nexport interface ExtractionHealth {\n  badChunksPath?: string;\n  parseFailCount: number;\n}\n\nexport interface VisualizationHealth {\n  mode: 'focus' | 'classic';\n  filteredEdgeCount: number;\n  totalEdgeCount: number;\n}\n\nexport interface DoctorStats {\n  version: string;\n  vaultPath: string;\n  overallLevel: HealthLevel;\n  index: IndexHealth;\n  embeddings: EmbeddingHealth;\n  wormholes: WormholeHealth;\n  extraction: ExtractionHealth;\n  visualization: VisualizationHealth;\n}\n\n// ============================================================================\n// Health Thresholds (per DESIGN.md)\n// ============================================================================\n\nconst EMBEDDING_OK_THRESHOLD = 95; // >= 95% = OK\nconst EMBEDDING_WARN_THRESHOLD = 60; // 60-95% = WARN, < 60% = FAIL\n\n/**\n * Compute embedding health level based on coverage percentage.\n */\nexport function getEmbeddingHealthLevel(coverage: number): HealthLevel {\n  if (coverage >= EMBEDDING_OK_THRESHOLD) return 'ok';\n  if (coverage >= EMBEDDING_WARN_THRESHOLD) return 'warn';\n  return 'fail';\n}\n\n// ============================================================================\n// Stats Computation (reusable)\n// ============================================================================\n\n/**\n * Compute comprehensive health stats for a vault.\n * This is the canonical source of truth for health data.\n */\nexport async function computeDoctorStats(ctx: CLIContext): Promise<DoctorStats> {\n  const { vaultPath, config, nodeRepository, edgeRepository, embeddingRepository } = ctx;\n\n  // Index stats\n  const nodeCount = await nodeRepository.count();\n  const edgeCount = await edgeRepository.count();\n  const edgesByType = await edgeRepository.countByType();\n\n  // Categorize edges by layer\n  const edgesByLayer = { A: 0, B: 0, C: 0 };\n  for (const [edgeType, count] of Object.entries(edgesByType)) {\n    const layer = getEdgeLayer(edgeType as EdgeType);\n    if (layer === 'A') edgesByLayer.A += count;\n    else if (layer === 'B') edgesByLayer.B += count;\n    else if (layer === 'C') edgesByLayer.C += count;\n  }\n\n  // Get db file stats\n  const dbPath = getDbPath(vaultPath);\n  let dbSizeBytes = 0;\n  try {\n    const stat = fs.statSync(dbPath);\n    dbSizeBytes = stat.size;\n  } catch {\n    // DB might not exist yet\n  }\n\n  // Embedding stats\n  const embeddingCount = await embeddingRepository.count();\n  const embeddingCoverage = nodeCount > 0 ? (embeddingCount / nodeCount) * 100 : 0;\n  const embeddingLevel = getEmbeddingHealthLevel(embeddingCoverage);\n  const pendingEmbeddings = await embeddingRepository.findDirtyNodeIds();\n\n  // Get model info\n  let embeddingModel: string | undefined;\n  const byModel = await embeddingRepository.countByModel();\n  const models = Object.keys(byModel);\n  if (models.length > 0) {\n    embeddingModel = models[0];\n  }\n\n  // Wormhole stats\n  const wormholeCount = edgesByType['semantic'] || 0;\n  const wormholeThreshold = 0.75; // Default threshold from wormhole command\n  let wormholeDisabledReason: string | undefined;\n  if (embeddingLevel === 'fail') {\n    wormholeDisabledReason = 'Insufficient embeddings';\n  } else if (embeddingCount === 0) {\n    wormholeDisabledReason = 'No embeddings computed';\n  }\n\n  // Extraction stats - check for bad-chunks file\n  const zettelDir = getZettelScriptDir(vaultPath);\n  const badChunksPath = path.join(zettelDir, 'extract-bad-chunks.jsonl');\n  let parseFailCount = 0;\n  if (fs.existsSync(badChunksPath)) {\n    try {\n      const content = fs.readFileSync(badChunksPath, 'utf-8');\n      parseFailCount = content.split('\\n').filter((line) => line.trim()).length;\n    } catch {\n      // Ignore read errors\n    }\n  }\n\n  // Visualization stats\n  const vizMode = config.visualization.mode;\n  let filteredEdgeCount = edgesByLayer.A + edgesByLayer.B;\n  if (vizMode === 'classic') {\n    filteredEdgeCount = edgeCount;\n  }\n\n  // Compute overall health level\n  let overallLevel: HealthLevel = 'ok';\n  if (embeddingLevel === 'fail' || parseFailCount > 10) {\n    overallLevel = 'fail';\n  } else if (embeddingLevel === 'warn' || parseFailCount > 0) {\n    overallLevel = 'warn';\n  }\n\n  return {\n    version: getVersion(),\n    vaultPath,\n    overallLevel,\n    index: {\n      nodeCount,\n      edgeCount,\n      edgesByLayer,\n      dbPath,\n      dbSizeBytes,\n    },\n    embeddings: {\n      level: embeddingLevel,\n      total: nodeCount,\n      embedded: embeddingCount,\n      coverage: embeddingCoverage,\n      pending: pendingEmbeddings.length,\n      errorCount: getCircuitBreaker().getStatus('embeddings').totalFailures,\n      model: embeddingModel,\n    },\n    wormholes: {\n      enabled: !wormholeDisabledReason,\n      count: wormholeCount,\n      threshold: wormholeThreshold,\n      disabledReason: wormholeDisabledReason,\n    },\n    extraction: {\n      badChunksPath: parseFailCount > 0 ? badChunksPath : undefined,\n      parseFailCount,\n    },\n    visualization: {\n      mode: vizMode,\n      filteredEdgeCount,\n      totalEdgeCount: edgeCount,\n    },\n  };\n}\n\n// ============================================================================\n// CLI Output Formatting\n// ============================================================================\n\nfunction formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n}\n\nfunction levelIcon(level: HealthLevel): string {\n  switch (level) {\n    case 'ok':\n      return '';\n    case 'warn':\n      return '';\n    case 'fail':\n      return '';\n  }\n}\n\nfunction levelColor(level: HealthLevel): string {\n  switch (level) {\n    case 'ok':\n      return '\\x1b[32m'; // green\n    case 'warn':\n      return '\\x1b[33m'; // yellow\n    case 'fail':\n      return '\\x1b[31m'; // red\n  }\n}\n\nconst RESET = '\\x1b[0m';\nconst DIM = '\\x1b[2m';\n\nfunction printStats(stats: DoctorStats): void {\n  console.log('');\n  console.log('ZettelScript Health Check');\n  console.log('');\n  console.log('');\n\n  // Index section\n  console.log(`${DIM}Index${RESET}`);\n  console.log(`  Nodes:       ${stats.index.nodeCount}`);\n  console.log(\n    `  Edges:       ${stats.index.edgeCount} (A: ${stats.index.edgesByLayer.A}, B: ${stats.index.edgesByLayer.B}, C: ${stats.index.edgesByLayer.C})`\n  );\n  console.log(`  Database:    ${formatBytes(stats.index.dbSizeBytes)}`);\n  console.log('');\n\n  // Embeddings section\n  const embColor = levelColor(stats.embeddings.level);\n  const embIcon = levelIcon(stats.embeddings.level);\n  console.log(`${DIM}Embeddings${RESET}`);\n  console.log(\n    `  Coverage:    ${embColor}${stats.embeddings.embedded}/${stats.embeddings.total} (${stats.embeddings.coverage.toFixed(0)}%) ${embIcon}${RESET}`\n  );\n  if (stats.embeddings.pending > 0) {\n    console.log(`  Pending:     ${stats.embeddings.pending} nodes`);\n  }\n  if (stats.embeddings.model) {\n    console.log(`  Model:       ${stats.embeddings.model}`);\n  }\n  if (stats.embeddings.level !== 'ok') {\n    console.log(`  ${DIM}Run: zs embed compute${RESET}`);\n  }\n  console.log('');\n\n  // Wormholes section\n  console.log(`${DIM}Wormholes${RESET}`);\n  if (stats.wormholes.enabled) {\n    console.log(`  Status:      \\x1b[32menabled\\x1b[0m`);\n    console.log(`  Count:       ${stats.wormholes.count} edges`);\n    console.log(`  Threshold:   ${stats.wormholes.threshold}`);\n  } else {\n    console.log(`  Status:      \\x1b[33mdisabled\\x1b[0m (${stats.wormholes.disabledReason})`);\n    console.log(`  ${DIM}Run: zs embed compute && zs wormhole detect${RESET}`);\n  }\n  console.log('');\n\n  // Extraction section\n  if (stats.extraction.parseFailCount > 0) {\n    console.log(`${DIM}Extraction${RESET}`);\n    console.log(`  Parse fails: \\x1b[33m${stats.extraction.parseFailCount}\\x1b[0m`);\n    if (stats.extraction.badChunksPath) {\n      console.log(`  Log:         ${stats.extraction.badChunksPath}`);\n    }\n    console.log(`  ${DIM}Run: zs extract --retry-failed${RESET}`);\n    console.log('');\n  }\n\n  // Visualization section\n  console.log(`${DIM}Visualization${RESET}`);\n  console.log(`  Mode:        ${stats.visualization.mode}`);\n  if (stats.visualization.mode === 'focus') {\n    const hidden = stats.visualization.totalEdgeCount - stats.visualization.filteredEdgeCount;\n    console.log(\n      `  Visible:     ${stats.visualization.filteredEdgeCount}/${stats.visualization.totalEdgeCount} edges (${hidden} Layer C hidden)`\n    );\n  }\n  console.log('');\n\n  // Circuit breaker section\n  const circuitBreaker = getCircuitBreaker();\n  const allStatus = circuitBreaker.getAllStatus();\n  const subsystems = Object.keys(allStatus) as Array<keyof typeof allStatus>;\n\n  if (subsystems.length > 0) {\n    console.log(`${DIM}Circuit Breakers${RESET}`);\n    for (const subsystem of subsystems) {\n      const status = allStatus[subsystem];\n      let stateColor: string;\n      let stateIcon: string;\n\n      switch (status.state) {\n        case CircuitState.CLOSED:\n          stateColor = '\\x1b[32m'; // green\n          stateIcon = '';\n          break;\n        case CircuitState.HALF_OPEN:\n          stateColor = '\\x1b[33m'; // yellow\n          stateIcon = '';\n          break;\n        case CircuitState.OPEN:\n          stateColor = '\\x1b[31m'; // red\n          stateIcon = '';\n          break;\n      }\n\n      console.log(`  ${subsystem}: ${stateColor}${status.state} ${stateIcon}${RESET}`);\n\n      if (status.state === CircuitState.OPEN) {\n        if (status.lastError) {\n          console.log(`    Error:     ${status.lastError}`);\n        }\n        if (status.cooldownRemainingMs !== null) {\n          const cooldownSeconds = Math.ceil(status.cooldownRemainingMs / 1000);\n          const cooldownMinutes = Math.floor(cooldownSeconds / 60);\n          const remainingSeconds = cooldownSeconds % 60;\n          const timeStr =\n            cooldownMinutes > 0\n              ? `${cooldownMinutes}m ${remainingSeconds}s`\n              : `${cooldownSeconds}s`;\n          console.log(`    Cooldown:  ${timeStr} remaining`);\n        }\n        // Actionable fix for embeddings\n        if (subsystem === 'embeddings') {\n          console.log(`    ${DIM}Run: zs embed compute${RESET}`);\n        }\n      }\n    }\n    console.log('');\n  }\n\n  // Summary\n  const overallColor = levelColor(stats.overallLevel);\n  const overallIcon = levelIcon(stats.overallLevel);\n  console.log('');\n  console.log(`Overall: ${overallColor}${stats.overallLevel.toUpperCase()} ${overallIcon}${RESET}`);\n  console.log('');\n}\n\n/**\n * Print a one-line embedding status summary (for use in other commands).\n */\nexport function printEmbeddingStatus(stats: DoctorStats): void {\n  const { embeddings } = stats;\n  const color = levelColor(embeddings.level);\n\n  let line = `Embeddings: ${color}${embeddings.level.toUpperCase()}${RESET} (${embeddings.coverage.toFixed(0)}% in view)`;\n\n  if (embeddings.pending > 0) {\n    line += `, ${embeddings.pending} pending`;\n  }\n\n  if (embeddings.level === 'fail') {\n    line += `. Run: zs embed compute`;\n  }\n\n  console.log(line);\n}\n\n/**\n * Print wormhole status if there's a problem.\n */\nexport function printWormholeStatus(stats: DoctorStats): void {\n  if (!stats.wormholes.enabled && stats.embeddings.level !== 'ok') {\n    console.log(\n      `\\x1b[33mWormholes disabled in view (${stats.wormholes.disabledReason}). See: zs doctor\\x1b[0m`\n    );\n  }\n}\n\n// ============================================================================\n// Command Definition\n// ============================================================================\n\nexport const doctorCommand = new Command('doctor')\n  .description('Check vault health and diagnose issues')\n  .option('--json', 'Output as JSON')\n  .action(async (options: { json?: boolean }) => {\n    try {\n      const ctx = await initContext();\n      const stats = await computeDoctorStats(ctx);\n\n      if (options.json) {\n        console.log(JSON.stringify(stats, null, 2));\n      } else {\n        printStats(stats);\n      }\n\n      ctx.connectionManager.close();\n\n      // Exit with appropriate code\n      if (stats.overallLevel === 'fail') {\n        process.exit(2);\n      } else if (stats.overallLevel === 'warn') {\n        process.exit(1);\n      }\n      process.exit(0);\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('Not in a ZettelScript vault')) {\n        console.error('Error: Not in a ZettelScript vault. Run \"zs init\" first.');\n        process.exit(2);\n      }\n      console.error('Error:', error);\n      process.exit(2);\n    }\n  });\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as readline from 'node:readline';\nimport process from 'node:process';\nimport { stringify as stringifyYaml } from 'yaml';\nimport { nanoid } from 'nanoid';\nimport { ConnectionManager } from '../../storage/database/connection.js';\nimport { DEFAULT_CONFIG, type ZettelScriptConfig } from '../../core/types/index.js';\nimport {\n  getZettelScriptDir,\n  getDbPath,\n  getConfigPath,\n  findVaultRoot,\n  initContext,\n  formatDuration,\n  Spinner,\n} from '../utils.js';\nimport { fullIndex } from '../../indexer/batch.js';\nimport { generateVisualizationHtml, typeColors, type GraphData } from './visualize.js';\nimport { EntityExtractor, type ExtractedEntity } from '../../extraction/index.js';\nimport {\n  OllamaLLMProvider,\n  checkOllamaRunning,\n  checkOllamaModelExists,\n  pullOllamaModel,\n  listOllamaModels,\n} from '../../llm/provider.js';\nimport { createEmbeddingProvider } from '../../retrieval/embeddings/provider.js';\nimport { WormholeDetector } from '../../retrieval/similarity/wormhole-detector.js';\n\n/**\n * Prompt user for yes/no confirmation\n */\nasync function promptYesNo(question: string): Promise<boolean> {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  return new Promise((resolve) => {\n    rl.question(`${question} (y/n) `, (answer) => {\n      rl.close();\n      resolve(answer.toLowerCase().startsWith('y'));\n    });\n  });\n}\n\n/**\n * Format bytes as human-readable string\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;\n}\n\nexport const setupCommand = new Command('setup')\n  .alias('go')\n  .description('Initialize vault, index files, and generate visualization (0 to hero)')\n  .option('-f, --force', 'Reinitialize even if already set up')\n  .option('--manuscript', 'Enable manuscript mode with POV and timeline validation')\n  .option('--extract', 'Extract entities from prose using LLM')\n  .option('--extract-model <model>', 'Ollama model for extraction', 'qwen2.5:7b')\n  .option('--embed', 'Compute embeddings for semantic features')\n  .option('--wormholes', 'Detect semantic wormholes (implies --embed)')\n  .option('--no-viz', 'Skip visualization generation')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const vaultPath = process.cwd();\n    const zettelDir = getZettelScriptDir(vaultPath);\n    let needsInit = true;\n\n    console.log('ZettelScript Setup');\n    console.log('==================\\n');\n\n    // Step 1: Initialize\n    if (fs.existsSync(zettelDir) && !options.force) {\n      const existingRoot = findVaultRoot(vaultPath);\n      if (existingRoot) {\n        console.log('Step 1: Initialize');\n        console.log('  Already initialized, skipping...\\n');\n        needsInit = false;\n      }\n    }\n\n    if (needsInit) {\n      console.log('Step 1: Initialize');\n      try {\n        // Create .zettelscript directory\n        fs.mkdirSync(zettelDir, { recursive: true });\n        console.log(`  Created ${path.relative(vaultPath, zettelDir)}/`);\n\n        // Create config file\n        const config: ZettelScriptConfig = {\n          ...DEFAULT_CONFIG,\n          vault: {\n            ...DEFAULT_CONFIG.vault,\n            path: '.',\n          },\n          manuscript: {\n            ...DEFAULT_CONFIG.manuscript,\n            enabled: options.manuscript || false,\n          },\n        };\n\n        const configPath = getConfigPath(vaultPath);\n        fs.writeFileSync(configPath, stringifyYaml(config), 'utf-8');\n        console.log(`  Created ${path.relative(vaultPath, configPath)}`);\n\n        // Initialize database\n        const dbPath = getDbPath(vaultPath);\n        const manager = ConnectionManager.getInstance(dbPath);\n        await manager.initialize();\n        manager.close();\n        ConnectionManager.resetInstance();\n        console.log(`  Created ${path.relative(vaultPath, dbPath)}`);\n\n        // Create .gitignore for .zettelscript\n        const gitignorePath = path.join(zettelDir, '.gitignore');\n        fs.writeFileSync(\n          gitignorePath,\n          '# Ignore database (regenerated from files)\\nzettelscript.db\\nzettelscript.db-*\\n',\n          'utf-8'\n        );\n\n        console.log('  Done!\\n');\n      } catch (error) {\n        console.error('  Failed to initialize:', error);\n        process.exit(1);\n      }\n    }\n\n    // Step 2: Index files\n    console.log('Step 2: Index files');\n    try {\n      const ctx = await initContext();\n\n      const spinner = new Spinner('  Scanning files...');\n      spinner.start();\n\n      let lastProgress = 0;\n      const result = await fullIndex(ctx.pipeline, ctx.vaultPath, {\n        excludePatterns: ctx.config.vault.excludePatterns,\n        onProgress: (current, total, filePath) => {\n          if (current > lastProgress) {\n            lastProgress = current;\n            spinner.update(`  Indexing ${current}/${total}: ${filePath}`);\n          }\n        },\n      });\n\n      spinner.stop();\n\n      console.log(`  Files: ${result.stats.totalFiles}`);\n      console.log(`  Nodes: ${result.stats.nodeCount}`);\n      console.log(`  Edges: ${result.stats.edgeCount}`);\n      if (result.stats.unresolvedCount > 0) {\n        console.log(`  Unresolved links: ${result.stats.unresolvedCount}`);\n      }\n      console.log(`  Duration: ${formatDuration(result.stats.durationMs)}`);\n\n      if (result.errors.length > 0 && options.verbose) {\n        console.log(`  Errors (${result.errors.length}):`);\n        for (const err of result.errors.slice(0, 5)) {\n          console.log(`    ${err.path}: ${err.error}`);\n        }\n        if (result.errors.length > 5) {\n          console.log(`    ... and ${result.errors.length - 5} more`);\n        }\n      }\n\n      console.log('  Done!\\n');\n\n      let stepNum = 3;\n\n      // Step 3 (optional): Extract entities\n      if (options.extract) {\n        console.log(`Step ${stepNum}: Extract entities`);\n        stepNum++;\n\n        // Check Ollama is running\n        const ollamaRunning = await checkOllamaRunning();\n        if (!ollamaRunning) {\n          console.log('  Ollama is not running, skipping extraction.');\n          console.log('  Start Ollama and run: zettel extract --all\\n');\n        } else {\n          // Check if model exists\n          const modelExists = await checkOllamaModelExists(options.extractModel);\n          if (!modelExists) {\n            console.log(`  Model '${options.extractModel}' is not installed.`);\n            const availableModels = await listOllamaModels();\n            if (availableModels.length > 0) {\n              console.log(\n                `  Installed: ${availableModels.slice(0, 3).join(', ')}${availableModels.length > 3 ? '...' : ''}`\n              );\n            }\n\n            const shouldDownload = await promptYesNo(`  Download '${options.extractModel}' now?`);\n            if (shouldDownload) {\n              console.log(`  Downloading ${options.extractModel}...`);\n              try {\n                for await (const progress of pullOllamaModel(options.extractModel)) {\n                  if (progress.completed !== undefined && progress.total !== undefined) {\n                    const percent = ((progress.completed / progress.total) * 100).toFixed(0);\n                    process.stdout.write(\n                      `\\r  ${progress.status}: ${formatBytes(progress.completed)} / ${formatBytes(progress.total)} (${percent}%)    `\n                    );\n                  } else {\n                    process.stdout.write(`\\r  ${progress.status}...    `);\n                  }\n                }\n                console.log('\\n  Download complete!');\n              } catch (err) {\n                console.error(\n                  `\\n  Failed to download: ${err instanceof Error ? err.message : err}`\n                );\n                console.log('  Skipping extraction.\\n');\n              }\n            } else {\n              console.log('  Skipping extraction.\\n');\n            }\n          }\n\n          // Re-check model exists (might have just downloaded)\n          const modelReady = await checkOllamaModelExists(options.extractModel);\n          if (modelReady) {\n            const llmProvider = new OllamaLLMProvider({\n              provider: 'ollama',\n              model: options.extractModel,\n              baseUrl: 'http://localhost:11434',\n            });\n\n            const extractor = new EntityExtractor({\n              llmProvider,\n              chunkSize: 6000,\n            });\n\n            // Find markdown files\n            const findMarkdown = (dir: string): string[] => {\n              const results: string[] = [];\n              const entries = fs.readdirSync(dir, { withFileTypes: true });\n              for (const entry of entries) {\n                const fullPath = path.join(dir, entry.name);\n                if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;\n                if (entry.isDirectory()) {\n                  results.push(...findMarkdown(fullPath));\n                } else if (entry.name.endsWith('.md')) {\n                  results.push(fullPath);\n                }\n              }\n              return results;\n            };\n\n            const files = findMarkdown(ctx.vaultPath);\n            const allEntities = new Map<string, ExtractedEntity>();\n            let filesProcessed = 0;\n\n            const spinner = new Spinner(`  Extracting from ${files.length} files...`);\n            spinner.start();\n\n            for (const filePath of files) {\n              const content = fs.readFileSync(filePath, 'utf-8');\n              if (content.length < 100) continue; // Skip tiny files\n\n              try {\n                const result = await extractor.extractFromText(content);\n                for (const entity of result.entities) {\n                  const key = entity.name.toLowerCase();\n                  if (!allEntities.has(key)) {\n                    allEntities.set(key, entity);\n                  } else {\n                    const existing = allEntities.get(key)!;\n                    existing.mentions += entity.mentions;\n                  }\n                }\n                filesProcessed++;\n                spinner.update(\n                  `  Extracted ${filesProcessed}/${files.length}: ${allEntities.size} entities found`\n                );\n              } catch {\n                // Skip files that fail extraction\n              }\n            }\n\n            spinner.stop();\n\n            // Create entity files\n            const outputDir = path.join(ctx.vaultPath, 'entities');\n            if (!fs.existsSync(outputDir)) {\n              fs.mkdirSync(outputDir, { recursive: true });\n            }\n\n            let created = 0;\n            for (const entity of allEntities.values()) {\n              if (entity.mentions < 2) continue; // Skip single-mention entities\n\n              const safeName = entity.name.replace(/[<>:\"/\\\\|?*]/g, '-');\n              const filePath = path.join(outputDir, `${safeName}.md`);\n\n              if (!fs.existsSync(filePath)) {\n                const frontmatter = {\n                  id: nanoid(12),\n                  title: entity.name,\n                  type: entity.type,\n                  aliases: entity.aliases.length > 0 ? entity.aliases : undefined,\n                };\n\n                const content = `---\\n${stringifyYaml(frontmatter)}---\\n\\n${entity.description}\\n`;\n                fs.writeFileSync(filePath, content, 'utf-8');\n                created++;\n              }\n            }\n\n            console.log(`  Entities found: ${allEntities.size}`);\n            console.log(`  Files created: ${created} (in entities/)`);\n            console.log('  Done!\\n');\n\n            // Re-index to include new entities\n            if (created > 0) {\n              console.log(`Step ${stepNum}: Re-index (including new entities)`);\n              stepNum++;\n              const reindexSpinner = new Spinner('  Re-indexing...');\n              reindexSpinner.start();\n              await fullIndex(ctx.pipeline, ctx.vaultPath, {\n                excludePatterns: ctx.config.vault.excludePatterns,\n              });\n              reindexSpinner.stop();\n              console.log('  Done!\\n');\n            }\n          }\n        }\n      }\n\n      // Step N (optional): Compute embeddings\n      const needsEmbed = options.embed || options.wormholes;\n      if (needsEmbed) {\n        console.log(`Step ${stepNum}: Compute embeddings`);\n        stepNum++;\n\n        try {\n          const provider = createEmbeddingProvider(ctx.config.embeddings);\n          const dirtyNodeIds = await ctx.embeddingRepository.findDirtyNodeIds();\n\n          if (dirtyNodeIds.length === 0) {\n            console.log('  All nodes have up-to-date embeddings.');\n            console.log('  Done!\\n');\n          } else {\n            const nodes = await ctx.nodeRepository.findByIds(dirtyNodeIds);\n            let computed = 0;\n            const spinner = new Spinner(`  Computing embeddings for ${nodes.length} nodes...`);\n            spinner.start();\n\n            for (const node of nodes) {\n              // Get content from file\n              const filePath = path.join(ctx.vaultPath, node.path);\n              let text = node.title;\n              if (fs.existsSync(filePath)) {\n                text = fs.readFileSync(filePath, 'utf-8');\n              }\n\n              try {\n                const embedding = await provider.embed(text);\n                await ctx.embeddingRepository.upsert({\n                  nodeId: node.nodeId,\n                  embedding,\n                  model: ctx.config.embeddings.model,\n                  dimensions: provider.dimensions,\n                  contentHash: node.contentHash || '',\n                });\n                computed++;\n                spinner.update(`  Computed ${computed}/${nodes.length} embeddings...`);\n              } catch {\n                // Skip nodes that fail\n              }\n            }\n\n            spinner.stop();\n            console.log(`  Embeddings computed: ${computed}`);\n            console.log('  Done!\\n');\n          }\n        } catch (err) {\n          console.log(\n            `  Embedding provider not configured: ${err instanceof Error ? err.message : err}`\n          );\n          console.log('  Configure embeddings in .zettelscript/config.yaml\\n');\n        }\n      }\n\n      // Step N (optional): Detect wormholes\n      if (options.wormholes) {\n        console.log(`Step ${stepNum}: Detect semantic wormholes`);\n        stepNum++;\n\n        try {\n          const detector = new WormholeDetector(\n            ctx.embeddingRepository,\n            ctx.edgeRepository,\n            ctx.wormholeRepository,\n            ctx.nodeRepository\n          );\n\n          const spinner = new Spinner('  Detecting wormholes...');\n          spinner.start();\n\n          const candidates = await detector.detectWormholes();\n\n          spinner.stop();\n          console.log(`  Wormholes detected: ${candidates.length}`);\n          console.log('  Done!\\n');\n        } catch (err) {\n          console.log(`  Failed: ${err instanceof Error ? err.message : err}\\n`);\n        }\n      }\n\n      // Final Step: Generate visualization (unless --no-viz)\n      if (options.viz) {\n        console.log(`Step ${stepNum}: Generate visualization`);\n\n        const nodes = await ctx.nodeRepository.findAll();\n        const edges = await ctx.edgeRepository.findAll();\n\n        if (nodes.length === 0) {\n          console.log('  No nodes to visualize, skipping...\\n');\n        } else {\n          const nodeWeights = new Map<string, number>();\n          edges.forEach((e) => {\n            nodeWeights.set(e.sourceId, (nodeWeights.get(e.sourceId) || 0) + 1);\n            nodeWeights.set(e.targetId, (nodeWeights.get(e.targetId) || 0) + 1);\n          });\n\n          const graphData: GraphData = {\n            nodes: nodes.map((n) => ({\n              id: n.nodeId,\n              name: n.title,\n              type: n.type,\n              val: Math.max(1, Math.min(10, (nodeWeights.get(n.nodeId) || 0) / 2)),\n              color: typeColors[n.type] || '#94a3b8',\n              path: n.path,\n              metadata: n.metadata as Record<string, unknown>,\n            })),\n            links: edges.map((e) => ({\n              source: e.sourceId,\n              target: e.targetId,\n              type: e.edgeType,\n              strength: e.strength ?? 1.0,\n              provenance: e.provenance,\n            })),\n          };\n\n          const htmlContent = generateVisualizationHtml(graphData, typeColors);\n\n          const outputPath = path.join(getZettelScriptDir(ctx.vaultPath), 'graph.html');\n          fs.writeFileSync(outputPath, htmlContent, 'utf-8');\n\n          console.log(`  Generated: ${path.relative(vaultPath, outputPath)}`);\n          console.log('  Done!\\n');\n        }\n      }\n\n      ctx.connectionManager.close();\n\n      // Summary\n      console.log('Setup complete!');\n      console.log('---------------');\n      console.log('Next steps:');\n\n      if (options.viz && result.stats.nodeCount > 0) {\n        console.log('  zettel viz              Open graph in browser');\n      }\n\n      if (!options.extract) {\n        console.log('  zettel go --extract     Extract entities with AI');\n      }\n\n      if (!options.wormholes) {\n        console.log('  zettel go --wormholes   Find hidden connections');\n      }\n\n      console.log('  zettel discover --all   Find unlinked mentions');\n      console.log('  zettel watch            Watch for file changes');\n\n      if (options.manuscript) {\n        console.log('\\nManuscript mode enabled:');\n        console.log('  zettel validate --continuity   Check POV/timeline consistency');\n      }\n\n      if (options.extract || options.wormholes) {\n        console.log('\\nTo explore semantic features:');\n        console.log('  zettel wormhole list    Show suggested connections');\n        console.log('  zettel path \"A\" \"B\"     Find narrative paths');\n      }\n    } catch (error) {\n      console.error('  Failed:', error);\n      process.exit(1);\n    }\n  });\n","/* global fetch */\nimport { EmbeddingError } from '../../core/errors.js';\n\nexport interface EmbeddingProvider {\n  name: string;\n  dimensions: number;\n  embed(text: string): Promise<number[]>;\n  embedBatch(texts: string[]): Promise<number[][]>;\n}\n\nexport interface OpenAIEmbeddingOptions {\n  apiKey: string;\n  model?: string;\n  baseUrl?: string;\n}\n\nexport interface OllamaEmbeddingOptions {\n  model?: string;\n  baseUrl?: string;\n}\n\n/**\n * OpenAI embedding provider\n */\nexport class OpenAIEmbeddingProvider implements EmbeddingProvider {\n  name = 'openai';\n  dimensions: number;\n  private apiKey: string;\n  private model: string;\n  private baseUrl: string;\n\n  constructor(options: OpenAIEmbeddingOptions) {\n    this.apiKey = options.apiKey;\n    this.model = options.model || 'text-embedding-3-small';\n    this.baseUrl = options.baseUrl || 'https://api.openai.com/v1';\n    this.dimensions = this.model.includes('3-small') ? 1536 : 3072;\n  }\n\n  async embed(text: string): Promise<number[]> {\n    const result = await this.embedBatch([text]);\n    if (!result[0]) {\n      throw new EmbeddingError('Empty embedding result', this.name);\n    }\n    return result[0];\n  }\n\n  async embedBatch(texts: string[]): Promise<number[][]> {\n    if (texts.length === 0) return [];\n\n    try {\n      const response = await fetch(`${this.baseUrl}/embeddings`, {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model: this.model,\n          input: texts,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        throw new EmbeddingError(`OpenAI API error: ${error}`, this.name);\n      }\n\n      const data = (await response.json()) as {\n        data: Array<{ embedding: number[]; index: number }>;\n      };\n\n      // Sort by index to maintain order\n      const sorted = data.data.sort((a, b) => a.index - b.index);\n      return sorted.map((d) => d.embedding);\n    } catch (error) {\n      if (error instanceof EmbeddingError) throw error;\n      throw new EmbeddingError(`Failed to get embeddings: ${error}`, this.name);\n    }\n  }\n}\n\n/**\n * Ollama embedding provider (for local models like nomic-embed-text)\n */\nexport class OllamaEmbeddingProvider implements EmbeddingProvider {\n  name = 'ollama';\n  dimensions: number;\n  private model: string;\n  private baseUrl: string;\n\n  constructor(options: OllamaEmbeddingOptions = {}) {\n    this.model = options.model || 'nomic-embed-text';\n    this.baseUrl = options.baseUrl || 'http://localhost:11434';\n    // nomic-embed-text uses 768 dimensions\n    this.dimensions = this.model.includes('nomic') ? 768 : 1536;\n  }\n\n  async embed(text: string): Promise<number[]> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/embeddings`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model: this.model,\n          prompt: text,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        throw new EmbeddingError(`Ollama API error: ${error}`, this.name);\n      }\n\n      const data = (await response.json()) as { embedding: number[] };\n      return data.embedding;\n    } catch (error) {\n      if (error instanceof EmbeddingError) throw error;\n      throw new EmbeddingError(`Failed to get embedding: ${error}`, this.name);\n    }\n  }\n\n  async embedBatch(texts: string[]): Promise<number[][]> {\n    // Ollama doesn't have native batch support, so we process sequentially\n    const results: number[][] = [];\n    for (const text of texts) {\n      results.push(await this.embed(text));\n    }\n    return results;\n  }\n}\n\n/**\n * Mock embedding provider for testing and development.\n *\n * This provider generates deterministic embeddings based on text hashes,\n * without making any API calls. It is intentionally included for:\n * - Unit testing without network dependencies\n * - Development environments without API keys\n * - Offline usage scenarios\n *\n * Note: Embeddings from this provider are NOT semantically meaningful.\n * For production use, configure OpenAI or Ollama providers.\n */\nexport class MockEmbeddingProvider implements EmbeddingProvider {\n  name = 'mock';\n  dimensions = 384;\n\n  async embed(text: string): Promise<number[]> {\n    // Generate deterministic embeddings based on text hash\n    const hash = this.hashString(text);\n    const embedding = new Array(this.dimensions).fill(0);\n\n    for (let i = 0; i < this.dimensions; i++) {\n      embedding[i] = Math.sin(hash * (i + 1)) * 0.5;\n    }\n\n    return embedding;\n  }\n\n  async embedBatch(texts: string[]): Promise<number[][]> {\n    return Promise.all(texts.map((t) => this.embed(t)));\n  }\n\n  private hashString(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash;\n    }\n    return hash;\n  }\n}\n\n/**\n * Create an embedding provider based on configuration\n */\nexport function createEmbeddingProvider(config: {\n  provider: 'openai' | 'ollama' | 'mock';\n  apiKey?: string;\n  model?: string;\n  baseUrl?: string;\n}): EmbeddingProvider {\n  switch (config.provider) {\n    case 'openai':\n      if (!config.apiKey) {\n        throw new EmbeddingError('OpenAI API key required', 'openai');\n      }\n      return new OpenAIEmbeddingProvider({\n        apiKey: config.apiKey,\n        ...(config.model != null && { model: config.model }),\n        ...(config.baseUrl != null && { baseUrl: config.baseUrl }),\n      });\n\n    case 'ollama':\n      return new OllamaEmbeddingProvider({\n        ...(config.model != null && { model: config.model }),\n        ...(config.baseUrl != null && { baseUrl: config.baseUrl }),\n      });\n\n    case 'mock':\n      return new MockEmbeddingProvider();\n\n    default:\n      throw new EmbeddingError(`Unknown provider: ${config.provider}`, 'unknown');\n  }\n}\n","/**\n * Cosine similarity computation and wormhole detection utilities\n */\n\n/**\n * Compute cosine similarity between two embedding vectors\n * Returns a value between -1 and 1 (typically 0 to 1 for normalized embeddings)\n */\nexport function cosineSimilarity(a: number[], b: number[]): number {\n  if (a.length !== b.length) {\n    throw new Error(`Vector dimension mismatch: ${a.length} vs ${b.length}`);\n  }\n\n  let dotProduct = 0;\n  let normA = 0;\n  let normB = 0;\n\n  for (let i = 0; i < a.length; i++) {\n    const aVal = a[i]!;\n    const bVal = b[i]!;\n    dotProduct += aVal * bVal;\n    normA += aVal * aVal;\n    normB += bVal * bVal;\n  }\n\n  const magnitude = Math.sqrt(normA) * Math.sqrt(normB);\n  if (magnitude === 0) return 0;\n\n  return dotProduct / magnitude;\n}\n\n/**\n * A candidate wormhole connection between two nodes\n */\nexport interface WormholeCandidate {\n  sourceId: string;\n  targetId: string;\n  similarity: number;\n}\n\n/**\n * Options for wormhole detection\n */\nexport interface WormholeDetectorOptions {\n  /**\n   * Minimum similarity score to consider (0-1)\n   * @default 0.75\n   */\n  similarityThreshold: number;\n\n  /**\n   * Maximum number of wormholes to suggest per node\n   * @default 5\n   */\n  maxWormholesPerNode: number;\n\n  /**\n   * Whether to exclude pairs that already have an edge\n   * @default true\n   */\n  excludeLinkedNodes: boolean;\n}\n\nexport const DEFAULT_WORMHOLE_OPTIONS: WormholeDetectorOptions = {\n  similarityThreshold: 0.75,\n  maxWormholesPerNode: 5,\n  excludeLinkedNodes: true,\n};\n","import {\n  cosineSimilarity,\n  type WormholeCandidate,\n  type WormholeDetectorOptions,\n  DEFAULT_WORMHOLE_OPTIONS,\n} from './similarity.js';\nimport type { EmbeddingRepository } from '../../storage/database/repositories/embedding-repository.js';\nimport type { EdgeRepository } from '../../storage/database/repositories/edge-repository.js';\nimport type { WormholeRepository } from '../../storage/database/repositories/wormhole-repository.js';\nimport type { NodeRepository } from '../../storage/database/repositories/node-repository.js';\nimport type { EdgeType } from '../../core/types/index.js';\n\n/**\n * Detects semantic wormholes - similar but unlinked nodes\n */\nexport class WormholeDetector {\n  private options: WormholeDetectorOptions;\n\n  constructor(\n    private embeddingRepo: EmbeddingRepository,\n    private edgeRepo: EdgeRepository,\n    private wormholeRepo: WormholeRepository,\n    private nodeRepo: NodeRepository,\n    options: Partial<WormholeDetectorOptions> = {}\n  ) {\n    this.options = { ...DEFAULT_WORMHOLE_OPTIONS, ...options };\n  }\n\n  /**\n   * Detect all wormhole candidates based on embedding similarity\n   */\n  async detectWormholes(): Promise<WormholeCandidate[]> {\n    // Get all embeddings\n    const embeddings = await this.embeddingRepo.findAll();\n\n    if (embeddings.length < 2) {\n      return [];\n    }\n\n    // Build set of existing edges for exclusion\n    const existingEdges = new Set<string>();\n    if (this.options.excludeLinkedNodes) {\n      const allEdges = await this.edgeRepo.findAll();\n      for (const edge of allEdges) {\n        // Store both directions for quick lookup\n        existingEdges.add(`${edge.sourceId}:${edge.targetId}`);\n        existingEdges.add(`${edge.targetId}:${edge.sourceId}`);\n      }\n    }\n\n    // Get content hashes for rejection checking\n    const nodeHashes = new Map<string, string>();\n    const nodes = await this.nodeRepo.findAll();\n    for (const node of nodes) {\n      if (node.contentHash) {\n        nodeHashes.set(node.nodeId, node.contentHash);\n      }\n    }\n\n    // Track per-node wormhole counts\n    const nodeWormholeCounts = new Map<string, number>();\n\n    // Compute all pairwise similarities\n    const candidates: WormholeCandidate[] = [];\n\n    for (let i = 0; i < embeddings.length; i++) {\n      const embA = embeddings[i]!;\n\n      for (let j = i + 1; j < embeddings.length; j++) {\n        const embB = embeddings[j]!;\n\n        // Skip if already linked\n        if (existingEdges.has(`${embA.nodeId}:${embB.nodeId}`)) {\n          continue;\n        }\n\n        // Compute similarity\n        const similarity = cosineSimilarity(embA.embedding, embB.embedding);\n\n        // Skip if below threshold\n        if (similarity < this.options.similarityThreshold) {\n          continue;\n        }\n\n        // Check if rejected (with current content hashes)\n        const sourceHash = nodeHashes.get(embA.nodeId) || '';\n        const targetHash = nodeHashes.get(embB.nodeId) || '';\n        const isRejected = await this.wormholeRepo.isRejected(\n          embA.nodeId,\n          embB.nodeId,\n          sourceHash,\n          targetHash\n        );\n        if (isRejected) {\n          continue;\n        }\n\n        candidates.push({\n          sourceId: embA.nodeId,\n          targetId: embB.nodeId,\n          similarity,\n        });\n      }\n    }\n\n    // Sort by similarity (descending)\n    candidates.sort((a, b) => b.similarity - a.similarity);\n\n    // Apply per-node limits\n    const filteredCandidates: WormholeCandidate[] = [];\n\n    for (const candidate of candidates) {\n      const sourceCount = nodeWormholeCounts.get(candidate.sourceId) || 0;\n      const targetCount = nodeWormholeCounts.get(candidate.targetId) || 0;\n\n      if (\n        sourceCount < this.options.maxWormholesPerNode &&\n        targetCount < this.options.maxWormholesPerNode\n      ) {\n        filteredCandidates.push(candidate);\n        nodeWormholeCounts.set(candidate.sourceId, sourceCount + 1);\n        nodeWormholeCounts.set(candidate.targetId, targetCount + 1);\n      }\n    }\n\n    return filteredCandidates;\n  }\n\n  /**\n   * Create semantic_suggestion edges from wormhole candidates\n   * Returns the number of edges created\n   */\n  async createSemanticEdges(candidates: WormholeCandidate[], model: string): Promise<number> {\n    let created = 0;\n\n    for (const candidate of candidates) {\n      // Check if edge already exists\n      const existing = await this.edgeRepo.findBySourceTargetType(\n        candidate.sourceId,\n        candidate.targetId,\n        'semantic_suggestion' as EdgeType\n      );\n\n      if (existing) {\n        // Update existing edge with new similarity\n        await this.edgeRepo.update(existing.edgeId, {\n          strength: candidate.similarity,\n          attributes: {\n            similarity: candidate.similarity,\n            model,\n            detectedAt: new Date().toISOString(),\n          },\n        });\n      } else {\n        // Create new edge\n        await this.edgeRepo.create({\n          sourceId: candidate.sourceId,\n          targetId: candidate.targetId,\n          edgeType: 'semantic_suggestion' as EdgeType,\n          strength: candidate.similarity,\n          provenance: 'computed',\n          attributes: {\n            similarity: candidate.similarity,\n            model,\n            detectedAt: new Date().toISOString(),\n          },\n        });\n        created++;\n      }\n    }\n\n    return created;\n  }\n\n  /**\n   * Remove all semantic_suggestion edges\n   */\n  async clearSemanticEdges(): Promise<number> {\n    const edges = await this.edgeRepo.findByType('semantic_suggestion' as EdgeType);\n    for (const edge of edges) {\n      await this.edgeRepo.delete(edge.edgeId);\n    }\n    return edges.length;\n  }\n\n  /**\n   * Accept a wormhole - convert semantic_suggestion to semantic edge\n   */\n  async acceptWormhole(edgeId: string): Promise<boolean> {\n    const edge = await this.edgeRepo.findById(edgeId);\n    if (!edge || edge.edgeType !== 'semantic_suggestion') {\n      return false;\n    }\n\n    await this.edgeRepo.update(edgeId, {\n      edgeType: 'semantic' as EdgeType,\n      provenance: 'user_approved',\n      attributes: {\n        ...edge.attributes,\n        acceptedAt: new Date().toISOString(),\n      },\n    });\n\n    return true;\n  }\n\n  /**\n   * Reject a wormhole - delete the edge and record rejection\n   */\n  async rejectWormhole(edgeId: string): Promise<boolean> {\n    const edge = await this.edgeRepo.findById(edgeId);\n    if (!edge || edge.edgeType !== 'semantic_suggestion') {\n      return false;\n    }\n\n    // Get content hashes for the nodes\n    const sourceNode = await this.nodeRepo.findById(edge.sourceId);\n    const targetNode = await this.nodeRepo.findById(edge.targetId);\n\n    if (!sourceNode || !targetNode) {\n      return false;\n    }\n\n    // Record rejection\n    await this.wormholeRepo.createRejection({\n      sourceId: edge.sourceId,\n      targetId: edge.targetId,\n      sourceContentHash: sourceNode.contentHash || '',\n      targetContentHash: targetNode.contentHash || '',\n    });\n\n    // Delete the edge\n    await this.edgeRepo.delete(edgeId);\n\n    return true;\n  }\n\n  /**\n   * Get statistics about current wormholes\n   */\n  async getStats(): Promise<{\n    suggestionCount: number;\n    acceptedCount: number;\n    rejectionCount: number;\n    embeddingCount: number;\n    embeddedNodeCount: number;\n    totalNodeCount: number;\n  }> {\n    const suggestions = await this.edgeRepo.findByType('semantic_suggestion' as EdgeType);\n    const accepted = await this.edgeRepo.findByType('semantic' as EdgeType);\n    const rejectionCount = await this.wormholeRepo.count();\n    const embeddingCount = await this.embeddingRepo.count();\n    const totalNodeCount = await this.nodeRepo.count();\n\n    return {\n      suggestionCount: suggestions.length,\n      acceptedCount: accepted.filter((e) => e.provenance === 'user_approved').length,\n      rejectionCount,\n      embeddingCount,\n      embeddedNodeCount: embeddingCount, // Same as embeddingCount since 1:1\n      totalNodeCount,\n    };\n  }\n}\n","import { Command } from 'commander';\nimport { initContext, printTable } from '../utils.js';\n\nexport const constellationCommand = new Command('constellation')\n  .alias('const')\n  .description('Manage saved graph views (constellations)');\n\n/**\n * Save a new constellation from JSON state\n */\nconstellationCommand\n  .command('save <name>')\n  .description('Save a constellation from JSON state')\n  .option('-s, --state <json>', 'State JSON from visualizer')\n  .option('-d, --description <text>', 'Description for the constellation')\n  .action(async (name: string, options: { state?: string; description?: string }) => {\n    try {\n      const ctx = await initContext();\n\n      // Check if constellation already exists\n      const existing = await ctx.constellationRepository.findByName(name);\n      if (existing) {\n        console.error(\n          `Constellation \"${name}\" already exists. Use a different name or delete it first.`\n        );\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Parse state if provided\n      let state: {\n        hiddenNodeTypes?: string[];\n        hiddenEdgeTypes?: string[];\n        showGhosts?: boolean;\n        ghostThreshold?: number;\n        cameraX?: number;\n        cameraY?: number;\n        cameraZoom?: number;\n        focusNodeIds?: string[];\n      } = {};\n\n      if (options.state) {\n        try {\n          state = JSON.parse(options.state);\n        } catch (e) {\n          console.error('Invalid JSON state:', e);\n          ctx.connectionManager.close();\n          process.exit(1);\n        }\n      }\n\n      // Create the constellation\n      const createInput: Parameters<typeof ctx.constellationRepository.create>[0] = {\n        name,\n        hiddenNodeTypes: state.hiddenNodeTypes ?? [],\n        hiddenEdgeTypes: state.hiddenEdgeTypes ?? [],\n        showGhosts: state.showGhosts ?? true,\n        ghostThreshold: state.ghostThreshold ?? 1,\n      };\n\n      // Only set optional properties if they have values\n      if (options.description !== undefined) createInput.description = options.description;\n      if (state.cameraX !== undefined) createInput.cameraX = state.cameraX;\n      if (state.cameraY !== undefined) createInput.cameraY = state.cameraY;\n      if (state.cameraZoom !== undefined) createInput.cameraZoom = state.cameraZoom;\n      if (state.focusNodeIds !== undefined) createInput.focusNodeIds = state.focusNodeIds;\n\n      const constellation = await ctx.constellationRepository.create(createInput);\n\n      console.log(`Constellation \"${constellation.name}\" saved successfully.`);\n      console.log(`\\nTo load it, run: zs visualize --constellation \"${name}\"`);\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to save constellation:', error);\n      process.exit(1);\n    }\n  });\n\n/**\n * List all constellations\n */\nconstellationCommand\n  .command('list')\n  .alias('ls')\n  .description('List all saved constellations')\n  .action(async () => {\n    try {\n      const ctx = await initContext();\n      const constellations = await ctx.constellationRepository.findAll();\n\n      if (constellations.length === 0) {\n        console.log('No constellations saved yet.');\n        console.log('\\nTo save one, open the visualizer and click \"Save Current View\".');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      const rows = constellations.map((c) => [\n        c.name,\n        c.description || '-',\n        c.hiddenNodeTypes.length > 0 ? `${c.hiddenNodeTypes.length} hidden` : 'all',\n        c.hiddenEdgeTypes.length > 0 ? `${c.hiddenEdgeTypes.length} hidden` : 'all',\n        c.showGhosts ? 'yes' : 'no',\n        new Date(c.updatedAt).toLocaleDateString(),\n      ]);\n\n      printTable(['Name', 'Description', 'Node Types', 'Edge Types', 'Ghosts', 'Updated'], rows);\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to list constellations:', error);\n      process.exit(1);\n    }\n  });\n\n/**\n * Show details of a specific constellation\n */\nconstellationCommand\n  .command('show <name>')\n  .description('Show details of a constellation')\n  .action(async (name: string) => {\n    try {\n      const ctx = await initContext();\n      const constellation = await ctx.constellationRepository.findByName(name);\n\n      if (!constellation) {\n        console.error(`Constellation \"${name}\" not found.`);\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      console.log(`\\nConstellation: ${constellation.name}`);\n      console.log(''.repeat(40));\n\n      if (constellation.description) {\n        console.log(`Description: ${constellation.description}`);\n      }\n\n      console.log(`\\nFilters:`);\n      console.log(\n        `  Hidden node types: ${constellation.hiddenNodeTypes.length > 0 ? constellation.hiddenNodeTypes.join(', ') : '(none)'}`\n      );\n      console.log(\n        `  Hidden edge types: ${constellation.hiddenEdgeTypes.length > 0 ? constellation.hiddenEdgeTypes.join(', ') : '(none)'}`\n      );\n\n      console.log(`\\nGhost Nodes:`);\n      console.log(`  Show ghosts: ${constellation.showGhosts ? 'yes' : 'no'}`);\n      console.log(`  Min references: ${constellation.ghostThreshold}`);\n\n      if (constellation.cameraX !== undefined || constellation.cameraY !== undefined) {\n        console.log(`\\nCamera:`);\n        console.log(\n          `  Position: (${constellation.cameraX?.toFixed(2) ?? 'auto'}, ${constellation.cameraY?.toFixed(2) ?? 'auto'})`\n        );\n        console.log(`  Zoom: ${constellation.cameraZoom?.toFixed(2) ?? 'auto'}`);\n      }\n\n      if (constellation.focusNodeIds && constellation.focusNodeIds.length > 0) {\n        console.log(`\\nFocus nodes: ${constellation.focusNodeIds.length}`);\n      }\n\n      console.log(`\\nCreated: ${new Date(constellation.createdAt).toLocaleString()}`);\n      console.log(`Updated: ${new Date(constellation.updatedAt).toLocaleString()}`);\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to show constellation:', error);\n      process.exit(1);\n    }\n  });\n\n/**\n * Delete a constellation\n */\nconstellationCommand\n  .command('delete <name>')\n  .alias('rm')\n  .description('Delete a constellation')\n  .action(async (name: string) => {\n    try {\n      const ctx = await initContext();\n      const deleted = await ctx.constellationRepository.deleteByName(name);\n\n      if (!deleted) {\n        console.error(`Constellation \"${name}\" not found.`);\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      console.log(`Constellation \"${name}\" deleted.`);\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to delete constellation:', error);\n      process.exit(1);\n    }\n  });\n\n/**\n * Update an existing constellation\n */\nconstellationCommand\n  .command('update <name>')\n  .description('Update an existing constellation')\n  .option('-s, --state <json>', 'New state JSON')\n  .option('-d, --description <text>', 'New description')\n  .option('-n, --new-name <name>', 'Rename the constellation')\n  .action(\n    async (name: string, options: { state?: string; description?: string; newName?: string }) => {\n      try {\n        const ctx = await initContext();\n        const existing = await ctx.constellationRepository.findByName(name);\n\n        if (!existing) {\n          console.error(`Constellation \"${name}\" not found.`);\n          ctx.connectionManager.close();\n          process.exit(1);\n        }\n\n        // Parse state if provided\n        let stateUpdates: {\n          hiddenNodeTypes?: string[];\n          hiddenEdgeTypes?: string[];\n          showGhosts?: boolean;\n          ghostThreshold?: number;\n          cameraX?: number;\n          cameraY?: number;\n          cameraZoom?: number;\n          focusNodeIds?: string[];\n        } = {};\n\n        if (options.state) {\n          try {\n            stateUpdates = JSON.parse(options.state);\n          } catch (e) {\n            console.error('Invalid JSON state:', e);\n            ctx.connectionManager.close();\n            process.exit(1);\n          }\n        }\n\n        const updates = {\n          ...stateUpdates,\n          ...(options.description !== undefined && { description: options.description }),\n          ...(options.newName !== undefined && { name: options.newName }),\n        };\n\n        await ctx.constellationRepository.update(existing.constellationId, updates);\n\n        const finalName = options.newName ?? name;\n        console.log(`Constellation \"${finalName}\" updated.`);\n\n        ctx.connectionManager.close();\n      } catch (error) {\n        console.error('Failed to update constellation:', error);\n        process.exit(1);\n      }\n    }\n  );\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { initContext, Spinner } from '../utils.js';\nimport { createEmbeddingProvider } from '../../retrieval/embeddings/provider.js';\n\nexport const embedCommand = new Command('embed').description(\n  'Manage node embeddings for semantic wormholes'\n);\n\nembedCommand\n  .command('compute')\n  .description('Compute embeddings for nodes that need them')\n  .option('-p, --provider <name>', 'Embedding provider (openai|ollama|mock)', 'openai')\n  .option('-m, --model <name>', 'Model name (provider-specific)')\n  .option('--force', 'Recompute all embeddings, not just dirty nodes')\n  .option('--batch-size <n>', 'Batch size for API calls', '10')\n  .action(\n    async (options: {\n      provider: 'openai' | 'ollama' | 'mock';\n      model?: string;\n      force?: boolean;\n      batchSize: string;\n    }) => {\n      try {\n        const ctx = await initContext();\n        const batchSize = parseInt(options.batchSize, 10);\n\n        // Determine which nodes need embeddings\n        let nodeIds: string[];\n        if (options.force) {\n          const nodes = await ctx.nodeRepository.findAll();\n          nodeIds = nodes.map((n) => n.nodeId);\n          console.log(`Force mode: will compute embeddings for all ${nodeIds.length} nodes`);\n        } else {\n          nodeIds = await ctx.embeddingRepository.findDirtyNodeIds();\n          if (nodeIds.length === 0) {\n            console.log('All nodes have up-to-date embeddings.');\n            ctx.connectionManager.close();\n            return;\n          }\n          console.log(`Found ${nodeIds.length} nodes needing embeddings`);\n        }\n\n        // Create embedding provider\n        const providerConfig: {\n          provider: 'openai' | 'ollama' | 'mock';\n          apiKey?: string;\n          model?: string;\n          baseUrl?: string;\n        } = {\n          provider: options.provider,\n        };\n\n        if (options.provider === 'openai') {\n          const apiKey = process.env.OPENAI_API_KEY || ctx.config.embeddings.apiKey;\n          if (!apiKey) {\n            console.error(\n              'Error: OPENAI_API_KEY environment variable or config.embeddings.apiKey required'\n            );\n            ctx.connectionManager.close();\n            process.exit(1);\n          }\n          providerConfig.apiKey = apiKey;\n        }\n\n        if (options.model) {\n          providerConfig.model = options.model;\n        } else if (ctx.config.embeddings.model) {\n          providerConfig.model = ctx.config.embeddings.model;\n        }\n\n        if (ctx.config.embeddings.baseUrl) {\n          providerConfig.baseUrl = ctx.config.embeddings.baseUrl;\n        }\n\n        const provider = createEmbeddingProvider(providerConfig);\n        const modelName = `${options.provider}:${providerConfig.model || provider.name}`;\n\n        console.log(`Using provider: ${modelName} (${provider.dimensions} dimensions)`);\n\n        // Get full node data\n        const nodes = await ctx.nodeRepository.findByIds(nodeIds);\n        const nodeMap = new Map(nodes.map((n) => [n.nodeId, n]));\n\n        // Process in batches\n        const spinner = new Spinner('Computing embeddings...');\n        spinner.start();\n\n        let processed = 0;\n        let errors = 0;\n\n        for (let i = 0; i < nodeIds.length; i += batchSize) {\n          const batch = nodeIds.slice(i, i + batchSize);\n          const batchNodes = batch.map((id) => nodeMap.get(id)!).filter(Boolean);\n\n          try {\n            // Get content for each node (using chunks or file content)\n            const texts: string[] = [];\n            for (const node of batchNodes) {\n              // Try to get content from chunks first\n              const chunks = await ctx.chunkRepository.findByNodeId(node.nodeId);\n              if (chunks.length > 0) {\n                // Combine all chunks\n                texts.push(chunks.map((c) => c.text).join('\\n'));\n              } else {\n                // Fall back to reading file content\n                const filePath = path.join(ctx.vaultPath, node.path);\n                if (fs.existsSync(filePath)) {\n                  const content = fs.readFileSync(filePath, 'utf-8');\n                  texts.push(content);\n                } else {\n                  texts.push(node.title); // Last resort: just use title\n                }\n              }\n            }\n\n            // Compute embeddings\n            const embeddings = await provider.embedBatch(texts);\n\n            // Store embeddings\n            for (let j = 0; j < batchNodes.length; j++) {\n              const node = batchNodes[j];\n              const embedding = embeddings[j];\n\n              if (node && embedding) {\n                await ctx.embeddingRepository.upsert({\n                  nodeId: node.nodeId,\n                  embedding,\n                  model: modelName,\n                  dimensions: provider.dimensions,\n                  contentHash: node.contentHash || '',\n                });\n              }\n            }\n\n            processed += batchNodes.length;\n            spinner.update(`Computing embeddings... ${processed}/${nodeIds.length}`);\n          } catch (error) {\n            errors += batchNodes.length;\n            console.error(`\\nError processing batch: ${error}`);\n          }\n        }\n\n        spinner.stop(\n          `Computed embeddings for ${processed} nodes${errors > 0 ? ` (${errors} errors)` : ''}`\n        );\n\n        ctx.connectionManager.close();\n      } catch (error) {\n        console.error('Embedding computation failed:', error);\n        process.exit(1);\n      }\n    }\n  );\n\nembedCommand\n  .command('stats')\n  .description('Show embedding statistics')\n  .action(async () => {\n    try {\n      const ctx = await initContext();\n\n      const totalNodes = await ctx.nodeRepository.count();\n      const embeddingCount = await ctx.embeddingRepository.count();\n      const dirtyCount = (await ctx.embeddingRepository.findDirtyNodeIds()).length;\n      const byModel = await ctx.embeddingRepository.countByModel();\n\n      console.log('\\n=== Embedding Statistics ===\\n');\n      console.log(`Total nodes: ${totalNodes}`);\n      console.log(`Embedded nodes: ${embeddingCount}`);\n      console.log(`Coverage: ${((embeddingCount / totalNodes) * 100).toFixed(1)}%`);\n      console.log(`Nodes needing update: ${dirtyCount}`);\n\n      if (Object.keys(byModel).length > 0) {\n        console.log('\\nBy model:');\n        for (const [model, count] of Object.entries(byModel)) {\n          console.log(`  ${model}: ${count}`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to get stats:', error);\n      process.exit(1);\n    }\n  });\n\nembedCommand\n  .command('clear')\n  .description('Clear all embeddings')\n  .option('-m, --model <name>', 'Only clear embeddings for a specific model')\n  .action(async (options: { model?: string }) => {\n    try {\n      const ctx = await initContext();\n\n      let count: number;\n      if (options.model) {\n        count = await ctx.embeddingRepository.deleteByModel(options.model);\n        console.log(`Cleared ${count} embeddings for model: ${options.model}`);\n      } else {\n        const embeddings = await ctx.embeddingRepository.findAll();\n        for (const emb of embeddings) {\n          await ctx.embeddingRepository.delete(emb.embeddingId);\n        }\n        count = embeddings.length;\n        console.log(`Cleared all ${count} embeddings`);\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to clear embeddings:', error);\n      process.exit(1);\n    }\n  });\n","import { Command } from 'commander';\nimport { initContext, Spinner, printTable } from '../utils.js';\nimport { WormholeDetector } from '../../retrieval/similarity/wormhole-detector.js';\nimport type { EdgeType } from '../../core/types/index.js';\n\nexport const wormholeCommand = new Command('wormhole').description(\n  'Detect and manage semantic wormholes (similar but unlinked nodes)'\n);\n\nwormholeCommand\n  .command('detect')\n  .description('Detect semantic wormholes and create suggestion edges')\n  .option('-t, --threshold <number>', 'Similarity threshold (0-1)', '0.75')\n  .option('-k, --max-per-node <number>', 'Maximum wormholes per node', '5')\n  .option('--dry-run', 'Preview without creating edges')\n  .action(async (options: { threshold: string; maxPerNode: string; dryRun?: boolean }) => {\n    try {\n      const ctx = await initContext();\n\n      const threshold = parseFloat(options.threshold);\n      const maxPerNode = parseInt(options.maxPerNode, 10);\n\n      // Check embedding coverage\n      const embeddingCount = await ctx.embeddingRepository.count();\n      const nodeCount = await ctx.nodeRepository.count();\n\n      if (embeddingCount === 0) {\n        console.log('No embeddings found. Run \"zs embed compute\" first to generate embeddings.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      const coverage = (embeddingCount / nodeCount) * 100;\n      console.log(\n        `Embedding coverage: ${embeddingCount}/${nodeCount} nodes (${coverage.toFixed(1)}%)`\n      );\n\n      if (coverage < 50) {\n        console.log('Warning: Low embedding coverage may result in missing wormholes.');\n      }\n\n      // Get model name from embeddings\n      const embeddings = await ctx.embeddingRepository.findAll();\n      const model = embeddings[0]?.model || 'unknown';\n\n      console.log(\n        `\\nDetecting wormholes (threshold: ${threshold}, max per node: ${maxPerNode})...`\n      );\n\n      const detector = new WormholeDetector(\n        ctx.embeddingRepository,\n        ctx.edgeRepository,\n        ctx.wormholeRepository,\n        ctx.nodeRepository,\n        {\n          similarityThreshold: threshold,\n          maxWormholesPerNode: maxPerNode,\n          excludeLinkedNodes: true,\n        }\n      );\n\n      const spinner = new Spinner('Analyzing embeddings...');\n      spinner.start();\n\n      const candidates = await detector.detectWormholes();\n\n      spinner.stop(`Found ${candidates.length} wormhole candidates`);\n\n      if (candidates.length === 0) {\n        console.log('\\nNo wormholes detected above threshold.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Get node titles for display\n      const nodeIds = new Set<string>();\n      candidates.forEach((c) => {\n        nodeIds.add(c.sourceId);\n        nodeIds.add(c.targetId);\n      });\n      const nodes = await ctx.nodeRepository.findByIds(Array.from(nodeIds));\n      const nodeMap = new Map(nodes.map((n) => [n.nodeId, n]));\n\n      // Display top candidates\n      console.log('\\nTop wormhole candidates:');\n      const displayCount = Math.min(10, candidates.length);\n      const rows = candidates.slice(0, displayCount).map((c, i) => {\n        const source = nodeMap.get(c.sourceId);\n        const target = nodeMap.get(c.targetId);\n        return [\n          String(i + 1),\n          truncate(source?.title || c.sourceId, 25),\n          truncate(target?.title || c.targetId, 25),\n          (c.similarity * 100).toFixed(1) + '%',\n        ];\n      });\n      printTable(['#', 'Source', 'Target', 'Similarity'], rows);\n\n      if (candidates.length > displayCount) {\n        console.log(`  ... and ${candidates.length - displayCount} more`);\n      }\n\n      if (options.dryRun) {\n        console.log('\\nDry run - no edges created.');\n      } else {\n        const created = await detector.createSemanticEdges(candidates, model);\n        console.log(`\\nCreated ${created} semantic_suggestion edges.`);\n        console.log('Run \"zs visualize\" to see wormholes in the graph.');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Wormhole detection failed:', error);\n      process.exit(1);\n    }\n  });\n\nwormholeCommand\n  .command('stats')\n  .description('Show wormhole statistics')\n  .action(async () => {\n    try {\n      const ctx = await initContext();\n\n      const detector = new WormholeDetector(\n        ctx.embeddingRepository,\n        ctx.edgeRepository,\n        ctx.wormholeRepository,\n        ctx.nodeRepository\n      );\n\n      const stats = await detector.getStats();\n\n      console.log('\\n=== Wormhole Statistics ===\\n');\n      console.log(`Embedding coverage: ${stats.embeddedNodeCount}/${stats.totalNodeCount} nodes`);\n      console.log(`Pending suggestions: ${stats.suggestionCount}`);\n      console.log(`Accepted wormholes: ${stats.acceptedCount}`);\n      console.log(`Rejected pairs: ${stats.rejectionCount}`);\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to get stats:', error);\n      process.exit(1);\n    }\n  });\n\nwormholeCommand\n  .command('list')\n  .description('List pending wormhole suggestions')\n  .action(async () => {\n    try {\n      const ctx = await initContext();\n\n      const suggestions = await ctx.edgeRepository.findByType('semantic_suggestion' as EdgeType);\n\n      if (suggestions.length === 0) {\n        console.log('No pending wormhole suggestions.');\n        console.log('Run \"zs wormhole detect\" to find semantic similarities.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Get node titles\n      const nodeIds = new Set<string>();\n      suggestions.forEach((s) => {\n        nodeIds.add(s.sourceId);\n        nodeIds.add(s.targetId);\n      });\n      const nodes = await ctx.nodeRepository.findByIds(Array.from(nodeIds));\n      const nodeMap = new Map(nodes.map((n) => [n.nodeId, n]));\n\n      console.log(`\\nPending wormhole suggestions (${suggestions.length}):\\n`);\n\n      const rows = suggestions.map((s) => {\n        const source = nodeMap.get(s.sourceId);\n        const target = nodeMap.get(s.targetId);\n        const similarity = s.strength || 0;\n        const attrs = s.attributes as { model?: string } | undefined;\n        return [\n          s.edgeId.slice(0, 8),\n          truncate(source?.title || s.sourceId, 20),\n          truncate(target?.title || s.targetId, 20),\n          (similarity * 100).toFixed(1) + '%',\n          attrs?.model?.split(':')[0] || '-',\n        ];\n      });\n\n      printTable(['ID', 'Source', 'Target', 'Similarity', 'Model'], rows);\n\n      console.log('\\nTo accept: zs wormhole accept <id>');\n      console.log('To reject: zs wormhole reject <id>');\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to list wormholes:', error);\n      process.exit(1);\n    }\n  });\n\nwormholeCommand\n  .command('accept <id>')\n  .description('Accept a wormhole suggestion (convert to permanent semantic edge)')\n  .action(async (id: string) => {\n    try {\n      const ctx = await initContext();\n\n      // Find the edge (support partial ID match)\n      const suggestions = await ctx.edgeRepository.findByType('semantic_suggestion' as EdgeType);\n      const edge = suggestions.find((s) => s.edgeId.startsWith(id));\n\n      if (!edge) {\n        console.error(`Wormhole suggestion not found: ${id}`);\n        console.log('Run \"zs wormhole list\" to see available suggestions.');\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      const detector = new WormholeDetector(\n        ctx.embeddingRepository,\n        ctx.edgeRepository,\n        ctx.wormholeRepository,\n        ctx.nodeRepository\n      );\n\n      const success = await detector.acceptWormhole(edge.edgeId);\n\n      if (success) {\n        const source = await ctx.nodeRepository.findById(edge.sourceId);\n        const target = await ctx.nodeRepository.findById(edge.targetId);\n        console.log(`Accepted wormhole: \"${source?.title}\" <-> \"${target?.title}\"`);\n        console.log('Edge converted to permanent semantic link.');\n      } else {\n        console.error('Failed to accept wormhole.');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to accept wormhole:', error);\n      process.exit(1);\n    }\n  });\n\nwormholeCommand\n  .command('reject <id>')\n  .description('Reject a wormhole suggestion (will not resurface unless content changes)')\n  .action(async (id: string) => {\n    try {\n      const ctx = await initContext();\n\n      // Find the edge (support partial ID match)\n      const suggestions = await ctx.edgeRepository.findByType('semantic_suggestion' as EdgeType);\n      const edge = suggestions.find((s) => s.edgeId.startsWith(id));\n\n      if (!edge) {\n        console.error(`Wormhole suggestion not found: ${id}`);\n        console.log('Run \"zs wormhole list\" to see available suggestions.');\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      const detector = new WormholeDetector(\n        ctx.embeddingRepository,\n        ctx.edgeRepository,\n        ctx.wormholeRepository,\n        ctx.nodeRepository\n      );\n\n      const success = await detector.rejectWormhole(edge.edgeId);\n\n      if (success) {\n        const source = await ctx.nodeRepository.findById(edge.sourceId);\n        const target = await ctx.nodeRepository.findById(edge.targetId);\n        console.log(`Rejected wormhole: \"${source?.title}\" <-> \"${target?.title}\"`);\n        console.log('This pair will not be suggested again unless content changes.');\n      } else {\n        console.error('Failed to reject wormhole.');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to reject wormhole:', error);\n      process.exit(1);\n    }\n  });\n\nwormholeCommand\n  .command('clear')\n  .description('Remove all wormhole suggestions')\n  .option('--include-rejections', 'Also clear rejection history')\n  .action(async (options: { includeRejections?: boolean }) => {\n    try {\n      const ctx = await initContext();\n\n      const detector = new WormholeDetector(\n        ctx.embeddingRepository,\n        ctx.edgeRepository,\n        ctx.wormholeRepository,\n        ctx.nodeRepository\n      );\n\n      const cleared = await detector.clearSemanticEdges();\n      console.log(`Cleared ${cleared} wormhole suggestions.`);\n\n      if (options.includeRejections) {\n        const rejections = await ctx.wormholeRepository.clearAll();\n        console.log(`Cleared ${rejections} rejection records.`);\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Failed to clear wormholes:', error);\n      process.exit(1);\n    }\n  });\n\nfunction truncate(str: string, maxLen: number): string {\n  if (str.length <= maxLen) return str;\n  return str.slice(0, maxLen - 1) + '';\n}\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport process from 'node:process';\nimport { initContext, Spinner, printTable } from '../utils.js';\nimport type { Node, EdgeType } from '../../core/types/index.js';\n\n// Default edge types for pathfinding\nconst DEFAULT_EDGE_TYPES: EdgeType[] = ['explicit_link', 'sequence', 'causes', 'semantic'];\nconst DEFAULT_EXCLUDED: EdgeType[] = ['semantic_suggestion', 'backlink', 'mention', 'hierarchy'];\n\n// All possible edge types\nconst ALL_EDGE_TYPES: EdgeType[] = [\n  'explicit_link',\n  'backlink',\n  'sequence',\n  'hierarchy',\n  'participation',\n  'pov_visible_to',\n  'causes',\n  'setup_payoff',\n  'semantic',\n  'semantic_suggestion',\n  'mention',\n  'alias',\n];\n\ninterface PathCommandOptions {\n  maxPaths: string;\n  maxDepth: string;\n  maxExtra: string;\n  format: 'table' | 'verbose' | 'md' | 'json';\n  output?: string;\n  edgeTypes?: string;\n  excludeEdges?: string;\n  ids?: boolean;\n}\n\n/**\n * Resolve a node identifier (title, path, or partial match)\n */\nasync function resolveNode(\n  identifier: string,\n  ctx: Awaited<ReturnType<typeof initContext>>\n): Promise<Node | null> {\n  // Try by path first\n  const node = await ctx.nodeRepository.findByPath(identifier);\n  if (node !== undefined) return node;\n\n  // Try by exact title\n  const byTitle = await ctx.nodeRepository.findByTitle(identifier);\n  if (byTitle.length === 1) return byTitle[0]!;\n  if (byTitle.length > 1) {\n    console.error(`Ambiguous title \"${identifier}\". Found ${byTitle.length} matches:`);\n    byTitle.slice(0, 5).forEach((n) => console.error(`  - ${n.title} (${n.path})`));\n    if (byTitle.length > 5) console.error(`  ... and ${byTitle.length - 5} more`);\n    return null;\n  }\n\n  // Try by alias or partial title match\n  const byAlias = await ctx.nodeRepository.findByTitleOrAlias(identifier);\n  if (byAlias.length === 1) return byAlias[0]!;\n  if (byAlias.length > 1) {\n    console.error(`Ambiguous identifier \"${identifier}\". Found ${byAlias.length} matches:`);\n    byAlias.slice(0, 5).forEach((n) => console.error(`  - ${n.title} (${n.path})`));\n    if (byAlias.length > 5) console.error(`  ... and ${byAlias.length - 5} more`);\n    return null;\n  }\n\n  return null;\n}\n\n/**\n * Parse comma-separated edge types\n */\nfunction parseEdgeTypes(input: string): EdgeType[] {\n  return input\n    .split(',')\n    .map((s) => s.trim())\n    .filter((s) => ALL_EDGE_TYPES.includes(s as EdgeType)) as EdgeType[];\n}\n\n/**\n * Format output as table\n */\nfunction formatTable(\n  fromNode: Node,\n  toNode: Node,\n  paths: Array<{ path: string[]; edges: EdgeType[]; hopCount: number; score: number }>,\n  nodeMap: Map<string, Node>,\n  options: PathCommandOptions,\n  effectiveEdgeTypes: EdgeType[],\n  reason: string,\n  k: number\n): void {\n  console.log(`\\nPaths from \"${fromNode.title}\" to \"${toNode.title}\":\\n`);\n\n  if (paths.length === 0) {\n    console.log('No paths found.\\n');\n    return;\n  }\n\n  const rows = paths.map((p, i) => {\n    const route = p.path\n      .map((id) => {\n        const node = nodeMap.get(id);\n        const name = node?.title || id;\n        return options.ids ? `${name} [${id.slice(0, 8)}]` : name;\n      })\n      .join('  ');\n\n    // Truncate route if too long\n    const maxRouteLen = 80;\n    const displayRoute =\n      route.length > maxRouteLen ? route.slice(0, maxRouteLen - 3) + '...' : route;\n\n    return [String(i + 1), String(p.hopCount), p.score.toFixed(1), displayRoute];\n  });\n\n  printTable(['#', 'Hops', 'Score', 'Route'], rows);\n\n  // Footer\n  console.log();\n  if (paths.length < k) {\n    const reasonText =\n      reason === 'diversity_filter'\n        ? 'diversity filter rejected remaining candidates'\n        : reason === 'exhausted_candidates'\n          ? 'no more unique paths exist'\n          : reason;\n    console.log(\n      `Found ${paths.length} path${paths.length !== 1 ? 's' : ''} (requested ${k}). Reason: ${reasonText}.`\n    );\n  } else {\n    console.log(`Found ${paths.length} path${paths.length !== 1 ? 's' : ''}.`);\n  }\n\n  console.log(\n    `Constraints: maxDepth=${options.maxDepth}, maxExtra=${options.maxExtra}, overlap0.7, edges=[${effectiveEdgeTypes.join(',')}]`\n  );\n}\n\n/**\n * Format output as verbose\n */\nfunction formatVerbose(\n  fromNode: Node,\n  toNode: Node,\n  paths: Array<{ path: string[]; edges: EdgeType[]; hopCount: number; score: number }>,\n  nodeMap: Map<string, Node>,\n  options: PathCommandOptions\n): void {\n  console.log(`\\nPaths from \"${fromNode.title}\" to \"${toNode.title}\":\\n`);\n\n  if (paths.length === 0) {\n    console.log('No paths found.\\n');\n    return;\n  }\n\n  for (let i = 0; i < paths.length; i++) {\n    const p = paths[i]!;\n    console.log(`Path ${i + 1} (${p.hopCount} hops, score ${p.score.toFixed(1)}):`);\n\n    let line = '  ';\n    for (let j = 0; j < p.path.length; j++) {\n      const id = p.path[j]!;\n      const node = nodeMap.get(id);\n      const name = node?.title || id;\n      const display = options.ids ? `${name} [${id.slice(0, 8)}]` : name;\n\n      line += display;\n      if (j < p.edges.length) {\n        line += ` [${p.edges[j]}] `;\n      }\n    }\n    console.log(line);\n    console.log();\n  }\n}\n\n/**\n * Format output as markdown\n */\nfunction formatMarkdown(\n  fromNode: Node,\n  toNode: Node,\n  paths: Array<{ path: string[]; edges: EdgeType[]; hopCount: number; score: number }>,\n  nodeMap: Map<string, Node>\n): string {\n  const lines: string[] = [];\n  lines.push(`# Reading Path: ${fromNode.title}  ${toNode.title}`);\n  lines.push('');\n\n  if (paths.length === 0) {\n    lines.push('No paths found between these nodes.');\n    lines.push('');\n  } else {\n    for (let i = 0; i < paths.length; i++) {\n      const p = paths[i]!;\n      lines.push(`## Path ${i + 1} (${p.hopCount} hops)`);\n      lines.push('');\n\n      for (let j = 0; j < p.path.length; j++) {\n        const id = p.path[j]!;\n        const node = nodeMap.get(id);\n        const name = node?.title || id;\n        const nodePath = node?.path || '';\n        lines.push(`${j + 1}. [${name}](${nodePath})`);\n      }\n      lines.push('');\n    }\n  }\n\n  lines.push('---');\n  lines.push('_Generated by ZettelScript Pathfinder_');\n\n  return lines.join('\\n');\n}\n\n/**\n * Format output as JSON\n */\nfunction formatJson(\n  fromNode: Node,\n  toNode: Node,\n  paths: Array<{ path: string[]; edges: EdgeType[]; hopCount: number; score: number }>,\n  options: PathCommandOptions,\n  effectiveEdgeTypes: EdgeType[],\n  reason: string,\n  k: number\n): string {\n  const output = {\n    version: 1,\n    computedAt: new Date().toISOString(),\n    fromId: fromNode.nodeId,\n    fromLabel: fromNode.title,\n    toId: toNode.nodeId,\n    toLabel: toNode.title,\n    options: {\n      k,\n      maxDepth: parseInt(options.maxDepth, 10),\n      maxExtra: parseInt(options.maxExtra, 10),\n      overlapThreshold: 0.7,\n      edgeTypes: effectiveEdgeTypes,\n    },\n    returnedCount: paths.length,\n    reason: paths.length < k ? reason : 'found_all',\n    paths: paths.map((p) => ({\n      hopCount: p.hopCount,\n      score: p.score,\n      nodes: p.path,\n      edges: p.edges,\n    })),\n  };\n\n  return JSON.stringify(output, null, 2);\n}\n\nexport const pathCommand = new Command('path')\n  .description('Find narrative paths between two nodes')\n  .argument('<from>', 'Starting node (title or path)')\n  .argument('<to>', 'Ending node (title or path)')\n  .option('-k, --max-paths <n>', 'Maximum paths to return', '3')\n  .option('--max-depth <n>', 'Maximum hops to search', '15')\n  .option('--max-extra <n>', 'Max extra hops beyond shortest', '2')\n  .option('--format <type>', 'Output format: table|verbose|md|json', 'table')\n  .option('-o, --output <file>', 'Write output to file')\n  .option('--edge-types <types>', 'Comma-separated edge types to include')\n  .option('--exclude-edges <types>', 'Comma-separated edge types to exclude')\n  .option('--ids', 'Show node IDs in output')\n  .action(async (from: string, to: string, options: PathCommandOptions) => {\n    const spinner = new Spinner('Finding paths...');\n\n    try {\n      const ctx = await initContext();\n      spinner.start();\n\n      // Resolve nodes\n      spinner.update('Resolving nodes...');\n      const fromNode = await resolveNode(from, ctx);\n      if (!fromNode) {\n        spinner.stop();\n        console.error(`Could not find node: \"${from}\"`);\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      const toNode = await resolveNode(to, ctx);\n      if (!toNode) {\n        spinner.stop();\n        console.error(`Could not find node: \"${to}\"`);\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Determine effective edge types\n      let effectiveEdgeTypes: EdgeType[];\n      if (options.edgeTypes) {\n        effectiveEdgeTypes = parseEdgeTypes(options.edgeTypes);\n      } else {\n        effectiveEdgeTypes = [...DEFAULT_EDGE_TYPES];\n      }\n\n      // Apply exclusions\n      if (options.excludeEdges) {\n        const excluded = new Set(parseEdgeTypes(options.excludeEdges));\n        effectiveEdgeTypes = effectiveEdgeTypes.filter((t) => !excluded.has(t));\n      } else if (!options.edgeTypes) {\n        // Apply default exclusions only if --edge-types not specified\n        const defaultExcluded = new Set(DEFAULT_EXCLUDED);\n        effectiveEdgeTypes = effectiveEdgeTypes.filter((t) => !defaultExcluded.has(t));\n      }\n\n      if (effectiveEdgeTypes.length === 0) {\n        spinner.stop();\n        console.error(\n          'No edge types selected. Check your --edge-types and --exclude-edges options.'\n        );\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Find paths\n      spinner.update('Searching for paths...');\n      const k = parseInt(options.maxPaths, 10);\n      const maxDepth = parseInt(options.maxDepth, 10);\n      const maxExtra = parseInt(options.maxExtra, 10);\n\n      const { paths, reason } = await ctx.graphEngine.findKShortestPaths(\n        fromNode.nodeId,\n        toNode.nodeId,\n        {\n          k,\n          maxDepth,\n          maxExtraHops: maxExtra,\n          edgeTypes: effectiveEdgeTypes,\n          overlapThreshold: 0.7,\n          maxCandidates: 100,\n        }\n      );\n\n      // Get node info for display\n      const allNodeIds = new Set<string>();\n      for (const p of paths) {\n        for (const id of p.path) {\n          allNodeIds.add(id);\n        }\n      }\n      const nodes = await ctx.nodeRepository.findByIds([...allNodeIds]);\n      const nodeMap = new Map(nodes.map((n) => [n.nodeId, n]));\n\n      spinner.stop();\n\n      // Format output\n      let output: string | undefined;\n\n      switch (options.format) {\n        case 'verbose':\n          formatVerbose(fromNode, toNode, paths, nodeMap, options);\n          break;\n\n        case 'md':\n          output = formatMarkdown(fromNode, toNode, paths, nodeMap);\n          if (options.output) {\n            fs.writeFileSync(options.output, output, 'utf-8');\n            console.log(`Markdown written to: ${options.output}`);\n          } else {\n            console.log(output);\n          }\n          break;\n\n        case 'json':\n          output = formatJson(fromNode, toNode, paths, options, effectiveEdgeTypes, reason, k);\n          if (options.output) {\n            fs.writeFileSync(options.output, output, 'utf-8');\n            console.log(`JSON written to: ${options.output}`);\n          } else {\n            console.log(output);\n          }\n          break;\n\n        case 'table':\n        default:\n          formatTable(fromNode, toNode, paths, nodeMap, options, effectiveEdgeTypes, reason, k);\n          break;\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      spinner.stop();\n      console.error('Path finding failed:', error);\n      process.exit(1);\n    }\n  });\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport open from 'open';\nimport { initContext, getZettelScriptDir, Spinner } from '../utils.js';\nimport type { CLIContext } from '../utils.js';\nimport { computeDoctorStats, printEmbeddingStatus, printWormholeStatus } from './doctor.js';\nimport {\n  generateVisualizationHtml,\n  typeColors,\n  type GraphData,\n  type GraphNode,\n  type GraphLink,\n} from './visualize.js';\nimport { getEdgeLayer, type EdgeType, type Node, type Edge } from '../../core/types/index.js';\nimport { assembleFocusBundle, type RelatedNote } from '../../discovery/focus-bundle.js';\nimport { SuggestionEngine, OrphanEngine } from '../../discovery/suggestion-engine.js';\n\n// ============================================================================\n// Hybrid Search Configuration (Phase 3)\n// ============================================================================\n\nexport interface HybridSearchConfig {\n  enabled: boolean;\n  wVec: number; // Weight for vector similarity (default: 0.85)\n  wKw: number; // Weight for keyword match (default: 0.15)\n}\n\nexport const DEFAULT_HYBRID_CONFIG: HybridSearchConfig = {\n  enabled: true,\n  wVec: 0.85,\n  wKw: 0.15,\n};\n\nexport interface GroupingConfig {\n  enabled: boolean;\n  kStrong: number; // Std multiplier for \"strong\" group boundary (default: 1.0)\n  kWeak: number; // Std multiplier for \"weak\" group boundary (default: 0.0)\n}\n\nexport const DEFAULT_GROUPING_CONFIG: GroupingConfig = {\n  enabled: true,\n  kStrong: 1.0,\n  kWeak: 0.0,\n};\n\n// ============================================================================\n// State Management\n// ============================================================================\n\ninterface FocusState {\n  lastFocusedNodeId?: string;\n  lastFocusedAt?: string;\n}\n\nfunction getStatePath(vaultPath: string): string {\n  return path.join(getZettelScriptDir(vaultPath), 'state.json');\n}\n\nfunction loadFocusState(vaultPath: string): FocusState {\n  const statePath = getStatePath(vaultPath);\n  try {\n    if (fs.existsSync(statePath)) {\n      return JSON.parse(fs.readFileSync(statePath, 'utf-8'));\n    }\n  } catch {\n    // Ignore parse errors\n  }\n  return {};\n}\n\nfunction saveFocusState(vaultPath: string, state: FocusState): void {\n  const statePath = getStatePath(vaultPath);\n  fs.writeFileSync(statePath, JSON.stringify(state, null, 2), 'utf-8');\n}\n\n// ============================================================================\n// Node Resolution\n// ============================================================================\n\nasync function resolveTargetNode(ctx: CLIContext, target?: string): Promise<Node | null> {\n  const { nodeRepository, vaultPath } = ctx;\n\n  // If target provided, resolve it\n  if (target) {\n    // Try as file path first\n    let node = await nodeRepository.findByPath(target);\n    if (node) return node;\n\n    // Try as title\n    const byTitle = await nodeRepository.findByTitle(target);\n    if (byTitle.length > 0) return byTitle[0];\n\n    // Try as alias\n    const byAlias = await nodeRepository.findByTitleOrAlias(target);\n    if (byAlias.length > 0) return byAlias[0];\n\n    // Try as node ID\n    node = await nodeRepository.findById(target);\n    if (node) return node;\n\n    return null;\n  }\n\n  // No target - use fallback order\n  // 1. File with most recent mtime in vault\n  const nodes = await nodeRepository.findAll();\n  if (nodes.length === 0) return null;\n\n  // Sort by updatedAt descending\n  nodes.sort((a, b) => {\n    const aTime = a.updatedAt ? new Date(a.updatedAt).getTime() : 0;\n    const bTime = b.updatedAt ? new Date(b.updatedAt).getTime() : 0;\n    return bTime - aTime;\n  });\n\n  const mostRecent = nodes[0];\n\n  // 2. Check last focused node\n  const state = loadFocusState(vaultPath);\n  if (state.lastFocusedNodeId) {\n    const lastFocused = await nodeRepository.findById(state.lastFocusedNodeId);\n    if (lastFocused) {\n      // Use last focused if it's reasonably recent (edited in last day)\n      const lastFocusedTime = lastFocused.updatedAt ? new Date(lastFocused.updatedAt).getTime() : 0;\n      const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;\n      if (lastFocusedTime > oneDayAgo) {\n        return lastFocused;\n      }\n    }\n  }\n\n  return mostRecent;\n}\n\n// ============================================================================\n// Bounded Subgraph Builder\n// ============================================================================\n\ninterface SubgraphOptions {\n  nodeBudget: number;\n  maxDepth: number;\n}\n\ninterface SubgraphResult {\n  nodes: Node[];\n  edges: Edge[];\n  focusNodeId: string;\n}\n\nasync function buildBoundedSubgraph(\n  ctx: CLIContext,\n  focusNode: Node,\n  options: SubgraphOptions\n): Promise<SubgraphResult> {\n  const { nodeRepository, edgeRepository } = ctx;\n  const { nodeBudget, maxDepth } = options;\n\n  const visitedNodes = new Set<string>([focusNode.nodeId]);\n  const collectedNodes: Node[] = [focusNode];\n  const collectedEdges: Edge[] = [];\n  const edgeSet = new Set<string>();\n\n  // BFS expansion - prioritize Layer A edges, then Layer B\n  let frontier = [focusNode.nodeId];\n  let depth = 0;\n\n  while (frontier.length > 0 && collectedNodes.length < nodeBudget && depth < maxDepth) {\n    const nextFrontier: string[] = [];\n    depth++;\n\n    for (const nodeId of frontier) {\n      if (collectedNodes.length >= nodeBudget) break;\n\n      // Get all connected edges (both directions)\n      const allEdges = await edgeRepository.findConnected(nodeId);\n\n      // Sort by layer priority (A first, then B)\n      allEdges.sort((a, b) => {\n        const layerA = getEdgeLayer(a.edgeType as EdgeType);\n        const layerB = getEdgeLayer(b.edgeType as EdgeType);\n        const priority: Record<string, number> = { A: 0, B: 1, C: 2, unknown: 3 };\n        return (priority[layerA] || 3) - (priority[layerB] || 3);\n      });\n\n      for (const edge of allEdges) {\n        if (collectedNodes.length >= nodeBudget) break;\n\n        // Skip Layer C edges in focus mode\n        const layer = getEdgeLayer(edge.edgeType as EdgeType);\n        if (layer === 'C') continue;\n\n        // Add edge if not seen\n        if (!edgeSet.has(edge.edgeId)) {\n          edgeSet.add(edge.edgeId);\n          collectedEdges.push(edge);\n        }\n\n        // Determine neighbor\n        const neighborId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n        if (!visitedNodes.has(neighborId)) {\n          visitedNodes.add(neighborId);\n          const neighborNode = await nodeRepository.findById(neighborId);\n          if (neighborNode) {\n            collectedNodes.push(neighborNode);\n            nextFrontier.push(neighborId);\n          }\n        }\n      }\n    }\n\n    frontier = nextFrontier;\n  }\n\n  return {\n    nodes: collectedNodes,\n    edges: collectedEdges,\n    focusNodeId: focusNode.nodeId,\n  };\n}\n\n// ============================================================================\n// Graph Data Conversion\n// ============================================================================\n\nfunction subgraphToGraphData(\n  result: SubgraphResult,\n  nodeColors: Record<string, string>\n): GraphData {\n  const { nodes, edges, focusNodeId } = result;\n\n  // Calculate degree for node sizing\n  const nodeWeights = new Map<string, number>();\n  edges.forEach((e) => {\n    nodeWeights.set(e.sourceId, (nodeWeights.get(e.sourceId) || 0) + 1);\n    nodeWeights.set(e.targetId, (nodeWeights.get(e.targetId) || 0) + 1);\n  });\n\n  const graphNodes: GraphNode[] = nodes.map((n) => ({\n    id: n.nodeId,\n    name: n.title,\n    type: n.type,\n    val:\n      n.nodeId === focusNodeId\n        ? 15 // Focus node is larger\n        : Math.max(1, Math.min(10, (nodeWeights.get(n.nodeId) || 0) / 2)),\n    color: nodeColors[n.type] || '#94a3b8',\n    path: n.path,\n    metadata: (n.metadata as Record<string, unknown>) || {},\n    updatedAtMs: n.updatedAt ? new Date(n.updatedAt).getTime() : undefined,\n  }));\n\n  const graphLinks: GraphLink[] = edges.map((e) => ({\n    source: e.sourceId,\n    target: e.targetId,\n    type: e.edgeType,\n    strength: e.strength ?? 1.0,\n    provenance: e.provenance,\n  }));\n\n  return { nodes: graphNodes, links: graphLinks };\n}\n\n// ============================================================================\n// Atomic File Writes\n// ============================================================================\n\n/**\n * Write content to a file atomically using tmp file + rename.\n * This prevents corruption on crash.\n */\nfunction writeFileAtomic(filePath: string, content: string): void {\n  const dir = path.dirname(filePath);\n  const basename = path.basename(filePath);\n\n  // Create temp file in same directory to ensure same filesystem\n  const tmpPath = path.join(dir, `.${basename}.tmp.${process.pid}`);\n\n  try {\n    // Write to temp file\n    fs.writeFileSync(tmpPath, content, 'utf-8');\n\n    // Rename atomically (on same filesystem)\n    fs.renameSync(tmpPath, filePath);\n  } catch (error) {\n    // Clean up temp file on error\n    try {\n      fs.unlinkSync(tmpPath);\n    } catch {\n      // Ignore cleanup errors\n    }\n    throw error;\n  }\n}\n\n// ============================================================================\n// Related Notes Computation\n// ============================================================================\n\n/**\n * Compute related notes based on semantic similarity with optional keyword boost.\n * Uses embeddings to find similar notes not already in the subgraph.\n * Phase 3: Hybrid search combines vector similarity with keyword matching.\n * Phase 3: Statistical grouping identifies natural clusters in results.\n */\nasync function computeRelatedNotes(\n  ctx: CLIContext,\n  focusNodeId: string,\n  nodesInView: Node[],\n  hybridConfig: HybridSearchConfig = DEFAULT_HYBRID_CONFIG,\n  groupingConfig: GroupingConfig = DEFAULT_GROUPING_CONFIG\n): Promise<RelatedNote[]> {\n  const { embeddingRepository, nodeRepository } = ctx;\n\n  // Get focus node and its embedding\n  const focusNodes = await nodeRepository.findByIds([focusNodeId]);\n  if (focusNodes.length === 0) {\n    return [];\n  }\n  const focusNode = focusNodes[0];\n\n  const focusEmbeddings = await embeddingRepository.findByNodeIds([focusNodeId]);\n  if (focusEmbeddings.length === 0) {\n    return [];\n  }\n\n  const focusEmbedding = focusEmbeddings[0].embedding;\n  const nodeIdsInView = new Set(nodesInView.map((n) => n.nodeId));\n\n  // Get all embeddings to find related notes (fetch 2x for reranking)\n  const allNodes = await nodeRepository.findAll();\n  const candidateNodeIds = allNodes\n    .filter((n) => !n.isGhost && !nodeIdsInView.has(n.nodeId))\n    .map((n) => n.nodeId);\n\n  if (candidateNodeIds.length === 0) {\n    return [];\n  }\n\n  const candidateEmbeddings = await embeddingRepository.findByNodeIds(candidateNodeIds);\n  const nodeMap = new Map(allNodes.map((n) => [n.nodeId, n]));\n\n  // Tokenize focus node title for keyword matching\n  const focusTokens = tokenize(focusNode.title);\n\n  // Compute hybrid scores\n  const scored: Array<{\n    nodeId: string;\n    vecScore: number;\n    kwScore: number;\n    finalScore: number;\n    matchedTerms: string[];\n  }> = [];\n\n  for (const emb of candidateEmbeddings) {\n    const vecScore = cosineSimilarity(focusEmbedding, emb.embedding);\n    if (vecScore < 0.35) {\n      // Minimum vector threshold (relaxed for hybrid)\n      continue;\n    }\n\n    const node = nodeMap.get(emb.nodeId);\n    if (!node) continue;\n\n    // Compute keyword score\n    let kwScore = 0;\n    let matchedTerms: string[] = [];\n\n    if (hybridConfig.enabled && hybridConfig.wKw > 0) {\n      const candidateTokens = tokenize(node.title);\n      const kwResult = keywordScore(focusTokens, candidateTokens);\n      kwScore = kwResult.score;\n      matchedTerms = kwResult.matchedTerms;\n    }\n\n    // Compute final hybrid score\n    const finalScore = hybridConfig.enabled\n      ? hybridConfig.wVec * vecScore + hybridConfig.wKw * kwScore\n      : vecScore;\n\n    scored.push({ nodeId: emb.nodeId, vecScore, kwScore, finalScore, matchedTerms });\n  }\n\n  // Sort by final score descending\n  scored.sort((a, b) => b.finalScore - a.finalScore);\n\n  // Apply statistical grouping to identify natural clusters\n  // Map to score-based array for grouping algorithm\n  const forGrouping = scored.map((s) => ({ ...s, score: s.finalScore }));\n  const grouped = applyGrouping(forGrouping, groupingConfig, 2); // Take top 2 groups (related mode)\n\n  // Take top 15 from grouped results (hard cap)\n  const top = grouped.slice(0, 15);\n\n  // Build RelatedNote objects with hybrid signals\n  return top\n    .map(({ nodeId, vecScore, kwScore, finalScore, matchedTerms }) => {\n      const node = nodeMap.get(nodeId);\n      if (!node) return null;\n\n      // Build reasons with both signals\n      const reasons: string[] = [];\n      reasons.push(`Semantic similarity: ${(vecScore * 100).toFixed(0)}%`);\n\n      if (kwScore > 0 && matchedTerms.length > 0) {\n        const termDisplay = matchedTerms.slice(0, 3).join(', ');\n        reasons.push(`Keyword match: ${matchedTerms.length} term(s) (${termDisplay})`);\n      }\n\n      return {\n        nodeId: node.nodeId,\n        title: node.title,\n        path: node.path,\n        score: finalScore,\n        reasons,\n        layer: 'B' as const,\n        isInView: false,\n        signals: {\n          semantic: vecScore,\n          lexical: kwScore > 0 ? kwScore : undefined,\n        },\n      };\n    })\n    .filter((rn): rn is RelatedNote => rn !== null);\n}\n\n/**\n * Cosine similarity between two vectors.\n */\nfunction cosineSimilarity(a: number[], b: number[]): number {\n  if (a.length !== b.length) return 0;\n\n  let dot = 0;\n  let normA = 0;\n  let normB = 0;\n\n  for (let i = 0; i < a.length; i++) {\n    dot += a[i] * b[i];\n    normA += a[i] * a[i];\n    normB += b[i] * b[i];\n  }\n\n  if (normA === 0 || normB === 0) return 0;\n  return dot / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n\n/**\n * Tokenize text into normalized terms for keyword matching.\n * Removes common stopwords and short terms.\n */\nfunction tokenize(text: string): Set<string> {\n  const stopwords = new Set([\n    'the',\n    'a',\n    'an',\n    'and',\n    'or',\n    'but',\n    'in',\n    'on',\n    'at',\n    'to',\n    'for',\n    'of',\n    'with',\n    'by',\n    'from',\n    'as',\n    'is',\n    'was',\n    'are',\n    'were',\n    'been',\n    'be',\n    'have',\n    'has',\n    'had',\n    'do',\n    'does',\n    'did',\n    'will',\n    'would',\n    'could',\n    'should',\n    'may',\n    'might',\n    'must',\n    'shall',\n    'can',\n    'need',\n    'dare',\n    'ought',\n    'this',\n    'that',\n    'these',\n    'those',\n    'it',\n    'its',\n    'my',\n    'your',\n    'his',\n    'her',\n    'their',\n    'our',\n    'we',\n    'you',\n    'he',\n    'she',\n    'they',\n    'them',\n    'us',\n    'me',\n  ]);\n\n  return new Set(\n    text\n      .toLowerCase()\n      .replace(/[^\\w\\s-]/g, ' ') // Keep alphanumeric, spaces, hyphens\n      .split(/\\s+/)\n      .filter((term) => term.length >= 3 && !stopwords.has(term))\n  );\n}\n\n/**\n * Compute keyword overlap score between two texts.\n * Returns a value between 0 and 1 based on Jaccard-like similarity.\n */\nfunction keywordScore(\n  focusTokens: Set<string>,\n  candidateTokens: Set<string>\n): {\n  score: number;\n  matchedTerms: string[];\n} {\n  if (focusTokens.size === 0 || candidateTokens.size === 0) {\n    return { score: 0, matchedTerms: [] };\n  }\n\n  const matchedTerms: string[] = [];\n  for (const term of focusTokens) {\n    if (candidateTokens.has(term)) {\n      matchedTerms.push(term);\n    }\n  }\n\n  // Jaccard-like: matches / (union size - matches + epsilon)\n  // But we weight by focus terms since that's what we're searching from\n  const score = matchedTerms.length / focusTokens.size;\n\n  return { score: Math.min(1, score), matchedTerms };\n}\n\n/**\n * Apply statistical grouping to scored results.\n * Uses mean + k*sigma threshold to identify natural group boundaries.\n *\n * @param results - Array of items with a score property, sorted descending by score\n * @param config - Grouping configuration\n * @param mode - 'strong' returns first group only, 'weak' returns up to 2 groups\n * @returns Indices of boundaries (positions where groups should be cut)\n */\nexport function findGroupBoundaries<T extends { score: number }>(\n  results: T[],\n  config: GroupingConfig\n): number[] {\n  if (!config.enabled || results.length <= 1) {\n    return [];\n  }\n\n  // Calculate gaps between consecutive results (assumes sorted desc by score)\n  const gaps: { index: number; gap: number }[] = [];\n  for (let i = 0; i < results.length - 1; i++) {\n    const gap = results[i].score - results[i + 1].score;\n    gaps.push({ index: i + 1, gap });\n  }\n\n  if (gaps.length === 0) {\n    return [];\n  }\n\n  // Calculate statistical threshold\n  const gapValues = gaps.map((g) => g.gap);\n  const mean = gapValues.reduce((a, b) => a + b, 0) / gapValues.length;\n  const variance = gapValues.reduce((a, b) => a + (b - mean) ** 2, 0) / gapValues.length;\n  const std = Math.sqrt(variance);\n\n  // Find boundaries using strong threshold (mean + kStrong * std)\n  // Add small epsilon for floating point tolerance\n  const epsilon = 1e-10;\n  const strongThreshold = mean + config.kStrong * std + epsilon;\n\n  const boundaries = gaps.filter((g) => g.gap > strongThreshold).map((g) => g.index);\n\n  return boundaries;\n}\n\n/**\n * Apply grouping to results, returning only the top group(s).\n *\n * @param results - Array sorted descending by score\n * @param config - Grouping configuration\n * @param maxGroups - Maximum number of groups to return (1 for strong, 2 for weak)\n * @returns Filtered array containing only the top group(s)\n */\nexport function applyGrouping<T extends { score: number }>(\n  results: T[],\n  config: GroupingConfig,\n  maxGroups: number = 1\n): T[] {\n  if (!config.enabled || results.length <= 1) {\n    return results;\n  }\n\n  const boundaries = findGroupBoundaries(results, config);\n\n  if (boundaries.length === 0) {\n    return results; // No natural boundaries found, return all\n  }\n\n  // Determine cutoff based on maxGroups\n  const cutoffIndex = maxGroups <= boundaries.length ? boundaries[maxGroups - 1] : results.length; // Not enough boundaries, return all\n\n  return results.slice(0, cutoffIndex);\n}\n\n// ============================================================================\n// Command Definition\n// ============================================================================\n\nexport const focusCommand = new Command('focus')\n  .description('Open a focus view centered on a specific note or the most recent file')\n  .argument('[target]', 'File path, node title, or node ID to focus on')\n  .option('-b, --budget <number>', 'Maximum number of nodes to show', '200')\n  .option('-d, --depth <number>', 'Maximum expansion depth', '3')\n  .option('-o, --output <path>', 'Output HTML file path')\n  .option('--no-open', 'Do not open browser automatically')\n  .option('--json-stdout', 'Print FocusBundle JSON to stdout, no file writes')\n  .option('--json-only', 'Write focus.json only, print path to stdout')\n  .action(\n    async (\n      target: string | undefined,\n      options: {\n        budget: string;\n        depth: string;\n        output?: string;\n        open: boolean;\n        jsonStdout?: boolean;\n        jsonOnly?: boolean;\n      }\n    ) => {\n      // Validate mutually exclusive flags\n      if (options.jsonStdout && options.jsonOnly) {\n        console.error(\n          JSON.stringify({\n            success: false,\n            error: '--json-stdout and --json-only are mutually exclusive',\n            errorCode: 'INVALID_ARGS',\n          })\n        );\n        process.exit(1);\n      }\n\n      const isJsonMode = options.jsonStdout || options.jsonOnly;\n\n      try {\n        const ctx = await initContext();\n        const nodeBudget = parseInt(options.budget, 10);\n        const maxDepth = parseInt(options.depth, 10);\n\n        // 1. Resolve target node\n        let spinner: Spinner | null = null;\n        if (!isJsonMode) {\n          spinner = new Spinner('Resolving target...');\n          spinner.start();\n        }\n\n        const focusNode = await resolveTargetNode(ctx, target);\n\n        if (!focusNode) {\n          if (spinner) spinner.stop();\n\n          if (isJsonMode) {\n            console.log(\n              JSON.stringify({\n                success: false,\n                error: target ? `Could not find node: \"${target}\"` : 'No nodes found in vault',\n                errorCode: 'NOT_FOUND',\n              })\n            );\n          } else {\n            if (target) {\n              console.error(`Could not find node: \"${target}\"`);\n              console.log('\\nTry:');\n              console.log('  - A file path relative to vault root');\n              console.log('  - A note title');\n              console.log('  - A node ID');\n            } else {\n              console.error('No nodes found in vault. Run \"zs index\" first.');\n            }\n          }\n          ctx.connectionManager.close();\n          process.exit(1);\n        }\n\n        if (spinner) {\n          spinner.update(`Building focus view for \"${focusNode.title}\"...`);\n        }\n\n        // Save focus state (unless in json-stdout mode)\n        if (!options.jsonStdout) {\n          saveFocusState(ctx.vaultPath, {\n            lastFocusedNodeId: focusNode.nodeId,\n            lastFocusedAt: new Date().toISOString(),\n          });\n        }\n\n        // 2. Build bounded subgraph\n        const subgraph = await buildBoundedSubgraph(ctx, focusNode, {\n          nodeBudget,\n          maxDepth,\n        });\n\n        // 3. Get health stats\n        const statusData = await computeDoctorStats(ctx);\n\n        // 4. Compute suggestions\n        const scopeNodeIds = subgraph.nodes.map((n) => n.nodeId);\n\n        // Initialize suggestion engines\n        const suggestionEngine = new SuggestionEngine(\n          ctx.nodeRepository,\n          ctx.edgeRepository,\n          ctx.mentionRepository,\n          ctx.embeddingRepository,\n          ctx.candidateEdgeRepository\n        );\n\n        const orphanEngine = new OrphanEngine(\n          ctx.nodeRepository,\n          ctx.edgeRepository,\n          ctx.mentionRepository,\n          ctx.embeddingRepository\n        );\n\n        // Compute candidates (this upserts to DB)\n        await suggestionEngine.computeAllCandidates(scopeNodeIds);\n\n        // Get suggested candidate edges for the scope\n        const candidateEdges =\n          await ctx.candidateEdgeRepository.findSuggestedForNodes(scopeNodeIds);\n\n        // Compute orphan scores\n        const orphanEntries = await orphanEngine.computeOrphanScores(scopeNodeIds);\n\n        // Compute related notes\n        const relatedNotes = await computeRelatedNotes(ctx, focusNode.nodeId, subgraph.nodes);\n\n        // 5. Assemble FocusBundle\n        const focusBundle = assembleFocusBundle({\n          focusNode,\n          nodesInView: subgraph.nodes,\n          edgesInView: subgraph.edges,\n          candidateEdges,\n          orphanEntries,\n          relatedNotes,\n          doctorStats: statusData,\n          mode: ctx.config.visualization.mode,\n        });\n\n        if (spinner) {\n          spinner.stop(\n            `Focus: \"${focusNode.title}\" (${subgraph.nodes.length} nodes, ${subgraph.edges.length} edges)`\n          );\n        }\n\n        // 6. Handle output based on mode\n        const outputDir = options.output\n          ? path.dirname(options.output)\n          : getZettelScriptDir(ctx.vaultPath);\n\n        if (!fs.existsSync(outputDir)) {\n          fs.mkdirSync(outputDir, { recursive: true });\n        }\n\n        if (options.jsonStdout) {\n          // JSON stdout mode: print JSON, no file writes\n          console.log(JSON.stringify(focusBundle));\n        } else if (options.jsonOnly) {\n          // JSON only mode: write focus.json, print path\n          const jsonPath = path.join(outputDir, 'focus.json');\n          writeFileAtomic(jsonPath, JSON.stringify(focusBundle, null, 2));\n          console.log(jsonPath);\n        } else {\n          // Default mode: write both files, print status, optionally open browser\n\n          // Print one-line embedding status\n          printEmbeddingStatus(statusData);\n          printWormholeStatus(statusData);\n\n          // Write focus.json atomically\n          const jsonPath = path.join(outputDir, 'focus.json');\n          writeFileAtomic(jsonPath, JSON.stringify(focusBundle, null, 2));\n\n          // Convert to graph data for HTML\n          const graphData = subgraphToGraphData(subgraph, typeColors);\n\n          // Generate HTML\n          const htmlContent = generateVisualizationHtml(\n            graphData,\n            typeColors,\n            null, // No constellation\n            null, // No path data\n            null, // No WebSocket\n            statusData,\n            focusBundle\n          );\n\n          // Write HTML\n          const outputPath = options.output || path.join(outputDir, 'focus.html');\n          writeFileAtomic(outputPath, htmlContent);\n\n          console.log(`\\nFocus view generated: ${outputPath}`);\n          console.log(`FocusBundle written: ${jsonPath}`);\n\n          // Print suggestion summary\n          const suggestionCount = focusBundle.suggestions.candidateLinks.length;\n          const orphanCount = focusBundle.suggestions.orphans.length;\n          const relatedCount = focusBundle.suggestions.relatedNotes.length;\n          if (suggestionCount > 0 || orphanCount > 0 || relatedCount > 0) {\n            console.log(\n              `Suggestions: ${relatedCount} related, ${suggestionCount} links, ${orphanCount} orphans`\n            );\n          }\n\n          // Open browser\n          if (options.open) {\n            console.log('Opening in default browser...');\n            await open(outputPath);\n          }\n        }\n\n        ctx.connectionManager.close();\n      } catch (error) {\n        if (isJsonMode) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          const errorCode = errorMessage.includes('Not in a ZettelScript vault')\n            ? 'NOT_VAULT'\n            : 'COMPUTE_ERROR';\n          console.log(\n            JSON.stringify({\n              success: false,\n              error: errorMessage,\n              errorCode,\n            })\n          );\n          process.exit(1);\n        }\n\n        if (error instanceof Error && error.message.includes('Not in a ZettelScript vault')) {\n          console.error('Error: Not in a ZettelScript vault. Run \"zs init\" first.');\n          process.exit(1);\n        }\n        console.error('Error:', error);\n        process.exit(1);\n      }\n    }\n  );\n","/**\n * Focus Bundle - Phase 2.2\n *\n * Assembles the FocusBundle schema that both Atlas and Obsidian consume.\n * This is the single source of truth for focus view data.\n *\n * Per Phase 2 Design Document Section 1.\n */\n\nimport type { Node, Edge, EdgeType, CandidateEdge } from '../core/types/index.js';\nimport { getEdgeLayer } from '../core/types/index.js';\nimport { getCircuitBreaker } from '../core/circuit-breaker.js';\nimport type { DoctorStats } from '../cli/commands/doctor.js';\nimport type { OrphanEntry } from './suggestion-engine.js';\n\n// ============================================================================\n// Schema Version\n// ============================================================================\n\nexport const FOCUS_SCHEMA_VERSION = 1;\nexport const APP_VERSION = '2.0.0';\n\n// ============================================================================\n// FocusBundle Types (per Phase 2 Design Section 1)\n// ============================================================================\n\nexport interface FocusBundleMeta {\n  schemaVersion: number;\n  appVersion: string;\n  generatedAt: string;\n  mode: 'focus' | 'classic';\n  scope: {\n    kind: 'node' | 'file' | 'folder' | 'vault';\n    focusNodeId: string;\n    focusNodePath: string;\n    focusNodeTitle: string;\n  };\n}\n\nexport interface HealthSummary {\n  level: 'ok' | 'warn' | 'fail';\n  warnings: string[];\n\n  embeddings: {\n    level: 'ok' | 'warn' | 'fail';\n    coverageInView: number;\n    eligibleInView: number;\n    embeddedInView: number;\n    missingInView: number;\n    pending: number;\n    errors: number;\n    lastError?: string;\n  };\n\n  wormholes: {\n    enabled: boolean;\n    level: 'ok' | 'warn' | 'fail';\n    countInView: number;\n    threshold: number;\n    disabledReason?: string;\n  };\n\n  index: {\n    lastRunAt?: string;\n    nodeCount: number;\n    edgeCountsByLayer: { A: number; B: number; C: number };\n  };\n\n  extraction: {\n    parseFailures: number;\n    badChunksPath?: string;\n  };\n}\n\nexport interface NodeDTO {\n  id: string;\n  title: string;\n  path: string;\n  type: string;\n  updatedAtMs?: number;\n  isGhost: boolean;\n  degreeA: number;\n  degreeB: number;\n  degreeC: number;\n}\n\nexport interface EdgeDTO {\n  id: string;\n  fromId: string;\n  toId: string;\n  type: string;\n  status: 'truth' | 'suggested' | 'approved' | 'rejected';\n  layer: 'A' | 'B' | 'C';\n  confidence?: number;\n  provenance?: string;\n}\n\nexport interface RelatedNote {\n  nodeId: string;\n  title: string;\n  path: string;\n  score: number;\n  reasons: string[];\n  layer: 'B';\n  isInView: boolean;\n  signals?: {\n    semantic?: number;\n    lexical?: number;\n    graph?: number;\n    recency?: number;\n  };\n}\n\nexport interface CandidateLink {\n  suggestionId: string;\n  fromId: string;\n  fromTitle: string;\n  toId: string;\n  toTitle: string;\n  toIsGhost: boolean;\n  suggestedEdgeType: EdgeType;\n  confidence: number;\n  reasons: string[];\n  source: 'mention' | 'semantic' | 'heuristic';\n  status: 'suggested' | 'approved' | 'rejected';\n  signals: {\n    semantic?: number;\n    mentionCount?: number;\n    graphProximity?: number;\n  };\n  provenance?: {\n    model?: string;\n    excerpt?: string;\n    createdAt?: string;\n  };\n}\n\nexport interface SuggestedAction {\n  actionType: 'link_to' | 'link_from' | 'create_note' | 'pin' | 'ignore';\n  targetNodeId?: string;\n  label: string;\n  template: string;\n}\n\nexport interface OrphanEntryDTO {\n  nodeId: string;\n  title: string;\n  path: string;\n  orphanScore: number;\n  severity: 'low' | 'med' | 'high';\n  percentile: number;\n  reasons: string[];\n  relatedNodeIds: string[];\n  suggestedActions: SuggestedAction[];\n}\n\nexport interface ActionTemplates {\n  approve: {\n    template: string;\n    supportsBatch: boolean;\n  };\n  reject: {\n    template: string;\n  };\n  focus: {\n    template: string;\n  };\n  createNote: {\n    template: string;\n  };\n}\n\nexport interface FocusBundle {\n  meta: FocusBundleMeta;\n  health: HealthSummary;\n  graph: {\n    nodes: NodeDTO[];\n    edges: EdgeDTO[];\n  };\n  suggestions: {\n    relatedNotes: RelatedNote[];\n    candidateLinks: CandidateLink[];\n    orphans: OrphanEntryDTO[];\n  };\n  actions: ActionTemplates;\n}\n\n// ============================================================================\n// Hard Caps (per Phase 2 Design Section 3.2)\n// ============================================================================\n\nexport const SUGGESTION_CAPS = {\n  relatedNotesPerFocus: 10,\n  candidateLinksPerFocus: 20,\n  orphansPerFocus: 10,\n  reasonsPerSuggestion: 3,\n  excerptMaxLength: 200,\n};\n\n// ============================================================================\n// Bundle Assembler\n// ============================================================================\n\nexport interface FocusBundleInput {\n  focusNode: Node;\n  nodesInView: Node[];\n  edgesInView: Edge[];\n  candidateEdges: CandidateEdge[];\n  orphanEntries: OrphanEntry[];\n  relatedNotes: RelatedNote[];\n  doctorStats: DoctorStats;\n  mode: 'focus' | 'classic';\n}\n\n/**\n * Assemble a FocusBundle from computed data.\n * Applies hard caps and deterministic ordering (score desc, then title).\n */\nexport function assembleFocusBundle(input: FocusBundleInput): FocusBundle {\n  const {\n    focusNode,\n    nodesInView,\n    edgesInView,\n    candidateEdges,\n    orphanEntries,\n    relatedNotes,\n    doctorStats,\n    mode,\n  } = input;\n\n  // Build node ID set for \"in view\" checks\n  const nodeIdsInView = new Set(nodesInView.map((n) => n.nodeId));\n\n  // Compute degree counts per node\n  const degreesA = new Map<string, number>();\n  const degreesB = new Map<string, number>();\n  const degreesC = new Map<string, number>();\n\n  for (const edge of edgesInView) {\n    const layer = getEdgeLayer(edge.edgeType as EdgeType);\n    const map = layer === 'A' ? degreesA : layer === 'B' ? degreesB : degreesC;\n\n    map.set(edge.sourceId, (map.get(edge.sourceId) || 0) + 1);\n    map.set(edge.targetId, (map.get(edge.targetId) || 0) + 1);\n  }\n\n  // Build NodeDTOs\n  const nodeDTOs: NodeDTO[] = nodesInView.map((node) => ({\n    id: node.nodeId,\n    title: node.title,\n    path: node.path,\n    type: node.type,\n    updatedAtMs: node.updatedAt ? new Date(node.updatedAt).getTime() : undefined,\n    isGhost: node.isGhost || false,\n    degreeA: degreesA.get(node.nodeId) || 0,\n    degreeB: degreesB.get(node.nodeId) || 0,\n    degreeC: degreesC.get(node.nodeId) || 0,\n  }));\n\n  // Build EdgeDTOs\n  const edgeDTOs: EdgeDTO[] = edgesInView.map((edge) => ({\n    id: edge.edgeId,\n    fromId: edge.sourceId,\n    toId: edge.targetId,\n    type: edge.edgeType,\n    status: 'truth' as const,\n    layer: getEdgeLayer(edge.edgeType as EdgeType) as 'A' | 'B' | 'C',\n    confidence: edge.strength,\n    provenance: edge.provenance,\n  }));\n\n  // Build node lookup for titles\n  const nodeMap = new Map(nodesInView.map((n) => [n.nodeId, n]));\n\n  // Build CandidateLinks with deterministic ordering\n  const candidateLinks: CandidateLink[] = candidateEdges\n    .filter((ce) => ce.status === 'suggested')\n    .map((ce) => {\n      const fromNode = nodeMap.get(ce.fromId);\n      const toNode = nodeMap.get(ce.toId);\n\n      // Determine source type\n      let source: 'mention' | 'semantic' | 'heuristic' = 'heuristic';\n      if (ce.signals?.mentionCount !== undefined && ce.signals.mentionCount > 0) {\n        source = 'mention';\n      } else if (ce.signals?.semantic !== undefined) {\n        source = 'semantic';\n      }\n\n      // Compute confidence from signals\n      let confidence = 0.5;\n      if (ce.signals?.semantic !== undefined) {\n        confidence = ce.signals.semantic;\n      } else if (ce.signals?.mentionCount !== undefined) {\n        confidence = Math.min(1, ce.signals.mentionCount / 10);\n      }\n\n      return {\n        suggestionId: ce.suggestionId,\n        fromId: ce.fromId,\n        fromTitle: fromNode?.title || 'Unknown',\n        toId: ce.toId,\n        toTitle: toNode?.title || 'Unknown',\n        toIsGhost: toNode?.isGhost || false,\n        suggestedEdgeType: ce.suggestedEdgeType,\n        confidence,\n        reasons: (ce.reasons || []).slice(0, SUGGESTION_CAPS.reasonsPerSuggestion),\n        source,\n        status: ce.status,\n        signals: ce.signals || {},\n        provenance:\n          ce.provenance && ce.provenance.length > 0\n            ? {\n                model: ce.provenance[0].model,\n                excerpt: ce.provenance[0].excerpt?.slice(0, SUGGESTION_CAPS.excerptMaxLength),\n                createdAt: ce.provenance[0].createdAt,\n              }\n            : undefined,\n      };\n    })\n    // Sort by confidence desc, then title\n    .sort((a, b) => {\n      if (b.confidence !== a.confidence) return b.confidence - a.confidence;\n      return a.toTitle.localeCompare(b.toTitle);\n    })\n    // Apply hard cap\n    .slice(0, SUGGESTION_CAPS.candidateLinksPerFocus);\n\n  // Build OrphanEntryDTOs with suggested actions\n  const orphanDTOs: OrphanEntryDTO[] = orphanEntries\n    .map((entry) => ({\n      nodeId: entry.nodeId,\n      title: entry.title,\n      path: entry.path,\n      orphanScore: entry.orphanScore,\n      severity: entry.severity,\n      percentile: entry.percentile,\n      reasons: entry.reasons.slice(0, SUGGESTION_CAPS.reasonsPerSuggestion),\n      relatedNodeIds: entry.relatedNodeIds.slice(0, 3),\n      suggestedActions: buildOrphanActions(entry, nodeMap),\n    }))\n    // Sort by score desc, then title\n    .sort((a, b) => {\n      if (b.orphanScore !== a.orphanScore) return b.orphanScore - a.orphanScore;\n      return a.title.localeCompare(b.title);\n    })\n    // Apply hard cap\n    .slice(0, SUGGESTION_CAPS.orphansPerFocus);\n\n  // Build RelatedNotes - mark isInView\n  const relatedNotesDTO: RelatedNote[] = relatedNotes\n    .map((rn) => ({\n      ...rn,\n      isInView: nodeIdsInView.has(rn.nodeId),\n      reasons: rn.reasons.slice(0, SUGGESTION_CAPS.reasonsPerSuggestion),\n    }))\n    // Sort by score desc, then title\n    .sort((a, b) => {\n      if (b.score !== a.score) return b.score - a.score;\n      return a.title.localeCompare(b.title);\n    })\n    // Apply hard cap\n    .slice(0, SUGGESTION_CAPS.relatedNotesPerFocus);\n\n  // Build HealthSummary from DoctorStats\n  const health = buildHealthSummary(doctorStats, nodesInView, edgesInView);\n\n  // Build action templates\n  const actions: ActionTemplates = {\n    approve: {\n      template: 'zs approve --suggestion-id {suggestionId} --json',\n      supportsBatch: true,\n    },\n    reject: {\n      template: 'zs reject --suggestion-id {suggestionId} --json',\n    },\n    focus: {\n      template: 'zs focus \"{path}\" --json-stdout',\n    },\n    createNote: {\n      template: 'zs create --title \"{title}\" --link-from {fromId} --json',\n    },\n  };\n\n  return {\n    meta: {\n      schemaVersion: FOCUS_SCHEMA_VERSION,\n      appVersion: APP_VERSION,\n      generatedAt: new Date().toISOString(),\n      mode,\n      scope: {\n        kind: 'node',\n        focusNodeId: focusNode.nodeId,\n        focusNodePath: focusNode.path,\n        focusNodeTitle: focusNode.title,\n      },\n    },\n    health,\n    graph: {\n      nodes: nodeDTOs,\n      edges: edgeDTOs,\n    },\n    suggestions: {\n      relatedNotes: relatedNotesDTO,\n      candidateLinks,\n      orphans: orphanDTOs,\n    },\n    actions,\n  };\n}\n\n/**\n * Build HealthSummary from DoctorStats, scoped to nodes in view.\n */\nfunction buildHealthSummary(\n  stats: DoctorStats,\n  nodesInView: Node[],\n  edgesInView: Edge[]\n): HealthSummary {\n  // Count non-ghost nodes (eligible for embedding)\n  const eligibleNodes = nodesInView.filter((n) => !n.isGhost);\n  const eligibleInView = eligibleNodes.length;\n\n  // Count embedded nodes in view (proxy: assume all non-ghost nodes with contentHash are embedded)\n  // Note: This is an approximation; true count would require embedding lookup\n  const embeddedInView = eligibleNodes.filter((n) => n.contentHash).length;\n  const missingInView = eligibleInView - embeddedInView;\n\n  // Coverage in view\n  const coverageInView = eligibleInView > 0 ? (embeddedInView / eligibleInView) * 100 : 100;\n\n  // Count wormholes in view\n  const wormholesInView = edgesInView.filter((e) => e.edgeType === 'semantic').length;\n\n  // Edge counts by layer in view\n  const edgeCountsByLayer = { A: 0, B: 0, C: 0 };\n  for (const edge of edgesInView) {\n    const layer = getEdgeLayer(edge.edgeType as EdgeType);\n    if (layer === 'A') edgeCountsByLayer.A++;\n    else if (layer === 'B') edgeCountsByLayer.B++;\n    else if (layer === 'C') edgeCountsByLayer.C++;\n  }\n\n  // Wormhole health level\n  let wormholeLevel: 'ok' | 'warn' | 'fail' = 'ok';\n  if (!stats.wormholes.enabled) {\n    wormholeLevel = stats.embeddings.level === 'fail' ? 'fail' : 'warn';\n  }\n\n  // Get circuit breaker warnings (plain text, no ANSI codes)\n  const circuitWarnings = getCircuitBreaker().getWarnings();\n\n  return {\n    level: stats.overallLevel,\n    warnings: circuitWarnings,\n\n    embeddings: {\n      level: stats.embeddings.level,\n      coverageInView,\n      eligibleInView,\n      embeddedInView,\n      missingInView,\n      pending: stats.embeddings.pending,\n      errors: stats.embeddings.errorCount,\n      lastError: stats.embeddings.lastError,\n    },\n\n    wormholes: {\n      enabled: stats.wormholes.enabled,\n      level: wormholeLevel,\n      countInView: wormholesInView,\n      threshold: stats.wormholes.threshold,\n      disabledReason: stats.wormholes.disabledReason,\n    },\n\n    index: {\n      lastRunAt: stats.index.lastIndexTime?.toISOString(),\n      nodeCount: stats.index.nodeCount,\n      edgeCountsByLayer,\n    },\n\n    extraction: {\n      parseFailures: stats.extraction.parseFailCount,\n      badChunksPath: stats.extraction.badChunksPath,\n    },\n  };\n}\n\n/**\n * Build suggested actions for an orphan entry.\n */\nfunction buildOrphanActions(entry: OrphanEntry, nodeMap: Map<string, Node>): SuggestedAction[] {\n  const actions: SuggestedAction[] = [];\n\n  // Suggest linking to related nodes\n  for (const relatedId of entry.relatedNodeIds.slice(0, 2)) {\n    const relatedNode = nodeMap.get(relatedId);\n    if (relatedNode) {\n      actions.push({\n        actionType: 'link_to',\n        targetNodeId: relatedId,\n        label: `Link to \"${relatedNode.title}\"`,\n        template: `zs link --from \"${entry.path}\" --to \"${relatedNode.path}\" --json`,\n      });\n    }\n  }\n\n  // Always offer ignore\n  actions.push({\n    actionType: 'ignore',\n    label: 'Ignore this orphan',\n    template: `zs orphan ignore --node-id ${entry.nodeId} --json`,\n  });\n\n  return actions;\n}\n","/**\n * Suggestion Engine - Phase 2.1\n *\n * Computes candidate edges from various signals:\n * - Mentions (text co-occurrence)\n * - Semantic similarity (below wormhole threshold)\n * - Graph proximity\n *\n * Per Phase 2 Design Document Section 3.\n */\n\nimport {\n  NodeRepository,\n  EdgeRepository,\n  CandidateEdgeRepository,\n} from '../storage/database/repositories/index.js';\nimport { MentionRepository } from '../storage/database/repositories/mention-repository.js';\nimport { EmbeddingRepository } from '../storage/database/repositories/embedding-repository.js';\nimport type { CandidateEdge, EdgeType } from '../core/types/index.js';\nimport { generateSuggestionId, isUndirectedEdgeType, LAYER_A_EDGES } from '../core/types/index.js';\n\n/**\n * Configuration for suggestion computation.\n * Per Phase 2 Design Section 3.1.\n */\nexport interface SuggestionConfig {\n  mentions: {\n    minOccurrences: number; // Default: 2 - Avoid single-mention noise\n    maxResults: number; // Default: 20\n  };\n  semantic: {\n    minSimilarity: number; // Default: 0.4 - Below this, too weak\n    maxSimilarity: number; // Default: 0.74 - At 0.75+, it's a wormhole\n    maxResults: number; // Default: 20\n  };\n}\n\nexport const DEFAULT_SUGGESTION_CONFIG: SuggestionConfig = {\n  mentions: {\n    minOccurrences: 2,\n    maxResults: 20,\n  },\n  semantic: {\n    minSimilarity: 0.4,\n    maxSimilarity: 0.74,\n    maxResults: 20,\n  },\n};\n\n/**\n * Result of computing candidates for a scope.\n */\nexport interface CandidateComputationResult {\n  created: CandidateEdge[];\n  updated: CandidateEdge[];\n  total: number;\n}\n\n/**\n * Mention aggregation intermediate result.\n */\ninterface MentionAggregation {\n  fromId: string;\n  toId: string;\n  count: number;\n  reasons: string[];\n}\n\n/**\n * Engine for computing candidate edge suggestions.\n */\nexport class SuggestionEngine {\n  private config: SuggestionConfig;\n\n  constructor(\n    private nodeRepository: NodeRepository,\n    private edgeRepository: EdgeRepository,\n    private mentionRepository: MentionRepository,\n    private embeddingRepository: EmbeddingRepository,\n    private candidateEdgeRepository: CandidateEdgeRepository,\n    config?: Partial<SuggestionConfig>\n  ) {\n    this.config = {\n      mentions: { ...DEFAULT_SUGGESTION_CONFIG.mentions, ...config?.mentions },\n      semantic: { ...DEFAULT_SUGGESTION_CONFIG.semantic, ...config?.semantic },\n    };\n  }\n\n  /**\n   * Compute candidate edges for mentions in a given scope.\n   *\n   * Per Phase 2 Design Section 3.3:\n   * - Filter: mentionMinOccurrences >= 2\n   * - Group by (fromId, toId) pair\n   * - Create/upsert CandidateEdge records\n   */\n  async computeMentionCandidates(scopeNodeIds: string[]): Promise<CandidateComputationResult> {\n    if (scopeNodeIds.length === 0) {\n      return { created: [], updated: [], total: 0 };\n    }\n\n    // Get existing Layer A edges to filter out already-connected pairs\n    const existingLayerA = await this.getLayerAConnections(scopeNodeIds);\n\n    // Aggregate mentions by pair\n    const aggregations = await this.aggregateMentionsForScope(scopeNodeIds);\n\n    // Filter by min occurrences and existing connections\n    const filtered = aggregations.filter((agg) => {\n      if (agg.count < this.config.mentions.minOccurrences) return false;\n      if (this.isAlreadyConnected(agg.fromId, agg.toId, existingLayerA)) return false;\n      return true;\n    });\n\n    // Sort by count descending and limit\n    filtered.sort((a, b) => b.count - a.count);\n    const limited = filtered.slice(0, this.config.mentions.maxResults);\n\n    // Create/upsert candidate edges\n    const created: CandidateEdge[] = [];\n    const updated: CandidateEdge[] = [];\n\n    for (const agg of limited) {\n      const edgeType: EdgeType = 'mention';\n      const suggestionId = generateSuggestionId(\n        agg.fromId,\n        agg.toId,\n        edgeType,\n        isUndirectedEdgeType(edgeType)\n      );\n\n      const existing = await this.candidateEdgeRepository.findById(suggestionId);\n\n      if (existing) {\n        // Update with merged signals\n        const updatedCandidate = await this.candidateEdgeRepository.update(suggestionId, {\n          signals: {\n            ...existing.signals,\n            mentionCount: agg.count,\n          },\n          reasons: mergeReasons(existing.reasons || [], agg.reasons),\n        });\n        updated.push(updatedCandidate);\n      } else {\n        // Create new\n        const candidate = await this.candidateEdgeRepository.create({\n          suggestionId,\n          fromId: agg.fromId,\n          toId: agg.toId,\n          suggestedEdgeType: edgeType,\n          signals: { mentionCount: agg.count },\n          reasons: agg.reasons.slice(0, 3),\n        });\n        created.push(candidate);\n      }\n    }\n\n    return {\n      created,\n      updated,\n      total: created.length + updated.length,\n    };\n  }\n\n  /**\n   * Compute candidate edges from semantic similarity.\n   *\n   * Per Phase 2 Design Section 3.1:\n   * - semanticMinSimilarity: 0.4 (below this, too weak)\n   * - semanticMaxSimilarity: 0.74 (at 0.75+, it's a wormhole)\n   */\n  async computeSemanticCandidates(scopeNodeIds: string[]): Promise<CandidateComputationResult> {\n    if (scopeNodeIds.length === 0) {\n      return { created: [], updated: [], total: 0 };\n    }\n\n    // Get existing Layer A edges\n    const existingLayerA = await this.getLayerAConnections(scopeNodeIds);\n\n    // Get embeddings for scope nodes\n    const embeddings = await this.embeddingRepository.findByNodeIds(scopeNodeIds);\n    if (embeddings.length < 2) {\n      return { created: [], updated: [], total: 0 };\n    }\n\n    // Find semantic near-misses\n    const candidates: Array<{\n      fromId: string;\n      toId: string;\n      similarity: number;\n    }> = [];\n\n    // Compare all pairs within scope\n    for (let i = 0; i < embeddings.length; i++) {\n      for (let j = i + 1; j < embeddings.length; j++) {\n        const e1 = embeddings[i];\n        const e2 = embeddings[j];\n\n        // Skip if already connected by Layer A\n        if (this.isAlreadyConnected(e1.nodeId, e2.nodeId, existingLayerA)) {\n          continue;\n        }\n\n        const similarity = cosineSimilarity(e1.embedding, e2.embedding);\n\n        // Check if in \"near-miss\" range\n        if (\n          similarity >= this.config.semantic.minSimilarity &&\n          similarity < this.config.semantic.maxSimilarity\n        ) {\n          candidates.push({\n            fromId: e1.nodeId,\n            toId: e2.nodeId,\n            similarity,\n          });\n        }\n      }\n    }\n\n    // Sort by similarity descending and limit\n    candidates.sort((a, b) => b.similarity - a.similarity);\n    const limited = candidates.slice(0, this.config.semantic.maxResults);\n\n    // Create/upsert candidate edges\n    const created: CandidateEdge[] = [];\n    const updated: CandidateEdge[] = [];\n\n    for (const cand of limited) {\n      const edgeType: EdgeType = 'semantic_suggestion';\n      const suggestionId = generateSuggestionId(\n        cand.fromId,\n        cand.toId,\n        edgeType,\n        isUndirectedEdgeType(edgeType)\n      );\n\n      const existing = await this.candidateEdgeRepository.findById(suggestionId);\n\n      if (existing) {\n        // Update with new similarity\n        const updatedCandidate = await this.candidateEdgeRepository.update(suggestionId, {\n          signals: {\n            ...existing.signals,\n            semantic: cand.similarity,\n          },\n          reasons: mergeReasons(existing.reasons || [], [\n            `Semantic similarity: ${(cand.similarity * 100).toFixed(0)}%`,\n          ]),\n        });\n        updated.push(updatedCandidate);\n      } else {\n        // Create new\n        const candidate = await this.candidateEdgeRepository.create({\n          suggestionId,\n          fromId: cand.fromId,\n          toId: cand.toId,\n          suggestedEdgeType: edgeType,\n          signals: { semantic: cand.similarity },\n          reasons: [`Semantic similarity: ${(cand.similarity * 100).toFixed(0)}%`],\n        });\n        created.push(candidate);\n      }\n    }\n\n    return {\n      created,\n      updated,\n      total: created.length + updated.length,\n    };\n  }\n\n  /**\n   * Compute all candidate types for a scope.\n   */\n  async computeAllCandidates(scopeNodeIds: string[]): Promise<{\n    mentions: CandidateComputationResult;\n    semantic: CandidateComputationResult;\n    total: number;\n  }> {\n    const mentions = await this.computeMentionCandidates(scopeNodeIds);\n    const semantic = await this.computeSemanticCandidates(scopeNodeIds);\n\n    return {\n      mentions,\n      semantic,\n      total: mentions.total + semantic.total,\n    };\n  }\n\n  /**\n   * Get all Layer A edge connections for nodes in scope.\n   * Returns a Set of normalized pair keys for fast lookup.\n   */\n  private async getLayerAConnections(nodeIds: string[]): Promise<Set<string>> {\n    const connections = new Set<string>();\n\n    for (const nodeId of nodeIds) {\n      const edges = await this.edgeRepository.findConnected(nodeId);\n\n      for (const edge of edges) {\n        // Only consider Layer A edges\n        if (!LAYER_A_EDGES.includes(edge.edgeType as EdgeType)) {\n          continue;\n        }\n\n        // Create normalized key (smaller ID first)\n        const key = normalizeEdgePair(edge.sourceId, edge.targetId);\n        connections.add(key);\n      }\n    }\n\n    return connections;\n  }\n\n  /**\n   * Check if two nodes are already connected by Layer A edge.\n   */\n  private isAlreadyConnected(\n    nodeId1: string,\n    nodeId2: string,\n    layerAConnections: Set<string>\n  ): boolean {\n    const key = normalizeEdgePair(nodeId1, nodeId2);\n    return layerAConnections.has(key);\n  }\n\n  /**\n   * Aggregate mentions by (source, target) pair.\n   * Counts occurrences and collects reasons.\n   */\n  private async aggregateMentionsForScope(nodeIds: string[]): Promise<MentionAggregation[]> {\n    const aggregations = new Map<string, MentionAggregation>();\n\n    for (const nodeId of nodeIds) {\n      // Get mentions where this node is the source\n      const mentions = await this.mentionRepository.findBySourceId(nodeId);\n\n      for (const mention of mentions) {\n        // Only count non-rejected mentions\n        if (mention.status === 'rejected') continue;\n\n        const key = normalizeEdgePair(mention.sourceId, mention.targetId);\n\n        if (!aggregations.has(key)) {\n          aggregations.set(key, {\n            fromId: mention.sourceId,\n            toId: mention.targetId,\n            count: 0,\n            reasons: [],\n          });\n        }\n\n        const agg = aggregations.get(key)!;\n        agg.count++;\n\n        // Build reason from surface text\n        if (mention.surfaceText && agg.reasons.length < 3) {\n          const reason = `Mentioned as \"${mention.surfaceText}\"`;\n          if (!agg.reasons.includes(reason)) {\n            agg.reasons.push(reason);\n          }\n        }\n      }\n    }\n\n    return Array.from(aggregations.values());\n  }\n}\n\n/**\n * Compute cosine similarity between two embedding vectors.\n */\nfunction cosineSimilarity(a: number[], b: number[]): number {\n  if (a.length !== b.length) return 0;\n\n  let dotProduct = 0;\n  let normA = 0;\n  let normB = 0;\n\n  for (let i = 0; i < a.length; i++) {\n    dotProduct += a[i] * b[i];\n    normA += a[i] * a[i];\n    normB += b[i] * b[i];\n  }\n\n  if (normA === 0 || normB === 0) return 0;\n\n  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n\n/**\n * Create a normalized edge pair key (smaller ID first).\n */\nfunction normalizeEdgePair(id1: string, id2: string): string {\n  return id1 < id2 ? `${id1}|${id2}` : `${id2}|${id1}`;\n}\n\n/**\n * Merge two reason arrays, keeping unique values up to max 3.\n */\nfunction mergeReasons(existing: string[], newReasons: string[]): string[] {\n  const merged = [...existing];\n  for (const reason of newReasons) {\n    if (!merged.includes(reason) && merged.length < 3) {\n      merged.push(reason);\n    }\n  }\n  return merged;\n}\n\n// ============================================================================\n// Orphan Score Computation (Phase 2.1 Item 6)\n// ============================================================================\n\n/**\n * Orphan score weights per DESIGN.md Section 12.2.\n */\nexport const ORPHAN_WEIGHTS = {\n  semanticPull: 0.45,\n  lowTruthDegree: 0.25,\n  mentionPressure: 0.2,\n  importance: 0.1,\n};\n\n/**\n * Orphan entry with computed score and reasons.\n * Per Phase 2 Design Section 2.3.\n */\nexport interface OrphanEntry {\n  nodeId: string;\n  title: string;\n  path: string;\n  orphanScore: number;\n  severity: 'low' | 'med' | 'high';\n  percentile: number;\n  reasons: string[];\n  relatedNodeIds: string[];\n  components: {\n    semanticPull: number;\n    lowTruthDegree: number;\n    mentionPressure: number;\n    importance: number;\n  };\n}\n\n/**\n * Configuration for orphan computation.\n */\nexport interface OrphanConfig {\n  minScore: number; // Default: 0.3\n  maxResults: number; // Default: 10\n  topSemanticNeighbors: number; // Default: 5 - How many neighbors to consider for semantic pull\n  recencyDays: number; // Default: 30 - Timeframe for recency normalization\n}\n\nexport const DEFAULT_ORPHAN_CONFIG: OrphanConfig = {\n  minScore: 0.3,\n  maxResults: 10,\n  topSemanticNeighbors: 5,\n  recencyDays: 30,\n};\n\n/**\n * Orphan computation engine.\n * Computes orphan scores for nodes that are semantically connected\n * but lack explicit (Layer A) edges.\n */\nexport class OrphanEngine {\n  private config: OrphanConfig;\n\n  constructor(\n    private nodeRepository: NodeRepository,\n    private edgeRepository: EdgeRepository,\n    private mentionRepository: MentionRepository,\n    private embeddingRepository: EmbeddingRepository,\n    config?: Partial<OrphanConfig>\n  ) {\n    this.config = { ...DEFAULT_ORPHAN_CONFIG, ...config };\n  }\n\n  /**\n   * Compute orphan scores for nodes in scope.\n   *\n   * Per DESIGN.md Section 12.2:\n   * orphanScore = 0.45 * semanticPull + 0.25 * (1/(1+truthDegree)) + 0.20 * mentionPressure + 0.10 * importance\n   */\n  async computeOrphanScores(scopeNodeIds: string[]): Promise<OrphanEntry[]> {\n    if (scopeNodeIds.length === 0) {\n      return [];\n    }\n\n    // Get nodes in scope\n    const nodes = await this.nodeRepository.findByIds(scopeNodeIds);\n    if (nodes.length === 0) {\n      return [];\n    }\n\n    // Build indexes for efficient computation\n    const layerADegrees = await this.computeLayerADegrees(scopeNodeIds);\n    const unresolvedMentionCounts = await this.computeUnresolvedMentionCounts(scopeNodeIds);\n    const maxMentionCount = Math.max(...Array.from(unresolvedMentionCounts.values()), 1);\n    const semanticNeighbors = await this.computeSemanticNeighbors(scopeNodeIds);\n\n    // Compute scores for each node\n    const entries: OrphanEntry[] = [];\n    const now = Date.now();\n\n    for (const node of nodes) {\n      // Skip ghosts\n      if (node.isGhost) continue;\n\n      const truthDegree = layerADegrees.get(node.nodeId) || 0;\n      const mentionCount = unresolvedMentionCounts.get(node.nodeId) || 0;\n      const neighbors = semanticNeighbors.get(node.nodeId) || [];\n\n      // Component 1: Semantic pull (average similarity to top neighbors NOT connected by Layer A)\n      // Filter out neighbors that are already connected by Layer A\n      // Note: neighbors don't have Layer A edges by construction in computeSemanticNeighbors\n      const unconnectedNeighbors = neighbors;\n      const semanticPull =\n        unconnectedNeighbors.length > 0\n          ? unconnectedNeighbors.reduce((sum, n) => sum + n.similarity, 0) /\n            unconnectedNeighbors.length\n          : 0;\n\n      // Component 2: Low truth degree (inverted - lower degree = higher score)\n      const lowTruthDegree = 1 / (1 + truthDegree);\n\n      // Component 3: Mention pressure (normalized by max across vault)\n      const mentionPressure = mentionCount / maxMentionCount;\n\n      // Component 4: Importance (recency score)\n      const importance = this.computeRecencyScore(node.updatedAt, now);\n\n      // Compute final score\n      const orphanScore =\n        ORPHAN_WEIGHTS.semanticPull * semanticPull +\n        ORPHAN_WEIGHTS.lowTruthDegree * lowTruthDegree +\n        ORPHAN_WEIGHTS.mentionPressure * mentionPressure +\n        ORPHAN_WEIGHTS.importance * importance;\n\n      // Build reasons\n      const reasons: string[] = [];\n      if (semanticPull > 0.3) {\n        reasons.push(`Similar to ${unconnectedNeighbors.length} unlinked note(s)`);\n      }\n      if (truthDegree === 0) {\n        reasons.push('No explicit links');\n      } else if (truthDegree < 3) {\n        reasons.push(`Only ${truthDegree} explicit link(s)`);\n      }\n      if (mentionCount > 0) {\n        reasons.push(`Mentioned ${mentionCount} time(s) without link`);\n      }\n\n      entries.push({\n        nodeId: node.nodeId,\n        title: node.title,\n        path: node.path,\n        orphanScore,\n        severity: 'low', // Will be set after percentile calculation\n        percentile: 0, // Will be calculated\n        reasons: reasons.slice(0, 3),\n        relatedNodeIds: unconnectedNeighbors.slice(0, 3).map((n) => n.nodeId),\n        components: {\n          semanticPull,\n          lowTruthDegree,\n          mentionPressure,\n          importance,\n        },\n      });\n    }\n\n    // Sort by score descending\n    entries.sort((a, b) => b.orphanScore - a.orphanScore);\n\n    // Calculate percentiles and severity\n    for (let i = 0; i < entries.length; i++) {\n      const percentile = ((entries.length - i) / entries.length) * 100;\n      entries[i].percentile = Math.round(percentile);\n      entries[i].severity = percentile >= 75 ? 'high' : percentile >= 50 ? 'med' : 'low';\n    }\n\n    // Filter by min score and limit\n    return entries\n      .filter((e) => e.orphanScore >= this.config.minScore)\n      .slice(0, this.config.maxResults);\n  }\n\n  /**\n   * Compute Layer A degree for each node in scope.\n   */\n  private async computeLayerADegrees(nodeIds: string[]): Promise<Map<string, number>> {\n    const degrees = new Map<string, number>();\n\n    for (const nodeId of nodeIds) {\n      const edges = await this.edgeRepository.findConnected(nodeId);\n      const layerACount = edges.filter((e) =>\n        LAYER_A_EDGES.includes(e.edgeType as EdgeType)\n      ).length;\n      degrees.set(nodeId, layerACount);\n    }\n\n    return degrees;\n  }\n\n  /**\n   * Count unresolved mentions (new or pending) pointing to each node.\n   */\n  private async computeUnresolvedMentionCounts(nodeIds: string[]): Promise<Map<string, number>> {\n    const counts = new Map<string, number>();\n\n    for (const nodeId of nodeIds) {\n      const mentions = await this.mentionRepository.findByTargetId(nodeId);\n      // Count only unresolved (new/pending) mentions\n      const unresolvedCount = mentions.filter(\n        (m) => m.status === 'new' || m.status === 'deferred'\n      ).length;\n      counts.set(nodeId, unresolvedCount);\n    }\n\n    return counts;\n  }\n\n  /**\n   * Compute semantic neighbors for each node.\n   * Returns top-K neighbors NOT connected by Layer A edges.\n   */\n  private async computeSemanticNeighbors(\n    nodeIds: string[]\n  ): Promise<Map<string, Array<{ nodeId: string; similarity: number }>>> {\n    const result = new Map<string, Array<{ nodeId: string; similarity: number }>>();\n\n    // Get embeddings for all nodes\n    const embeddings = await this.embeddingRepository.findByNodeIds(nodeIds);\n    const embeddingMap = new Map(embeddings.map((e) => [e.nodeId, e.embedding]));\n\n    // Get Layer A connections\n    const layerAConnections = new Set<string>();\n    for (const nodeId of nodeIds) {\n      const edges = await this.edgeRepository.findConnected(nodeId);\n      for (const edge of edges) {\n        if (LAYER_A_EDGES.includes(edge.edgeType as EdgeType)) {\n          layerAConnections.add(normalizeEdgePair(edge.sourceId, edge.targetId));\n        }\n      }\n    }\n\n    // Compute neighbors for each node\n    for (const nodeId of nodeIds) {\n      const embedding = embeddingMap.get(nodeId);\n      if (!embedding) {\n        result.set(nodeId, []);\n        continue;\n      }\n\n      const neighbors: Array<{ nodeId: string; similarity: number }> = [];\n\n      for (const [otherNodeId, otherEmbedding] of embeddingMap) {\n        if (otherNodeId === nodeId) continue;\n\n        // Skip if already connected by Layer A\n        if (layerAConnections.has(normalizeEdgePair(nodeId, otherNodeId))) {\n          continue;\n        }\n\n        const similarity = cosineSimilarity(embedding, otherEmbedding);\n        if (similarity > 0.1) {\n          // Only include meaningful similarities\n          neighbors.push({ nodeId: otherNodeId, similarity });\n        }\n      }\n\n      // Sort by similarity and take top K\n      neighbors.sort((a, b) => b.similarity - a.similarity);\n      result.set(nodeId, neighbors.slice(0, this.config.topSemanticNeighbors));\n    }\n\n    return result;\n  }\n\n  /**\n   * Compute recency score (0-1) based on days since last update.\n   * More recent = higher score.\n   */\n  private computeRecencyScore(updatedAt: string, nowMs: number): number {\n    const updatedMs = new Date(updatedAt).getTime();\n    const daysSinceUpdate = (nowMs - updatedMs) / (1000 * 60 * 60 * 24);\n\n    // Exponential decay over recencyDays\n    return Math.exp(-daysSinceUpdate / this.config.recencyDays);\n  }\n}\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { initContext } from '../utils.js';\nimport { generateSuggestionId, isUndirectedEdgeType } from '../../core/types/index.js';\nimport type { EdgeType } from '../../core/types/index.js';\n\n/**\n * Response shape for JSON mode per Phase 2 Design Section 10.2\n */\ninterface ApproveResponse {\n  success: boolean;\n  warnings?: string[];\n  error?: string;\n  errorCode?: 'NOT_VAULT' | 'DB_ERROR' | 'INVALID_ARGS' | 'NOT_FOUND' | 'COMPUTE_ERROR';\n  idempotent?: boolean;\n\n  // Success details\n  suggestionId?: string;\n  fromId?: string;\n  fromTitle?: string;\n  toId?: string;\n  toTitle?: string;\n  edgeId?: string;\n  edgeType?: string;\n\n  // Writeback details\n  writeback?: 'success' | 'skipped' | 'failed';\n  writebackReason?: string;\n  writebackPath?: string;\n}\n\n/**\n * Insert a wikilink into a markdown file at the appropriate location.\n * Per Phase 2 Design Section 5.3:\n * - Do NOT modify YAML frontmatter\n * - Use Links section in body only\n * - If ambiguous: use end of file\n * - If file read-only: skip writeback, succeed in DB\n *\n * @returns Object with status and reason\n */\nasync function insertWikilink(\n  filePath: string,\n  targetPath: string,\n  targetTitle: string,\n  vaultPath: string\n): Promise<{ status: 'success' | 'skipped' | 'failed'; reason?: string; path?: string }> {\n  const absolutePath = path.join(vaultPath, filePath);\n\n  // Check if file exists\n  if (!fs.existsSync(absolutePath)) {\n    return { status: 'skipped', reason: 'Source file not found' };\n  }\n\n  // Check if file is readable\n  let content: string;\n  try {\n    content = fs.readFileSync(absolutePath, 'utf-8');\n  } catch {\n    return { status: 'failed', reason: 'Could not read source file' };\n  }\n\n  // Build the wikilink text\n  // Safe format: includes path when needed for disambiguation\n  const linkText = targetPath.includes('/')\n    ? `[[${targetPath.replace(/\\.md$/, '')}|${targetTitle}]]`\n    : `[[${targetTitle}]]`;\n\n  // Check if link already exists (avoid duplicates)\n  if (content.includes(linkText) || content.includes(`[[${targetTitle}]]`)) {\n    return { status: 'skipped', reason: 'Link already exists in file' };\n  }\n\n  // Find insertion point\n  const lines = content.split('\\n');\n  let insertionIndex = lines.length;\n  let linksSectionFound = false;\n\n  // Skip YAML frontmatter\n  let bodyStartIndex = 0;\n  if (lines[0]?.trim() === '---') {\n    for (let i = 1; i < lines.length; i++) {\n      if (lines[i]?.trim() === '---') {\n        bodyStartIndex = i + 1;\n        break;\n      }\n    }\n  }\n\n  // Look for existing Links section\n  for (let i = bodyStartIndex; i < lines.length; i++) {\n    const line = lines[i];\n    if (line && /^##?\\s*links?\\s*$/i.test(line)) {\n      linksSectionFound = true;\n      // Find end of this section (next heading or end of file)\n      for (let j = i + 1; j < lines.length; j++) {\n        if (lines[j] && /^##?\\s/.test(lines[j])) {\n          insertionIndex = j;\n          break;\n        }\n      }\n      if (!linksSectionFound) {\n        insertionIndex = lines.length;\n      }\n      insertionIndex = i + 1; // Insert right after the Links header\n      break;\n    }\n  }\n\n  // If no Links section, insert at end of file (before trailing blanks)\n  if (!linksSectionFound) {\n    // Find last non-blank line\n    for (let i = lines.length - 1; i >= bodyStartIndex; i--) {\n      if (lines[i]?.trim()) {\n        insertionIndex = i + 1;\n        break;\n      }\n    }\n  }\n\n  // Insert the link\n  const prefix = linksSectionFound ? '- ' : '\\n- ';\n  lines.splice(insertionIndex, 0, prefix + linkText);\n  const newContent = lines.join('\\n');\n\n  // Atomic write (tmp + rename)\n  const tmpPath = absolutePath + '.tmp.' + Date.now();\n  try {\n    fs.writeFileSync(tmpPath, newContent, 'utf-8');\n    fs.renameSync(tmpPath, absolutePath);\n    return { status: 'success', path: filePath };\n  } catch (err) {\n    // Clean up tmp file if it exists\n    try {\n      if (fs.existsSync(tmpPath)) {\n        fs.unlinkSync(tmpPath);\n      }\n    } catch {\n      // Ignore cleanup errors\n    }\n    return {\n      status: 'failed',\n      reason: err instanceof Error ? err.message : 'Unknown write error',\n    };\n  }\n}\n\nexport const approveCommand = new Command('approve')\n  .description('Approve a suggested link, converting it to a truth edge')\n  .option('--suggestion-id <id>', 'The suggestion ID to approve')\n  .option('--from <id>', 'Source node ID (alternative to --suggestion-id)')\n  .option('--to <id>', 'Target node ID (alternative to --suggestion-id)')\n  .option('--type <type>', 'Edge type (alternative to --suggestion-id)', 'explicit_link')\n  .option('--json', 'Output JSON response')\n  .option('--no-writeback', 'Skip markdown file modification')\n  .action(async (options) => {\n    const response: ApproveResponse = { success: false };\n\n    const outputJson = () => {\n      if (options.json) {\n        console.log(JSON.stringify(response));\n      }\n    };\n\n    try {\n      const ctx = await initContext();\n\n      // Determine suggestionId\n      let suggestionId: string;\n\n      if (options.suggestionId) {\n        suggestionId = options.suggestionId;\n      } else if (options.from && options.to) {\n        // Generate suggestionId from components\n        const edgeType = options.type as EdgeType;\n        const isUndirected = isUndirectedEdgeType(edgeType);\n        suggestionId = generateSuggestionId(options.from, options.to, edgeType, isUndirected);\n      } else {\n        response.error = 'Must provide --suggestion-id or both --from and --to';\n        response.errorCode = 'INVALID_ARGS';\n        if (options.json) {\n          outputJson();\n        } else {\n          console.error('Error:', response.error);\n        }\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Load candidate edge\n      const candidate = await ctx.candidateEdgeRepository.findById(suggestionId);\n\n      if (!candidate) {\n        response.error = `Suggestion not found: ${suggestionId}`;\n        response.errorCode = 'NOT_FOUND';\n        if (options.json) {\n          outputJson();\n        } else {\n          console.error('Error:', response.error);\n        }\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Check if already approved (idempotent)\n      if (candidate.status === 'approved') {\n        response.success = true;\n        response.idempotent = true;\n        response.suggestionId = suggestionId;\n        response.fromId = candidate.fromId;\n        response.toId = candidate.toId;\n        response.edgeType = candidate.suggestedEdgeType;\n        response.edgeId = candidate.approvedEdgeId;\n\n        if (options.json) {\n          outputJson();\n        } else {\n          console.log('Already approved (idempotent)');\n        }\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Check if rejected (can't approve rejected)\n      if (candidate.status === 'rejected') {\n        response.error = 'Cannot approve a rejected suggestion. Unreject first.';\n        response.errorCode = 'INVALID_ARGS';\n        if (options.json) {\n          outputJson();\n        } else {\n          console.error('Error:', response.error);\n        }\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Get node info for response\n      const fromNode = await ctx.nodeRepository.findById(candidate.fromId);\n      const toNode = await ctx.nodeRepository.findById(candidate.toId);\n\n      // Transaction 1: Insert truth edge and update candidate status\n      const truthEdge = await ctx.edgeRepository.create({\n        sourceId: candidate.fromId,\n        targetId: candidate.toId,\n        edgeType: candidate.suggestedEdgeType,\n        provenance: 'user_approved',\n        strength: candidate.signals?.semantic,\n      });\n\n      await ctx.candidateEdgeRepository.updateStatus(suggestionId, 'approved', truthEdge.edgeId);\n\n      response.success = true;\n      response.suggestionId = suggestionId;\n      response.fromId = candidate.fromId;\n      response.fromTitle = fromNode?.title;\n      response.toId = candidate.toId;\n      response.toTitle = toNode?.title;\n      response.edgeId = truthEdge.edgeId;\n      response.edgeType = candidate.suggestedEdgeType;\n\n      // Attempt markdown writeback (unless disabled)\n      if (options.writeback !== false && fromNode && toNode && !fromNode.isGhost) {\n        const writebackResult = await insertWikilink(\n          fromNode.path,\n          toNode.path,\n          toNode.title,\n          ctx.vaultPath\n        );\n\n        response.writeback = writebackResult.status;\n        response.writebackReason = writebackResult.reason;\n        response.writebackPath = writebackResult.path;\n\n        // Record writeback status\n        await ctx.candidateEdgeRepository.update(suggestionId, {\n          writebackStatus: writebackResult.status,\n          writebackReason: writebackResult.reason,\n        });\n\n        // Writeback failure is a warning, not failure\n        if (writebackResult.status === 'failed') {\n          response.warnings = response.warnings || [];\n          response.warnings.push(`Writeback failed: ${writebackResult.reason}`);\n        }\n      } else {\n        response.writeback = 'skipped';\n        if (fromNode?.isGhost) {\n          response.writebackReason = 'Source is a ghost node';\n        } else if (!fromNode) {\n          response.writebackReason = 'Source node not found';\n        } else if (options.writeback === false) {\n          response.writebackReason = 'Disabled by flag';\n        }\n      }\n\n      if (options.json) {\n        outputJson();\n      } else {\n        console.log(\n          `Approved: ${fromNode?.title || candidate.fromId} -> ${toNode?.title || candidate.toId}`\n        );\n        console.log(`  Edge ID: ${truthEdge.edgeId}`);\n        console.log(`  Type: ${candidate.suggestedEdgeType}`);\n        if (response.writeback === 'success') {\n          console.log(`  Writeback: Link added to ${response.writebackPath}`);\n        } else if (response.writeback === 'failed') {\n          console.log(`  Writeback failed: ${response.writebackReason}`);\n        } else {\n          console.log(`  Writeback skipped: ${response.writebackReason}`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      response.error = error instanceof Error ? error.message : String(error);\n      response.errorCode = 'DB_ERROR';\n      if (options.json) {\n        outputJson();\n      } else {\n        console.error('Error:', response.error);\n      }\n      process.exit(1);\n    }\n  });\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { generateSuggestionId, isUndirectedEdgeType } from '../../core/types/index.js';\nimport type { EdgeType } from '../../core/types/index.js';\n\n/**\n * Response shape for JSON mode per Phase 2 Design Section 10.2\n */\ninterface RejectResponse {\n  success: boolean;\n  warnings?: string[];\n  error?: string;\n  errorCode?: 'NOT_VAULT' | 'DB_ERROR' | 'INVALID_ARGS' | 'NOT_FOUND' | 'COMPUTE_ERROR';\n  idempotent?: boolean;\n\n  // Success details\n  suggestionId?: string;\n  fromId?: string;\n  fromTitle?: string;\n  toId?: string;\n  toTitle?: string;\n  edgeType?: string;\n}\n\nexport const rejectCommand = new Command('reject')\n  .description('Reject a suggested link, hiding it from future suggestions')\n  .option('--suggestion-id <id>', 'The suggestion ID to reject')\n  .option('--from <id>', 'Source node ID (alternative to --suggestion-id)')\n  .option('--to <id>', 'Target node ID (alternative to --suggestion-id)')\n  .option('--type <type>', 'Edge type (alternative to --suggestion-id)', 'explicit_link')\n  .option('--json', 'Output JSON response')\n  .action(async (options) => {\n    const response: RejectResponse = { success: false };\n\n    const outputJson = () => {\n      if (options.json) {\n        console.log(JSON.stringify(response));\n      }\n    };\n\n    try {\n      const ctx = await initContext();\n\n      // Determine suggestionId\n      let suggestionId: string;\n\n      if (options.suggestionId) {\n        suggestionId = options.suggestionId;\n      } else if (options.from && options.to) {\n        // Generate suggestionId from components\n        const edgeType = options.type as EdgeType;\n        const isUndirected = isUndirectedEdgeType(edgeType);\n        suggestionId = generateSuggestionId(options.from, options.to, edgeType, isUndirected);\n      } else {\n        response.error = 'Must provide --suggestion-id or both --from and --to';\n        response.errorCode = 'INVALID_ARGS';\n        if (options.json) {\n          outputJson();\n        } else {\n          console.error('Error:', response.error);\n        }\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Load candidate edge\n      const candidate = await ctx.candidateEdgeRepository.findById(suggestionId);\n\n      if (!candidate) {\n        response.error = `Suggestion not found: ${suggestionId}`;\n        response.errorCode = 'NOT_FOUND';\n        if (options.json) {\n          outputJson();\n        } else {\n          console.error('Error:', response.error);\n        }\n        ctx.connectionManager.close();\n        process.exit(1);\n      }\n\n      // Check if already rejected (idempotent)\n      if (candidate.status === 'rejected') {\n        response.success = true;\n        response.idempotent = true;\n        response.suggestionId = suggestionId;\n        response.fromId = candidate.fromId;\n        response.toId = candidate.toId;\n        response.edgeType = candidate.suggestedEdgeType;\n\n        if (options.json) {\n          outputJson();\n        } else {\n          console.log('Already rejected (idempotent)');\n        }\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Check if already approved (can still reject - will update status)\n      // Per design, we allow transitioning approved -> rejected\n      // This removes the truth edge effectively by marking the candidate as rejected\n\n      // Get node info for response\n      const fromNode = await ctx.nodeRepository.findById(candidate.fromId);\n      const toNode = await ctx.nodeRepository.findById(candidate.toId);\n\n      // Update candidate status to rejected\n      await ctx.candidateEdgeRepository.updateStatus(suggestionId, 'rejected');\n\n      response.success = true;\n      response.suggestionId = suggestionId;\n      response.fromId = candidate.fromId;\n      response.fromTitle = fromNode?.title;\n      response.toId = candidate.toId;\n      response.toTitle = toNode?.title;\n      response.edgeType = candidate.suggestedEdgeType;\n\n      if (options.json) {\n        outputJson();\n      } else {\n        console.log(\n          `Rejected: ${fromNode?.title || candidate.fromId} -> ${toNode?.title || candidate.toId}`\n        );\n        console.log(`  Type: ${candidate.suggestedEdgeType}`);\n        console.log('  This suggestion will be hidden from future views.');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      response.error = error instanceof Error ? error.message : String(error);\n      response.errorCode = 'DB_ERROR';\n      if (options.json) {\n        outputJson();\n      } else {\n        console.error('Error:', response.error);\n      }\n      process.exit(1);\n    }\n  });\n"],"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAo5CU,KAAK,UAAU,SAAS,CAAC;AAAA,yBACnB,KAAK,UAAU,cAAc,CAAC;AAAA,yBAC9B,KAAK,UAAU,UAAU,CAAC;AAAA,kCACjB,kBAAkB;AAAA,uBAC7B,YAAY;AAAA,uBACZ,YAAY;AAAA,yBACV,cAAc;AAAA,0BACb,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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","names":["Command","fs","path","stringifyYaml","fs","path","parseYaml","stringifyYaml","path","text","eq","and","inArray","sql","nanoid","nanoid","eq","and","inArray","result","sql","eq","and","sql","nanoid","nanoid","eq","and","sql","eq","sql","inArray","nanoid","nanoid","eq","inArray","sql","eq","and","sql","nanoid","nanoid","eq","and","sql","sql","sql","eq","eq","eq","inArray","sql","nanoid","DEFAULT_CONFIG","nanoid","eq","inArray","sql","eq","and","or","sql","nanoid","nanoid","and","eq","or","sql","eq","and","inArray","sql","eq","sql","and","inArray","aliases","text","edges","wikilink","path","edges","path","path","edges","nodes","parseYaml","stringifyYaml","Command","fs","path","createHash","createHash","logger","Command","path","Command","EventEmitter","path","DEFAULT_EXTENSIONS","DEFAULT_EXCLUDE","EventEmitter","Command","edges","Command","Command","nodes","path","Command","nodes","edges","Type","nodes","edges","Command","Command","fs","path","nodes","aliases","text","resolve","Command","nodes","path","Command","edges","chunks","nodes","Command","Command","fs","path","nodes","Command","nodes","Command","fs","path","readline","fs","path","text","aliases","text","chunks","nanoid","stringifyYaml","resolve","Command","outputDir","Command","path","desc","fs","path","stringifyYaml","text","fs","path","buildTags","buildTags","buildTags","desc","getEventFilename","fs","path","aliases","Command","Command","path","Command","Command","process","fs","path","nanoid","fs","path","stringifyYaml","nanoid","stringifyYaml","edges","resolve","Command","fs","path","dirname","dirname","formatBytes","Command","Command","constellations","process","nodes","edges","Command","fs","path","readline","process","stringifyYaml","nanoid","text","nodes","edges","promptYesNo","process","resolve","formatBytes","Command","stringifyYaml","spinner","result","nanoid","nodes","text","edges","Command","Command","constellations","Command","fs","path","Command","nodes","chunks","Command","Command","nodes","Command","fs","process","Command","process","nodes","Command","fs","path","open","candidateEdges","cosineSimilarity","edges","nodes","nodes","edges","basename","cosineSimilarity","text","Command","candidateEdges","open","Command","fs","path","Command","Command","Command","Command"]}