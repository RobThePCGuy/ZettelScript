{"version":3,"sources":["../../src/cli/index.ts","../../src/cli/commands/init.ts","../../src/storage/database/connection.ts","../../src/storage/database/schema.ts","../../src/core/errors.ts","../../src/core/types/index.ts","../../src/cli/utils.ts","../../src/storage/database/repositories/node-repository.ts","../../src/storage/database/repositories/edge-repository.ts","../../src/storage/database/repositories/version-repository.ts","../../src/storage/database/repositories/chunk-repository.ts","../../src/storage/database/repositories/mention-repository.ts","../../src/parser/markdown.ts","../../src/parser/frontmatter.ts","../../src/parser/exclusions.ts","../../src/parser/wikilink.ts","../../src/parser/resolver.ts","../../src/indexer/pipeline.ts","../../src/core/graph/engine.ts","../../src/cli/commands/index.ts","../../src/storage/filesystem/reader.ts","../../src/core/logger.ts","../../src/indexer/batch.ts","../../src/cli/commands/watch.ts","../../src/indexer/incremental.ts","../../src/storage/filesystem/watcher.ts","../../src/cli/commands/query.ts","../../src/core/validation.ts","../../src/cli/commands/validate.ts","../../src/validation/link-validator.ts","../../src/validation/schema-validator.ts","../../src/validation/continuity-checker.ts","../../src/cli/commands/discover.ts","../../src/discovery/mention-detector.ts","../../src/discovery/mention-ranker.ts","../../src/cli/interactive-approver.ts","../../src/cli/commands/retrieve.ts","../../src/retrieval/expansion/graph-expander.ts","../../src/retrieval/fusion/rrf.ts","../../src/retrieval/context/assembler.ts","../../src/cli/commands/rewrite.ts","../../src/engine/manuscript/impact-analyzer.ts","../../src/engine/manuscript/rewrite-orchestrator.ts","../../src/llm/provider.ts","../../src/llm/prompts.ts","../../src/cli/commands/extract.ts","../../src/extraction/entity-extractor.ts","../../src/cli/commands/generate.ts","../../src/generators/types.ts","../../src/generators/utils.ts","../../src/generators/characters.ts","../../src/generators/chapters.ts","../../src/generators/locations.ts","../../src/generators/objects.ts","../../src/generators/lore.ts","../../src/generators/timeline.ts","../../src/generators/arcs.ts","../../src/generators/inject-links.ts","../../src/cli/commands/inject-links.ts"],"sourcesContent":["#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport { initCommand } from './commands/init.js';\nimport { indexCommand } from './commands/index.js';\nimport { watchCommand } from './commands/watch.js';\nimport { queryCommand } from './commands/query.js';\nimport { validateCommand } from './commands/validate.js';\nimport { discoverCommand } from './commands/discover.js';\nimport { retrieveCommand } from './commands/retrieve.js';\nimport { rewriteCommand } from './commands/rewrite.js';\nimport { extractCommand } from './commands/extract.js';\nimport { generateCommand } from './commands/generate.js';\nimport { injectLinksCommand } from './commands/inject-links.js';\n\nconst program = new Command();\n\nprogram\n  .name('zettel')\n  .description('ZettelScript - Graph-first knowledge management system')\n  .version('0.1.0');\n\n// Register commands\nprogram.addCommand(initCommand);\nprogram.addCommand(indexCommand);\nprogram.addCommand(watchCommand);\nprogram.addCommand(queryCommand);\nprogram.addCommand(validateCommand);\nprogram.addCommand(discoverCommand);\nprogram.addCommand(retrieveCommand);\nprogram.addCommand(rewriteCommand);\nprogram.addCommand(extractCommand);\nprogram.addCommand(generateCommand);\nprogram.addCommand(injectLinksCommand);\n\n// Parse arguments\nprogram.parse();\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { stringify as stringifyYaml } from 'yaml';\nimport { ConnectionManager } from '../../storage/database/connection.js';\nimport { DEFAULT_CONFIG, type ZettelScriptConfig } from '../../core/types/index.js';\nimport { getZettelScriptDir, getDbPath, getConfigPath, findVaultRoot } from '../utils.js';\n\nexport const initCommand = new Command('init')\n  .description('Initialize a ZettelScript vault in the current directory')\n  .option('-f, --force', 'Overwrite existing initialization')\n  .option('--manuscript', 'Enable manuscript mode with POV and timeline validation')\n  .action(async (options) => {\n    const vaultPath = process.cwd();\n    const zettelDir = getZettelScriptDir(vaultPath);\n\n    // Check if already initialized\n    if (fs.existsSync(zettelDir) && !options.force) {\n      const existingRoot = findVaultRoot(vaultPath);\n      if (existingRoot) {\n        console.log(`Already initialized at: ${existingRoot}`);\n        console.log('Use --force to reinitialize.');\n        return;\n      }\n    }\n\n    console.log('Initializing ZettelScript vault...');\n\n    try {\n      // Create .zettelscript directory\n      fs.mkdirSync(zettelDir, { recursive: true });\n      console.log(`  Created ${path.relative(vaultPath, zettelDir)}/`);\n\n      // Create config file\n      const config: ZettelScriptConfig = {\n        ...DEFAULT_CONFIG,\n        vault: {\n          ...DEFAULT_CONFIG.vault,\n          path: '.',\n        },\n        manuscript: {\n          ...DEFAULT_CONFIG.manuscript,\n          enabled: options.manuscript || false,\n        },\n      };\n\n      const configPath = getConfigPath(vaultPath);\n      fs.writeFileSync(configPath, stringifyYaml(config), 'utf-8');\n      console.log(`  Created ${path.relative(vaultPath, configPath)}`);\n\n      // Initialize database\n      const dbPath = getDbPath(vaultPath);\n      const manager = ConnectionManager.getInstance(dbPath);\n      await manager.initialize();\n      manager.close();\n      ConnectionManager.resetInstance();\n      console.log(`  Created ${path.relative(vaultPath, dbPath)}`);\n\n      // Create .gitignore for .zettelscript\n      const gitignorePath = path.join(zettelDir, '.gitignore');\n      fs.writeFileSync(gitignorePath, '# Ignore database (regenerated from files)\\nzettelscript.db\\nzettelscript.db-*\\n', 'utf-8');\n\n      console.log('\\nZettelScript vault initialized!');\n      console.log('\\nNext steps:');\n      console.log('  zettel index    Index all markdown files');\n      console.log('  zettel watch    Watch for file changes');\n      console.log('  zettel query    Query the graph');\n\n      if (options.manuscript) {\n        console.log('\\nManuscript mode enabled:');\n        console.log('  - Add \"type: scene\" to scene frontmatter');\n        console.log('  - Add \"pov: CharacterName\" for POV tracking');\n        console.log('  - Add \"scene_order: N\" for timeline ordering');\n        console.log('  - Run \"zettel validate --continuity\" to check consistency');\n      }\n    } catch (error) {\n      console.error('Failed to initialize:', error);\n      process.exit(1);\n    }\n  });\n","import Database from 'better-sqlite3';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport * as schema from './schema.js';\nimport { DatabaseError } from '../../core/errors.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport type DrizzleDB = ReturnType<typeof drizzle<typeof schema>>;\n\n// SQL for creating FTS5 virtual table\nconst FTS5_SCHEMA = `\nCREATE VIRTUAL TABLE IF NOT EXISTS chunks_fts USING fts5(\n  chunk_id,\n  node_id,\n  text,\n  tokenize='porter'\n);\n`;\n\n// SQL for creating FTS triggers to keep it in sync\nconst FTS5_TRIGGERS = `\nCREATE TRIGGER IF NOT EXISTS chunks_ai AFTER INSERT ON chunks BEGIN\n  INSERT INTO chunks_fts(chunk_id, node_id, text)\n  VALUES (new.chunk_id, new.node_id, new.text);\nEND;\n\nCREATE TRIGGER IF NOT EXISTS chunks_ad AFTER DELETE ON chunks BEGIN\n  DELETE FROM chunks_fts WHERE chunk_id = old.chunk_id;\nEND;\n\nCREATE TRIGGER IF NOT EXISTS chunks_au AFTER UPDATE ON chunks BEGIN\n  DELETE FROM chunks_fts WHERE chunk_id = old.chunk_id;\n  INSERT INTO chunks_fts(chunk_id, node_id, text)\n  VALUES (new.chunk_id, new.node_id, new.text);\nEND;\n`;\n\n// Schema version for migrations\nconst SCHEMA_VERSION = 1;\n\n/**\n * Database connection manager for ZettelScript\n */\nexport class ConnectionManager {\n  private static instance: ConnectionManager | null = null;\n  private sqlite: Database.Database | null = null;\n  private db: DrizzleDB | null = null;\n  private dbPath: string;\n\n  private constructor(dbPath: string) {\n    this.dbPath = dbPath;\n  }\n\n  /**\n   * Get or create the singleton connection manager\n   */\n  static getInstance(dbPath?: string): ConnectionManager {\n    if (!ConnectionManager.instance) {\n      if (!dbPath) {\n        throw new DatabaseError('Database path required for initial connection');\n      }\n      ConnectionManager.instance = new ConnectionManager(dbPath);\n    }\n    return ConnectionManager.instance;\n  }\n\n  /**\n   * Reset the singleton (useful for testing)\n   */\n  static resetInstance(): void {\n    if (ConnectionManager.instance) {\n      ConnectionManager.instance.close();\n      ConnectionManager.instance = null;\n    }\n  }\n\n  /**\n   * Initialize the database connection and schema\n   */\n  async initialize(): Promise<void> {\n    if (this.db) {\n      return; // Already initialized\n    }\n\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(this.dbPath);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n\n      // Open SQLite connection\n      this.sqlite = new Database(this.dbPath);\n\n      // Enable WAL mode for better concurrent performance\n      this.sqlite.pragma('journal_mode = WAL');\n      this.sqlite.pragma('foreign_keys = ON');\n      this.sqlite.pragma('synchronous = NORMAL');\n\n      // Create Drizzle instance\n      this.db = drizzle(this.sqlite, { schema });\n\n      // Run migrations/schema creation\n      await this.migrate();\n    } catch (error) {\n      throw new DatabaseError(`Failed to initialize database: ${error}`, {\n        path: this.dbPath,\n        error: String(error),\n      });\n    }\n  }\n\n  /**\n   * Run database migrations\n   */\n  private async migrate(): Promise<void> {\n    if (!this.sqlite) {\n      throw new DatabaseError('SQLite connection not initialized');\n    }\n\n    // Check current schema version\n    let currentVersion = 0;\n    try {\n      const result = this.sqlite.prepare('SELECT version FROM schema_version LIMIT 1').get() as { version: number } | undefined;\n      if (result) {\n        currentVersion = result.version;\n      }\n    } catch {\n      // Table doesn't exist yet, that's fine\n    }\n\n    if (currentVersion >= SCHEMA_VERSION) {\n      return; // Already up to date\n    }\n\n    // Run initial schema creation\n    this.sqlite.exec(`\n      -- Schema version tracking\n      CREATE TABLE IF NOT EXISTS schema_version (\n        version INTEGER PRIMARY KEY\n      );\n\n      -- Nodes\n      CREATE TABLE IF NOT EXISTS nodes (\n        node_id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        title TEXT NOT NULL,\n        path TEXT NOT NULL UNIQUE,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL,\n        content_hash TEXT,\n        metadata TEXT\n      );\n\n      -- Edges with version ranges\n      CREATE TABLE IF NOT EXISTS edges (\n        edge_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        edge_type TEXT NOT NULL,\n        strength REAL,\n        provenance TEXT NOT NULL,\n        created_at TEXT NOT NULL,\n        version_start TEXT,\n        version_end TEXT,\n        attributes TEXT\n      );\n\n      -- Version history\n      CREATE TABLE IF NOT EXISTS versions (\n        version_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        content_hash TEXT NOT NULL,\n        parent_version_id TEXT,\n        created_at TEXT NOT NULL,\n        summary TEXT\n      );\n\n      -- Mention candidates\n      CREATE TABLE IF NOT EXISTS mention_candidates (\n        candidate_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        surface_text TEXT NOT NULL,\n        span_start INTEGER,\n        span_end INTEGER,\n        confidence REAL NOT NULL,\n        reasons TEXT,\n        status TEXT DEFAULT 'new'\n      );\n\n      -- Chunks for retrieval\n      CREATE TABLE IF NOT EXISTS chunks (\n        chunk_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        text TEXT NOT NULL,\n        offset_start INTEGER NOT NULL,\n        offset_end INTEGER NOT NULL,\n        version_id TEXT NOT NULL,\n        token_count INTEGER\n      );\n\n      -- Aliases\n      CREATE TABLE IF NOT EXISTS aliases (\n        alias_id TEXT PRIMARY KEY,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        alias TEXT NOT NULL\n      );\n\n      -- Graph metrics cache\n      CREATE TABLE IF NOT EXISTS graph_metrics (\n        node_id TEXT PRIMARY KEY REFERENCES nodes(node_id) ON DELETE CASCADE,\n        centrality_pagerank REAL,\n        cluster_id TEXT,\n        computed_at TEXT NOT NULL\n      );\n\n      -- Proposals\n      CREATE TABLE IF NOT EXISTS proposals (\n        proposal_id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        node_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        description TEXT NOT NULL,\n        diff TEXT NOT NULL,\n        status TEXT DEFAULT 'pending',\n        created_at TEXT NOT NULL,\n        applied_at TEXT,\n        metadata TEXT\n      );\n\n      -- Unresolved links\n      CREATE TABLE IF NOT EXISTS unresolved_links (\n        link_id TEXT PRIMARY KEY,\n        source_id TEXT NOT NULL REFERENCES nodes(node_id) ON DELETE CASCADE,\n        target_text TEXT NOT NULL,\n        span_start INTEGER,\n        span_end INTEGER,\n        created_at TEXT NOT NULL\n      );\n\n      -- Performance indexes\n      CREATE INDEX IF NOT EXISTS idx_nodes_title ON nodes(title COLLATE NOCASE);\n      CREATE INDEX IF NOT EXISTS idx_nodes_type ON nodes(type);\n      CREATE INDEX IF NOT EXISTS idx_nodes_path ON nodes(path);\n      CREATE INDEX IF NOT EXISTS idx_edges_source ON edges(source_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_target ON edges(target_id);\n      CREATE INDEX IF NOT EXISTS idx_edges_type ON edges(edge_type);\n      CREATE INDEX IF NOT EXISTS idx_edges_source_target ON edges(source_id, target_id);\n      CREATE INDEX IF NOT EXISTS idx_versions_node ON versions(node_id);\n      CREATE INDEX IF NOT EXISTS idx_versions_parent ON versions(parent_version_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_source ON mention_candidates(source_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_target ON mention_candidates(target_id);\n      CREATE INDEX IF NOT EXISTS idx_mentions_status ON mention_candidates(status);\n      CREATE INDEX IF NOT EXISTS idx_chunks_node ON chunks(node_id);\n      CREATE INDEX IF NOT EXISTS idx_chunks_version ON chunks(version_id);\n      CREATE INDEX IF NOT EXISTS idx_aliases_node ON aliases(node_id);\n      CREATE INDEX IF NOT EXISTS idx_aliases_alias ON aliases(alias COLLATE NOCASE);\n      CREATE INDEX IF NOT EXISTS idx_proposals_node ON proposals(node_id);\n      CREATE INDEX IF NOT EXISTS idx_proposals_status ON proposals(status);\n      CREATE INDEX IF NOT EXISTS idx_unresolved_source ON unresolved_links(source_id);\n      CREATE INDEX IF NOT EXISTS idx_unresolved_target ON unresolved_links(target_text);\n    `);\n\n    // Create FTS5 virtual table\n    this.sqlite.exec(FTS5_SCHEMA);\n    this.sqlite.exec(FTS5_TRIGGERS);\n\n    // Update schema version\n    this.sqlite.exec(`\n      DELETE FROM schema_version;\n      INSERT INTO schema_version (version) VALUES (${SCHEMA_VERSION});\n    `);\n  }\n\n  /**\n   * Get the Drizzle database instance\n   */\n  getDb(): DrizzleDB {\n    if (!this.db) {\n      throw new DatabaseError('Database not initialized. Call initialize() first.');\n    }\n    return this.db;\n  }\n\n  /**\n   * Get the raw SQLite database instance (for FTS5 and custom queries)\n   */\n  getSqlite(): Database.Database {\n    if (!this.sqlite) {\n      throw new DatabaseError('Database not initialized. Call initialize() first.');\n    }\n    return this.sqlite;\n  }\n\n  /**\n   * Close the database connection\n   */\n  close(): void {\n    if (this.sqlite) {\n      this.sqlite.close();\n      this.sqlite = null;\n      this.db = null;\n    }\n  }\n\n  /**\n   * Run a transaction\n   */\n  transaction<T>(fn: () => T): T {\n    const sqlite = this.getSqlite();\n    return sqlite.transaction(fn)();\n  }\n\n  /**\n   * Check if the database is initialized\n   */\n  isInitialized(): boolean {\n    return this.db !== null;\n  }\n\n  /**\n   * Get database statistics\n   */\n  getStats(): {\n    nodeCount: number;\n    edgeCount: number;\n    chunkCount: number;\n    dbSizeBytes: number;\n  } {\n    const sqlite = this.getSqlite();\n\n    const nodeCount = (sqlite.prepare('SELECT COUNT(*) as count FROM nodes').get() as { count: number }).count;\n    const edgeCount = (sqlite.prepare('SELECT COUNT(*) as count FROM edges').get() as { count: number }).count;\n    const chunkCount = (sqlite.prepare('SELECT COUNT(*) as count FROM chunks').get() as { count: number }).count;\n\n    const stats = fs.statSync(this.dbPath);\n\n    return {\n      nodeCount,\n      edgeCount,\n      chunkCount,\n      dbSizeBytes: stats.size,\n    };\n  }\n}\n\n/**\n * Helper to get a database connection for a vault\n */\nexport async function getDatabase(vaultPath: string): Promise<DrizzleDB> {\n  const dbPath = path.join(vaultPath, '.zettelscript', 'zettelscript.db');\n  const manager = ConnectionManager.getInstance(dbPath);\n  await manager.initialize();\n  return manager.getDb();\n}\n\n/**\n * Helper to get raw SQLite for FTS5 queries\n */\nexport function getRawSqlite(vaultPath: string): Database.Database {\n  const dbPath = path.join(vaultPath, '.zettelscript', 'zettelscript.db');\n  const manager = ConnectionManager.getInstance(dbPath);\n  return manager.getSqlite();\n}\n","import { sqliteTable, text, real, integer, index } from 'drizzle-orm/sqlite-core';\n\n// ============================================================================\n// Nodes Table\n// ============================================================================\n\nexport const nodes = sqliteTable('nodes', {\n  nodeId: text('node_id').primaryKey(),\n  type: text('type').notNull(),\n  title: text('title').notNull(),\n  path: text('path').notNull().unique(),\n  createdAt: text('created_at').notNull(),\n  updatedAt: text('updated_at').notNull(),\n  contentHash: text('content_hash'),\n  metadata: text('metadata', { mode: 'json' }),\n}, (table) => [\n  index('idx_nodes_title').on(table.title),\n  index('idx_nodes_type').on(table.type),\n  index('idx_nodes_path').on(table.path),\n]);\n\n// ============================================================================\n// Edges Table\n// ============================================================================\n\nexport const edges = sqliteTable('edges', {\n  edgeId: text('edge_id').primaryKey(),\n  sourceId: text('source_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  targetId: text('target_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  edgeType: text('edge_type').notNull(),\n  strength: real('strength'),\n  provenance: text('provenance').notNull(),\n  createdAt: text('created_at').notNull(),\n  versionStart: text('version_start'),\n  versionEnd: text('version_end'),\n  attributes: text('attributes', { mode: 'json' }),\n}, (table) => [\n  index('idx_edges_source').on(table.sourceId),\n  index('idx_edges_target').on(table.targetId),\n  index('idx_edges_type').on(table.edgeType),\n  index('idx_edges_source_target').on(table.sourceId, table.targetId),\n]);\n\n// ============================================================================\n// Versions Table\n// ============================================================================\n\nexport const versions = sqliteTable('versions', {\n  versionId: text('version_id').primaryKey(),\n  nodeId: text('node_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  contentHash: text('content_hash').notNull(),\n  parentVersionId: text('parent_version_id'),\n  createdAt: text('created_at').notNull(),\n  summary: text('summary'),\n}, (table) => [\n  index('idx_versions_node').on(table.nodeId),\n  index('idx_versions_parent').on(table.parentVersionId),\n]);\n\n// ============================================================================\n// Mention Candidates Table\n// ============================================================================\n\nexport const mentionCandidates = sqliteTable('mention_candidates', {\n  candidateId: text('candidate_id').primaryKey(),\n  sourceId: text('source_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  targetId: text('target_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  surfaceText: text('surface_text').notNull(),\n  spanStart: integer('span_start'),\n  spanEnd: integer('span_end'),\n  confidence: real('confidence').notNull(),\n  reasons: text('reasons', { mode: 'json' }),\n  status: text('status').default('new'),\n}, (table) => [\n  index('idx_mentions_source').on(table.sourceId),\n  index('idx_mentions_target').on(table.targetId),\n  index('idx_mentions_status').on(table.status),\n]);\n\n// ============================================================================\n// Chunks Table\n// ============================================================================\n\nexport const chunks = sqliteTable('chunks', {\n  chunkId: text('chunk_id').primaryKey(),\n  nodeId: text('node_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  text: text('text').notNull(),\n  offsetStart: integer('offset_start').notNull(),\n  offsetEnd: integer('offset_end').notNull(),\n  versionId: text('version_id').notNull(),\n  tokenCount: integer('token_count'),\n}, (table) => [\n  index('idx_chunks_node').on(table.nodeId),\n  index('idx_chunks_version').on(table.versionId),\n]);\n\n// ============================================================================\n// Aliases Table\n// ============================================================================\n\nexport const aliases = sqliteTable('aliases', {\n  aliasId: text('alias_id').primaryKey(),\n  nodeId: text('node_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  alias: text('alias').notNull(),\n}, (table) => [\n  index('idx_aliases_node').on(table.nodeId),\n  index('idx_aliases_alias').on(table.alias),\n]);\n\n// ============================================================================\n// Graph Metrics Cache\n// ============================================================================\n\nexport const graphMetrics = sqliteTable('graph_metrics', {\n  nodeId: text('node_id').primaryKey().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  centralityPagerank: real('centrality_pagerank'),\n  clusterId: text('cluster_id'),\n  computedAt: text('computed_at').notNull(),\n});\n\n// ============================================================================\n// Proposals Table\n// ============================================================================\n\nexport const proposals = sqliteTable('proposals', {\n  proposalId: text('proposal_id').primaryKey(),\n  type: text('type').notNull(),\n  nodeId: text('node_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  description: text('description').notNull(),\n  diff: text('diff', { mode: 'json' }).notNull(),\n  status: text('status').default('pending'),\n  createdAt: text('created_at').notNull(),\n  appliedAt: text('applied_at'),\n  metadata: text('metadata', { mode: 'json' }),\n}, (table) => [\n  index('idx_proposals_node').on(table.nodeId),\n  index('idx_proposals_status').on(table.status),\n]);\n\n// ============================================================================\n// Unresolved Links Table\n// ============================================================================\n\nexport const unresolvedLinks = sqliteTable('unresolved_links', {\n  linkId: text('link_id').primaryKey(),\n  sourceId: text('source_id').notNull().references(() => nodes.nodeId, { onDelete: 'cascade' }),\n  targetText: text('target_text').notNull(),\n  spanStart: integer('span_start'),\n  spanEnd: integer('span_end'),\n  createdAt: text('created_at').notNull(),\n}, (table) => [\n  index('idx_unresolved_source').on(table.sourceId),\n  index('idx_unresolved_target').on(table.targetText),\n]);\n\n// Type exports for use in repositories\nexport type NodeRow = typeof nodes.$inferSelect;\nexport type NewNodeRow = typeof nodes.$inferInsert;\n\nexport type EdgeRow = typeof edges.$inferSelect;\nexport type NewEdgeRow = typeof edges.$inferInsert;\n\nexport type VersionRow = typeof versions.$inferSelect;\nexport type NewVersionRow = typeof versions.$inferInsert;\n\nexport type MentionCandidateRow = typeof mentionCandidates.$inferSelect;\nexport type NewMentionCandidateRow = typeof mentionCandidates.$inferInsert;\n\nexport type ChunkRow = typeof chunks.$inferSelect;\nexport type NewChunkRow = typeof chunks.$inferInsert;\n\nexport type AliasRow = typeof aliases.$inferSelect;\nexport type NewAliasRow = typeof aliases.$inferInsert;\n\nexport type ProposalRow = typeof proposals.$inferSelect;\nexport type NewProposalRow = typeof proposals.$inferInsert;\n","/**\n * Base error class for ZettelScript\n */\nexport class ZettelScriptError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'ZettelScriptError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n/**\n * Database-related errors\n */\nexport class DatabaseError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'DATABASE_ERROR', details);\n    this.name = 'DatabaseError';\n  }\n}\n\n/**\n * Parsing errors (markdown, frontmatter, wikilinks)\n */\nexport class ParseError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public filePath: string,\n    public line?: number,\n    public column?: number,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'PARSE_ERROR', { filePath, line, column, ...details });\n    this.name = 'ParseError';\n  }\n}\n\n/**\n * Link resolution errors\n */\nexport class ResolutionError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public linkText: string,\n    public candidates?: string[],\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'RESOLUTION_ERROR', { linkText, candidates, ...details });\n    this.name = 'ResolutionError';\n  }\n}\n\n/**\n * Validation errors\n */\nexport class ValidationError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public issues: Array<{\n      path: string;\n      message: string;\n      severity: 'error' | 'warning';\n    }>,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'VALIDATION_ERROR', { issues, ...details });\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Configuration errors\n */\nexport class ConfigError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'CONFIG_ERROR', details);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Graph operation errors\n */\nexport class GraphError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'GRAPH_ERROR', details);\n    this.name = 'GraphError';\n  }\n}\n\n/**\n * Retrieval/embedding errors\n */\nexport class RetrievalError extends ZettelScriptError {\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message, 'RETRIEVAL_ERROR', details);\n    this.name = 'RetrievalError';\n  }\n}\n\n/**\n * File system errors\n */\nexport class FileSystemError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public filePath: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'FILESYSTEM_ERROR', { filePath, ...details });\n    this.name = 'FileSystemError';\n  }\n}\n\n/**\n * Manuscript/continuity errors\n */\nexport class ContinuityError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public issueType: string,\n    public nodeId: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'CONTINUITY_ERROR', { issueType, nodeId, ...details });\n    this.name = 'ContinuityError';\n  }\n}\n\n/**\n * Proposal/writeback errors\n */\nexport class ProposalError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public proposalId: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'PROPOSAL_ERROR', { proposalId, ...details });\n    this.name = 'ProposalError';\n  }\n}\n\n/**\n * Embedding provider errors\n */\nexport class EmbeddingError extends ZettelScriptError {\n  constructor(\n    message: string,\n    public provider: string,\n    details?: Record<string, unknown>\n  ) {\n    super(message, 'EMBEDDING_ERROR', { provider, ...details });\n    this.name = 'EmbeddingError';\n  }\n}\n","import { Type, Static } from '@sinclair/typebox';\n\n// ============================================================================\n// Node Types\n// ============================================================================\n\nexport const NodeTypeSchema = Type.Union([\n  Type.Literal('note'),\n  Type.Literal('scene'),\n  Type.Literal('character'),\n  Type.Literal('location'),\n  Type.Literal('object'),\n  Type.Literal('event'),\n  Type.Literal('concept'),\n  Type.Literal('moc'),\n  Type.Literal('timeline'),\n  Type.Literal('draft'),\n]);\n\nexport type NodeType = Static<typeof NodeTypeSchema>;\n\nexport const NodeSchema = Type.Object({\n  nodeId: Type.String(),\n  type: NodeTypeSchema,\n  title: Type.String(),\n  path: Type.String(),\n  createdAt: Type.String({ format: 'date-time' }),\n  updatedAt: Type.String({ format: 'date-time' }),\n  contentHash: Type.Optional(Type.String()),\n  metadata: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n});\n\nexport type Node = Static<typeof NodeSchema>;\n\n// ============================================================================\n// Edge Types\n// ============================================================================\n\nexport const EdgeTypeSchema = Type.Union([\n  Type.Literal('explicit_link'),\n  Type.Literal('backlink'),\n  Type.Literal('sequence'),\n  Type.Literal('hierarchy'),\n  Type.Literal('participation'),\n  Type.Literal('pov_visible_to'),\n  Type.Literal('causes'),\n  Type.Literal('setup_payoff'),\n  Type.Literal('semantic'),\n  Type.Literal('mention'),\n  Type.Literal('alias'),\n]);\n\nexport type EdgeType = Static<typeof EdgeTypeSchema>;\n\nexport const EdgeProvenanceSchema = Type.Union([\n  Type.Literal('explicit'),\n  Type.Literal('inferred'),\n  Type.Literal('computed'),\n  Type.Literal('user_approved'),\n]);\n\nexport type EdgeProvenance = Static<typeof EdgeProvenanceSchema>;\n\nexport const EdgeSchema = Type.Object({\n  edgeId: Type.String(),\n  sourceId: Type.String(),\n  targetId: Type.String(),\n  edgeType: EdgeTypeSchema,\n  strength: Type.Optional(Type.Number({ minimum: 0, maximum: 1 })),\n  provenance: EdgeProvenanceSchema,\n  createdAt: Type.String({ format: 'date-time' }),\n  versionStart: Type.Optional(Type.String()),\n  versionEnd: Type.Optional(Type.String()),\n  attributes: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n});\n\nexport type Edge = Static<typeof EdgeSchema>;\n\n// ============================================================================\n// Version Types\n// ============================================================================\n\nexport const VersionSchema = Type.Object({\n  versionId: Type.String(),\n  nodeId: Type.String(),\n  contentHash: Type.String(),\n  parentVersionId: Type.Optional(Type.String()),\n  createdAt: Type.String({ format: 'date-time' }),\n  summary: Type.Optional(Type.String()),\n});\n\nexport type Version = Static<typeof VersionSchema>;\n\n// ============================================================================\n// Mention Types\n// ============================================================================\n\nexport const MentionStatusSchema = Type.Union([\n  Type.Literal('new'),\n  Type.Literal('approved'),\n  Type.Literal('rejected'),\n  Type.Literal('deferred'),\n]);\n\nexport type MentionStatus = Static<typeof MentionStatusSchema>;\n\nexport const MentionCandidateSchema = Type.Object({\n  candidateId: Type.String(),\n  sourceId: Type.String(),\n  targetId: Type.String(),\n  surfaceText: Type.String(),\n  spanStart: Type.Optional(Type.Integer()),\n  spanEnd: Type.Optional(Type.Integer()),\n  confidence: Type.Number({ minimum: 0, maximum: 1 }),\n  reasons: Type.Optional(Type.Array(Type.String())),\n  status: MentionStatusSchema,\n});\n\nexport type MentionCandidate = Static<typeof MentionCandidateSchema>;\n\n// ============================================================================\n// Chunk Types (for retrieval)\n// ============================================================================\n\nexport const ChunkSchema = Type.Object({\n  chunkId: Type.String(),\n  nodeId: Type.String(),\n  text: Type.String(),\n  offsetStart: Type.Integer(),\n  offsetEnd: Type.Integer(),\n  versionId: Type.String(),\n  tokenCount: Type.Optional(Type.Integer()),\n});\n\nexport type Chunk = Static<typeof ChunkSchema>;\n\n// ============================================================================\n// Proposal Types (for writeback)\n// ============================================================================\n\nexport const ProposalTypeSchema = Type.Union([\n  Type.Literal('link_addition'),\n  Type.Literal('content_edit'),\n  Type.Literal('node_creation'),\n  Type.Literal('node_deletion'),\n  Type.Literal('metadata_update'),\n]);\n\nexport type ProposalType = Static<typeof ProposalTypeSchema>;\n\nexport const ProposalStatusSchema = Type.Union([\n  Type.Literal('pending'),\n  Type.Literal('approved'),\n  Type.Literal('rejected'),\n  Type.Literal('applied'),\n]);\n\nexport type ProposalStatus = Static<typeof ProposalStatusSchema>;\n\nexport const ProposalSchema = Type.Object({\n  proposalId: Type.String(),\n  type: ProposalTypeSchema,\n  nodeId: Type.String(),\n  description: Type.String(),\n  diff: Type.Object({\n    before: Type.Optional(Type.String()),\n    after: Type.String(),\n  }),\n  status: ProposalStatusSchema,\n  createdAt: Type.String({ format: 'date-time' }),\n  appliedAt: Type.Optional(Type.String({ format: 'date-time' })),\n  metadata: Type.Optional(Type.Record(Type.String(), Type.Unknown())),\n});\n\nexport type Proposal = Static<typeof ProposalSchema>;\n\n// ============================================================================\n// Graph Metrics\n// ============================================================================\n\nexport const GraphMetricsSchema = Type.Object({\n  nodeId: Type.String(),\n  centralityPagerank: Type.Optional(Type.Number()),\n  clusterId: Type.Optional(Type.String()),\n  computedAt: Type.String({ format: 'date-time' }),\n});\n\nexport type GraphMetrics = Static<typeof GraphMetricsSchema>;\n\n// ============================================================================\n// Frontmatter Schema\n// ============================================================================\n\nexport const FrontmatterSchema = Type.Object({\n  id: Type.Optional(Type.String()),\n  title: Type.Optional(Type.String()),\n  type: Type.Optional(NodeTypeSchema),\n  aliases: Type.Optional(Type.Array(Type.String())),\n  tags: Type.Optional(Type.Array(Type.String())),\n  created: Type.Optional(Type.String()),\n  updated: Type.Optional(Type.String()),\n  // Manuscript-specific fields\n  pov: Type.Optional(Type.String()),\n  scene_order: Type.Optional(Type.Number()),\n  timeline_position: Type.Optional(Type.String()),\n  characters: Type.Optional(Type.Array(Type.String())),\n  locations: Type.Optional(Type.Array(Type.String())),\n  // Allow additional fields\n}, { additionalProperties: true });\n\nexport type Frontmatter = Static<typeof FrontmatterSchema>;\n\n// ============================================================================\n// Wikilink Types\n// ============================================================================\n\nexport interface WikiLink {\n  raw: string;           // Original text including brackets\n  target: string;        // The link target (after id: prefix if present)\n  display: string;       // Display text (after | if present)\n  isIdLink: boolean;     // Whether it uses id: prefix\n  start: number;         // Start position in source\n  end: number;           // End position in source\n}\n\nexport interface ResolvedLink extends WikiLink {\n  resolvedNodeId: string | null;\n  ambiguous: boolean;\n  candidates: string[];  // Node IDs if ambiguous\n}\n\n// ============================================================================\n// Query Types\n// ============================================================================\n\nexport interface BacklinkResult {\n  sourceNode: Node;\n  edge: Edge;\n  context?: string;  // Surrounding text for context\n}\n\nexport interface NeighborResult {\n  node: Node;\n  edge: Edge;\n  direction: 'incoming' | 'outgoing';\n}\n\nexport interface TraversalResult {\n  nodeId: string;\n  depth: number;\n  score: number;\n  path: string[];  // Node IDs forming the path\n}\n\n// ============================================================================\n// Retrieval Types\n// ============================================================================\n\nexport interface RetrievalQuery {\n  text: string;\n  maxResults?: number;\n  filters?: {\n    nodeTypes?: NodeType[];\n    excludeNodeIds?: string[];\n    dateRange?: { start?: string; end?: string };\n  };\n  expansion?: {\n    maxDepth?: number;\n    budget?: number;\n    edgeTypes?: EdgeType[];\n    decayFactor?: number;\n  };\n}\n\nexport interface RetrievalResult {\n  chunks: Array<{\n    chunk: Chunk;\n    node: Node;\n    score: number;\n    matchType: 'semantic' | 'lexical' | 'graph';\n  }>;\n  context: string;\n  provenance: Array<{\n    nodeId: string;\n    path: string;\n    contribution: number;\n  }>;\n}\n\n// ============================================================================\n// Manuscript Types\n// ============================================================================\n\nexport interface SceneInfo {\n  nodeId: string;\n  sceneOrder: number;\n  timelinePosition?: string;\n  pov?: string;\n  characters: string[];\n  locations: string[];\n}\n\nexport interface CharacterKnowledge {\n  characterId: string;\n  knows: Map<string, { learnedAt: string; source: string }>;\n  present: string[];  // Scene IDs where character is present\n}\n\nexport interface ContinuityIssue {\n  type: 'pov_leakage' | 'timeline_inconsistency' | 'missing_setup' | 'orphaned_payoff' | 'character_knowledge';\n  severity: 'error' | 'warning' | 'info';\n  nodeId: string;\n  description: string;\n  suggestion?: string;\n}\n\nexport interface ImpactAnalysis {\n  directImpact: string[];      // Directly affected node IDs\n  transitiveImpact: string[];  // Indirectly affected via graph\n  povImpact: string[];         // Scenes with same POV\n  timelineImpact: string[];    // Scenes in timeline range\n  characterImpact: string[];   // Characters whose knowledge changes\n}\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\nexport interface ZettelScriptConfig {\n  vault: {\n    path: string;\n    excludePatterns: string[];\n  };\n  database: {\n    path: string;\n  };\n  embeddings: {\n    provider: 'openai' | 'ollama';\n    model: string;\n    dimensions: number;\n    apiKey?: string;\n    baseUrl?: string;\n  };\n  retrieval: {\n    defaultMaxResults: number;\n    semanticWeight: number;\n    lexicalWeight: number;\n    graphWeight: number;\n    rrfK: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n  manuscript: {\n    enabled: boolean;\n    validatePov: boolean;\n    validateTimeline: boolean;\n    validateSetupPayoff: boolean;\n  };\n  graph: {\n    defaultMaxDepth: number;\n    defaultBudget: number;\n    decayFactor: number;\n    scoreThreshold: number;\n  };\n  chunking: {\n    maxTokens: number;\n    overlap: number;\n    minChunkSize: number;\n  };\n  discovery: {\n    weights: {\n      locality: number;\n      centrality: number;\n      frequency: number;\n      matchQuality: number;\n    };\n    confidenceThreshold: number;\n    ambiguityPenalty: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n  cache: {\n    defaultTtlMs: number;\n    defaultMaxSize: number;\n    mentionTtlMs: number;\n    mentionMaxSize: number;\n    mocTtlMs: number;\n    mocMaxSize: number;\n  };\n  impact: {\n    timelineRange: number;\n    maxTransitiveDepth: number;\n    maxTransitiveBudget: number;\n  };\n  moc: {\n    scoreNormalizationBase: number;\n    hubScoreNormalization: number;\n    clusterScoreNormalization: number;\n    defaultHubThreshold: number;\n  };\n  versioning: {\n    driftVersionWindow: number;\n    butterflyLogDefaultEntries: number;\n  };\n  search: {\n    defaultLimit: number;\n    contextWindowChars: number;\n    diffContextLines: number;\n  };\n  llm: {\n    provider: 'openai' | 'ollama' | 'none';\n    model: string;\n    apiKey?: string;\n    baseUrl?: string;\n    maxTokens?: number;\n    temperature?: number;\n  };\n}\n\nexport const DEFAULT_CONFIG: ZettelScriptConfig = {\n  vault: {\n    path: '.',\n    excludePatterns: ['node_modules/**', '.git/**', '.zettelscript/**'],\n  },\n  database: {\n    path: '.zettelscript/zettelscript.db',\n  },\n  embeddings: {\n    provider: 'openai',\n    model: 'text-embedding-3-small',\n    dimensions: 1536,\n  },\n  retrieval: {\n    defaultMaxResults: 20,\n    semanticWeight: 0.5,\n    lexicalWeight: 0.3,\n    graphWeight: 0.2,\n    rrfK: 60,\n    expansionMaxDepth: 3,\n    expansionBudget: 50,\n  },\n  manuscript: {\n    enabled: false,\n    validatePov: true,\n    validateTimeline: true,\n    validateSetupPayoff: true,\n  },\n  graph: {\n    defaultMaxDepth: 3,\n    defaultBudget: 50,\n    decayFactor: 0.7,\n    scoreThreshold: 0.01,\n  },\n  chunking: {\n    maxTokens: 512,\n    overlap: 50,\n    minChunkSize: 50,\n  },\n  discovery: {\n    weights: {\n      locality: 0.3,\n      centrality: 0.2,\n      frequency: 0.2,\n      matchQuality: 0.3,\n    },\n    confidenceThreshold: 0.3,\n    ambiguityPenalty: 0.7,\n    expansionMaxDepth: 4,\n    expansionBudget: 100,\n  },\n  cache: {\n    defaultTtlMs: 300000, // 5 minutes\n    defaultMaxSize: 1000,\n    mentionTtlMs: 600000, // 10 minutes\n    mentionMaxSize: 500,\n    mocTtlMs: 300000, // 5 minutes\n    mocMaxSize: 100,\n  },\n  impact: {\n    timelineRange: 5,\n    maxTransitiveDepth: 3,\n    maxTransitiveBudget: 50,\n  },\n  moc: {\n    scoreNormalizationBase: 100,\n    hubScoreNormalization: 50,\n    clusterScoreNormalization: 20,\n    defaultHubThreshold: 5,\n  },\n  versioning: {\n    driftVersionWindow: 5,\n    butterflyLogDefaultEntries: 50,\n  },\n  search: {\n    defaultLimit: 20,\n    contextWindowChars: 50,\n    diffContextLines: 3,\n  },\n  llm: {\n    provider: 'none',\n    model: 'gpt-4',\n  },\n};\n","import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport { ConnectionManager } from '../storage/database/connection.js';\nimport { NodeRepository, EdgeRepository, VersionRepository, ChunkRepository, MentionRepository } from '../storage/database/repositories/index.js';\nimport { IndexingPipeline } from '../indexer/pipeline.js';\nimport { GraphEngine } from '../core/graph/engine.js';\nimport type { ZettelScriptConfig } from '../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../core/types/index.js';\n\nconst ZETTELSCRIPT_DIR = '.zettelscript';\nconst CONFIG_FILE = 'config.yaml';\nconst DB_FILE = 'zettelscript.db';\n\n/**\n * Find the vault root by looking for .zettelscript directory\n */\nexport function findVaultRoot(startPath: string = process.cwd()): string | null {\n  let currentPath = path.resolve(startPath);\n\n  while (currentPath !== path.dirname(currentPath)) {\n    const zettelDir = path.join(currentPath, ZETTELSCRIPT_DIR);\n    if (fs.existsSync(zettelDir)) {\n      return currentPath;\n    }\n    currentPath = path.dirname(currentPath);\n  }\n\n  return null;\n}\n\n/**\n * Get the .zettelscript directory path\n */\nexport function getZettelScriptDir(vaultPath: string): string {\n  return path.join(vaultPath, ZETTELSCRIPT_DIR);\n}\n\n/**\n * Get the database path\n */\nexport function getDbPath(vaultPath: string): string {\n  return path.join(vaultPath, ZETTELSCRIPT_DIR, DB_FILE);\n}\n\n/**\n * Get the config file path\n */\nexport function getConfigPath(vaultPath: string): string {\n  return path.join(vaultPath, ZETTELSCRIPT_DIR, CONFIG_FILE);\n}\n\n/**\n * Load configuration\n */\nexport function loadConfig(vaultPath: string): ZettelScriptConfig {\n  const configPath = getConfigPath(vaultPath);\n\n  if (!fs.existsSync(configPath)) {\n    return { ...DEFAULT_CONFIG, vault: { ...DEFAULT_CONFIG.vault, path: vaultPath } };\n  }\n\n  try {\n    const content = fs.readFileSync(configPath, 'utf-8');\n    const userConfig = parseYaml(content) as Partial<ZettelScriptConfig>;\n\n    return {\n      ...DEFAULT_CONFIG,\n      ...userConfig,\n      vault: { ...DEFAULT_CONFIG.vault, ...userConfig.vault, path: vaultPath },\n      database: { ...DEFAULT_CONFIG.database, ...userConfig.database },\n      embeddings: { ...DEFAULT_CONFIG.embeddings, ...userConfig.embeddings },\n      retrieval: { ...DEFAULT_CONFIG.retrieval, ...userConfig.retrieval },\n      manuscript: { ...DEFAULT_CONFIG.manuscript, ...userConfig.manuscript },\n      graph: { ...DEFAULT_CONFIG.graph, ...userConfig.graph },\n      chunking: { ...DEFAULT_CONFIG.chunking, ...userConfig.chunking },\n      discovery: {\n        ...DEFAULT_CONFIG.discovery,\n        ...userConfig.discovery,\n        weights: { ...DEFAULT_CONFIG.discovery.weights, ...userConfig.discovery?.weights },\n      },\n      cache: { ...DEFAULT_CONFIG.cache, ...userConfig.cache },\n      impact: { ...DEFAULT_CONFIG.impact, ...userConfig.impact },\n    };\n  } catch (error) {\n    console.warn(`Warning: Could not parse config file: ${error}`);\n    return { ...DEFAULT_CONFIG, vault: { ...DEFAULT_CONFIG.vault, path: vaultPath } };\n  }\n}\n\n/**\n * Save configuration\n */\nexport function saveConfig(vaultPath: string, config: ZettelScriptConfig): void {\n  const configPath = getConfigPath(vaultPath);\n  const content = stringifyYaml(config);\n  fs.writeFileSync(configPath, content, 'utf-8');\n}\n\n/**\n * Context object containing all initialized components\n */\nexport interface CLIContext {\n  vaultPath: string;\n  config: ZettelScriptConfig;\n  connectionManager: ConnectionManager;\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  versionRepository: VersionRepository;\n  chunkRepository: ChunkRepository;\n  mentionRepository: MentionRepository;\n  pipeline: IndexingPipeline;\n  graphEngine: GraphEngine;\n}\n\n/**\n * Initialize CLI context\n */\nexport async function initContext(vaultPath?: string): Promise<CLIContext> {\n  // Find vault root\n  const resolvedPath = vaultPath ? path.resolve(vaultPath) : findVaultRoot();\n\n  if (!resolvedPath) {\n    throw new Error(\n      'Not in a ZettelScript vault. Run \"zettel init\" to create one.'\n    );\n  }\n\n  // Load config\n  const config = loadConfig(resolvedPath);\n\n  // Initialize database\n  const dbPath = getDbPath(resolvedPath);\n  const connectionManager = ConnectionManager.getInstance(dbPath);\n  await connectionManager.initialize();\n\n  const db = connectionManager.getDb();\n  const sqlite = connectionManager.getSqlite();\n\n  // Initialize repositories\n  const nodeRepository = new NodeRepository(db);\n  const edgeRepository = new EdgeRepository(db);\n  const versionRepository = new VersionRepository(db);\n  const chunkRepository = new ChunkRepository(db, sqlite);\n  const mentionRepository = new MentionRepository(db);\n\n  // Initialize pipeline\n  const pipeline = new IndexingPipeline({\n    nodeRepository,\n    edgeRepository,\n    versionRepository,\n  });\n\n  // Initialize graph engine\n  const graphEngine = new GraphEngine({\n    nodeRepository,\n    edgeRepository,\n  });\n\n  return {\n    vaultPath: resolvedPath,\n    config,\n    connectionManager,\n    nodeRepository,\n    edgeRepository,\n    versionRepository,\n    chunkRepository,\n    mentionRepository,\n    pipeline,\n    graphEngine,\n  };\n}\n\n/**\n * Format a duration in milliseconds\n */\nexport function formatDuration(ms: number): string {\n  if (ms < 1000) {\n    return `${ms}ms`;\n  }\n  if (ms < 60000) {\n    return `${(ms / 1000).toFixed(1)}s`;\n  }\n  const minutes = Math.floor(ms / 60000);\n  const seconds = ((ms % 60000) / 1000).toFixed(1);\n  return `${minutes}m ${seconds}s`;\n}\n\n/**\n * Format a file size\n */\nexport function formatSize(bytes: number): string {\n  if (bytes < 1024) {\n    return `${bytes}B`;\n  }\n  if (bytes < 1024 * 1024) {\n    return `${(bytes / 1024).toFixed(1)}KB`;\n  }\n  return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;\n}\n\n/**\n * Simple spinner for CLI feedback\n */\nexport class Spinner {\n  private frames = ['', '', '', '', '', '', '', '', '', ''];\n  private frameIndex = 0;\n  private interval: ReturnType<typeof setInterval> | null = null;\n  private message: string;\n\n  constructor(message: string) {\n    this.message = message;\n  }\n\n  start(): void {\n    this.interval = setInterval(() => {\n      const frame = this.frames[this.frameIndex];\n      process.stdout.write(`\\r${frame} ${this.message}`);\n      this.frameIndex = (this.frameIndex + 1) % this.frames.length;\n    }, 80);\n  }\n\n  update(message: string): void {\n    this.message = message;\n  }\n\n  stop(finalMessage?: string): void {\n    if (this.interval) {\n      clearInterval(this.interval);\n      this.interval = null;\n    }\n    process.stdout.write('\\r' + ' '.repeat(this.message.length + 10) + '\\r');\n    if (finalMessage) {\n      console.log(finalMessage);\n    }\n  }\n}\n\n/**\n * Print a table\n */\nexport function printTable(\n  headers: string[],\n  rows: string[][],\n  options: { padding?: number } = {}\n): void {\n  const { padding = 2 } = options;\n\n  // Calculate column widths\n  const widths = headers.map((h, i) => {\n    const values = [h, ...rows.map(r => r[i] || '')];\n    return Math.max(...values.map(v => v.length));\n  });\n\n  // Print header\n  const headerLine = headers\n    .map((h, i) => h.padEnd(widths[i] ?? 0))\n    .join(' '.repeat(padding));\n  console.log(headerLine);\n  console.log('-'.repeat(headerLine.length));\n\n  // Print rows\n  for (const row of rows) {\n    const line = row\n      .map((cell, i) => (cell || '').padEnd(widths[i] ?? 0))\n      .join(' '.repeat(padding));\n    console.log(line);\n  }\n}\n","import { eq, like, and, inArray, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { nodes, aliases, type NodeRow, type NewNodeRow } from '../schema.js';\nimport type { Node, NodeType } from '../../../core/types/index.js';\n\n/**\n * Repository for Node CRUD operations\n */\nexport class NodeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new node\n   */\n  async create(data: Omit<Node, 'nodeId'>): Promise<Node> {\n    const nodeId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewNodeRow = {\n      nodeId,\n      type: data.type,\n      title: data.title,\n      path: data.path,\n      createdAt: data.createdAt || now,\n      updatedAt: data.updatedAt || now,\n      contentHash: data.contentHash ?? null,\n      metadata: data.metadata ?? null,\n    };\n\n    await this.db.insert(nodes).values(row);\n\n    return this.rowToNode({ ...row, nodeId } as NodeRow);\n  }\n\n  /**\n   * Create or update a node by path\n   */\n  async upsert(data: Omit<Node, 'nodeId'> & { nodeId?: string }): Promise<Node> {\n    const now = new Date().toISOString();\n    const nodeId = data.nodeId || nanoid();\n\n    const existing = await this.findByPath(data.path);\n\n    if (existing) {\n      return this.update(existing.nodeId, {\n        ...data,\n        updatedAt: now,\n      });\n    }\n\n    const row: NewNodeRow = {\n      nodeId,\n      type: data.type,\n      title: data.title,\n      path: data.path,\n      createdAt: data.createdAt || now,\n      updatedAt: data.updatedAt || now,\n      contentHash: data.contentHash ?? null,\n      metadata: data.metadata ?? null,\n    };\n\n    await this.db.insert(nodes).values(row);\n\n    return this.rowToNode({ ...row, nodeId } as NodeRow);\n  }\n\n  /**\n   * Find a node by ID\n   */\n  async findById(nodeId: string): Promise<Node | null> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(eq(nodes.nodeId, nodeId))\n      .limit(1);\n\n    return result[0] ? this.rowToNode(result[0]) : null;\n  }\n\n  /**\n   * Find a node by path\n   */\n  async findByPath(path: string): Promise<Node | null> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(eq(nodes.path, path))\n      .limit(1);\n\n    return result[0] ? this.rowToNode(result[0]) : null;\n  }\n\n  /**\n   * Find a node by title (case-insensitive)\n   */\n  async findByTitle(title: string): Promise<Node[]> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(sql`${nodes.title} COLLATE NOCASE = ${title}`);\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Find a node by title or alias\n   */\n  async findByTitleOrAlias(text: string): Promise<Node[]> {\n    // First check exact title match\n    const titleMatches = await this.db\n      .select()\n      .from(nodes)\n      .where(sql`${nodes.title} COLLATE NOCASE = ${text}`);\n\n    // Then check aliases\n    const aliasMatches = await this.db\n      .select({ node: nodes })\n      .from(aliases)\n      .innerJoin(nodes, eq(aliases.nodeId, nodes.nodeId))\n      .where(sql`${aliases.alias} COLLATE NOCASE = ${text}`);\n\n    // Combine and deduplicate\n    const nodeMap = new Map<string, NodeRow>();\n    for (const row of titleMatches) {\n      nodeMap.set(row.nodeId, row);\n    }\n    for (const { node } of aliasMatches) {\n      nodeMap.set(node.nodeId, node);\n    }\n\n    return Array.from(nodeMap.values()).map(this.rowToNode);\n  }\n\n  /**\n   * Find nodes by type\n   */\n  async findByType(type: NodeType): Promise<Node[]> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(eq(nodes.type, type));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Get all nodes\n   */\n  async findAll(): Promise<Node[]> {\n    const result = await this.db.select().from(nodes);\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Find nodes by IDs\n   */\n  async findByIds(nodeIds: string[]): Promise<Node[]> {\n    if (nodeIds.length === 0) return [];\n\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(inArray(nodes.nodeId, nodeIds));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Search nodes by title pattern\n   */\n  async searchByTitle(pattern: string): Promise<Node[]> {\n    const result = await this.db\n      .select()\n      .from(nodes)\n      .where(like(nodes.title, `%${pattern}%`));\n\n    return result.map(this.rowToNode);\n  }\n\n  /**\n   * Update a node\n   */\n  async update(nodeId: string, data: Partial<Omit<Node, 'nodeId'>>): Promise<Node> {\n    const updateData: Partial<NodeRow> = {};\n\n    if (data.type !== undefined) updateData.type = data.type;\n    if (data.title !== undefined) updateData.title = data.title;\n    if (data.path !== undefined) updateData.path = data.path;\n    if (data.contentHash !== undefined) updateData.contentHash = data.contentHash;\n    if (data.metadata !== undefined) updateData.metadata = data.metadata;\n    updateData.updatedAt = data.updatedAt || new Date().toISOString();\n\n    await this.db\n      .update(nodes)\n      .set(updateData)\n      .where(eq(nodes.nodeId, nodeId));\n\n    const updated = await this.findById(nodeId);\n    if (!updated) {\n      throw new Error(`Node ${nodeId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a node\n   */\n  async delete(nodeId: string): Promise<void> {\n    await this.db.delete(nodes).where(eq(nodes.nodeId, nodeId));\n  }\n\n  /**\n   * Delete nodes by path pattern\n   */\n  async deleteByPathPattern(pattern: string): Promise<number> {\n    const result = await this.db\n      .delete(nodes)\n      .where(like(nodes.path, pattern));\n\n    return result.changes;\n  }\n\n  /**\n   * Count nodes\n   */\n  async count(): Promise<number> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(nodes);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count nodes by type\n   */\n  async countByType(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        type: nodes.type,\n        count: sql<number>`count(*)`,\n      })\n      .from(nodes)\n      .groupBy(nodes.type);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      counts[row.type] = row.count;\n    }\n    return counts;\n  }\n\n  /**\n   * Add an alias for a node\n   */\n  async addAlias(nodeId: string, alias: string): Promise<void> {\n    await this.db.insert(aliases).values({\n      aliasId: nanoid(),\n      nodeId,\n      alias,\n    });\n  }\n\n  /**\n   * Remove an alias\n   */\n  async removeAlias(nodeId: string, alias: string): Promise<void> {\n    await this.db\n      .delete(aliases)\n      .where(and(\n        eq(aliases.nodeId, nodeId),\n        sql`${aliases.alias} COLLATE NOCASE = ${alias}`\n      ));\n  }\n\n  /**\n   * Get aliases for a node\n   */\n  async getAliases(nodeId: string): Promise<string[]> {\n    const result = await this.db\n      .select({ alias: aliases.alias })\n      .from(aliases)\n      .where(eq(aliases.nodeId, nodeId));\n\n    return result.map(r => r.alias);\n  }\n\n  /**\n   * Set aliases for a node (replaces existing)\n   */\n  async setAliases(nodeId: string, newAliases: string[]): Promise<void> {\n    // Delete existing aliases\n    await this.db.delete(aliases).where(eq(aliases.nodeId, nodeId));\n\n    // Insert new aliases\n    if (newAliases.length > 0) {\n      await this.db.insert(aliases).values(\n        newAliases.map(alias => ({\n          aliasId: nanoid(),\n          nodeId,\n          alias,\n        }))\n      );\n    }\n  }\n\n  /**\n   * Convert database row to Node type\n   */\n  private rowToNode(row: NodeRow): Node {\n    return {\n      nodeId: row.nodeId,\n      type: row.type as NodeType,\n      title: row.title,\n      path: row.path,\n      createdAt: row.createdAt,\n      updatedAt: row.updatedAt,\n      ...(row.contentHash != null && { contentHash: row.contentHash }),\n      ...(row.metadata != null && { metadata: row.metadata as Record<string, unknown> }),\n    };\n  }\n}\n","import { eq, and, or, inArray, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { edges, nodes, type EdgeRow, type NewEdgeRow } from '../schema.js';\nimport type { Edge, EdgeType, EdgeProvenance } from '../../../core/types/index.js';\n\n/**\n * Repository for Edge CRUD operations\n */\nexport class EdgeRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new edge\n   */\n  async create(data: Omit<Edge, 'edgeId' | 'createdAt'>): Promise<Edge> {\n    const edgeId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewEdgeRow = {\n      edgeId,\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      edgeType: data.edgeType,\n      strength: data.strength ?? null,\n      provenance: data.provenance,\n      createdAt: now,\n      versionStart: data.versionStart ?? null,\n      versionEnd: data.versionEnd ?? null,\n      attributes: data.attributes ?? null,\n    };\n\n    await this.db.insert(edges).values(row);\n\n    return this.rowToEdge({ ...row, edgeId, createdAt: now } as EdgeRow);\n  }\n\n  /**\n   * Create or update an edge\n   */\n  async upsert(data: Omit<Edge, 'edgeId' | 'createdAt'>): Promise<Edge> {\n    // Check for existing edge with same source, target, and type\n    const existing = await this.findBySourceTargetType(\n      data.sourceId,\n      data.targetId,\n      data.edgeType\n    );\n\n    if (existing) {\n      return this.update(existing.edgeId, data);\n    }\n\n    return this.create(data);\n  }\n\n  /**\n   * Find an edge by ID\n   */\n  async findById(edgeId: string): Promise<Edge | null> {\n    const result = await this.db\n      .select()\n      .from(edges)\n      .where(eq(edges.edgeId, edgeId))\n      .limit(1);\n\n    return result[0] ? this.rowToEdge(result[0]) : null;\n  }\n\n  /**\n   * Find edge by source, target, and type\n   */\n  async findBySourceTargetType(\n    sourceId: string,\n    targetId: string,\n    edgeType: EdgeType\n  ): Promise<Edge | null> {\n    const result = await this.db\n      .select()\n      .from(edges)\n      .where(and(\n        eq(edges.sourceId, sourceId),\n        eq(edges.targetId, targetId),\n        eq(edges.edgeType, edgeType)\n      ))\n      .limit(1);\n\n    return result[0] ? this.rowToEdge(result[0]) : null;\n  }\n\n  /**\n   * Find all outgoing edges from a node\n   */\n  async findOutgoing(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    let query = this.db\n      .select()\n      .from(edges)\n      .where(eq(edges.sourceId, nodeId));\n\n    if (edgeTypes && edgeTypes.length > 0) {\n      query = this.db\n        .select()\n        .from(edges)\n        .where(and(\n          eq(edges.sourceId, nodeId),\n          inArray(edges.edgeType, edgeTypes)\n        ));\n    }\n\n    const result = await query;\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find all incoming edges to a node\n   */\n  async findIncoming(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    let query = this.db\n      .select()\n      .from(edges)\n      .where(eq(edges.targetId, nodeId));\n\n    if (edgeTypes && edgeTypes.length > 0) {\n      query = this.db\n        .select()\n        .from(edges)\n        .where(and(\n          eq(edges.targetId, nodeId),\n          inArray(edges.edgeType, edgeTypes)\n        ));\n    }\n\n    const result = await query;\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find all edges connected to a node (both directions)\n   */\n  async findConnected(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    const condition = or(\n      eq(edges.sourceId, nodeId),\n      eq(edges.targetId, nodeId)\n    );\n\n    let result;\n    if (edgeTypes && edgeTypes.length > 0) {\n      result = await this.db\n        .select()\n        .from(edges)\n        .where(and(condition, inArray(edges.edgeType, edgeTypes)));\n    } else {\n      result = await this.db.select().from(edges).where(condition);\n    }\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find edges by type\n   */\n  async findByType(edgeType: EdgeType): Promise<Edge[]> {\n    const result = await this.db\n      .select()\n      .from(edges)\n      .where(eq(edges.edgeType, edgeType));\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Get all edges\n   */\n  async findAll(): Promise<Edge[]> {\n    const result = await this.db.select().from(edges);\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Find backlinks (explicit_link edges targeting a node)\n   */\n  async findBacklinks(nodeId: string): Promise<Edge[]> {\n    const result = await this.db\n      .select()\n      .from(edges)\n      .where(and(\n        eq(edges.targetId, nodeId),\n        eq(edges.edgeType, 'explicit_link')\n      ));\n\n    return result.map(this.rowToEdge);\n  }\n\n  /**\n   * Update an edge\n   */\n  async update(edgeId: string, data: Partial<Omit<Edge, 'edgeId' | 'createdAt'>>): Promise<Edge> {\n    const updateData: Partial<EdgeRow> = {};\n\n    if (data.sourceId !== undefined) updateData.sourceId = data.sourceId;\n    if (data.targetId !== undefined) updateData.targetId = data.targetId;\n    if (data.edgeType !== undefined) updateData.edgeType = data.edgeType;\n    if (data.strength !== undefined) updateData.strength = data.strength;\n    if (data.provenance !== undefined) updateData.provenance = data.provenance;\n    if (data.versionStart !== undefined) updateData.versionStart = data.versionStart;\n    if (data.versionEnd !== undefined) updateData.versionEnd = data.versionEnd;\n    if (data.attributes !== undefined) updateData.attributes = data.attributes;\n\n    await this.db\n      .update(edges)\n      .set(updateData)\n      .where(eq(edges.edgeId, edgeId));\n\n    const updated = await this.findById(edgeId);\n    if (!updated) {\n      throw new Error(`Edge ${edgeId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete an edge\n   */\n  async delete(edgeId: string): Promise<void> {\n    await this.db.delete(edges).where(eq(edges.edgeId, edgeId));\n  }\n\n  /**\n   * Delete all edges for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(edges)\n      .where(or(\n        eq(edges.sourceId, nodeId),\n        eq(edges.targetId, nodeId)\n      ));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete edges by source and type\n   */\n  async deleteBySourceAndType(sourceId: string, edgeType: EdgeType): Promise<number> {\n    const result = await this.db\n      .delete(edges)\n      .where(and(\n        eq(edges.sourceId, sourceId),\n        eq(edges.edgeType, edgeType)\n      ));\n\n    return result.changes;\n  }\n\n  /**\n   * Count edges\n   */\n  async count(): Promise<number> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(edges);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count edges by type\n   */\n  async countByType(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        type: edges.edgeType,\n        count: sql<number>`count(*)`,\n      })\n      .from(edges)\n      .groupBy(edges.edgeType);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      counts[row.type] = row.count;\n    }\n    return counts;\n  }\n\n  /**\n   * Find neighbors with node info\n   */\n  async findNeighborsWithNodes(nodeId: string, edgeTypes?: EdgeType[]): Promise<Array<{\n    edge: Edge;\n    node: { nodeId: string; title: string; type: string; path: string };\n    direction: 'incoming' | 'outgoing';\n  }>> {\n    const outgoing = await this.findOutgoing(nodeId, edgeTypes);\n    const incoming = await this.findIncoming(nodeId, edgeTypes);\n\n    const results: Array<{\n      edge: Edge;\n      node: { nodeId: string; title: string; type: string; path: string };\n      direction: 'incoming' | 'outgoing';\n    }> = [];\n\n    // Get target nodes for outgoing edges\n    if (outgoing.length > 0) {\n      const targetIds = outgoing.map(e => e.targetId);\n      const targetNodes = await this.db\n        .select({\n          nodeId: nodes.nodeId,\n          title: nodes.title,\n          type: nodes.type,\n          path: nodes.path,\n        })\n        .from(nodes)\n        .where(inArray(nodes.nodeId, targetIds));\n\n      const nodeMap = new Map(targetNodes.map(n => [n.nodeId, n]));\n\n      for (const edge of outgoing) {\n        const node = nodeMap.get(edge.targetId);\n        if (node) {\n          results.push({ edge, node, direction: 'outgoing' });\n        }\n      }\n    }\n\n    // Get source nodes for incoming edges\n    if (incoming.length > 0) {\n      const sourceIds = incoming.map(e => e.sourceId);\n      const sourceNodes = await this.db\n        .select({\n          nodeId: nodes.nodeId,\n          title: nodes.title,\n          type: nodes.type,\n          path: nodes.path,\n        })\n        .from(nodes)\n        .where(inArray(nodes.nodeId, sourceIds));\n\n      const nodeMap = new Map(sourceNodes.map(n => [n.nodeId, n]));\n\n      for (const edge of incoming) {\n        const node = nodeMap.get(edge.sourceId);\n        if (node) {\n          results.push({ edge, node, direction: 'incoming' });\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Convert database row to Edge type\n   */\n  private rowToEdge(row: EdgeRow): Edge {\n    return {\n      edgeId: row.edgeId,\n      sourceId: row.sourceId,\n      targetId: row.targetId,\n      edgeType: row.edgeType as EdgeType,\n      provenance: row.provenance as EdgeProvenance,\n      createdAt: row.createdAt,\n      ...(row.strength != null && { strength: row.strength }),\n      ...(row.versionStart != null && { versionStart: row.versionStart }),\n      ...(row.versionEnd != null && { versionEnd: row.versionEnd }),\n      ...(row.attributes != null && { attributes: row.attributes as Record<string, unknown> }),\n    };\n  }\n}\n","import { eq, and, sql, desc } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { versions, type VersionRow, type NewVersionRow } from '../schema.js';\nimport type { Version } from '../../../core/types/index.js';\n\n/**\n * Repository for Version CRUD operations\n */\nexport class VersionRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new version\n   */\n  async create(data: Omit<Version, 'versionId' | 'createdAt'>): Promise<Version> {\n    const versionId = nanoid();\n    const now = new Date().toISOString();\n\n    const row: NewVersionRow = {\n      versionId,\n      nodeId: data.nodeId,\n      contentHash: data.contentHash,\n      parentVersionId: data.parentVersionId ?? null,\n      createdAt: now,\n      summary: data.summary ?? null,\n    };\n\n    await this.db.insert(versions).values(row);\n\n    return this.rowToVersion({ ...row, versionId, createdAt: now } as VersionRow);\n  }\n\n  /**\n   * Find a version by ID\n   */\n  async findById(versionId: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.versionId, versionId))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Find all versions for a node\n   */\n  async findByNodeId(nodeId: string): Promise<Version[]> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.nodeId, nodeId))\n      .orderBy(desc(versions.createdAt));\n\n    return result.map(this.rowToVersion);\n  }\n\n  /**\n   * Find the latest version for a node\n   */\n  async findLatest(nodeId: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.nodeId, nodeId))\n      .orderBy(desc(versions.createdAt))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Find version by content hash\n   */\n  async findByContentHash(nodeId: string, contentHash: string): Promise<Version | null> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(and(\n        eq(versions.nodeId, nodeId),\n        eq(versions.contentHash, contentHash)\n      ))\n      .limit(1);\n\n    return result[0] ? this.rowToVersion(result[0]) : null;\n  }\n\n  /**\n   * Get version chain (all ancestors)\n   */\n  async getVersionChain(versionId: string): Promise<Version[]> {\n    const chain: Version[] = [];\n    let currentId: string | null = versionId;\n\n    while (currentId) {\n      const version = await this.findById(currentId);\n      if (!version) break;\n      chain.push(version);\n      currentId = version.parentVersionId ?? null;\n    }\n\n    return chain;\n  }\n\n  /**\n   * Get child versions\n   */\n  async findChildren(versionId: string): Promise<Version[]> {\n    const result = await this.db\n      .select()\n      .from(versions)\n      .where(eq(versions.parentVersionId, versionId));\n\n    return result.map(this.rowToVersion);\n  }\n\n  /**\n   * Update a version (mainly for summary)\n   */\n  async update(versionId: string, data: Pick<Version, 'summary'>): Promise<Version> {\n    await this.db\n      .update(versions)\n      .set({ summary: data.summary ?? null })\n      .where(eq(versions.versionId, versionId));\n\n    const updated = await this.findById(versionId);\n    if (!updated) {\n      throw new Error(`Version ${versionId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a version\n   */\n  async delete(versionId: string): Promise<void> {\n    await this.db.delete(versions).where(eq(versions.versionId, versionId));\n  }\n\n  /**\n   * Delete all versions for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(versions)\n      .where(eq(versions.nodeId, nodeId));\n\n    return result.changes;\n  }\n\n  /**\n   * Count versions\n   */\n  async count(): Promise<number> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(versions);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count versions per node\n   */\n  async countPerNode(): Promise<Map<string, number>> {\n    const result = await this.db\n      .select({\n        nodeId: versions.nodeId,\n        count: sql<number>`count(*)`,\n      })\n      .from(versions)\n      .groupBy(versions.nodeId);\n\n    return new Map(result.map(r => [r.nodeId, r.count]));\n  }\n\n  /**\n   * Convert database row to Version type\n   */\n  private rowToVersion(row: VersionRow): Version {\n    return {\n      versionId: row.versionId,\n      nodeId: row.nodeId,\n      contentHash: row.contentHash,\n      createdAt: row.createdAt,\n      ...(row.parentVersionId != null && { parentVersionId: row.parentVersionId }),\n      ...(row.summary != null && { summary: row.summary }),\n    };\n  }\n}\n","import { eq, sql, inArray } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport Database from 'better-sqlite3';\nimport { DrizzleDB } from '../connection.js';\nimport { chunks, type ChunkRow, type NewChunkRow } from '../schema.js';\nimport type { Chunk } from '../../../core/types/index.js';\n\n/**\n * Repository for Chunk CRUD operations including FTS5 queries\n */\nexport class ChunkRepository {\n  constructor(\n    private db: DrizzleDB,\n    private sqlite: Database.Database\n  ) {}\n\n  /**\n   * Create a new chunk\n   */\n  async create(data: Omit<Chunk, 'chunkId'>): Promise<Chunk> {\n    const chunkId = nanoid();\n\n    const row: NewChunkRow = {\n      chunkId,\n      nodeId: data.nodeId,\n      text: data.text,\n      offsetStart: data.offsetStart,\n      offsetEnd: data.offsetEnd,\n      versionId: data.versionId,\n      tokenCount: data.tokenCount ?? null,\n    };\n\n    await this.db.insert(chunks).values(row);\n\n    return this.rowToChunk({ ...row, chunkId } as ChunkRow);\n  }\n\n  /**\n   * Create multiple chunks\n   */\n  async createMany(dataArray: Array<Omit<Chunk, 'chunkId'>>): Promise<Chunk[]> {\n    if (dataArray.length === 0) return [];\n\n    const rows: NewChunkRow[] = dataArray.map(data => ({\n      chunkId: nanoid(),\n      nodeId: data.nodeId,\n      text: data.text,\n      offsetStart: data.offsetStart,\n      offsetEnd: data.offsetEnd,\n      versionId: data.versionId,\n      tokenCount: data.tokenCount ?? null,\n    }));\n\n    await this.db.insert(chunks).values(rows);\n\n    return rows.map(row => this.rowToChunk(row as ChunkRow));\n  }\n\n  /**\n   * Find a chunk by ID\n   */\n  async findById(chunkId: string): Promise<Chunk | null> {\n    const result = await this.db\n      .select()\n      .from(chunks)\n      .where(eq(chunks.chunkId, chunkId))\n      .limit(1);\n\n    return result[0] ? this.rowToChunk(result[0]) : null;\n  }\n\n  /**\n   * Find all chunks for a node\n   */\n  async findByNodeId(nodeId: string): Promise<Chunk[]> {\n    const result = await this.db\n      .select()\n      .from(chunks)\n      .where(eq(chunks.nodeId, nodeId))\n      .orderBy(chunks.offsetStart);\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Find chunks by version\n   */\n  async findByVersionId(versionId: string): Promise<Chunk[]> {\n    const result = await this.db\n      .select()\n      .from(chunks)\n      .where(eq(chunks.versionId, versionId))\n      .orderBy(chunks.offsetStart);\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Find chunks by IDs\n   */\n  async findByIds(chunkIds: string[]): Promise<Chunk[]> {\n    if (chunkIds.length === 0) return [];\n\n    const result = await this.db\n      .select()\n      .from(chunks)\n      .where(inArray(chunks.chunkId, chunkIds));\n\n    return result.map(this.rowToChunk);\n  }\n\n  /**\n   * Full-text search using FTS5\n   */\n  searchFullText(\n    query: string,\n    limit: number = 20\n  ): Array<{ chunkId: string; nodeId: string; text: string; rank: number }> {\n    // Escape special FTS5 characters\n    const escapedQuery = query\n      .replace(/['\"]/g, '')\n      .replace(/\\*/g, '')\n      .split(/\\s+/)\n      .filter(word => word.length > 0)\n      .join(' OR ');\n\n    if (!escapedQuery) return [];\n\n    const stmt = this.sqlite.prepare(`\n      SELECT\n        chunk_id as chunkId,\n        node_id as nodeId,\n        text,\n        rank\n      FROM chunks_fts\n      WHERE chunks_fts MATCH ?\n      ORDER BY rank\n      LIMIT ?\n    `);\n\n    return stmt.all(escapedQuery, limit) as Array<{\n      chunkId: string;\n      nodeId: string;\n      text: string;\n      rank: number;\n    }>;\n  }\n\n  /**\n   * Full-text search with BM25 ranking\n   */\n  searchBM25(\n    query: string,\n    limit: number = 20\n  ): Array<{ chunkId: string; nodeId: string; text: string; score: number }> {\n    const escapedQuery = query\n      .replace(/['\"]/g, '')\n      .replace(/\\*/g, '')\n      .split(/\\s+/)\n      .filter(word => word.length > 0)\n      .join(' OR ');\n\n    if (!escapedQuery) return [];\n\n    const stmt = this.sqlite.prepare(`\n      SELECT\n        chunk_id as chunkId,\n        node_id as nodeId,\n        text,\n        bm25(chunks_fts) as score\n      FROM chunks_fts\n      WHERE chunks_fts MATCH ?\n      ORDER BY bm25(chunks_fts)\n      LIMIT ?\n    `);\n\n    return stmt.all(escapedQuery, limit) as Array<{\n      chunkId: string;\n      nodeId: string;\n      text: string;\n      score: number;\n    }>;\n  }\n\n  /**\n   * Update a chunk\n   */\n  async update(chunkId: string, data: Partial<Omit<Chunk, 'chunkId'>>): Promise<Chunk> {\n    const updateData: Partial<ChunkRow> = {};\n\n    if (data.nodeId !== undefined) updateData.nodeId = data.nodeId;\n    if (data.text !== undefined) updateData.text = data.text;\n    if (data.offsetStart !== undefined) updateData.offsetStart = data.offsetStart;\n    if (data.offsetEnd !== undefined) updateData.offsetEnd = data.offsetEnd;\n    if (data.versionId !== undefined) updateData.versionId = data.versionId;\n    if (data.tokenCount !== undefined) updateData.tokenCount = data.tokenCount;\n\n    await this.db\n      .update(chunks)\n      .set(updateData)\n      .where(eq(chunks.chunkId, chunkId));\n\n    const updated = await this.findById(chunkId);\n    if (!updated) {\n      throw new Error(`Chunk ${chunkId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a chunk\n   */\n  async delete(chunkId: string): Promise<void> {\n    await this.db.delete(chunks).where(eq(chunks.chunkId, chunkId));\n  }\n\n  /**\n   * Delete all chunks for a node\n   */\n  async deleteForNode(nodeId: string): Promise<number> {\n    const result = await this.db\n      .delete(chunks)\n      .where(eq(chunks.nodeId, nodeId));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete chunks by version\n   */\n  async deleteByVersion(versionId: string): Promise<number> {\n    const result = await this.db\n      .delete(chunks)\n      .where(eq(chunks.versionId, versionId));\n\n    return result.changes;\n  }\n\n  /**\n   * Count chunks\n   */\n  async count(): Promise<number> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(chunks);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Get total token count\n   */\n  async getTotalTokens(): Promise<number> {\n    const result = await this.db\n      .select({ total: sql<number>`COALESCE(SUM(token_count), 0)` })\n      .from(chunks);\n\n    return result[0]?.total ?? 0;\n  }\n\n  /**\n   * Convert database row to Chunk type\n   */\n  private rowToChunk(row: ChunkRow): Chunk {\n    return {\n      chunkId: row.chunkId,\n      nodeId: row.nodeId,\n      text: row.text,\n      offsetStart: row.offsetStart,\n      offsetEnd: row.offsetEnd,\n      versionId: row.versionId,\n      ...(row.tokenCount != null && { tokenCount: row.tokenCount }),\n    };\n  }\n}\n","import { eq, and, sql } from 'drizzle-orm';\nimport { nanoid } from 'nanoid';\nimport { DrizzleDB } from '../connection.js';\nimport { mentionCandidates, type MentionCandidateRow, type NewMentionCandidateRow } from '../schema.js';\nimport type { MentionCandidate, MentionStatus } from '../../../core/types/index.js';\n\n/**\n * Repository for MentionCandidate CRUD operations\n */\nexport class MentionRepository {\n  constructor(private db: DrizzleDB) {}\n\n  /**\n   * Create a new mention candidate\n   */\n  async create(data: Omit<MentionCandidate, 'candidateId'>): Promise<MentionCandidate> {\n    const candidateId = nanoid();\n\n    const row: NewMentionCandidateRow = {\n      candidateId,\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      surfaceText: data.surfaceText,\n      spanStart: data.spanStart ?? null,\n      spanEnd: data.spanEnd ?? null,\n      confidence: data.confidence,\n      reasons: data.reasons ?? null,\n      status: data.status,\n    };\n\n    await this.db.insert(mentionCandidates).values(row);\n\n    return this.rowToMention({ ...row, candidateId } as MentionCandidateRow);\n  }\n\n  /**\n   * Create multiple mention candidates\n   */\n  async createMany(dataArray: Array<Omit<MentionCandidate, 'candidateId'>>): Promise<MentionCandidate[]> {\n    if (dataArray.length === 0) return [];\n\n    const rows: NewMentionCandidateRow[] = dataArray.map(data => ({\n      candidateId: nanoid(),\n      sourceId: data.sourceId,\n      targetId: data.targetId,\n      surfaceText: data.surfaceText,\n      spanStart: data.spanStart ?? null,\n      spanEnd: data.spanEnd ?? null,\n      confidence: data.confidence,\n      reasons: data.reasons ?? null,\n      status: data.status,\n    }));\n\n    await this.db.insert(mentionCandidates).values(rows);\n\n    return rows.map(row => this.rowToMention(row as MentionCandidateRow));\n  }\n\n  /**\n   * Find a mention by ID\n   */\n  async findById(candidateId: string): Promise<MentionCandidate | null> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.candidateId, candidateId))\n      .limit(1);\n\n    return result[0] ? this.rowToMention(result[0]) : null;\n  }\n\n  /**\n   * Find mentions by source node\n   */\n  async findBySourceId(sourceId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.sourceId, sourceId));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find mentions by target node\n   */\n  async findByTargetId(targetId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.targetId, targetId));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find mentions by status\n   */\n  async findByStatus(status: MentionStatus): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.status, status));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Find new (pending review) mentions for a source\n   */\n  async findNewForSource(sourceId: string): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(and(\n        eq(mentionCandidates.sourceId, sourceId),\n        eq(mentionCandidates.status, 'new')\n      ));\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Check if a mention already exists\n   */\n  async exists(sourceId: string, targetId: string, spanStart: number, spanEnd: number): Promise<boolean> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(mentionCandidates)\n      .where(and(\n        eq(mentionCandidates.sourceId, sourceId),\n        eq(mentionCandidates.targetId, targetId),\n        eq(mentionCandidates.spanStart, spanStart),\n        eq(mentionCandidates.spanEnd, spanEnd)\n      ));\n\n    return (result[0]?.count ?? 0) > 0;\n  }\n\n  /**\n   * Update mention status\n   */\n  async updateStatus(candidateId: string, status: MentionStatus): Promise<MentionCandidate> {\n    await this.db\n      .update(mentionCandidates)\n      .set({ status })\n      .where(eq(mentionCandidates.candidateId, candidateId));\n\n    const updated = await this.findById(candidateId);\n    if (!updated) {\n      throw new Error(`Mention ${candidateId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Approve a mention (converts to edge)\n   */\n  async approve(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'approved');\n  }\n\n  /**\n   * Reject a mention\n   */\n  async reject(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'rejected');\n  }\n\n  /**\n   * Defer a mention for later review\n   */\n  async defer(candidateId: string): Promise<MentionCandidate> {\n    return this.updateStatus(candidateId, 'deferred');\n  }\n\n  /**\n   * Update confidence score\n   */\n  async updateConfidence(candidateId: string, confidence: number): Promise<MentionCandidate> {\n    await this.db\n      .update(mentionCandidates)\n      .set({ confidence })\n      .where(eq(mentionCandidates.candidateId, candidateId));\n\n    const updated = await this.findById(candidateId);\n    if (!updated) {\n      throw new Error(`Mention ${candidateId} not found after update`);\n    }\n    return updated;\n  }\n\n  /**\n   * Delete a mention\n   */\n  async delete(candidateId: string): Promise<void> {\n    await this.db\n      .delete(mentionCandidates)\n      .where(eq(mentionCandidates.candidateId, candidateId));\n  }\n\n  /**\n   * Delete all mentions for a source\n   */\n  async deleteForSource(sourceId: string): Promise<number> {\n    const result = await this.db\n      .delete(mentionCandidates)\n      .where(eq(mentionCandidates.sourceId, sourceId));\n\n    return result.changes;\n  }\n\n  /**\n   * Delete rejected mentions\n   */\n  async deleteRejected(): Promise<number> {\n    const result = await this.db\n      .delete(mentionCandidates)\n      .where(eq(mentionCandidates.status, 'rejected'));\n\n    return result.changes;\n  }\n\n  /**\n   * Count mentions\n   */\n  async count(): Promise<number> {\n    const result = await this.db\n      .select({ count: sql<number>`count(*)` })\n      .from(mentionCandidates);\n\n    return result[0]?.count ?? 0;\n  }\n\n  /**\n   * Count mentions by status\n   */\n  async countByStatus(): Promise<Record<string, number>> {\n    const result = await this.db\n      .select({\n        status: mentionCandidates.status,\n        count: sql<number>`count(*)`,\n      })\n      .from(mentionCandidates)\n      .groupBy(mentionCandidates.status);\n\n    const counts: Record<string, number> = {};\n    for (const row of result) {\n      if (row.status) {\n        counts[row.status] = row.count;\n      }\n    }\n    return counts;\n  }\n\n  /**\n   * Get top mentions by confidence\n   */\n  async getTopByConfidence(limit: number = 10): Promise<MentionCandidate[]> {\n    const result = await this.db\n      .select()\n      .from(mentionCandidates)\n      .where(eq(mentionCandidates.status, 'new'))\n      .orderBy(sql`${mentionCandidates.confidence} DESC`)\n      .limit(limit);\n\n    return result.map(this.rowToMention);\n  }\n\n  /**\n   * Convert database row to MentionCandidate type\n   */\n  private rowToMention(row: MentionCandidateRow): MentionCandidate {\n    return {\n      candidateId: row.candidateId,\n      sourceId: row.sourceId,\n      targetId: row.targetId,\n      surfaceText: row.surfaceText,\n      confidence: row.confidence,\n      status: (row.status ?? 'new') as MentionStatus,\n      ...(row.spanStart != null && { spanStart: row.spanStart }),\n      ...(row.spanEnd != null && { spanEnd: row.spanEnd }),\n      ...(row.reasons != null && { reasons: row.reasons as string[] }),\n    };\n  }\n}\n","import { unified } from 'unified';\nimport remarkParse from 'remark-parse';\nimport remarkFrontmatter from 'remark-frontmatter';\nimport remarkStringify from 'remark-stringify';\nimport type { Root, Content, Heading, Paragraph, Text } from 'mdast';\nimport type { WikiLink, Frontmatter, NodeType } from '../core/types/index.js';\nimport { parseFrontmatter, extractTitle, extractNodeType, extractAliases } from './frontmatter.js';\nimport { extractWikilinks, type WikiLinkParseResult } from './wikilink.js';\nimport type { ExclusionZone } from './exclusions.js';\n\nexport interface ParsedMarkdown {\n  frontmatter: Frontmatter | null;\n  title: string;\n  type: NodeType;\n  aliases: string[];\n  content: string;\n  contentStartOffset: number;\n  links: WikiLink[];\n  exclusionZones: ExclusionZone[];\n  headings: Array<{\n    level: number;\n    text: string;\n    position: { start: number; end: number };\n  }>;\n  paragraphs: Array<{\n    text: string;\n    position: { start: number; end: number };\n  }>;\n  ast: Root;\n}\n\n/**\n * Create the unified markdown processor\n */\nfunction createProcessor() {\n  return unified()\n    .use(remarkParse)\n    .use(remarkFrontmatter, ['yaml'])\n    .use(remarkStringify);\n}\n\n/**\n * Parse a markdown document into structured data\n */\nexport function parseMarkdown(\n  source: string,\n  filePath: string\n): ParsedMarkdown {\n  // Parse frontmatter first\n  const { frontmatter, content, contentStartOffset } = parseFrontmatter(source, filePath);\n\n  // Extract title, type, and aliases from frontmatter\n  const title = extractTitle(frontmatter, content, filePath);\n  const type = extractNodeType(frontmatter) as NodeType;\n  const aliases = extractAliases(frontmatter);\n\n  // Extract wikilinks\n  const linkResult: WikiLinkParseResult = extractWikilinks(content, contentStartOffset);\n\n  // Parse AST\n  const processor = createProcessor();\n  const ast = processor.parse(source) as Root;\n\n  // Extract headings and paragraphs\n  const headings: ParsedMarkdown['headings'] = [];\n  const paragraphs: ParsedMarkdown['paragraphs'] = [];\n\n  function visitNode(node: Content) {\n    if (node.type === 'heading' && node.position) {\n      const heading = node as Heading;\n      const text = getTextContent(heading);\n      headings.push({\n        level: heading.depth,\n        text,\n        position: {\n          start: node.position.start.offset ?? 0,\n          end: node.position.end.offset ?? 0,\n        },\n      });\n    }\n\n    if (node.type === 'paragraph' && node.position) {\n      const paragraph = node as Paragraph;\n      const text = getTextContent(paragraph);\n      paragraphs.push({\n        text,\n        position: {\n          start: node.position.start.offset ?? 0,\n          end: node.position.end.offset ?? 0,\n        },\n      });\n    }\n\n    // Recurse into children\n    if ('children' in node && Array.isArray(node.children)) {\n      for (const child of node.children) {\n        visitNode(child as Content);\n      }\n    }\n  }\n\n  for (const node of ast.children) {\n    visitNode(node);\n  }\n\n  return {\n    frontmatter,\n    title,\n    type,\n    aliases,\n    content,\n    contentStartOffset,\n    links: linkResult.links,\n    exclusionZones: linkResult.exclusionZones,\n    headings,\n    paragraphs,\n    ast,\n  };\n}\n\n/**\n * Get text content from an AST node\n */\nfunction getTextContent(node: Content): string {\n  if (node.type === 'text') {\n    return (node as Text).value;\n  }\n\n  if ('children' in node && Array.isArray(node.children)) {\n    return node.children.map(child => getTextContent(child as Content)).join('');\n  }\n\n  return '';\n}\n\n/**\n * Extract plain text from markdown (strips formatting)\n */\nexport function extractPlainText(source: string): string {\n  const processor = createProcessor();\n  const ast = processor.parse(source) as Root;\n\n  function getText(node: Content): string {\n    if (node.type === 'text') {\n      return (node as Text).value;\n    }\n\n    if (node.type === 'code') {\n      return ''; // Skip code blocks\n    }\n\n    if (node.type === 'yaml') {\n      return ''; // Skip frontmatter\n    }\n\n    if ('children' in node && Array.isArray(node.children)) {\n      return node.children.map(child => getText(child as Content)).join(' ');\n    }\n\n    return '';\n  }\n\n  return ast.children\n    .map(node => getText(node))\n    .join('\\n')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n/**\n * Split content into sections based on headings\n */\nexport function splitIntoSections(parsed: ParsedMarkdown): Array<{\n  heading: string | null;\n  level: number;\n  content: string;\n  start: number;\n  end: number;\n}> {\n  const sections: Array<{\n    heading: string | null;\n    level: number;\n    content: string;\n    start: number;\n    end: number;\n  }> = [];\n\n  const source = parsed.content;\n\n  if (parsed.headings.length === 0) {\n    // No headings - entire content is one section\n    return [{\n      heading: null,\n      level: 0,\n      content: source,\n      start: parsed.contentStartOffset,\n      end: parsed.contentStartOffset + source.length,\n    }];\n  }\n\n  // Content before first heading\n  const firstHeading = parsed.headings[0];\n  if (firstHeading && firstHeading.position.start > parsed.contentStartOffset) {\n    const contentBefore = source.slice(0, firstHeading.position.start - parsed.contentStartOffset);\n    if (contentBefore.trim()) {\n      sections.push({\n        heading: null,\n        level: 0,\n        content: contentBefore,\n        start: parsed.contentStartOffset,\n        end: firstHeading.position.start,\n      });\n    }\n  }\n\n  // Process each heading and its content\n  for (let i = 0; i < parsed.headings.length; i++) {\n    const heading = parsed.headings[i];\n    const nextHeading = parsed.headings[i + 1];\n\n    if (!heading) continue;\n\n    const start = heading.position.end;\n    const end = nextHeading\n      ? nextHeading.position.start\n      : parsed.contentStartOffset + source.length;\n\n    const content = source.slice(\n      start - parsed.contentStartOffset,\n      end - parsed.contentStartOffset\n    );\n\n    sections.push({\n      heading: heading.text,\n      level: heading.level,\n      content: content.trim(),\n      start,\n      end,\n    });\n  }\n\n  return sections;\n}\n\n/**\n * Split content into paragraphs\n */\nexport function splitIntoParagraphs(content: string): Array<{\n  text: string;\n  start: number;\n  end: number;\n}> {\n  const paragraphs: Array<{ text: string; start: number; end: number }> = [];\n\n  // Split by blank lines\n  const regex = /(?:\\r?\\n){2,}/g;\n  let lastEnd = 0;\n  let match;\n\n  while ((match = regex.exec(content)) !== null) {\n    const text = content.slice(lastEnd, match.index).trim();\n    if (text) {\n      paragraphs.push({\n        text,\n        start: lastEnd,\n        end: match.index,\n      });\n    }\n    lastEnd = match.index + match[0].length;\n  }\n\n  // Last paragraph\n  const remaining = content.slice(lastEnd).trim();\n  if (remaining) {\n    paragraphs.push({\n      text: remaining,\n      start: lastEnd,\n      end: content.length,\n    });\n  }\n\n  return paragraphs;\n}\n\n/**\n * Stringify markdown AST back to text\n */\nexport function stringifyMarkdown(ast: Root): string {\n  const processor = createProcessor();\n  return processor.stringify(ast);\n}\n","import { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport type { Frontmatter } from '../core/types/index.js';\nimport { ParseError } from '../core/errors.js';\n\n// Frontmatter delimiter\nconst FRONTMATTER_REGEX = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---\\r?\\n?/;\n\nexport interface ParsedDocument {\n  frontmatter: Frontmatter | null;\n  content: string;\n  contentStartOffset: number;\n}\n\n/**\n * Parse frontmatter from a markdown document\n */\nexport function parseFrontmatter(\n  source: string,\n  filePath: string\n): ParsedDocument {\n  const match = source.match(FRONTMATTER_REGEX);\n\n  if (!match) {\n    return {\n      frontmatter: null,\n      content: source,\n      contentStartOffset: 0,\n    };\n  }\n\n  const yamlContent = match[1];\n  const fullMatch = match[0];\n\n  if (!yamlContent) {\n    return {\n      frontmatter: null,\n      content: source,\n      contentStartOffset: 0,\n    };\n  }\n\n  try {\n    const parsed = parseYaml(yamlContent) as Frontmatter | null;\n\n    return {\n      frontmatter: parsed ?? null,\n      content: source.slice(fullMatch.length),\n      contentStartOffset: fullMatch.length,\n    };\n  } catch (error) {\n    throw new ParseError(\n      `Invalid YAML frontmatter: ${error}`,\n      filePath,\n      undefined,\n      undefined,\n      { yaml: yamlContent }\n    );\n  }\n}\n\n/**\n * Extract title from frontmatter or first heading\n */\nexport function extractTitle(\n  frontmatter: Frontmatter | null,\n  content: string,\n  filePath: string\n): string {\n  // Priority 1: frontmatter title\n  if (frontmatter?.title) {\n    return frontmatter.title;\n  }\n\n  // Priority 2: first H1 heading\n  const h1Match = content.match(/^#\\s+(.+)$/m);\n  if (h1Match?.[1]) {\n    return h1Match[1].trim();\n  }\n\n  // Priority 3: filename without extension\n  const filename = filePath.split('/').pop() || filePath;\n  return filename.replace(/\\.md$/, '');\n}\n\n/**\n * Extract node type from frontmatter\n */\nexport function extractNodeType(\n  frontmatter: Frontmatter | null\n): string {\n  if (frontmatter?.type) {\n    return frontmatter.type;\n  }\n  return 'note';\n}\n\n/**\n * Extract aliases from frontmatter\n */\nexport function extractAliases(frontmatter: Frontmatter | null): string[] {\n  if (!frontmatter?.aliases) {\n    return [];\n  }\n\n  if (Array.isArray(frontmatter.aliases)) {\n    return frontmatter.aliases.filter(a => typeof a === 'string');\n  }\n\n  return [];\n}\n\n/**\n * Serialize frontmatter back to YAML string\n */\nexport function serializeFrontmatter(frontmatter: Frontmatter): string {\n  return `---\\n${stringifyYaml(frontmatter)}---\\n`;\n}\n\n/**\n * Update frontmatter in a document\n */\nexport function updateFrontmatter(\n  source: string,\n  updates: Partial<Frontmatter>,\n  filePath: string\n): string {\n  const { frontmatter, content } = parseFrontmatter(source, filePath);\n\n  const newFrontmatter: Frontmatter = {\n    ...frontmatter,\n    ...updates,\n  };\n\n  return serializeFrontmatter(newFrontmatter) + content;\n}\n\n/**\n * Validate frontmatter schema\n */\nexport function validateFrontmatter(frontmatter: Frontmatter): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Check type is valid if present\n  const validTypes = [\n    'note', 'scene', 'character', 'location', 'object',\n    'event', 'concept', 'moc', 'timeline', 'draft'\n  ];\n\n  if (frontmatter.type && !validTypes.includes(frontmatter.type)) {\n    errors.push(`Invalid type \"${frontmatter.type}\". Valid types: ${validTypes.join(', ')}`);\n  }\n\n  // Check aliases is an array if present\n  if (frontmatter.aliases !== undefined && !Array.isArray(frontmatter.aliases)) {\n    errors.push('aliases must be an array');\n  }\n\n  // Check tags is an array if present\n  if (frontmatter.tags !== undefined && !Array.isArray(frontmatter.tags)) {\n    errors.push('tags must be an array');\n  }\n\n  // Check scene_order is a number if present\n  if (frontmatter.scene_order !== undefined && typeof frontmatter.scene_order !== 'number') {\n    errors.push('scene_order must be a number');\n  }\n\n  // Check characters is an array if present\n  if (frontmatter.characters !== undefined && !Array.isArray(frontmatter.characters)) {\n    errors.push('characters must be an array');\n  }\n\n  // Check locations is an array if present\n  if (frontmatter.locations !== undefined && !Array.isArray(frontmatter.locations)) {\n    errors.push('locations must be an array');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Exclusion zones for wikilink detection.\n * These areas should not be scanned for wikilinks or unlinked mentions.\n */\n\nexport interface ExclusionZone {\n  start: number;\n  end: number;\n  type: 'code_block' | 'inline_code' | 'url' | 'existing_link' | 'frontmatter' | 'html_tag';\n}\n\n// Regex patterns for exclusion zones\nconst PATTERNS = {\n  // Fenced code blocks (``` or ~~~)\n  codeBlock: /```[\\s\\S]*?```|~~~[\\s\\S]*?~~~/g,\n\n  // Inline code\n  inlineCode: /`[^`\\n]+`/g,\n\n  // URLs (http, https, ftp)\n  url: /(?:https?|ftp):\\/\\/[^\\s<>[\\]()]+/g,\n\n  // Markdown links [text](url) and ![alt](url)\n  markdownLink: /!?\\[[^\\]]*\\]\\([^)]+\\)/g,\n\n  // Existing wikilinks [[...]]\n  wikilink: /\\[\\[[^\\]]+\\]\\]/g,\n\n  // HTML tags\n  htmlTag: /<[^>]+>/g,\n\n  // HTML comments\n  htmlComment: /<!--[\\s\\S]*?-->/g,\n\n  // LaTeX math blocks\n  mathBlock: /\\$\\$[\\s\\S]*?\\$\\$/g,\n\n  // Inline math\n  inlineMath: /\\$[^$\\n]+\\$/g,\n};\n\n/**\n * Find all exclusion zones in a document\n */\nexport function findExclusionZones(\n  content: string,\n  frontmatterOffset: number = 0\n): ExclusionZone[] {\n  const zones: ExclusionZone[] = [];\n\n  // Add frontmatter zone if present\n  if (frontmatterOffset > 0) {\n    zones.push({\n      start: 0,\n      end: frontmatterOffset,\n      type: 'frontmatter',\n    });\n  }\n\n  // Find code blocks first (they have priority)\n  for (const match of content.matchAll(PATTERNS.codeBlock)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'code_block',\n      });\n    }\n  }\n\n  // Find inline code\n  for (const match of content.matchAll(PATTERNS.inlineCode)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'inline_code',\n      });\n    }\n  }\n\n  // Find URLs\n  for (const match of content.matchAll(PATTERNS.url)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'url',\n      });\n    }\n  }\n\n  // Find existing wikilinks\n  for (const match of content.matchAll(PATTERNS.wikilink)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'existing_link',\n      });\n    }\n  }\n\n  // Find markdown links\n  for (const match of content.matchAll(PATTERNS.markdownLink)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'existing_link',\n      });\n    }\n  }\n\n  // Find HTML tags\n  for (const match of content.matchAll(PATTERNS.htmlTag)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'html_tag',\n      });\n    }\n  }\n\n  // Find HTML comments\n  for (const match of content.matchAll(PATTERNS.htmlComment)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'html_tag',\n      });\n    }\n  }\n\n  // Find math blocks (treat as code)\n  for (const match of content.matchAll(PATTERNS.mathBlock)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'code_block',\n      });\n    }\n  }\n\n  // Find inline math\n  for (const match of content.matchAll(PATTERNS.inlineMath)) {\n    if (match.index !== undefined) {\n      zones.push({\n        start: match.index + frontmatterOffset,\n        end: match.index + match[0].length + frontmatterOffset,\n        type: 'inline_code',\n      });\n    }\n  }\n\n  // Sort by start position and merge overlapping zones\n  return mergeZones(zones);\n}\n\n/**\n * Merge overlapping exclusion zones\n */\nfunction mergeZones(zones: ExclusionZone[]): ExclusionZone[] {\n  if (zones.length === 0) return [];\n\n  // Sort by start position\n  zones.sort((a, b) => a.start - b.start);\n\n  const merged: ExclusionZone[] = [];\n  let current = zones[0];\n\n  if (!current) return [];\n\n  for (let i = 1; i < zones.length; i++) {\n    const next = zones[i];\n    if (!next) continue;\n\n    if (next.start <= current.end) {\n      // Overlapping or adjacent - extend current zone\n      current = {\n        start: current.start,\n        end: Math.max(current.end, next.end),\n        type: current.type, // Keep the type of the first zone\n      };\n    } else {\n      // Non-overlapping - save current and start new\n      merged.push(current);\n      current = next;\n    }\n  }\n\n  merged.push(current);\n  return merged;\n}\n\n/**\n * Check if a position is within an exclusion zone\n */\nexport function isInExclusionZone(\n  position: number,\n  zones: ExclusionZone[]\n): boolean {\n  return zones.some(zone => position >= zone.start && position < zone.end);\n}\n\n/**\n * Check if a range overlaps with any exclusion zone\n */\nexport function overlapsExclusionZone(\n  start: number,\n  end: number,\n  zones: ExclusionZone[]\n): boolean {\n  return zones.some(zone => start < zone.end && end > zone.start);\n}\n\n/**\n * Filter out matches that overlap with exclusion zones\n */\nexport function filterExcludedMatches<T extends { start: number; end: number }>(\n  matches: T[],\n  zones: ExclusionZone[]\n): T[] {\n  return matches.filter(match => !overlapsExclusionZone(match.start, match.end, zones));\n}\n\n/**\n * Get content with exclusion zones replaced by spaces\n * (useful for text analysis that needs position preservation)\n */\nexport function maskExclusionZones(content: string, zones: ExclusionZone[]): string {\n  let masked = content;\n\n  // Process zones in reverse order to preserve positions\n  const sortedZones = [...zones].sort((a, b) => b.start - a.start);\n\n  for (const zone of sortedZones) {\n    const before = masked.slice(0, zone.start);\n    const after = masked.slice(zone.end);\n    const replacement = ' '.repeat(zone.end - zone.start);\n    masked = before + replacement + after;\n  }\n\n  return masked;\n}\n","import type { WikiLink } from '../core/types/index.js';\nimport { findExclusionZones, filterExcludedMatches, type ExclusionZone } from './exclusions.js';\n\n// Wikilink pattern: [[target]] or [[target|display]]\n// Also supports [[id:node-id]] for direct ID references\nconst WIKILINK_REGEX = /\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]/g;\n\n// ID prefix for direct node references\nconst ID_PREFIX = 'id:';\n\nexport interface WikiLinkParseResult {\n  links: WikiLink[];\n  exclusionZones: ExclusionZone[];\n}\n\n/**\n * Extract all wikilinks from content\n */\nexport function extractWikilinks(\n  content: string,\n  contentStartOffset: number = 0\n): WikiLinkParseResult {\n  const exclusionZones = findExclusionZones(content, contentStartOffset);\n  const rawLinks: WikiLink[] = [];\n\n  // Find all wikilinks\n  for (const match of content.matchAll(WIKILINK_REGEX)) {\n    if (match.index === undefined) continue;\n\n    const raw = match[0];\n    const targetPart = match[1]?.trim() ?? '';\n    const displayPart = match[2]?.trim();\n\n    // Check for id: prefix\n    const isIdLink = targetPart.startsWith(ID_PREFIX);\n    const target = isIdLink ? targetPart.slice(ID_PREFIX.length) : targetPart;\n\n    // Display text: explicit > target without id: prefix\n    const display = displayPart ?? target;\n\n    const start = match.index + contentStartOffset;\n    const end = start + raw.length;\n\n    rawLinks.push({\n      raw,\n      target,\n      display,\n      isIdLink,\n      start,\n      end,\n    });\n  }\n\n  // Filter out links that are inside exclusion zones\n  // (but keep the wikilinks themselves as valid - they create new exclusion zones)\n  const links = filterExcludedMatches(rawLinks, exclusionZones.filter(z => z.type !== 'existing_link'));\n\n  return { links, exclusionZones };\n}\n\n/**\n * Extract link targets only (simplified version)\n */\nexport function extractLinkTargets(content: string): string[] {\n  const { links } = extractWikilinks(content);\n  return links.map(link => link.target);\n}\n\n/**\n * Check if a string contains wikilinks\n */\nexport function hasWikilinks(content: string): boolean {\n  WIKILINK_REGEX.lastIndex = 0;\n  return WIKILINK_REGEX.test(content);\n}\n\n/**\n * Create a wikilink string\n */\nexport function createWikilink(\n  target: string,\n  display?: string,\n  useIdPrefix: boolean = false\n): string {\n  const targetPart = useIdPrefix ? `id:${target}` : target;\n\n  if (display && display !== target) {\n    return `[[${targetPart}|${display}]]`;\n  }\n\n  return `[[${targetPart}]]`;\n}\n\n/**\n * Replace text with a wikilink at a specific position\n */\nexport function insertWikilink(\n  content: string,\n  start: number,\n  end: number,\n  target: string,\n  display?: string\n): string {\n  const before = content.slice(0, start);\n  const after = content.slice(end);\n  const link = createWikilink(target, display);\n  return before + link + after;\n}\n\n/**\n * Get all unique link targets from content\n */\nexport function getUniqueTargets(content: string): Set<string> {\n  const { links } = extractWikilinks(content);\n  return new Set(links.map(link => link.target));\n}\n\n/**\n * Normalize a link target for comparison\n * - Trim whitespace\n * - Collapse multiple spaces\n * - Case-insensitive comparison done separately\n */\nexport function normalizeTarget(target: string): string {\n  return target\n    .trim()\n    .replace(/\\s+/g, ' ');\n}\n\n/**\n * Check if two link targets match (case-insensitive)\n */\nexport function targetsMatch(target1: string, target2: string): boolean {\n  return normalizeTarget(target1).toLowerCase() === normalizeTarget(target2).toLowerCase();\n}\n\n/**\n * Parse a wikilink string into components\n */\nexport function parseWikilinkString(wikilink: string): WikiLink | null {\n  const match = wikilink.match(/^\\[\\[([^\\]|]+)(?:\\|([^\\]]+))?\\]\\]$/);\n\n  if (!match) return null;\n\n  const targetPart = match[1]?.trim() ?? '';\n  const displayPart = match[2]?.trim();\n\n  const isIdLink = targetPart.startsWith(ID_PREFIX);\n  const target = isIdLink ? targetPart.slice(ID_PREFIX.length) : targetPart;\n  const display = displayPart ?? target;\n\n  return {\n    raw: wikilink,\n    target,\n    display,\n    isIdLink,\n    start: 0,\n    end: wikilink.length,\n  };\n}\n\n// Default context window size (can be overridden via config)\nconst DEFAULT_CONTEXT_CHARS = 50;\n\n/**\n * Get context around a wikilink (surrounding text)\n */\nexport function getWikilinkContext(\n  content: string,\n  link: WikiLink,\n  contextChars: number = DEFAULT_CONTEXT_CHARS\n): string {\n  const start = Math.max(0, link.start - contextChars);\n  const end = Math.min(content.length, link.end + contextChars);\n\n  let context = content.slice(start, end);\n\n  // Add ellipsis if truncated\n  if (start > 0) context = '...' + context;\n  if (end < content.length) context = context + '...';\n\n  return context;\n}\n","import type { WikiLink, ResolvedLink, Node } from '../core/types/index.js';\nimport { normalizeTarget, targetsMatch } from './wikilink.js';\n\nexport interface LinkResolverOptions {\n  /**\n   * Function to find nodes by title (case-insensitive)\n   */\n  findByTitle: (title: string) => Promise<Node[]>;\n\n  /**\n   * Function to find a node by ID\n   */\n  findById: (nodeId: string) => Promise<Node | null>;\n\n  /**\n   * Function to find nodes by title or alias\n   */\n  findByTitleOrAlias: (text: string) => Promise<Node[]>;\n}\n\nexport interface ResolutionResult {\n  resolved: ResolvedLink[];\n  unresolved: WikiLink[];\n  ambiguous: WikiLink[];\n}\n\n/**\n * Link resolver following the spec:\n * 1. If id: prefix  direct node_id lookup\n * 2. Else normalize text:\n *    a. Exact title match (case-insensitive)\n *    b. Alias match\n * 3. Multiple matches  ambiguous (prompt user)\n * 4. No matches  unresolved (record separately)\n */\nexport class LinkResolver {\n  private cache: Map<string, Node[]> = new Map();\n\n  constructor(private options: LinkResolverOptions) {}\n\n  /**\n   * Resolve a single wikilink\n   */\n  async resolveLink(link: WikiLink): Promise<ResolvedLink> {\n    // Case 1: Direct ID reference\n    if (link.isIdLink) {\n      const node = await this.options.findById(link.target);\n      return {\n        ...link,\n        resolvedNodeId: node?.nodeId ?? null,\n        ambiguous: false,\n        candidates: node ? [node.nodeId] : [],\n      };\n    }\n\n    // Case 2: Title/alias resolution\n    const normalizedTarget = normalizeTarget(link.target);\n\n    // Check cache first\n    let candidates = this.cache.get(normalizedTarget.toLowerCase());\n\n    if (!candidates) {\n      // Find by title or alias\n      candidates = await this.options.findByTitleOrAlias(normalizedTarget);\n      this.cache.set(normalizedTarget.toLowerCase(), candidates);\n    }\n\n    if (candidates.length === 0) {\n      // No matches - unresolved\n      return {\n        ...link,\n        resolvedNodeId: null,\n        ambiguous: false,\n        candidates: [],\n      };\n    }\n\n    if (candidates.length === 1) {\n      // Single match - resolved\n      return {\n        ...link,\n        resolvedNodeId: candidates[0]?.nodeId ?? null,\n        ambiguous: false,\n        candidates: [candidates[0]?.nodeId ?? ''],\n      };\n    }\n\n    // Multiple matches - ambiguous\n    // Try to disambiguate by exact title match\n    const exactMatch = candidates.find(c =>\n      targetsMatch(c.title, normalizedTarget)\n    );\n\n    if (exactMatch) {\n      return {\n        ...link,\n        resolvedNodeId: exactMatch.nodeId,\n        ambiguous: false,\n        candidates: candidates.map(c => c.nodeId),\n      };\n    }\n\n    // Still ambiguous\n    return {\n      ...link,\n      resolvedNodeId: null,\n      ambiguous: true,\n      candidates: candidates.map(c => c.nodeId),\n    };\n  }\n\n  /**\n   * Resolve multiple wikilinks\n   */\n  async resolveLinks(links: WikiLink[]): Promise<ResolutionResult> {\n    const resolved: ResolvedLink[] = [];\n    const unresolved: WikiLink[] = [];\n    const ambiguous: WikiLink[] = [];\n\n    for (const link of links) {\n      const result = await this.resolveLink(link);\n\n      if (result.ambiguous) {\n        ambiguous.push(link);\n      } else if (result.resolvedNodeId === null) {\n        unresolved.push(link);\n      }\n\n      resolved.push(result);\n    }\n\n    return { resolved, unresolved, ambiguous };\n  }\n\n  /**\n   * Clear the resolution cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; hits: number } {\n    return {\n      size: this.cache.size,\n      hits: 0, // Would need to track this separately\n    };\n  }\n}\n\n/**\n * Create a link resolver with repository functions\n */\nexport function createLinkResolver(\n  nodeRepository: {\n    findByTitle: (title: string) => Promise<Node[]>;\n    findById: (nodeId: string) => Promise<Node | null>;\n    findByTitleOrAlias: (text: string) => Promise<Node[]>;\n  }\n): LinkResolver {\n  return new LinkResolver({\n    findByTitle: nodeRepository.findByTitle.bind(nodeRepository),\n    findById: nodeRepository.findById.bind(nodeRepository),\n    findByTitleOrAlias: nodeRepository.findByTitleOrAlias.bind(nodeRepository),\n  });\n}\n\n/**\n * Simple in-memory resolver for testing or single-file parsing\n */\nexport class InMemoryLinkResolver {\n  private nodesByTitle: Map<string, Node[]> = new Map();\n  private nodesById: Map<string, Node> = new Map();\n  private nodesByAlias: Map<string, Node[]> = new Map();\n\n  /**\n   * Add a node to the resolver\n   */\n  addNode(node: Node, aliases: string[] = []): void {\n    this.nodesById.set(node.nodeId, node);\n\n    // Index by title\n    const titleLower = node.title.toLowerCase();\n    const titleNodes = this.nodesByTitle.get(titleLower) || [];\n    titleNodes.push(node);\n    this.nodesByTitle.set(titleLower, titleNodes);\n\n    // Index by aliases\n    for (const alias of aliases) {\n      const aliasLower = alias.toLowerCase();\n      const aliasNodes = this.nodesByAlias.get(aliasLower) || [];\n      aliasNodes.push(node);\n      this.nodesByAlias.set(aliasLower, aliasNodes);\n    }\n  }\n\n  /**\n   * Resolve a wikilink\n   */\n  resolveLink(link: WikiLink): ResolvedLink {\n    // Case 1: Direct ID reference\n    if (link.isIdLink) {\n      const node = this.nodesById.get(link.target);\n      return {\n        ...link,\n        resolvedNodeId: node?.nodeId ?? null,\n        ambiguous: false,\n        candidates: node ? [node.nodeId] : [],\n      };\n    }\n\n    // Case 2: Title/alias resolution\n    const normalized = normalizeTarget(link.target).toLowerCase();\n\n    // Find by title\n    const titleMatches = this.nodesByTitle.get(normalized) || [];\n\n    // Find by alias\n    const aliasMatches = this.nodesByAlias.get(normalized) || [];\n\n    // Combine and deduplicate\n    const candidateMap = new Map<string, Node>();\n    for (const node of [...titleMatches, ...aliasMatches]) {\n      candidateMap.set(node.nodeId, node);\n    }\n\n    const candidates = Array.from(candidateMap.values());\n\n    if (candidates.length === 0) {\n      return {\n        ...link,\n        resolvedNodeId: null,\n        ambiguous: false,\n        candidates: [],\n      };\n    }\n\n    if (candidates.length === 1) {\n      return {\n        ...link,\n        resolvedNodeId: candidates[0]?.nodeId ?? null,\n        ambiguous: false,\n        candidates: [candidates[0]?.nodeId ?? ''],\n      };\n    }\n\n    // Try exact title match for disambiguation\n    const exactMatch = candidates.find(c =>\n      targetsMatch(c.title, link.target)\n    );\n\n    if (exactMatch) {\n      return {\n        ...link,\n        resolvedNodeId: exactMatch.nodeId,\n        ambiguous: false,\n        candidates: candidates.map(c => c.nodeId),\n      };\n    }\n\n    return {\n      ...link,\n      resolvedNodeId: null,\n      ambiguous: true,\n      candidates: candidates.map(c => c.nodeId),\n    };\n  }\n\n  /**\n   * Clear all indexed nodes\n   */\n  clear(): void {\n    this.nodesByTitle.clear();\n    this.nodesById.clear();\n    this.nodesByAlias.clear();\n  }\n}\n","import type { Node, Edge, WikiLink, NodeType } from '../core/types/index.js';\nimport { parseMarkdown, type ParsedMarkdown } from '../parser/markdown.js';\nimport { createLinkResolver, type LinkResolver } from '../parser/resolver.js';\nimport type { FileInfo } from '../storage/filesystem/reader.js';\nimport { NodeRepository, EdgeRepository, VersionRepository } from '../storage/database/repositories/index.js';\n\nexport interface IndexingResult {\n  node: Node;\n  links: Array<{\n    wikilink: WikiLink;\n    targetNodeId: string | null;\n    ambiguous: boolean;\n  }>;\n  edges: Edge[];\n  unresolved: WikiLink[];\n  ambiguous: WikiLink[];\n}\n\nexport interface BatchIndexingResult {\n  indexed: IndexingResult[];\n  errors: Array<{ path: string; error: string }>;\n  stats: {\n    totalFiles: number;\n    successCount: number;\n    errorCount: number;\n    nodeCount: number;\n    edgeCount: number;\n    unresolvedCount: number;\n    ambiguousCount: number;\n    durationMs: number;\n  };\n}\n\nexport interface IndexerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  versionRepository: VersionRepository;\n}\n\n/**\n * Main indexing pipeline\n */\nexport class IndexingPipeline {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private versionRepo: VersionRepository;\n  private resolver: LinkResolver | null = null;\n\n  constructor(options: IndexerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.versionRepo = options.versionRepository;\n  }\n\n  /**\n   * Initialize the link resolver\n   */\n  private async getResolver(): Promise<LinkResolver> {\n    if (!this.resolver) {\n      this.resolver = createLinkResolver(this.nodeRepo);\n    }\n    return this.resolver;\n  }\n\n  /**\n   * Clear resolver cache (call after batch operations)\n   */\n  clearResolverCache(): void {\n    if (this.resolver) {\n      this.resolver.clearCache();\n    }\n  }\n\n  /**\n   * Index a single file\n   */\n  async indexFile(file: FileInfo): Promise<IndexingResult> {\n    // Parse the markdown\n    const parsed = parseMarkdown(file.content, file.relativePath);\n\n    // Create or update the node\n    const node = await this.upsertNode(file, parsed);\n\n    // Create version if content changed\n    await this.createVersionIfNeeded(node, file.contentHash);\n\n    // Update aliases\n    await this.nodeRepo.setAliases(node.nodeId, parsed.aliases);\n\n    // Resolve links and create edges\n    const { links, edges, unresolved, ambiguous } = await this.processLinks(\n      node,\n      parsed.links\n    );\n\n    return { node, links, edges, unresolved, ambiguous };\n  }\n\n  /**\n   * Create or update a node from file info\n   */\n  private async upsertNode(file: FileInfo, parsed: ParsedMarkdown): Promise<Node> {\n    const existing = await this.nodeRepo.findByPath(file.relativePath);\n\n    const nodeData = {\n      type: parsed.type as NodeType,\n      title: parsed.title,\n      path: file.relativePath,\n      createdAt: existing?.createdAt || file.stats.createdAt.toISOString(),\n      updatedAt: file.stats.modifiedAt.toISOString(),\n      contentHash: file.contentHash,\n      ...(parsed.frontmatter && { metadata: { ...parsed.frontmatter } }),\n    };\n\n    if (existing) {\n      return this.nodeRepo.update(existing.nodeId, nodeData);\n    }\n\n    return this.nodeRepo.create(nodeData);\n  }\n\n  /**\n   * Create a version entry if content has changed\n   */\n  private async createVersionIfNeeded(node: Node, contentHash: string): Promise<void> {\n    const latestVersion = await this.versionRepo.findLatest(node.nodeId);\n\n    if (latestVersion?.contentHash === contentHash) {\n      return; // No change\n    }\n\n    await this.versionRepo.create({\n      nodeId: node.nodeId,\n      contentHash,\n      ...(latestVersion?.versionId && { parentVersionId: latestVersion.versionId }),\n    });\n  }\n\n  /**\n   * Process wikilinks and create edges\n   */\n  private async processLinks(\n    sourceNode: Node,\n    wikilinks: WikiLink[]\n  ): Promise<{\n    links: IndexingResult['links'];\n    edges: Edge[];\n    unresolved: WikiLink[];\n    ambiguous: WikiLink[];\n  }> {\n    const resolver = await this.getResolver();\n\n    // Delete existing explicit_link edges from this source\n    await this.edgeRepo.deleteBySourceAndType(sourceNode.nodeId, 'explicit_link');\n\n    const links: IndexingResult['links'] = [];\n    const edges: Edge[] = [];\n    const unresolved: WikiLink[] = [];\n    const ambiguous: WikiLink[] = [];\n\n    for (const wikilink of wikilinks) {\n      const resolved = await resolver.resolveLink(wikilink);\n\n      links.push({\n        wikilink,\n        targetNodeId: resolved.resolvedNodeId,\n        ambiguous: resolved.ambiguous,\n      });\n\n      if (resolved.ambiguous) {\n        ambiguous.push(wikilink);\n      } else if (resolved.resolvedNodeId === null) {\n        unresolved.push(wikilink);\n      } else {\n        // Create edge\n        const edge = await this.edgeRepo.create({\n          sourceId: sourceNode.nodeId,\n          targetId: resolved.resolvedNodeId,\n          edgeType: 'explicit_link',\n          provenance: 'explicit',\n          attributes: {\n            displayText: wikilink.display,\n            position: { start: wikilink.start, end: wikilink.end },\n          },\n        });\n        edges.push(edge);\n      }\n    }\n\n    return { links, edges, unresolved, ambiguous };\n  }\n\n  /**\n   * Two-pass batch indexing for handling circular references\n   *\n   * Pass 1: Create all nodes (stubs)\n   * Pass 2: Process links and create edges\n   */\n  async batchIndex(files: FileInfo[]): Promise<BatchIndexingResult> {\n    const startTime = Date.now();\n    const indexed: IndexingResult[] = [];\n    const errors: Array<{ path: string; error: string }> = [];\n\n    // Pass 1: Create/update all nodes\n    const nodeMap = new Map<string, { node: Node; parsed: ParsedMarkdown; file: FileInfo }>();\n\n    for (const file of files) {\n      try {\n        const parsed = parseMarkdown(file.content, file.relativePath);\n        const node = await this.upsertNode(file, parsed);\n        await this.nodeRepo.setAliases(node.nodeId, parsed.aliases);\n        nodeMap.set(file.relativePath, { node, parsed, file });\n      } catch (error) {\n        errors.push({\n          path: file.relativePath,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    // Clear resolver cache before pass 2 (new nodes are now visible)\n    this.clearResolverCache();\n\n    // Pass 2: Process links and create edges\n    let totalEdges = 0;\n    let totalUnresolved = 0;\n    let totalAmbiguous = 0;\n\n    for (const { node, parsed, file } of nodeMap.values()) {\n      try {\n        // Create version\n        await this.createVersionIfNeeded(node, file.contentHash);\n\n        // Process links\n        const { links, edges, unresolved, ambiguous } = await this.processLinks(\n          node,\n          parsed.links\n        );\n\n        indexed.push({ node, links, edges, unresolved, ambiguous });\n        totalEdges += edges.length;\n        totalUnresolved += unresolved.length;\n        totalAmbiguous += ambiguous.length;\n      } catch (error) {\n        errors.push({\n          path: file.relativePath,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    const durationMs = Date.now() - startTime;\n\n    return {\n      indexed,\n      errors,\n      stats: {\n        totalFiles: files.length,\n        successCount: indexed.length,\n        errorCount: errors.length,\n        nodeCount: nodeMap.size,\n        edgeCount: totalEdges,\n        unresolvedCount: totalUnresolved,\n        ambiguousCount: totalAmbiguous,\n        durationMs,\n      },\n    };\n  }\n\n  /**\n   * Remove a node and its edges\n   */\n  async removeNode(nodeId: string): Promise<void> {\n    // Edges will be cascade deleted due to foreign key\n    await this.nodeRepo.delete(nodeId);\n    this.clearResolverCache();\n  }\n\n  /**\n   * Remove a node by path\n   */\n  async removeByPath(path: string): Promise<void> {\n    const node = await this.nodeRepo.findByPath(path);\n    if (node) {\n      await this.removeNode(node.nodeId);\n    }\n  }\n\n  /**\n   * Check if a file needs reindexing\n   */\n  async needsReindex(file: FileInfo): Promise<boolean> {\n    const node = await this.nodeRepo.findByPath(file.relativePath);\n\n    if (!node) {\n      return true; // New file\n    }\n\n    return node.contentHash !== file.contentHash;\n  }\n\n  /**\n   * Get indexing statistics\n   */\n  async getStats(): Promise<{\n    nodeCount: number;\n    edgeCount: number;\n    nodesByType: Record<string, number>;\n    edgesByType: Record<string, number>;\n  }> {\n    const [nodeCount, edgeCount, nodesByType, edgesByType] = await Promise.all([\n      this.nodeRepo.count(),\n      this.edgeRepo.count(),\n      this.nodeRepo.countByType(),\n      this.edgeRepo.countByType(),\n    ]);\n\n    return { nodeCount, edgeCount, nodesByType, edgesByType };\n  }\n}\n","import type {\n  Node,\n  Edge,\n  EdgeType,\n  BacklinkResult,\n  NeighborResult,\n  TraversalResult,\n  ZettelScriptConfig,\n} from '../types/index.js';\nimport { DEFAULT_CONFIG } from '../types/index.js';\nimport { NodeRepository, EdgeRepository } from '../../storage/database/repositories/index.js';\n\nexport interface GraphEngineOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Graph engine for traversal, queries, and analytics\n */\nexport class GraphEngine {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private config: ZettelScriptConfig;\n\n  constructor(options: GraphEngineOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.config = options.config ?? DEFAULT_CONFIG;\n  }\n\n  // ============================================================================\n  // Node Operations\n  // ============================================================================\n\n  async getNode(nodeId: string): Promise<Node | null> {\n    return this.nodeRepo.findById(nodeId);\n  }\n\n  async getNodeByPath(path: string): Promise<Node | null> {\n    return this.nodeRepo.findByPath(path);\n  }\n\n  async getNodeByTitle(title: string): Promise<Node[]> {\n    return this.nodeRepo.findByTitle(title);\n  }\n\n  async getAllNodes(): Promise<Node[]> {\n    return this.nodeRepo.findAll();\n  }\n\n  // ============================================================================\n  // Edge Operations\n  // ============================================================================\n\n  async getEdge(edgeId: string): Promise<Edge | null> {\n    return this.edgeRepo.findById(edgeId);\n  }\n\n  async getOutgoingEdges(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    return this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n  }\n\n  async getIncomingEdges(nodeId: string, edgeTypes?: EdgeType[]): Promise<Edge[]> {\n    return this.edgeRepo.findIncoming(nodeId, edgeTypes);\n  }\n\n  // ============================================================================\n  // Backlinks (Spec 6.2)\n  // ============================================================================\n\n  /**\n   * Get backlinks for a node\n   * backlinks(node) = { edge.source_id | edge.edge_type == 'explicit_link' AND edge.target_id == node }\n   */\n  async getBacklinks(nodeId: string): Promise<BacklinkResult[]> {\n    const edges = await this.edgeRepo.findBacklinks(nodeId);\n\n    if (edges.length === 0) return [];\n\n    const sourceIds = edges.map(e => e.sourceId);\n    const sourceNodes = await this.nodeRepo.findByIds(sourceIds);\n    const nodeMap = new Map(sourceNodes.map(n => [n.nodeId, n]));\n\n    const results: BacklinkResult[] = [];\n    for (const edge of edges) {\n      const sourceNode = nodeMap.get(edge.sourceId);\n      if (sourceNode) {\n        results.push({\n          sourceNode,\n          edge,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Count backlinks for a node\n   */\n  async countBacklinks(nodeId: string): Promise<number> {\n    const edges = await this.edgeRepo.findBacklinks(nodeId);\n    return edges.length;\n  }\n\n  // ============================================================================\n  // Neighbors\n  // ============================================================================\n\n  /**\n   * Get all neighbors of a node (both directions)\n   */\n  async getNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<NeighborResult[]> {\n    const neighborsWithNodes = await this.edgeRepo.findNeighborsWithNodes(nodeId, edgeTypes);\n\n    return neighborsWithNodes.map(({ edge, node, direction }) => ({\n      node: {\n        nodeId: node.nodeId,\n        title: node.title,\n        type: node.type as Node['type'],\n        path: node.path,\n        createdAt: '',\n        updatedAt: '',\n      },\n      edge,\n      direction,\n    }));\n  }\n\n  /**\n   * Get outgoing neighbors\n   */\n  async getOutgoingNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<Node[]> {\n    const edges = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n    if (edges.length === 0) return [];\n\n    const targetIds = edges.map(e => e.targetId);\n    return this.nodeRepo.findByIds(targetIds);\n  }\n\n  /**\n   * Get incoming neighbors\n   */\n  async getIncomingNeighbors(nodeId: string, edgeTypes?: EdgeType[]): Promise<Node[]> {\n    const edges = await this.edgeRepo.findIncoming(nodeId, edgeTypes);\n\n    if (edges.length === 0) return [];\n\n    const sourceIds = edges.map(e => e.sourceId);\n    return this.nodeRepo.findByIds(sourceIds);\n  }\n\n  // ============================================================================\n  // Bounded Graph Traversal (Spec 7.3)\n  // ============================================================================\n\n  /**\n   * Bounded graph expansion from seed nodes\n   *\n   * Algorithm:\n   * frontier = seed_nodes\n   * for depth in 1..max_depth:\n   *     if visited_count >= budget: break\n   *     for node in frontier:\n   *         for edge in outgoing_edges(node, allowed_types):\n   *             score = current_score * edge_weight * decay^depth\n   *             accumulated_scores[edge.target] = max(existing, score)\n   *     frontier = newly_discovered_nodes\n   */\n  async expandGraph(options: {\n    seedNodes: Array<{ nodeId: string; score: number }>;\n    maxDepth?: number;\n    budget?: number;\n    edgeTypes?: EdgeType[];\n    decayFactor?: number;\n    includeIncoming?: boolean;\n  }): Promise<TraversalResult[]> {\n    const {\n      seedNodes,\n      maxDepth = this.config.graph.defaultMaxDepth,\n      budget = this.config.graph.defaultBudget,\n      edgeTypes = ['explicit_link', 'sequence', 'hierarchy'],\n      decayFactor = this.config.graph.decayFactor,\n      includeIncoming = false,\n    } = options;\n\n    if (seedNodes.length === 0) return [];\n\n    // Track scores and paths\n    const scores = new Map<string, number>();\n    const paths = new Map<string, string[]>();\n    const depths = new Map<string, number>();\n\n    // Initialize with seed nodes\n    let frontier = new Set<string>();\n    for (const seed of seedNodes) {\n      scores.set(seed.nodeId, seed.score);\n      paths.set(seed.nodeId, [seed.nodeId]);\n      depths.set(seed.nodeId, 0);\n      frontier.add(seed.nodeId);\n    }\n\n    const visited = new Set<string>(frontier);\n\n    // BFS with decay\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (visited.size >= budget) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (visited.size >= budget) break;\n\n        const currentScore = scores.get(nodeId) ?? 0;\n        const currentPath = paths.get(nodeId) ?? [];\n\n        // Get outgoing edges\n        const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n        // Optionally include incoming edges\n        const incoming = includeIncoming\n          ? await this.edgeRepo.findIncoming(nodeId, edgeTypes)\n          : [];\n\n        const allEdges = [...outgoing, ...incoming];\n\n        for (const edge of allEdges) {\n          if (visited.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Calculate new score with decay\n          const edgeWeight = edge.strength ?? 1.0;\n          const newScore = currentScore * edgeWeight * Math.pow(decayFactor, depth);\n\n          // Update if new score is better\n          const existingScore = scores.get(targetId) ?? 0;\n          if (newScore > existingScore) {\n            scores.set(targetId, newScore);\n            paths.set(targetId, [...currentPath, targetId]);\n            depths.set(targetId, depth);\n          }\n\n          if (!visited.has(targetId)) {\n            visited.add(targetId);\n            newFrontier.add(targetId);\n          }\n        }\n      }\n\n      frontier = newFrontier;\n\n      if (frontier.size === 0) break;\n    }\n\n    // Build results sorted by score\n    const results: TraversalResult[] = [];\n    for (const [nodeId, score] of scores) {\n      results.push({\n        nodeId,\n        depth: depths.get(nodeId) ?? 0,\n        score,\n        path: paths.get(nodeId) ?? [],\n      });\n    }\n\n    return results.sort((a, b) => b.score - a.score);\n  }\n\n  // ============================================================================\n  // Path Finding\n  // ============================================================================\n\n  /**\n   * Find shortest path between two nodes (BFS)\n   */\n  async findShortestPath(\n    startId: string,\n    endId: string,\n    edgeTypes?: EdgeType[]\n  ): Promise<string[] | null> {\n    if (startId === endId) return [startId];\n\n    const visited = new Set<string>([startId]);\n    const queue: Array<{ nodeId: string; path: string[] }> = [\n      { nodeId: startId, path: [startId] },\n    ];\n\n    while (queue.length > 0) {\n      const current = queue.shift();\n      if (!current) break;\n\n      const edges = await this.edgeRepo.findOutgoing(current.nodeId, edgeTypes);\n\n      for (const edge of edges) {\n        if (edge.targetId === endId) {\n          return [...current.path, endId];\n        }\n\n        if (!visited.has(edge.targetId)) {\n          visited.add(edge.targetId);\n          queue.push({\n            nodeId: edge.targetId,\n            path: [...current.path, edge.targetId],\n          });\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if two nodes are connected\n   */\n  async areConnected(\n    nodeId1: string,\n    nodeId2: string,\n    edgeTypes?: EdgeType[],\n    maxDepth?: number\n  ): Promise<boolean> {\n    const depth = maxDepth ?? this.config.graph.defaultMaxDepth;\n    const result = await this.expandGraph({\n      seedNodes: [{ nodeId: nodeId1, score: 1 }],\n      maxDepth: depth,\n      budget: 1000,\n      ...(edgeTypes && { edgeTypes }),\n    });\n\n    return result.some(r => r.nodeId === nodeId2);\n  }\n\n  // ============================================================================\n  // Subgraph Extraction\n  // ============================================================================\n\n  /**\n   * Extract a subgraph around a node\n   */\n  async extractSubgraph(\n    centerNodeId: string,\n    radius: number = 2,\n    edgeTypes?: EdgeType[]\n  ): Promise<{ nodes: Node[]; edges: Edge[] }> {\n    const traversal = await this.expandGraph({\n      seedNodes: [{ nodeId: centerNodeId, score: 1 }],\n      maxDepth: radius,\n      budget: 100,\n      ...(edgeTypes && { edgeTypes }),\n      includeIncoming: true,\n    });\n\n    const nodeIds = traversal.map(t => t.nodeId);\n    const nodes = await this.nodeRepo.findByIds(nodeIds);\n\n    // Get all edges between these nodes\n    const nodeIdSet = new Set(nodeIds);\n    const edges: Edge[] = [];\n\n    for (const nodeId of nodeIds) {\n      const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n      for (const edge of outgoing) {\n        if (nodeIdSet.has(edge.targetId)) {\n          edges.push(edge);\n        }\n      }\n    }\n\n    return { nodes, edges };\n  }\n\n  // ============================================================================\n  // Graph Statistics\n  // ============================================================================\n\n  /**\n   * Calculate degree for a node\n   */\n  async getDegree(nodeId: string): Promise<{\n    in: number;\n    out: number;\n    total: number;\n  }> {\n    const incoming = await this.edgeRepo.findIncoming(nodeId);\n    const outgoing = await this.edgeRepo.findOutgoing(nodeId);\n\n    return {\n      in: incoming.length,\n      out: outgoing.length,\n      total: incoming.length + outgoing.length,\n    };\n  }\n\n  /**\n   * Find isolated nodes (no edges)\n   */\n  async findIsolatedNodes(): Promise<Node[]> {\n    const allNodes = await this.nodeRepo.findAll();\n    const isolated: Node[] = [];\n\n    for (const node of allNodes) {\n      const edges = await this.edgeRepo.findConnected(node.nodeId);\n      if (edges.length === 0) {\n        isolated.push(node);\n      }\n    }\n\n    return isolated;\n  }\n\n  /**\n   * Find nodes with high in-degree (potential hubs)\n   */\n  async findHighInDegreeNodes(threshold?: number): Promise<Array<{\n    node: Node;\n    inDegree: number;\n  }>> {\n    const minThreshold = threshold ?? this.config.moc?.defaultHubThreshold ?? 5;\n    const allNodes = await this.nodeRepo.findAll();\n    const results: Array<{ node: Node; inDegree: number }> = [];\n\n    for (const node of allNodes) {\n      const incoming = await this.edgeRepo.findIncoming(node.nodeId);\n      if (incoming.length >= minThreshold) {\n        results.push({ node, inDegree: incoming.length });\n      }\n    }\n\n    return results.sort((a, b) => b.inDegree - a.inDegree);\n  }\n\n  // ============================================================================\n  // Connected Components\n  // ============================================================================\n\n  /**\n   * Find connected components in the graph\n   */\n  async findConnectedComponents(): Promise<string[][]> {\n    const allNodes = await this.nodeRepo.findAll();\n    const visited = new Set<string>();\n    const components: string[][] = [];\n\n    for (const node of allNodes) {\n      if (visited.has(node.nodeId)) continue;\n\n      // BFS to find all connected nodes\n      const component: string[] = [];\n      const queue = [node.nodeId];\n\n      while (queue.length > 0) {\n        const currentId = queue.shift();\n        if (!currentId || visited.has(currentId)) continue;\n\n        visited.add(currentId);\n        component.push(currentId);\n\n        // Get all connected nodes (both directions)\n        const edges = await this.edgeRepo.findConnected(currentId);\n        for (const edge of edges) {\n          const neighborId = edge.sourceId === currentId ? edge.targetId : edge.sourceId;\n          if (!visited.has(neighborId)) {\n            queue.push(neighborId);\n          }\n        }\n      }\n\n      if (component.length > 0) {\n        components.push(component);\n      }\n    }\n\n    // Sort by size (largest first)\n    return components.sort((a, b) => b.length - a.length);\n  }\n\n  /**\n   * Get the component containing a specific node\n   */\n  async getComponentContaining(nodeId: string): Promise<string[]> {\n    const visited = new Set<string>();\n    const component: string[] = [];\n    const queue = [nodeId];\n\n    while (queue.length > 0) {\n      const currentId = queue.shift();\n      if (!currentId || visited.has(currentId)) continue;\n\n      visited.add(currentId);\n      component.push(currentId);\n\n      const edges = await this.edgeRepo.findConnected(currentId);\n      for (const edge of edges) {\n        const neighborId = edge.sourceId === currentId ? edge.targetId : edge.sourceId;\n        if (!visited.has(neighborId)) {\n          queue.push(neighborId);\n        }\n      }\n    }\n\n    return component;\n  }\n}\n","import { Command } from 'commander';\nimport { initContext, formatDuration, Spinner } from '../utils.js';\nimport { fullIndex } from '../../indexer/batch.js';\n\nexport const indexCommand = new Command('index')\n  .description('Index all markdown files in the vault')\n  .option('-v, --verbose', 'Show detailed output')\n  .option('--stats', 'Show indexing statistics')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      console.log(`Indexing vault: ${ctx.vaultPath}`);\n\n      const spinner = new Spinner('Scanning files...');\n      spinner.start();\n\n      let lastProgress = 0;\n      const result = await fullIndex(ctx.pipeline, ctx.vaultPath, {\n        excludePatterns: ctx.config.vault.excludePatterns,\n        onProgress: (current, total, path) => {\n          if (current > lastProgress) {\n            lastProgress = current;\n            spinner.update(`Indexing ${current}/${total}: ${path}`);\n          }\n        },\n      });\n\n      spinner.stop();\n\n      // Summary\n      console.log('\\nIndexing complete:');\n      console.log(`  Files processed: ${result.stats.totalFiles}`);\n      console.log(`  Nodes created:   ${result.stats.nodeCount}`);\n      console.log(`  Edges created:   ${result.stats.edgeCount}`);\n      console.log(`  Unresolved:      ${result.stats.unresolvedCount}`);\n      console.log(`  Ambiguous:       ${result.stats.ambiguousCount}`);\n      console.log(`  Duration:        ${formatDuration(result.stats.durationMs)}`);\n\n      // Show errors if any\n      if (result.errors.length > 0) {\n        console.log(`\\nErrors (${result.errors.length}):`);\n        for (const err of result.errors.slice(0, 10)) {\n          console.log(`  ${err.path}: ${err.error}`);\n        }\n        if (result.errors.length > 10) {\n          console.log(`  ... and ${result.errors.length - 10} more`);\n        }\n      }\n\n      // Show verbose output\n      if (options.verbose) {\n        // Show unresolved links\n        const allUnresolved = result.indexed.flatMap(r =>\n          r.unresolved.map(u => ({ path: r.node.path, link: u.target }))\n        );\n        if (allUnresolved.length > 0) {\n          console.log(`\\nUnresolved links (${allUnresolved.length}):`);\n          for (const u of allUnresolved.slice(0, 20)) {\n            console.log(`  ${u.path}: [[${u.link}]]`);\n          }\n          if (allUnresolved.length > 20) {\n            console.log(`  ... and ${allUnresolved.length - 20} more`);\n          }\n        }\n\n        // Show ambiguous links\n        const allAmbiguous = result.indexed.flatMap(r =>\n          r.ambiguous.map(a => ({ path: r.node.path, link: a.target }))\n        );\n        if (allAmbiguous.length > 0) {\n          console.log(`\\nAmbiguous links (${allAmbiguous.length}):`);\n          for (const a of allAmbiguous.slice(0, 20)) {\n            console.log(`  ${a.path}: [[${a.link}]]`);\n          }\n          if (allAmbiguous.length > 20) {\n            console.log(`  ... and ${allAmbiguous.length - 20} more`);\n          }\n        }\n      }\n\n      // Show stats\n      if (options.stats) {\n        const stats = await ctx.pipeline.getStats();\n        console.log('\\nGraph statistics:');\n        console.log('  Nodes by type:');\n        for (const [type, count] of Object.entries(stats.nodesByType)) {\n          console.log(`    ${type}: ${count}`);\n        }\n        console.log('  Edges by type:');\n        for (const [type, count] of Object.entries(stats.edgesByType)) {\n          console.log(`    ${type}: ${count}`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Index failed:', error);\n      process.exit(1);\n    }\n  });\n","import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { createHash } from 'node:crypto';\nimport { FileSystemError } from '../../core/errors.js';\nimport { getLogger } from '../../core/logger.js';\n\nexport interface FileInfo {\n  path: string;\n  relativePath: string;\n  content: string;\n  contentHash: string;\n  stats: {\n    size: number;\n    createdAt: Date;\n    modifiedAt: Date;\n  };\n}\n\nexport interface WalkOptions {\n  extensions?: string[];\n  excludePatterns?: string[];\n  maxDepth?: number;\n}\n\nconst DEFAULT_EXTENSIONS = ['.md', '.markdown'];\nconst DEFAULT_EXCLUDE = [\n  'node_modules',\n  '.git',\n  '.zettelscript',\n  '.obsidian',\n  '.vscode',\n  '.idea',\n];\n\n/**\n * Calculate content hash (SHA-256)\n */\nexport function hashContent(content: string): string {\n  return createHash('sha256').update(content).digest('hex');\n}\n\n/**\n * Read a single file\n */\nexport async function readFile(filePath: string, basePath: string): Promise<FileInfo> {\n  try {\n    const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(basePath, filePath);\n    const relativePath = path.relative(basePath, absolutePath);\n\n    const content = await fs.promises.readFile(absolutePath, 'utf-8');\n    const stats = await fs.promises.stat(absolutePath);\n\n    return {\n      path: absolutePath,\n      relativePath,\n      content,\n      contentHash: hashContent(content),\n      stats: {\n        size: stats.size,\n        createdAt: stats.birthtime,\n        modifiedAt: stats.mtime,\n      },\n    };\n  } catch (error) {\n    throw new FileSystemError(`Failed to read file: ${error}`, filePath);\n  }\n}\n\n/**\n * Check if a path should be excluded\n */\nfunction shouldExclude(relativePath: string, excludePatterns: string[]): boolean {\n  for (const pattern of excludePatterns) {\n    // Simple glob matching\n    if (pattern.includes('*')) {\n      const regex = new RegExp(\n        '^' + pattern.replace(/\\*/g, '.*').replace(/\\?/g, '.') + '$'\n      );\n      if (regex.test(relativePath)) return true;\n    } else {\n      // Direct match or prefix match\n      if (\n        relativePath === pattern ||\n        relativePath.startsWith(pattern + '/') ||\n        relativePath.startsWith(pattern + '\\\\')\n      ) {\n        return true;\n      }\n\n      // Check if any path segment matches\n      const segments = relativePath.split(/[/\\\\]/);\n      if (segments.some(s => s === pattern)) return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Walk a directory tree and yield markdown files\n */\nexport async function* walkDirectory(\n  basePath: string,\n  options: WalkOptions = {}\n): AsyncGenerator<FileInfo> {\n  const {\n    extensions = DEFAULT_EXTENSIONS,\n    excludePatterns = DEFAULT_EXCLUDE,\n    maxDepth = Infinity,\n  } = options;\n\n  const logger = getLogger().child('filesystem');\n\n  async function* walk(dir: string, depth: number): AsyncGenerator<FileInfo> {\n    if (depth > maxDepth) return;\n\n    let entries;\n    try {\n      entries = await fs.promises.readdir(dir, { withFileTypes: true });\n    } catch (error) {\n      logger.error(`Error reading directory ${dir}: ${error}`);\n      return;\n    }\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      const relativePath = path.relative(basePath, fullPath);\n\n      // Check exclusions\n      if (shouldExclude(relativePath, excludePatterns)) continue;\n      if (entry.name.startsWith('.')) continue; // Skip hidden files\n\n      if (entry.isDirectory()) {\n        yield* walk(fullPath, depth + 1);\n      } else if (entry.isFile()) {\n        const ext = path.extname(entry.name).toLowerCase();\n        if (extensions.includes(ext)) {\n          try {\n            yield await readFile(fullPath, basePath);\n          } catch (error) {\n            logger.error(`Error reading file ${fullPath}: ${error}`);\n          }\n        }\n      }\n    }\n  }\n\n  yield* walk(basePath, 0);\n}\n\n/**\n * Get all markdown files in a directory (non-streaming)\n */\nexport async function getMarkdownFiles(\n  basePath: string,\n  options: WalkOptions = {}\n): Promise<FileInfo[]> {\n  const files: FileInfo[] = [];\n\n  for await (const file of walkDirectory(basePath, options)) {\n    files.push(file);\n  }\n\n  return files;\n}\n\n/**\n * Check if a file exists\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    await fs.promises.access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get file stats\n */\nexport async function getFileStats(filePath: string): Promise<fs.Stats | null> {\n  try {\n    return await fs.promises.stat(filePath);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Compare file modification time with stored time\n */\nexport async function hasFileChanged(\n  filePath: string,\n  storedHash: string\n): Promise<boolean> {\n  try {\n    const content = await fs.promises.readFile(filePath, 'utf-8');\n    const currentHash = hashContent(content);\n    return currentHash !== storedHash;\n  } catch {\n    return true; // Assume changed if we can't read\n  }\n}\n","/**\n * Lightweight logger with configurable log levels\n */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  SILENT = 4,\n}\n\nexport interface LoggerOptions {\n  level?: LogLevel;\n  prefix?: string;\n}\n\n/**\n * Simple logger with log levels\n */\nexport class Logger {\n  private level: LogLevel;\n  private prefix: string;\n\n  constructor(options: LoggerOptions = {}) {\n    this.level = options.level ?? LogLevel.INFO;\n    this.prefix = options.prefix ?? '';\n  }\n\n  /**\n   * Set the log level\n   */\n  setLevel(level: LogLevel): void {\n    this.level = level;\n  }\n\n  /**\n   * Get the current log level\n   */\n  getLevel(): LogLevel {\n    return this.level;\n  }\n\n  /**\n   * Format a log message with optional prefix\n   */\n  private format(message: string): string {\n    return this.prefix ? `[${this.prefix}] ${message}` : message;\n  }\n\n  /**\n   * Log a debug message\n   */\n  debug(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.DEBUG) {\n      console.debug(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log an info message\n   */\n  info(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.INFO) {\n      console.log(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log a warning message\n   */\n  warn(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.WARN) {\n      console.warn(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Log an error message\n   */\n  error(message: string, ...args: unknown[]): void {\n    if (this.level <= LogLevel.ERROR) {\n      console.error(this.format(message), ...args);\n    }\n  }\n\n  /**\n   * Create a child logger with a prefix\n   */\n  child(prefix: string): Logger {\n    const childPrefix = this.prefix ? `${this.prefix}:${prefix}` : prefix;\n    return new Logger({ level: this.level, prefix: childPrefix });\n  }\n}\n\n// Default logger instance\nlet defaultLogger = new Logger();\n\n/**\n * Get the default logger\n */\nexport function getLogger(): Logger {\n  return defaultLogger;\n}\n\n/**\n * Set the default logger\n */\nexport function setDefaultLogger(logger: Logger): void {\n  defaultLogger = logger;\n}\n\n/**\n * Create a new logger with the given options\n */\nexport function createLogger(options: LoggerOptions = {}): Logger {\n  return new Logger(options);\n}\n\n/**\n * Configure the default logger\n */\nexport function configureLogger(options: LoggerOptions): void {\n  if (options.level !== undefined) {\n    defaultLogger.setLevel(options.level);\n  }\n}\n","import { getMarkdownFiles, type FileInfo, type WalkOptions } from '../storage/filesystem/reader.js';\nimport { IndexingPipeline, type BatchIndexingResult } from './pipeline.js';\n\nexport interface FullIndexOptions extends WalkOptions {\n  /** Callback for progress updates */\n  onProgress?: (current: number, total: number, path: string) => void;\n  /** Whether to clear existing data before indexing */\n  clearExisting?: boolean;\n}\n\n/**\n * Perform a full vault index\n */\nexport async function fullIndex(\n  pipeline: IndexingPipeline,\n  basePath: string,\n  options: FullIndexOptions = {}\n): Promise<BatchIndexingResult> {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { onProgress, clearExisting = false, ...walkOptions } = options;\n\n  // Get all markdown files\n  const files = await getMarkdownFiles(basePath, walkOptions);\n\n  if (onProgress) {\n    let current = 0;\n    const total = files.length;\n\n    // Wrap the batch indexing with progress\n    const originalIndex = pipeline.indexFile.bind(pipeline);\n    pipeline.indexFile = async (file: FileInfo) => {\n      current++;\n      onProgress(current, total, file.relativePath);\n      return originalIndex(file);\n    };\n  }\n\n  // Run batch indexing\n  return pipeline.batchIndex(files);\n}\n\n/**\n * Index files that have changed since last index\n */\nexport async function incrementalIndex(\n  pipeline: IndexingPipeline,\n  basePath: string,\n  options: WalkOptions = {}\n): Promise<BatchIndexingResult> {\n  const files = await getMarkdownFiles(basePath, options);\n\n  // Filter to only files that need reindexing\n  const filesToIndex: FileInfo[] = [];\n  for (const file of files) {\n    if (await pipeline.needsReindex(file)) {\n      filesToIndex.push(file);\n    }\n  }\n\n  if (filesToIndex.length === 0) {\n    return {\n      indexed: [],\n      errors: [],\n      stats: {\n        totalFiles: 0,\n        successCount: 0,\n        errorCount: 0,\n        nodeCount: 0,\n        edgeCount: 0,\n        unresolvedCount: 0,\n        ambiguousCount: 0,\n        durationMs: 0,\n      },\n    };\n  }\n\n  return pipeline.batchIndex(filesToIndex);\n}\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { createIncrementalIndexer, type IncrementalIndexEvent } from '../../indexer/incremental.js';\n\nexport const watchCommand = new Command('watch')\n  .description('Watch for file changes and incrementally index')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      console.log(`Watching vault: ${ctx.vaultPath}`);\n      console.log('Press Ctrl+C to stop.\\n');\n\n      const indexer = createIncrementalIndexer(ctx.vaultPath, ctx.pipeline, {\n        excludePatterns: ctx.config.vault.excludePatterns.map(p => `**/${p}`),\n      });\n\n      indexer.on('ready', () => {\n        console.log('Watcher ready. Listening for changes...\\n');\n      });\n\n      indexer.on('event', (event: IncrementalIndexEvent) => {\n        const timestamp = new Date().toLocaleTimeString();\n\n        switch (event.type) {\n          case 'indexed':\n            console.log(`[${timestamp}] Indexed: ${event.path}`);\n            if (options.verbose && event.result) {\n              const { edges, unresolved, ambiguous } = event.result;\n              if (edges.length > 0) {\n                console.log(`  Links: ${edges.length}`);\n              }\n              if (unresolved.length > 0) {\n                console.log(`  Unresolved: ${unresolved.map(u => u.target).join(', ')}`);\n              }\n              if (ambiguous.length > 0) {\n                console.log(`  Ambiguous: ${ambiguous.map(a => a.target).join(', ')}`);\n              }\n            }\n            break;\n\n          case 'removed':\n            console.log(`[${timestamp}] Removed: ${event.path}`);\n            break;\n\n          case 'error':\n            console.log(`[${timestamp}] Error: ${event.path}`);\n            console.log(`  ${event.error}`);\n            break;\n        }\n      });\n\n      indexer.on('error', (error: Error) => {\n        console.error('Watcher error:', error.message);\n      });\n\n      indexer.start();\n\n      // Handle graceful shutdown\n      const shutdown = async () => {\n        console.log('\\nStopping watcher...');\n        await indexer.stop();\n        ctx.connectionManager.close();\n        process.exit(0);\n      };\n\n      process.on('SIGINT', shutdown);\n      process.on('SIGTERM', shutdown);\n    } catch (error) {\n      console.error('Watch failed:', error);\n      process.exit(1);\n    }\n  });\n","import { EventEmitter } from 'node:events';\nimport { FileWatcher, type FileEvent, type WatcherOptions } from '../storage/filesystem/watcher.js';\nimport { readFile } from '../storage/filesystem/reader.js';\nimport { IndexingPipeline, type IndexingResult } from './pipeline.js';\n\nexport interface IncrementalIndexerOptions extends Omit<WatcherOptions, 'basePath'> {\n  basePath: string;\n  pipeline: IndexingPipeline;\n}\n\nexport interface IncrementalIndexEvent {\n  type: 'indexed' | 'removed' | 'error';\n  path: string;\n  result?: IndexingResult;\n  error?: string;\n}\n\n/**\n * Incremental indexer that watches for file changes\n */\nexport class IncrementalIndexer extends EventEmitter {\n  private watcher: FileWatcher;\n  private pipeline: IndexingPipeline;\n  private basePath: string;\n  private processing: Set<string> = new Set();\n\n  constructor(options: IncrementalIndexerOptions) {\n    super();\n\n    this.basePath = options.basePath;\n    this.pipeline = options.pipeline;\n\n    this.watcher = new FileWatcher({\n      ...options,\n      basePath: this.basePath,\n    });\n\n    // Set up event handlers\n    this.watcher.on('file', this.handleFileEvent.bind(this));\n    this.watcher.on('error', (error) => this.emit('error', error));\n    this.watcher.on('ready', () => this.emit('ready'));\n  }\n\n  /**\n   * Start watching and indexing\n   */\n  start(): void {\n    this.watcher.start();\n  }\n\n  /**\n   * Stop watching\n   */\n  async stop(): Promise<void> {\n    await this.watcher.stop();\n  }\n\n  /**\n   * Handle a file event\n   */\n  private async handleFileEvent(event: FileEvent): Promise<void> {\n    // Prevent concurrent processing of the same file\n    if (this.processing.has(event.path)) {\n      return;\n    }\n\n    this.processing.add(event.path);\n\n    try {\n      switch (event.type) {\n        case 'add':\n        case 'change':\n          await this.handleAddOrChange(event);\n          break;\n\n        case 'unlink':\n          await this.handleUnlink(event);\n          break;\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.emit('event', {\n        type: 'error',\n        path: event.relativePath,\n        error: errorMessage,\n      } as IncrementalIndexEvent);\n    } finally {\n      this.processing.delete(event.path);\n    }\n  }\n\n  /**\n   * Handle file add or change\n   */\n  private async handleAddOrChange(event: FileEvent): Promise<void> {\n    const file = await readFile(event.path, this.basePath);\n    const result = await this.pipeline.indexFile(file);\n\n    this.emit('event', {\n      type: 'indexed',\n      path: event.relativePath,\n      result,\n    } as IncrementalIndexEvent);\n\n    // Clear resolver cache after changes\n    this.pipeline.clearResolverCache();\n  }\n\n  /**\n   * Handle file deletion\n   */\n  private async handleUnlink(event: FileEvent): Promise<void> {\n    await this.pipeline.removeByPath(event.relativePath);\n\n    this.emit('event', {\n      type: 'removed',\n      path: event.relativePath,\n    } as IncrementalIndexEvent);\n\n    // Clear resolver cache after deletion\n    this.pipeline.clearResolverCache();\n  }\n\n  /**\n   * Check if watching\n   */\n  isWatching(): boolean {\n    return this.watcher.isWatching();\n  }\n}\n\n/**\n * Create an incremental indexer\n */\nexport function createIncrementalIndexer(\n  basePath: string,\n  pipeline: IndexingPipeline,\n  options: Omit<IncrementalIndexerOptions, 'basePath' | 'pipeline'> = {}\n): IncrementalIndexer {\n  return new IncrementalIndexer({\n    ...options,\n    basePath,\n    pipeline,\n  });\n}\n","import { watch, type FSWatcher } from 'chokidar';\nimport * as path from 'node:path';\nimport { EventEmitter } from 'node:events';\n\nexport type FileEventType = 'add' | 'change' | 'unlink' | 'rename';\n\nexport interface FileEvent {\n  type: FileEventType;\n  path: string;\n  relativePath: string;\n  oldPath?: string;  // For rename events\n}\n\nexport interface WatcherOptions {\n  basePath: string;\n  extensions?: string[];\n  excludePatterns?: string[];\n  debounceMs?: number;\n  awaitWriteFinish?: boolean;\n}\n\nconst DEFAULT_EXTENSIONS = ['.md', '.markdown'];\nconst DEFAULT_EXCLUDE = [\n  '**/node_modules/**',\n  '**/.git/**',\n  '**/.zettelscript/**',\n  '**/.obsidian/**',\n  '**/.vscode/**',\n  '**/.*',\n];\n\n/**\n * File system watcher using chokidar\n */\nexport class FileWatcher extends EventEmitter {\n  private watcher: FSWatcher | null = null;\n  private basePath: string;\n  private options: WatcherOptions;\n  private debounceTimers: Map<string, ReturnType<typeof setTimeout>> = new Map();\n  private pendingEvents: Map<string, FileEvent> = new Map();\n\n  constructor(options: WatcherOptions) {\n    super();\n    this.basePath = options.basePath;\n    this.options = {\n      extensions: DEFAULT_EXTENSIONS,\n      excludePatterns: DEFAULT_EXCLUDE,\n      debounceMs: 100,\n      awaitWriteFinish: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Start watching\n   */\n  start(): void {\n    if (this.watcher) {\n      return;\n    }\n\n    const patterns = this.options.extensions!.map(\n      ext => path.join(this.basePath, '**', `*${ext}`)\n    );\n\n    this.watcher = watch(patterns, {\n      ...(this.options.excludePatterns != null && { ignored: this.options.excludePatterns }),\n      persistent: true,\n      ignoreInitial: true,\n      awaitWriteFinish: this.options.awaitWriteFinish\n        ? { stabilityThreshold: 100, pollInterval: 50 }\n        : false,\n      usePolling: false,\n    });\n\n    this.watcher\n      .on('add', (filePath) => this.handleEvent('add', filePath))\n      .on('change', (filePath) => this.handleEvent('change', filePath))\n      .on('unlink', (filePath) => this.handleEvent('unlink', filePath))\n      .on('error', (error) => this.emit('error', error))\n      .on('ready', () => this.emit('ready'));\n  }\n\n  /**\n   * Stop watching\n   */\n  async stop(): Promise<void> {\n    if (!this.watcher) {\n      return;\n    }\n\n    // Clear pending timers\n    for (const timer of this.debounceTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.debounceTimers.clear();\n    this.pendingEvents.clear();\n\n    await this.watcher.close();\n    this.watcher = null;\n  }\n\n  /**\n   * Handle a file event with debouncing\n   */\n  private handleEvent(type: FileEventType, filePath: string): void {\n    const relativePath = path.relative(this.basePath, filePath);\n\n    // Cancel existing timer for this file\n    const existingTimer = this.debounceTimers.get(filePath);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n\n    // Store the event\n    const event: FileEvent = { type, path: filePath, relativePath };\n\n    // If there's a pending add followed by a change, keep it as add\n    const pending = this.pendingEvents.get(filePath);\n    if (pending?.type === 'add' && type === 'change') {\n      event.type = 'add';\n    }\n\n    this.pendingEvents.set(filePath, event);\n\n    // Set debounce timer\n    const timer = setTimeout(() => {\n      const finalEvent = this.pendingEvents.get(filePath);\n      if (finalEvent) {\n        this.pendingEvents.delete(filePath);\n        this.debounceTimers.delete(filePath);\n        this.emit('file', finalEvent);\n        this.emit(finalEvent.type, finalEvent);\n      }\n    }, this.options.debounceMs);\n\n    this.debounceTimers.set(filePath, timer);\n  }\n\n  /**\n   * Check if watching\n   */\n  isWatching(): boolean {\n    return this.watcher !== null;\n  }\n\n  /**\n   * Get watched paths\n   */\n  getWatched(): Record<string, string[]> {\n    if (!this.watcher) {\n      return {};\n    }\n    return this.watcher.getWatched();\n  }\n}\n\n/**\n * Create a file watcher\n */\nexport function createWatcher(options: WatcherOptions): FileWatcher {\n  return new FileWatcher(options);\n}\n","import { Command } from 'commander';\nimport { initContext, printTable } from '../utils.js';\nimport { parseIntSafe } from '../../core/validation.js';\n\nexport const queryCommand = new Command('query')\n  .description('Query the knowledge graph');\n\n// Backlinks subcommand\nqueryCommand\n  .command('backlinks <node>')\n  .description('Show incoming links to a node')\n  .option('-l, --limit <n>', 'Maximum results', '20')\n  .action(async (nodeIdentifier: string, options) => {\n    try {\n      const ctx = await initContext();\n      const limit = parseIntSafe(options.limit, ctx.config.search.defaultLimit);\n\n      // Find node by title or path\n      let node = await ctx.nodeRepository.findByPath(nodeIdentifier);\n      if (!node) {\n        const nodes = await ctx.nodeRepository.findByTitle(nodeIdentifier);\n        node = nodes[0] ?? null;\n      }\n      if (!node) {\n        const nodes = await ctx.nodeRepository.findByTitleOrAlias(nodeIdentifier);\n        node = nodes[0] ?? null;\n      }\n\n      if (!node) {\n        console.log(`Node not found: ${nodeIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`Backlinks to: ${node.title} (${node.path})\\n`);\n\n      const backlinks = await ctx.graphEngine.getBacklinks(node.nodeId);\n\n      if (backlinks.length === 0) {\n        console.log('No backlinks found.');\n      } else {\n        const rows = backlinks.slice(0, limit).map(bl => [\n          bl.sourceNode.title,\n          bl.sourceNode.type,\n          bl.sourceNode.path,\n        ]);\n        printTable(['Title', 'Type', 'Path'], rows);\n\n        if (backlinks.length > limit) {\n          console.log(`\\n... and ${backlinks.length - limit} more`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Neighbors subcommand\nqueryCommand\n  .command('neighbors <node>')\n  .description('Show connected nodes')\n  .option('-l, --limit <n>', 'Maximum results', '20')\n  .option('-d, --direction <dir>', 'Filter direction (in/out/both)', 'both')\n  .action(async (nodeIdentifier: string, options) => {\n    try {\n      const ctx = await initContext();\n      const limit = parseIntSafe(options.limit, ctx.config.search.defaultLimit);\n\n      // Find node\n      let node = await ctx.nodeRepository.findByPath(nodeIdentifier);\n      if (!node) {\n        const nodes = await ctx.nodeRepository.findByTitle(nodeIdentifier);\n        node = nodes[0] ?? null;\n      }\n      if (!node) {\n        const nodes = await ctx.nodeRepository.findByTitleOrAlias(nodeIdentifier);\n        node = nodes[0] ?? null;\n      }\n\n      if (!node) {\n        console.log(`Node not found: ${nodeIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`Neighbors of: ${node.title} (${node.path})\\n`);\n\n      const neighbors = await ctx.graphEngine.getNeighbors(node.nodeId);\n\n      // Filter by direction\n      const filtered = neighbors.filter(n => {\n        if (options.direction === 'in') return n.direction === 'incoming';\n        if (options.direction === 'out') return n.direction === 'outgoing';\n        return true;\n      });\n\n      if (filtered.length === 0) {\n        console.log('No neighbors found.');\n      } else {\n        const rows = filtered.slice(0, limit).map(n => [\n          n.direction === 'incoming' ? '' : '',\n          n.node.title,\n          n.node.type,\n          n.edge.edgeType,\n        ]);\n        printTable(['Dir', 'Title', 'Type', 'Edge Type'], rows);\n\n        if (filtered.length > limit) {\n          console.log(`\\n... and ${filtered.length - limit} more`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Path subcommand\nqueryCommand\n  .command('path <from> <to>')\n  .description('Find shortest path between nodes')\n  .action(async (fromIdentifier: string, toIdentifier: string) => {\n    try {\n      const ctx = await initContext();\n\n      // Find from node\n      let fromNode = await ctx.nodeRepository.findByPath(fromIdentifier);\n      if (!fromNode) {\n        const nodes = await ctx.nodeRepository.findByTitle(fromIdentifier);\n        fromNode = nodes[0] ?? null;\n      }\n      if (!fromNode) {\n        console.log(`Node not found: ${fromIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Find to node\n      let toNode = await ctx.nodeRepository.findByPath(toIdentifier);\n      if (!toNode) {\n        const nodes = await ctx.nodeRepository.findByTitle(toIdentifier);\n        toNode = nodes[0] ?? null;\n      }\n      if (!toNode) {\n        console.log(`Node not found: ${toIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`Path from \"${fromNode.title}\" to \"${toNode.title}\":\\n`);\n\n      const path = await ctx.graphEngine.findShortestPath(fromNode.nodeId, toNode.nodeId);\n\n      if (!path) {\n        console.log('No path found.');\n      } else {\n        const pathNodes = await ctx.nodeRepository.findByIds(path);\n        const nodeMap = new Map(pathNodes.map(n => [n.nodeId, n]));\n\n        for (let i = 0; i < path.length; i++) {\n          const nodeId = path[i];\n          if (nodeId) {\n            const node = nodeMap.get(nodeId);\n            const prefix = i === 0 ? '' : i === path.length - 1 ? '' : '';\n            console.log(`  ${prefix} ${node?.title || nodeId}`);\n          }\n        }\n        console.log(`\\nPath length: ${path.length - 1} hops`);\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Stats subcommand\nqueryCommand\n  .command('stats')\n  .description('Show graph statistics')\n  .action(async () => {\n    try {\n      const ctx = await initContext();\n\n      const stats = await ctx.pipeline.getStats();\n      const dbStats = ctx.connectionManager.getStats();\n\n      console.log('Graph Statistics\\n');\n      console.log(`Total nodes:  ${stats.nodeCount}`);\n      console.log(`Total edges:  ${stats.edgeCount}`);\n      console.log(`Total chunks: ${dbStats.chunkCount}`);\n      console.log(`DB size:      ${(dbStats.dbSizeBytes / 1024).toFixed(1)}KB`);\n\n      console.log('\\nNodes by type:');\n      for (const [type, count] of Object.entries(stats.nodesByType).sort((a, b) => b[1] - a[1])) {\n        console.log(`  ${type}: ${count}`);\n      }\n\n      console.log('\\nEdges by type:');\n      for (const [type, count] of Object.entries(stats.edgesByType).sort((a, b) => b[1] - a[1])) {\n        console.log(`  ${type}: ${count}`);\n      }\n\n      // Find orphan nodes\n      const components = await ctx.graphEngine.findConnectedComponents();\n      const isolatedCount = components.filter(c => c.length === 1).length;\n      if (isolatedCount > 0) {\n        console.log(`\\nIsolated nodes: ${isolatedCount}`);\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Orphans subcommand\nqueryCommand\n  .command('orphans')\n  .description('Find nodes with no links')\n  .option('-l, --limit <n>', 'Maximum results', '20')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n      const limit = parseIntSafe(options.limit, ctx.config.search.defaultLimit);\n\n      const isolated = await ctx.graphEngine.findIsolatedNodes();\n\n      if (isolated.length === 0) {\n        console.log('No orphan nodes found.');\n      } else {\n        console.log(`Orphan nodes (${isolated.length}):\\n`);\n\n        const rows = isolated.slice(0, limit).map(n => [\n          n.title,\n          n.type,\n          n.path,\n        ]);\n        printTable(['Title', 'Type', 'Path'], rows);\n\n        if (isolated.length > limit) {\n          console.log(`\\n... and ${isolated.length - limit} more`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Hubs subcommand\nqueryCommand\n  .command('hubs')\n  .description('Find highly-connected nodes')\n  .option('-l, --limit <n>', 'Maximum results', '10')\n  .option('-t, --threshold <n>', 'Minimum connections', '5')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n      const limit = parseIntSafe(options.limit, 10);\n      const threshold = parseIntSafe(options.threshold, ctx.config.moc.defaultHubThreshold);\n\n      const hubs = await ctx.graphEngine.findHighInDegreeNodes(threshold);\n\n      if (hubs.length === 0) {\n        console.log(`No nodes with ${threshold}+ incoming links.`);\n      } else {\n        console.log(`Hub nodes (${hubs.length}):\\n`);\n\n        const rows = hubs.slice(0, limit).map(h => [\n          h.node.title,\n          h.node.type,\n          h.inDegree.toString(),\n        ]);\n        printTable(['Title', 'Type', 'Incoming Links'], rows);\n\n        if (hubs.length > limit) {\n          console.log(`\\n... and ${hubs.length - limit} more`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Query failed:', error);\n      process.exit(1);\n    }\n  });\n","/**\n * Safe parsing and validation utilities\n */\n\n/**\n * Parse an integer from a string with fallback to default value\n * Returns defaultValue if the string is not a valid integer\n */\nexport function parseIntSafe(value: string, defaultValue: number): number {\n  const parsed = parseInt(value, 10);\n  return Number.isNaN(parsed) ? defaultValue : parsed;\n}\n\n/**\n * Parse a float from a string with fallback to default value\n * Returns defaultValue if the string is not a valid number\n */\nexport function parseFloatSafe(value: string, defaultValue: number): number {\n  const parsed = parseFloat(value);\n  return Number.isNaN(parsed) ? defaultValue : parsed;\n}\n\n/**\n * Clamp a number between min and max values\n */\nexport function clampNumber(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * Parse an integer with bounds checking\n * Returns defaultValue if parsing fails or value is out of bounds\n */\nexport function parseIntBounded(\n  value: string,\n  defaultValue: number,\n  min: number,\n  max: number\n): number {\n  const parsed = parseIntSafe(value, defaultValue);\n  return clampNumber(parsed, min, max);\n}\n\n/**\n * Parse a float with bounds checking\n * Returns defaultValue if parsing fails or value is out of bounds\n */\nexport function parseFloatBounded(\n  value: string,\n  defaultValue: number,\n  min: number,\n  max: number\n): number {\n  const parsed = parseFloatSafe(value, defaultValue);\n  return clampNumber(parsed, min, max);\n}\n\n/**\n * Validate that a value is a positive integer\n */\nexport function isPositiveInt(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value > 0;\n}\n\n/**\n * Validate that a value is a non-negative integer\n */\nexport function isNonNegativeInt(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Validate that a value is a number in range [0, 1]\n */\nexport function isNormalizedNumber(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value <= 1;\n}\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { LinkValidator } from '../../validation/link-validator.js';\nimport { SchemaValidator } from '../../validation/schema-validator.js';\nimport { ContinuityChecker } from '../../validation/continuity-checker.js';\n\nexport const validateCommand = new Command('validate')\n  .description('Validate the vault')\n  .option('--links', 'Check for broken and ambiguous links')\n  .option('--schema', 'Validate frontmatter schema')\n  .option('--continuity', 'Check manuscript continuity (POV, timeline)')\n  .option('--all', 'Run all validations')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      const runAll = options.all || (!options.links && !options.schema && !options.continuity);\n      let hasErrors = false;\n\n      // Link validation\n      if (runAll || options.links) {\n        console.log('Checking links...\\n');\n\n        const linkValidator = new LinkValidator({\n          nodeRepository: ctx.nodeRepository,\n          edgeRepository: ctx.edgeRepository,\n        });\n\n        const linkResult = await linkValidator.validate();\n\n        if (linkResult.broken.length === 0 && linkResult.ambiguous.length === 0) {\n          console.log('   All links valid\\n');\n        } else {\n          if (linkResult.broken.length > 0) {\n            hasErrors = true;\n            console.log(`   Broken links: ${linkResult.broken.length}`);\n            if (options.verbose) {\n              for (const b of linkResult.broken.slice(0, 10)) {\n                console.log(`    ${b.sourcePath}: [[${b.targetText}]]`);\n              }\n              if (linkResult.broken.length > 10) {\n                console.log(`    ... and ${linkResult.broken.length - 10} more`);\n              }\n            }\n          }\n\n          if (linkResult.ambiguous.length > 0) {\n            console.log(`  ! Ambiguous links: ${linkResult.ambiguous.length}`);\n            if (options.verbose) {\n              for (const a of linkResult.ambiguous.slice(0, 10)) {\n                console.log(`    ${a.sourcePath}: [[${a.targetText}]]  ${a.candidates.length} matches`);\n              }\n            }\n          }\n          console.log('');\n        }\n      }\n\n      // Schema validation\n      if (runAll || options.schema) {\n        console.log('Validating schema...\\n');\n\n        const schemaValidator = new SchemaValidator({\n          nodeRepository: ctx.nodeRepository,\n        });\n\n        const schemaResult = await schemaValidator.validate();\n\n        if (schemaResult.errors.length === 0) {\n          console.log('   All frontmatter valid\\n');\n        } else {\n          hasErrors = true;\n          console.log(`   Schema errors: ${schemaResult.errors.length}`);\n          if (options.verbose) {\n            for (const e of schemaResult.errors.slice(0, 10)) {\n              console.log(`    ${e.path}: ${e.message}`);\n            }\n            if (schemaResult.errors.length > 10) {\n              console.log(`    ... and ${schemaResult.errors.length - 10} more`);\n            }\n          }\n          console.log('');\n        }\n      }\n\n      // Continuity validation (manuscript mode)\n      if ((runAll || options.continuity) && ctx.config.manuscript.enabled) {\n        console.log('Checking continuity...\\n');\n\n        const continuityChecker = new ContinuityChecker({\n          nodeRepository: ctx.nodeRepository,\n          edgeRepository: ctx.edgeRepository,\n          config: ctx.config.manuscript,\n        });\n\n        const continuityResult = await continuityChecker.check();\n\n        const errors = continuityResult.issues.filter(i => i.severity === 'error');\n        const warnings = continuityResult.issues.filter(i => i.severity === 'warning');\n\n        if (errors.length === 0 && warnings.length === 0) {\n          console.log('   No continuity issues\\n');\n        } else {\n          if (errors.length > 0) {\n            hasErrors = true;\n            console.log(`   Continuity errors: ${errors.length}`);\n            if (options.verbose) {\n              for (const e of errors.slice(0, 10)) {\n                console.log(`    ${e.nodeId}: ${e.description}`);\n                if (e.suggestion) {\n                  console.log(`      Suggestion: ${e.suggestion}`);\n                }\n              }\n            }\n          }\n\n          if (warnings.length > 0) {\n            console.log(`  ! Continuity warnings: ${warnings.length}`);\n            if (options.verbose) {\n              for (const w of warnings.slice(0, 10)) {\n                console.log(`    ${w.nodeId}: ${w.description}`);\n              }\n            }\n          }\n          console.log('');\n        }\n      } else if ((runAll || options.continuity) && !ctx.config.manuscript.enabled) {\n        console.log('Continuity checking skipped (manuscript mode not enabled).\\n');\n        console.log('Enable with: zettel init --manuscript\\n');\n      }\n\n      // Summary\n      if (hasErrors) {\n        console.log('Validation completed with errors.');\n        process.exitCode = 1;\n      } else {\n        console.log('Validation passed.');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Validation failed:', error);\n      process.exit(1);\n    }\n  });\n","import type { Node } from '../core/types/index.js';\nimport { NodeRepository, EdgeRepository } from '../storage/database/repositories/index.js';\n\nexport interface BrokenLink {\n  sourceId: string;\n  sourcePath: string;\n  targetText: string;\n  spanStart?: number;\n  spanEnd?: number;\n}\n\nexport interface AmbiguousLink {\n  sourceId: string;\n  sourcePath: string;\n  targetText: string;\n  candidates: string[];  // Node IDs\n  candidateTitles: string[];\n}\n\nexport interface LinkValidationResult {\n  broken: BrokenLink[];\n  ambiguous: AmbiguousLink[];\n  valid: number;\n  total: number;\n}\n\nexport interface LinkValidatorOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n}\n\n/**\n * Validates links in the graph\n */\nexport class LinkValidator {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n\n  constructor(options: LinkValidatorOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n  }\n\n  /**\n   * Validate all links in the graph\n   */\n  async validate(): Promise<LinkValidationResult> {\n    const broken: BrokenLink[] = [];\n    const ambiguous: AmbiguousLink[] = [];\n    let valid = 0;\n\n    // Get all nodes\n    const nodes = await this.nodeRepo.findAll();\n    const nodeMap = new Map(nodes.map(n => [n.nodeId, n]));\n\n    // Get all explicit_link edges\n    const edges = await this.edgeRepo.findByType('explicit_link');\n\n    for (const edge of edges) {\n      const sourceNode = nodeMap.get(edge.sourceId);\n      const targetNode = nodeMap.get(edge.targetId);\n\n      if (!sourceNode) {\n        // Source node missing (shouldn't happen due to FK constraints)\n        continue;\n      }\n\n      if (!targetNode) {\n        // Target node missing - broken link\n        const attributes = edge.attributes as { displayText?: string; position?: { start: number; end: number } } | undefined;\n        broken.push({\n          sourceId: edge.sourceId,\n          sourcePath: sourceNode.path,\n          targetText: attributes?.displayText || edge.targetId,\n          ...(attributes?.position?.start != null && { spanStart: attributes.position.start }),\n          ...(attributes?.position?.end != null && { spanEnd: attributes.position.end }),\n        });\n      } else {\n        valid++;\n      }\n    }\n\n    // Note: Ambiguous links are tracked during indexing, not in edges\n    // They would be stored separately if we wanted to validate them\n\n    return {\n      broken,\n      ambiguous,\n      valid,\n      total: edges.length,\n    };\n  }\n\n  /**\n   * Validate links for a specific node\n   */\n  async validateNode(nodeId: string): Promise<{\n    broken: BrokenLink[];\n    valid: number;\n  }> {\n    const broken: BrokenLink[] = [];\n    let valid = 0;\n\n    const node = await this.nodeRepo.findById(nodeId);\n    if (!node) {\n      return { broken, valid: 0 };\n    }\n\n    const edges = await this.edgeRepo.findOutgoing(nodeId, ['explicit_link']);\n\n    for (const edge of edges) {\n      const targetNode = await this.nodeRepo.findById(edge.targetId);\n\n      if (!targetNode) {\n        const attributes = edge.attributes as { displayText?: string; position?: { start: number; end: number } } | undefined;\n        broken.push({\n          sourceId: nodeId,\n          sourcePath: node.path,\n          targetText: attributes?.displayText || edge.targetId,\n          ...(attributes?.position?.start != null && { spanStart: attributes.position.start }),\n          ...(attributes?.position?.end != null && { spanEnd: attributes.position.end }),\n        });\n      } else {\n        valid++;\n      }\n    }\n\n    return { broken, valid };\n  }\n\n  /**\n   * Find all nodes that link to a given node\n   */\n  async findLinkers(targetNodeId: string): Promise<Node[]> {\n    const edges = await this.edgeRepo.findBacklinks(targetNodeId);\n    const sourceIds = edges.map(e => e.sourceId);\n    return this.nodeRepo.findByIds(sourceIds);\n  }\n\n  /**\n   * Check if a link would create a cycle\n   */\n  async wouldCreateCycle(\n    sourceId: string,\n    targetId: string,\n    maxDepth: number = 10\n  ): Promise<boolean> {\n    // BFS from target to see if we can reach source\n    const visited = new Set<string>([targetId]);\n    let frontier = [targetId];\n\n    for (let depth = 0; depth < maxDepth && frontier.length > 0; depth++) {\n      const nextFrontier: string[] = [];\n\n      for (const nodeId of frontier) {\n        const outgoing = await this.edgeRepo.findOutgoing(nodeId, ['explicit_link']);\n\n        for (const edge of outgoing) {\n          if (edge.targetId === sourceId) {\n            return true; // Found cycle\n          }\n\n          if (!visited.has(edge.targetId)) {\n            visited.add(edge.targetId);\n            nextFrontier.push(edge.targetId);\n          }\n        }\n      }\n\n      frontier = nextFrontier;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get link statistics\n   */\n  async getStats(): Promise<{\n    totalNodes: number;\n    totalLinks: number;\n    avgLinksPerNode: number;\n    nodesWithNoLinks: number;\n    nodesWithNoIncoming: number;\n    nodesWithNoOutgoing: number;\n  }> {\n    const nodes = await this.nodeRepo.findAll();\n    const edges = await this.edgeRepo.findByType('explicit_link');\n\n    // Count links per node\n    const outgoingCount = new Map<string, number>();\n    const incomingCount = new Map<string, number>();\n\n    for (const edge of edges) {\n      outgoingCount.set(edge.sourceId, (outgoingCount.get(edge.sourceId) || 0) + 1);\n      incomingCount.set(edge.targetId, (incomingCount.get(edge.targetId) || 0) + 1);\n    }\n\n    let nodesWithNoLinks = 0;\n    let nodesWithNoIncoming = 0;\n    let nodesWithNoOutgoing = 0;\n\n    for (const node of nodes) {\n      const out = outgoingCount.get(node.nodeId) || 0;\n      const inc = incomingCount.get(node.nodeId) || 0;\n\n      if (out === 0 && inc === 0) nodesWithNoLinks++;\n      if (inc === 0) nodesWithNoIncoming++;\n      if (out === 0) nodesWithNoOutgoing++;\n    }\n\n    return {\n      totalNodes: nodes.length,\n      totalLinks: edges.length,\n      avgLinksPerNode: nodes.length > 0 ? edges.length / nodes.length : 0,\n      nodesWithNoLinks,\n      nodesWithNoIncoming,\n      nodesWithNoOutgoing,\n    };\n  }\n}\n","import Ajv, { type ValidateFunction } from 'ajv';\nimport { Type, type TSchema } from '@sinclair/typebox';\nimport type { Node, Frontmatter } from '../core/types/index.js';\nimport { NodeRepository } from '../storage/database/repositories/index.js';\n\nexport interface SchemaError {\n  nodeId: string;\n  path: string;\n  field: string;\n  message: string;\n  value?: unknown;\n}\n\nexport interface SchemaValidationResult {\n  errors: SchemaError[];\n  warnings: SchemaError[];\n  valid: number;\n  total: number;\n}\n\nexport interface SchemaValidatorOptions {\n  nodeRepository: NodeRepository;\n  customSchemas?: Record<string, TSchema>;\n}\n\n// Base frontmatter schema\nconst BaseFrontmatterSchema = Type.Object({\n  id: Type.Optional(Type.String()),\n  title: Type.Optional(Type.String()),\n  type: Type.Optional(Type.Union([\n    Type.Literal('note'),\n    Type.Literal('scene'),\n    Type.Literal('character'),\n    Type.Literal('location'),\n    Type.Literal('object'),\n    Type.Literal('event'),\n    Type.Literal('concept'),\n    Type.Literal('moc'),\n    Type.Literal('timeline'),\n    Type.Literal('draft'),\n  ])),\n  aliases: Type.Optional(Type.Array(Type.String())),\n  tags: Type.Optional(Type.Array(Type.String())),\n  created: Type.Optional(Type.String()),\n  updated: Type.Optional(Type.String()),\n}, { additionalProperties: true });\n\n// Scene-specific schema\nconst SceneFrontmatterSchema = Type.Object({\n  type: Type.Literal('scene'),\n  pov: Type.Optional(Type.String()),\n  scene_order: Type.Optional(Type.Number()),\n  timeline_position: Type.Optional(Type.String()),\n  characters: Type.Optional(Type.Array(Type.String())),\n  locations: Type.Optional(Type.Array(Type.String())),\n}, { additionalProperties: true });\n\n// Character-specific schema\nconst CharacterFrontmatterSchema = Type.Object({\n  type: Type.Literal('character'),\n  aliases: Type.Optional(Type.Array(Type.String())),\n  description: Type.Optional(Type.String()),\n  traits: Type.Optional(Type.Array(Type.String())),\n}, { additionalProperties: true });\n\n/**\n * Validates frontmatter schema for nodes\n */\nexport class SchemaValidator {\n  private nodeRepo: NodeRepository;\n  private ajv: Ajv;\n  private validators: Map<string, ValidateFunction>;\n\n  constructor(options: SchemaValidatorOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.ajv = new Ajv({ allErrors: true, strict: false });\n    this.validators = new Map();\n\n    // Register base validator\n    this.validators.set('base', this.ajv.compile(BaseFrontmatterSchema));\n\n    // Register type-specific validators\n    this.validators.set('scene', this.ajv.compile(SceneFrontmatterSchema));\n    this.validators.set('character', this.ajv.compile(CharacterFrontmatterSchema));\n\n    // Register custom schemas\n    if (options.customSchemas) {\n      for (const [type, schema] of Object.entries(options.customSchemas)) {\n        this.validators.set(type, this.ajv.compile(schema));\n      }\n    }\n  }\n\n  /**\n   * Validate all nodes\n   */\n  async validate(): Promise<SchemaValidationResult> {\n    const errors: SchemaError[] = [];\n    const warnings: SchemaError[] = [];\n    let valid = 0;\n\n    const nodes = await this.nodeRepo.findAll();\n\n    for (const node of nodes) {\n      const result = this.validateNode(node);\n\n      if (result.errors.length === 0) {\n        valid++;\n      }\n\n      errors.push(...result.errors);\n      warnings.push(...result.warnings);\n    }\n\n    return {\n      errors,\n      warnings,\n      valid,\n      total: nodes.length,\n    };\n  }\n\n  /**\n   * Validate a single node's frontmatter\n   */\n  validateNode(node: Node): { errors: SchemaError[]; warnings: SchemaError[] } {\n    const errors: SchemaError[] = [];\n    const warnings: SchemaError[] = [];\n\n    const metadata = node.metadata as Frontmatter | undefined;\n\n    if (!metadata) {\n      // No frontmatter - could be a warning depending on requirements\n      return { errors, warnings };\n    }\n\n    // Validate against base schema\n    const baseValidator = this.validators.get('base');\n    if (baseValidator && !baseValidator(metadata)) {\n      for (const err of baseValidator.errors || []) {\n        errors.push({\n          nodeId: node.nodeId,\n          path: node.path,\n          field: err.instancePath || 'root',\n          message: err.message || 'Validation failed',\n          value: err.data,\n        });\n      }\n    }\n\n    // Validate against type-specific schema if available\n    const typeValidator = this.validators.get(node.type);\n    if (typeValidator && metadata.type === node.type) {\n      if (!typeValidator(metadata)) {\n        for (const err of typeValidator.errors || []) {\n          errors.push({\n            nodeId: node.nodeId,\n            path: node.path,\n            field: err.instancePath || 'root',\n            message: err.message || 'Validation failed',\n            value: err.data,\n          });\n        }\n      }\n    }\n\n    // Type-specific validation rules\n    if (node.type === 'scene') {\n      // Scene should have POV for manuscript mode\n      if (!metadata.pov) {\n        warnings.push({\n          nodeId: node.nodeId,\n          path: node.path,\n          field: 'pov',\n          message: 'Scene missing POV character',\n        });\n      }\n\n      // Scene should have scene_order for timeline\n      if (metadata.scene_order === undefined) {\n        warnings.push({\n          nodeId: node.nodeId,\n          path: node.path,\n          field: 'scene_order',\n          message: 'Scene missing scene_order for timeline tracking',\n        });\n      }\n    }\n\n    if (node.type === 'character') {\n      // Character should have aliases for mention detection\n      if (!metadata.aliases || metadata.aliases.length === 0) {\n        warnings.push({\n          nodeId: node.nodeId,\n          path: node.path,\n          field: 'aliases',\n          message: 'Character has no aliases defined',\n        });\n      }\n    }\n\n    return { errors, warnings };\n  }\n\n  /**\n   * Add a custom schema for a type\n   */\n  addSchema(type: string, schema: TSchema): void {\n    this.validators.set(type, this.ajv.compile(schema));\n  }\n\n  /**\n   * Get validation summary by type\n   */\n  async getSummary(): Promise<Record<string, { total: number; valid: number; errors: number }>> {\n    const nodes = await this.nodeRepo.findAll();\n    const summary: Record<string, { total: number; valid: number; errors: number }> = {};\n\n    for (const node of nodes) {\n      if (!summary[node.type]) {\n        summary[node.type] = { total: 0, valid: 0, errors: 0 };\n      }\n\n      const typeStats = summary[node.type];\n      if (typeStats) {\n        typeStats.total++;\n\n        const result = this.validateNode(node);\n        if (result.errors.length === 0) {\n          typeStats.valid++;\n        } else {\n          typeStats.errors++;\n        }\n      }\n    }\n\n    return summary;\n  }\n}\n","import type { Node, ContinuityIssue, Frontmatter, SceneInfo } from '../core/types/index.js';\nimport { NodeRepository, EdgeRepository } from '../storage/database/repositories/index.js';\n\nexport interface ContinuityCheckResult {\n  issues: ContinuityIssue[];\n  stats: {\n    scenesChecked: number;\n    povIssues: number;\n    timelineIssues: number;\n    setupPayoffIssues: number;\n    knowledgeIssues: number;\n  };\n}\n\nexport interface ContinuityCheckerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  config: {\n    validatePov: boolean;\n    validateTimeline: boolean;\n    validateSetupPayoff: boolean;\n  };\n}\n\n/**\n * Checks manuscript continuity for POV, timeline, and setup/payoff consistency\n */\nexport class ContinuityChecker {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private config: ContinuityCheckerOptions['config'];\n\n  constructor(options: ContinuityCheckerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.config = options.config;\n  }\n\n  /**\n   * Run all continuity checks\n   */\n  async check(): Promise<ContinuityCheckResult> {\n    const issues: ContinuityIssue[] = [];\n\n    // Get all scenes\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    if (scenes.length === 0) {\n      return {\n        issues: [],\n        stats: {\n          scenesChecked: 0,\n          povIssues: 0,\n          timelineIssues: 0,\n          setupPayoffIssues: 0,\n          knowledgeIssues: 0,\n        },\n      };\n    }\n\n    // Extract scene info\n    const sceneInfos = scenes.map(s => this.extractSceneInfo(s));\n\n    // POV validation\n    if (this.config.validatePov) {\n      const povIssues = await this.checkPovConsistency(scenes, sceneInfos);\n      issues.push(...povIssues);\n    }\n\n    // Timeline validation\n    if (this.config.validateTimeline) {\n      const timelineIssues = await this.checkTimelineConsistency(scenes, sceneInfos);\n      issues.push(...timelineIssues);\n    }\n\n    // Setup/payoff validation\n    if (this.config.validateSetupPayoff) {\n      const setupPayoffIssues = await this.checkSetupPayoff(scenes);\n      issues.push(...setupPayoffIssues);\n    }\n\n    return {\n      issues,\n      stats: {\n        scenesChecked: scenes.length,\n        povIssues: issues.filter(i => i.type === 'pov_leakage').length,\n        timelineIssues: issues.filter(i => i.type === 'timeline_inconsistency').length,\n        setupPayoffIssues: issues.filter(i => i.type === 'missing_setup' || i.type === 'orphaned_payoff').length,\n        knowledgeIssues: issues.filter(i => i.type === 'character_knowledge').length,\n      },\n    };\n  }\n\n  /**\n   * Extract scene info from node metadata\n   */\n  private extractSceneInfo(node: Node): SceneInfo {\n    const metadata = node.metadata as Frontmatter | undefined;\n\n    return {\n      nodeId: node.nodeId,\n      sceneOrder: metadata?.scene_order ?? Infinity,\n      ...(metadata?.timeline_position != null && { timelinePosition: metadata.timeline_position }),\n      ...(metadata?.pov != null && { pov: metadata.pov }),\n      characters: metadata?.characters ?? [],\n      locations: metadata?.locations ?? [],\n    };\n  }\n\n  /**\n   * Check POV consistency - ensure POV character knows information they reveal\n   */\n  private async checkPovConsistency(\n    scenes: Node[],\n    sceneInfos: SceneInfo[]\n  ): Promise<ContinuityIssue[]> {\n    const issues: ContinuityIssue[] = [];\n\n    // Sort scenes by order\n    const sortedScenes = [...sceneInfos].sort((a, b) => a.sceneOrder - b.sceneOrder);\n\n    // Track what each character knows\n    const characterKnowledge = new Map<string, Set<string>>();\n\n    for (const scene of sortedScenes) {\n      const sceneNode = scenes.find(s => s.nodeId === scene.nodeId);\n      if (!sceneNode) continue;\n\n      if (!scene.pov) {\n        issues.push({\n          type: 'pov_leakage',\n          severity: 'warning',\n          nodeId: scene.nodeId,\n          description: 'Scene has no POV character defined',\n          suggestion: 'Add \"pov: CharacterName\" to frontmatter',\n        });\n        continue;\n      }\n\n      // Get links from this scene to other nodes\n      const outgoing = await this.edgeRepo.findOutgoing(scene.nodeId);\n\n      for (const edge of outgoing) {\n        // Check if target is a character\n        const targetNode = await this.nodeRepo.findById(edge.targetId);\n        if (!targetNode) continue;\n\n        if (targetNode.type === 'character' && targetNode.title !== scene.pov) {\n          // POV character is referencing another character\n          // This is generally fine, but check if POV should know about them\n          if (!scene.characters.includes(targetNode.title)) {\n            issues.push({\n              type: 'pov_leakage',\n              severity: 'info',\n              nodeId: scene.nodeId,\n              description: `POV (${scene.pov}) references ${targetNode.title} who is not listed in scene characters`,\n              suggestion: `Add \"${targetNode.title}\" to characters list if they are present`,\n            });\n          }\n        }\n      }\n\n      // Update character knowledge for characters in this scene\n      for (const char of scene.characters) {\n        if (!characterKnowledge.has(char)) {\n          characterKnowledge.set(char, new Set());\n        }\n        // Character now knows about events in this scene\n        characterKnowledge.get(char)?.add(scene.nodeId);\n      }\n    }\n\n    return issues;\n  }\n\n  /**\n   * Check timeline consistency - ensure scene_order is sequential and logical\n   */\n  private async checkTimelineConsistency(\n    scenes: Node[],\n    sceneInfos: SceneInfo[]\n  ): Promise<ContinuityIssue[]> {\n    const issues: ContinuityIssue[] = [];\n\n    // Check for missing scene_order\n    const withoutOrder = sceneInfos.filter(s => s.sceneOrder === Infinity);\n    for (const scene of withoutOrder) {\n      const sceneNode = scenes.find(s => s.nodeId === scene.nodeId);\n      issues.push({\n        type: 'timeline_inconsistency',\n        severity: 'warning',\n        nodeId: scene.nodeId,\n        description: `Scene \"${sceneNode?.title}\" has no scene_order`,\n        suggestion: 'Add \"scene_order: N\" to frontmatter for timeline tracking',\n      });\n    }\n\n    // Check for duplicate scene_order\n    const orderCounts = new Map<number, string[]>();\n    for (const scene of sceneInfos) {\n      if (scene.sceneOrder !== Infinity) {\n        const existing = orderCounts.get(scene.sceneOrder) || [];\n        existing.push(scene.nodeId);\n        orderCounts.set(scene.sceneOrder, existing);\n      }\n    }\n\n    for (const [order, nodeIds] of orderCounts) {\n      if (nodeIds.length > 1) {\n        for (const nodeId of nodeIds) {\n          const sceneNode = scenes.find(s => s.nodeId === nodeId);\n          issues.push({\n            type: 'timeline_inconsistency',\n            severity: 'error',\n            nodeId,\n            description: `Scene \"${sceneNode?.title}\" has duplicate scene_order ${order}`,\n            suggestion: 'Ensure each scene has a unique scene_order',\n          });\n        }\n      }\n    }\n\n    // Check for large gaps in scene_order\n    const orderedScenes = sceneInfos\n      .filter(s => s.sceneOrder !== Infinity)\n      .sort((a, b) => a.sceneOrder - b.sceneOrder);\n\n    for (let i = 1; i < orderedScenes.length; i++) {\n      const prev = orderedScenes[i - 1];\n      const curr = orderedScenes[i];\n      if (prev && curr) {\n        const gap = curr.sceneOrder - prev.sceneOrder;\n        if (gap > 10) {\n          issues.push({\n            type: 'timeline_inconsistency',\n            severity: 'info',\n            nodeId: curr.nodeId,\n            description: `Large gap (${gap}) in scene_order between scenes`,\n            suggestion: 'Consider renumbering scenes for clarity',\n          });\n        }\n      }\n    }\n\n    return issues;\n  }\n\n  /**\n   * Check setup/payoff consistency using edges\n   */\n  private async checkSetupPayoff(_scenes: Node[]): Promise<ContinuityIssue[]> {\n    const issues: ContinuityIssue[] = [];\n\n    // Get all setup_payoff edges\n    const setupPayoffEdges = await this.edgeRepo.findByType('setup_payoff');\n\n    // Track setups and payoffs\n    const setups = new Set<string>();\n    const payoffs = new Set<string>();\n\n    for (const edge of setupPayoffEdges) {\n      setups.add(edge.sourceId);\n      payoffs.add(edge.targetId);\n    }\n\n    // Check for setups without payoffs\n    for (const setupId of setups) {\n      const hasPayoff = setupPayoffEdges.some(e => e.sourceId === setupId);\n      if (!hasPayoff) {\n        const node = await this.nodeRepo.findById(setupId);\n        if (node) {\n          issues.push({\n            type: 'orphaned_payoff',\n            severity: 'warning',\n            nodeId: setupId,\n            description: `Setup in \"${node.title}\" has no linked payoff`,\n            suggestion: 'Ensure this setup is resolved later in the narrative',\n          });\n        }\n      }\n    }\n\n    // Check for payoffs without setups\n    for (const payoffId of payoffs) {\n      const hasSetup = setupPayoffEdges.some(e => e.targetId === payoffId);\n      if (!hasSetup) {\n        const node = await this.nodeRepo.findById(payoffId);\n        if (node) {\n          issues.push({\n            type: 'missing_setup',\n            severity: 'warning',\n            nodeId: payoffId,\n            description: `Payoff in \"${node.title}\" has no linked setup`,\n            suggestion: 'Ensure this payoff is properly foreshadowed earlier',\n          });\n        }\n      }\n    }\n\n    return issues;\n  }\n\n  /**\n   * Check if a character could know about something at a given scene\n   */\n  async canCharacterKnow(\n    characterName: string,\n    informationNodeId: string,\n    atSceneOrder: number\n  ): Promise<boolean> {\n    // Get all scenes where character is present up to atSceneOrder\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    for (const scene of scenes) {\n      const metadata = scene.metadata as Frontmatter | undefined;\n      const sceneOrder = metadata?.scene_order ?? Infinity;\n\n      if (sceneOrder > atSceneOrder) continue;\n\n      const characters = metadata?.characters ?? [];\n      if (!characters.includes(characterName)) continue;\n\n      // Check if this scene connects to the information\n      const edges = await this.edgeRepo.findOutgoing(scene.nodeId);\n      if (edges.some(e => e.targetId === informationNodeId)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","import { Command } from 'commander';\nimport { initContext, printTable } from '../utils.js';\nimport { MentionDetector } from '../../discovery/mention-detector.js';\nimport { MentionRanker } from '../../discovery/mention-ranker.js';\nimport { InteractiveApprover, batchApproveMentions } from '../interactive-approver.js';\nimport { parseIntSafe, parseFloatSafe } from '../../core/validation.js';\n\nexport const discoverCommand = new Command('discover')\n  .description('Find unlinked mentions')\n  .option('-n, --node <id>', 'Check specific node')\n  .option('--all', 'Check all nodes')\n  .option('-l, --limit <n>', 'Maximum mentions per node', '10')\n  .option('-t, --threshold <n>', 'Minimum confidence threshold', '0.3')\n  .option('--approve', 'Interactive approval mode')\n  .option('--batch <action>', 'Batch action: approve, reject, or defer')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      const limit = parseIntSafe(options.limit, ctx.config.search.defaultLimit);\n      const threshold = parseFloatSafe(options.threshold, ctx.config.discovery.confidenceThreshold);\n\n      const detector = new MentionDetector({\n        nodeRepository: ctx.nodeRepository,\n        vaultPath: ctx.vaultPath,\n      });\n\n      const ranker = new MentionRanker({\n        edgeRepository: ctx.edgeRepository,\n        graphEngine: ctx.graphEngine,\n      });\n\n      let nodesToCheck: Array<{ nodeId: string; path: string; title: string }> = [];\n\n      if (options.node) {\n        // Check specific node\n        let node = await ctx.nodeRepository.findByPath(options.node);\n        if (!node) {\n          const nodes = await ctx.nodeRepository.findByTitle(options.node);\n          node = nodes[0] ?? null;\n        }\n\n        if (!node) {\n          console.log(`Node not found: ${options.node}`);\n          ctx.connectionManager.close();\n          return;\n        }\n\n        nodesToCheck = [{ nodeId: node.nodeId, path: node.path, title: node.title }];\n      } else if (options.all) {\n        // Check all nodes\n        const allNodes = await ctx.nodeRepository.findAll();\n        nodesToCheck = allNodes.map(n => ({ nodeId: n.nodeId, path: n.path, title: n.title }));\n      } else {\n        console.log('Specify --node <id> or --all to discover mentions.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      let totalMentions = 0;\n\n      for (const { nodeId, path, title } of nodesToCheck) {\n        // Detect mentions\n        const mentions = await detector.detectInNode(nodeId);\n\n        if (mentions.length === 0) continue;\n\n        // Rank mentions\n        const ranked = await ranker.rank(mentions);\n\n        // Filter by threshold\n        const filtered = ranked.filter(m => m.confidence >= threshold);\n\n        if (filtered.length === 0) continue;\n\n        console.log(`\\n${title} (${path}):`);\n\n        const display = filtered.slice(0, limit);\n        const rows = display.map(m => [\n          m.surfaceText,\n          m.targetTitle || m.targetId,\n          (m.confidence * 100).toFixed(0) + '%',\n          m.reasons?.join(', ') || '',\n        ]);\n\n        printTable(['Text', 'Target', 'Confidence', 'Reasons'], rows);\n\n        if (filtered.length > limit) {\n          console.log(`  ... and ${filtered.length - limit} more`);\n        }\n\n        totalMentions += filtered.length;\n\n        // Interactive or batch approval\n        if (display.length > 0) {\n          if (options.batch) {\n            // Batch mode\n            const action = options.batch.toLowerCase();\n            if (!['approve', 'reject', 'defer'].includes(action)) {\n              console.error(`Invalid batch action: ${action}. Use: approve, reject, or defer`);\n              ctx.connectionManager.close();\n              return;\n            }\n\n            // Batch mode approves ALL filtered mentions, not just displayed\n            const results = await batchApproveMentions(\n              filtered,\n              nodeId,\n              ctx.edgeRepository,\n              action as 'approve' | 'reject' | 'defer'\n            );\n\n            const approvedCount = results.filter(r => r.action === 'approve').length;\n            if (approvedCount > 0) {\n              console.log(`  Batch ${action}: ${approvedCount} mention(s)`);\n            }\n          } else if (options.approve) {\n            // Interactive mode\n            const approver = new InteractiveApprover({\n              edgeRepository: ctx.edgeRepository,\n              sourceNodeId: nodeId,\n            });\n\n            if (!approver.isTTY()) {\n              console.warn('\\nNot running in interactive mode (non-TTY). Use --batch flag for non-interactive approval.');\n            } else {\n              console.log('\\nInteractive approval mode:');\n              const results = await approver.approveAll(display);\n\n              const approved = results.filter(r => r.action === 'approve').length;\n              const rejected = results.filter(r => r.action === 'reject').length;\n              const deferred = results.filter(r => r.action === 'defer').length;\n\n              if (approved > 0 || rejected > 0 || deferred > 0) {\n                console.log(`\\nApproved: ${approved}, Rejected: ${rejected}, Deferred: ${deferred}`);\n              }\n\n              // Check if user quit early\n              if (results.some(r => r.action === 'quit')) {\n                console.log('Approval cancelled.');\n                ctx.connectionManager.close();\n                return;\n              }\n            }\n          }\n        }\n      }\n\n      if (totalMentions === 0) {\n        console.log('No unlinked mentions found.');\n      } else {\n        console.log(`\\nTotal mentions found: ${totalMentions}`);\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Discovery failed:', error);\n      process.exit(1);\n    }\n  });\n","import { NodeRepository } from '../storage/database/repositories/index.js';\nimport { findExclusionZones, type ExclusionZone } from '../parser/exclusions.js';\nimport { parseFrontmatter } from '../parser/frontmatter.js';\nimport { FileSystemError, ParseError } from '../core/errors.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport interface DetectedMention {\n  targetId: string;\n  targetTitle: string;\n  surfaceText: string;\n  spanStart: number;\n  spanEnd: number;\n  matchType: 'title' | 'alias';\n}\n\nexport interface MentionDetectorOptions {\n  nodeRepository: NodeRepository;\n  vaultPath?: string;\n}\n\n/**\n * Detects unlinked mentions of nodes in content\n * Following spec 8.1:\n * 1. Strip excluded zones (code, links, URLs, frontmatter)\n * 2. Match titles/aliases with boundary-aware rules\n * 3. Deduplicate overlapping (prefer longer matches)\n */\nexport class MentionDetector {\n  private nodeRepo: NodeRepository;\n  private vaultPath: string;\n  private titleIndex: Map<string, { nodeId: string; title: string }[]> = new Map();\n  private aliasIndex: Map<string, { nodeId: string; title: string; alias: string }[]> = new Map();\n\n  constructor(options: MentionDetectorOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.vaultPath = options.vaultPath || process.cwd();\n  }\n\n  /**\n   * Build the title/alias index for fast matching\n   */\n  async buildIndex(): Promise<void> {\n    this.titleIndex.clear();\n    this.aliasIndex.clear();\n\n    const nodes = await this.nodeRepo.findAll();\n\n    for (const node of nodes) {\n      // Index by title (case-insensitive)\n      const titleLower = node.title.toLowerCase();\n      if (!this.titleIndex.has(titleLower)) {\n        this.titleIndex.set(titleLower, []);\n      }\n      this.titleIndex.get(titleLower)?.push({ nodeId: node.nodeId, title: node.title });\n\n      // Index by aliases\n      const aliases = await this.nodeRepo.getAliases(node.nodeId);\n      for (const alias of aliases) {\n        const aliasLower = alias.toLowerCase();\n        if (!this.aliasIndex.has(aliasLower)) {\n          this.aliasIndex.set(aliasLower, []);\n        }\n        this.aliasIndex.get(aliasLower)?.push({\n          nodeId: node.nodeId,\n          title: node.title,\n          alias,\n        });\n      }\n    }\n  }\n\n  /**\n   * Detect mentions in a specific node\n   */\n  async detectInNode(nodeId: string): Promise<DetectedMention[]> {\n    // Ensure index is built\n    if (this.titleIndex.size === 0) {\n      await this.buildIndex();\n    }\n\n    const node = await this.nodeRepo.findById(nodeId);\n    if (!node) return [];\n\n    // Read file content\n    const filePath = path.join(this.vaultPath, node.path);\n\n    try {\n      if (!fs.existsSync(filePath)) {\n        throw new FileSystemError(`File not found: ${filePath}`, filePath);\n      }\n\n      const content = fs.readFileSync(filePath, 'utf-8');\n      return this.detectInContent(content, nodeId, node.path);\n    } catch (error) {\n      if (error instanceof FileSystemError) {\n        throw error;\n      }\n      throw new FileSystemError(\n        `Failed to read file for mention detection: ${error instanceof Error ? error.message : String(error)}`,\n        filePath\n      );\n    }\n  }\n\n  /**\n   * Detect mentions in content\n   */\n  detectInContent(content: string, sourceNodeId: string, sourcePath: string): DetectedMention[] {\n    // Parse frontmatter to get content offset\n    let contentStartOffset: number;\n    try {\n      const parsed = parseFrontmatter(content, sourcePath);\n      contentStartOffset = parsed.contentStartOffset;\n    } catch (error) {\n      throw new ParseError(\n        `Failed to parse frontmatter: ${error instanceof Error ? error.message : String(error)}`,\n        sourcePath\n      );\n    }\n\n    // Get exclusion zones\n    const exclusionZones = findExclusionZones(content, 0);\n\n    // Collect all potential matches\n    const allMatches: Array<DetectedMention & { start: number; end: number }> = [];\n\n    // Match titles\n    for (const [titleLower, nodes] of this.titleIndex) {\n      // Skip single character matches\n      if (titleLower.length < 2) continue;\n\n      // Skip if this is the source node\n      const isSourceNode = nodes.some(n => n.nodeId === sourceNodeId);\n      if (isSourceNode) continue;\n\n      // Build boundary-aware regex\n      const pattern = this.buildBoundaryPattern(titleLower);\n      if (!pattern) continue;\n\n      const regex = new RegExp(pattern, 'gi');\n      let match;\n\n      while ((match = regex.exec(content)) !== null) {\n        if (match.index === undefined) continue;\n\n        const start = match.index;\n        const end = start + match[0].length;\n\n        // Skip if in exclusion zone\n        if (this.isInExclusionZone(start, end, exclusionZones)) continue;\n\n        // Skip if in frontmatter\n        if (start < contentStartOffset) continue;\n\n        for (const nodeInfo of nodes) {\n          allMatches.push({\n            targetId: nodeInfo.nodeId,\n            targetTitle: nodeInfo.title,\n            surfaceText: match[0],\n            spanStart: start,\n            spanEnd: end,\n            matchType: 'title',\n            start,\n            end,\n          });\n        }\n      }\n    }\n\n    // Match aliases\n    for (const [aliasLower, nodes] of this.aliasIndex) {\n      // Skip single character matches\n      if (aliasLower.length < 2) continue;\n\n      // Skip if this is the source node\n      const isSourceNode = nodes.some(n => n.nodeId === sourceNodeId);\n      if (isSourceNode) continue;\n\n      // Build boundary-aware regex\n      const pattern = this.buildBoundaryPattern(aliasLower);\n      if (!pattern) continue;\n\n      const regex = new RegExp(pattern, 'gi');\n      let match;\n\n      while ((match = regex.exec(content)) !== null) {\n        if (match.index === undefined) continue;\n\n        const start = match.index;\n        const end = start + match[0].length;\n\n        // Skip if in exclusion zone\n        if (this.isInExclusionZone(start, end, exclusionZones)) continue;\n\n        // Skip if in frontmatter\n        if (start < contentStartOffset) continue;\n\n        for (const nodeInfo of nodes) {\n          allMatches.push({\n            targetId: nodeInfo.nodeId,\n            targetTitle: nodeInfo.title,\n            surfaceText: match[0],\n            spanStart: start,\n            spanEnd: end,\n            matchType: 'alias',\n            start,\n            end,\n          });\n        }\n      }\n    }\n\n    // Deduplicate overlapping matches (prefer longer)\n    return this.deduplicateMatches(allMatches);\n  }\n\n  /**\n   * Build a boundary-aware regex pattern\n   */\n  private buildBoundaryPattern(text: string): string | null {\n    // Escape regex special characters\n    const escaped = text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n    // Word boundary pattern that handles various contexts\n    // Matches when surrounded by non-word characters or at string boundaries\n    return `(?<![\\\\w])${escaped}(?![\\\\w])`;\n  }\n\n  /**\n   * Check if a range is in an exclusion zone\n   */\n  private isInExclusionZone(start: number, end: number, zones: ExclusionZone[]): boolean {\n    return zones.some(zone => start < zone.end && end > zone.start);\n  }\n\n  /**\n   * Deduplicate overlapping matches, preferring longer matches\n   */\n  private deduplicateMatches(\n    matches: Array<DetectedMention & { start: number; end: number }>\n  ): DetectedMention[] {\n    if (matches.length === 0) return [];\n\n    // Sort by start position, then by length (descending)\n    matches.sort((a, b) => {\n      if (a.start !== b.start) return a.start - b.start;\n      return (b.end - b.start) - (a.end - a.start);\n    });\n\n    const result: DetectedMention[] = [];\n    let lastEnd = -1;\n\n    for (const match of matches) {\n      // Skip if this match overlaps with previous\n      if (match.start < lastEnd) continue;\n\n      result.push({\n        targetId: match.targetId,\n        targetTitle: match.targetTitle,\n        surfaceText: match.surfaceText,\n        spanStart: match.spanStart,\n        spanEnd: match.spanEnd,\n        matchType: match.matchType,\n      });\n\n      lastEnd = match.end;\n    }\n\n    return result;\n  }\n\n  /**\n   * Clear the index (call when nodes change)\n   */\n  clearIndex(): void {\n    this.titleIndex.clear();\n    this.aliasIndex.clear();\n  }\n}\n","import type { DetectedMention } from './mention-detector.js';\nimport type { ZettelScriptConfig } from '../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../core/types/index.js';\nimport { EdgeRepository } from '../storage/database/repositories/index.js';\nimport { GraphEngine } from '../core/graph/engine.js';\n\nexport interface RankedMention extends DetectedMention {\n  confidence: number;\n  reasons: string[];\n}\n\nexport interface MentionRankerOptions {\n  edgeRepository: EdgeRepository;\n  graphEngine: GraphEngine;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Ranks detected mentions by likelihood of being intentional\n * Following spec 8.1 ranking factors:\n * - Ambiguity penalty\n * - Graph locality (distance from source)\n * - Centrality (importance in graph)\n * - Frequency (how often this target is mentioned)\n */\nexport class MentionRanker {\n  private edgeRepo: EdgeRepository;\n  private graphEngine: GraphEngine;\n  private config: ZettelScriptConfig;\n\n  // Weighting factors from config\n  private weights: {\n    locality: number;\n    centrality: number;\n    frequency: number;\n    matchQuality: number;\n  };\n\n  private ambiguityPenalty: number;\n  private confidenceThreshold: number;\n  private expansionMaxDepth: number;\n  private expansionBudget: number;\n\n  constructor(options: MentionRankerOptions) {\n    this.edgeRepo = options.edgeRepository;\n    this.graphEngine = options.graphEngine;\n    this.config = options.config ?? DEFAULT_CONFIG;\n\n    // Initialize from config\n    this.weights = { ...this.config.discovery.weights };\n    this.ambiguityPenalty = this.config.discovery.ambiguityPenalty;\n    this.confidenceThreshold = this.config.discovery.confidenceThreshold;\n    this.expansionMaxDepth = this.config.discovery.expansionMaxDepth;\n    this.expansionBudget = this.config.discovery.expansionBudget;\n  }\n\n  /**\n   * Rank a list of detected mentions\n   */\n  async rank(mentions: DetectedMention[], sourceNodeId?: string): Promise<RankedMention[]> {\n    if (mentions.length === 0) return [];\n\n    // Get unique target IDs\n    const targetIds = [...new Set(mentions.map(m => m.targetId))];\n\n    // Calculate centrality scores\n    const centralityScores = await this.calculateCentrality(targetIds);\n\n    // Calculate locality scores if source provided\n    const localityScores = sourceNodeId\n      ? await this.calculateLocality(sourceNodeId, targetIds)\n      : new Map<string, number>();\n\n    // Calculate frequency scores\n    const frequencyScores = await this.calculateFrequency(targetIds);\n\n    // Rank each mention\n    const ranked: RankedMention[] = [];\n\n    for (const mention of mentions) {\n      const reasons: string[] = [];\n      let score = 0;\n\n      // Match quality score\n      const matchQualityScore = this.calculateMatchQuality(mention);\n      score += matchQualityScore * this.weights.matchQuality;\n      if (matchQualityScore > 0.7) {\n        reasons.push('exact_match');\n      }\n\n      // Locality score\n      const localityScore = localityScores.get(mention.targetId) ?? 0.5;\n      score += localityScore * this.weights.locality;\n      if (localityScore > 0.7) {\n        reasons.push('nearby_in_graph');\n      }\n\n      // Centrality score\n      const centralityScore = centralityScores.get(mention.targetId) ?? 0.5;\n      score += centralityScore * this.weights.centrality;\n      if (centralityScore > 0.7) {\n        reasons.push('important_node');\n      }\n\n      // Frequency score\n      const frequencyScore = frequencyScores.get(mention.targetId) ?? 0.5;\n      score += frequencyScore * this.weights.frequency;\n      if (frequencyScore > 0.7) {\n        reasons.push('frequently_linked');\n      }\n\n      // Ambiguity penalty\n      const ambiguousTargets = mentions.filter(\n        m => m.surfaceText.toLowerCase() === mention.surfaceText.toLowerCase() &&\n             m.targetId !== mention.targetId\n      );\n      if (ambiguousTargets.length > 0) {\n        score *= this.ambiguityPenalty; // Reduce confidence for ambiguous matches\n        reasons.push('ambiguous');\n      }\n\n      ranked.push({\n        ...mention,\n        confidence: Math.min(1, Math.max(0, score)),\n        reasons,\n      });\n    }\n\n    // Sort by confidence (descending)\n    return ranked.sort((a, b) => b.confidence - a.confidence);\n  }\n\n  /**\n   * Calculate match quality based on how well the surface text matches\n   */\n  private calculateMatchQuality(mention: DetectedMention): number {\n    const surface = mention.surfaceText.toLowerCase();\n    const target = mention.targetTitle.toLowerCase();\n\n    // Exact match with original casing preserved\n    if (mention.surfaceText === mention.targetTitle) {\n      return 1.0;\n    }\n\n    // Case-insensitive exact match\n    if (surface === target) {\n      return 0.95;\n    }\n\n    // Alias match\n    if (mention.matchType === 'alias') {\n      return 0.85;\n    }\n\n    // Partial match (shouldn't happen with current detection, but handle it)\n    return 0.7;\n  }\n\n  /**\n   * Calculate centrality scores (based on incoming link count)\n   */\n  private async calculateCentrality(nodeIds: string[]): Promise<Map<string, number>> {\n    const scores = new Map<string, number>();\n\n    // Get max in-degree for normalization\n    let maxInDegree = 1;\n    const inDegrees = new Map<string, number>();\n\n    for (const nodeId of nodeIds) {\n      const incoming = await this.edgeRepo.findIncoming(nodeId);\n      const inDegree = incoming.length;\n      inDegrees.set(nodeId, inDegree);\n      maxInDegree = Math.max(maxInDegree, inDegree);\n    }\n\n    // Normalize scores\n    for (const nodeId of nodeIds) {\n      const inDegree = inDegrees.get(nodeId) ?? 0;\n      // Use log scale to prevent very popular nodes from dominating\n      scores.set(nodeId, Math.log(inDegree + 1) / Math.log(maxInDegree + 1));\n    }\n\n    return scores;\n  }\n\n  /**\n   * Calculate locality scores (graph distance from source)\n   */\n  private async calculateLocality(\n    sourceNodeId: string,\n    targetNodeIds: string[]\n  ): Promise<Map<string, number>> {\n    const scores = new Map<string, number>();\n\n    // Expand from source to find distances\n    const expansion = await this.graphEngine.expandGraph({\n      seedNodes: [{ nodeId: sourceNodeId, score: 1 }],\n      maxDepth: this.expansionMaxDepth,\n      budget: this.expansionBudget,\n      includeIncoming: true,\n    });\n\n    const distanceMap = new Map(expansion.map(e => [e.nodeId, e.depth]));\n\n    for (const targetId of targetNodeIds) {\n      const distance = distanceMap.get(targetId);\n\n      if (distance === undefined) {\n        // Not connected - low locality score\n        scores.set(targetId, 0.1);\n      } else if (distance === 0) {\n        // Same node - shouldn't happen\n        scores.set(targetId, 0);\n      } else {\n        // Score decreases with distance\n        scores.set(targetId, 1 / distance);\n      }\n    }\n\n    return scores;\n  }\n\n  /**\n   * Calculate frequency scores (how often target is linked to)\n   */\n  private async calculateFrequency(nodeIds: string[]): Promise<Map<string, number>> {\n    const scores = new Map<string, number>();\n\n    // Count total incoming explicit links\n    let maxLinks = 1;\n    const linkCounts = new Map<string, number>();\n\n    for (const nodeId of nodeIds) {\n      const backlinks = await this.edgeRepo.findBacklinks(nodeId);\n      const count = backlinks.length;\n      linkCounts.set(nodeId, count);\n      maxLinks = Math.max(maxLinks, count);\n    }\n\n    // Normalize\n    for (const nodeId of nodeIds) {\n      const count = linkCounts.get(nodeId) ?? 0;\n      scores.set(nodeId, count / maxLinks);\n    }\n\n    return scores;\n  }\n\n  /**\n   * Filter mentions below a confidence threshold\n   */\n  filterByThreshold(mentions: RankedMention[], threshold?: number): RankedMention[] {\n    const thresh = threshold ?? this.confidenceThreshold;\n    return mentions.filter(m => m.confidence >= thresh);\n  }\n\n  /**\n   * Group mentions by target\n   */\n  groupByTarget(mentions: RankedMention[]): Map<string, RankedMention[]> {\n    const groups = new Map<string, RankedMention[]>();\n\n    for (const mention of mentions) {\n      const existing = groups.get(mention.targetId) || [];\n      existing.push(mention);\n      groups.set(mention.targetId, existing);\n    }\n\n    return groups;\n  }\n}\n","import * as readline from 'node:readline';\nimport type { RankedMention } from '../discovery/mention-ranker.js';\nimport { EdgeRepository } from '../storage/database/repositories/index.js';\nimport { DatabaseError } from '../core/errors.js';\n\nexport type ApprovalAction = 'approve' | 'reject' | 'defer' | 'skip' | 'quit' | 'approveAll';\n\nexport interface ApprovalResult {\n  mention: RankedMention;\n  action: ApprovalAction;\n}\n\nexport interface InteractiveApproverOptions {\n  edgeRepository: EdgeRepository;\n  sourceNodeId: string;\n}\n\n/**\n * Interactive mention approver using readline\n * Supports commands: (y)es, (n)o, (d)efer, (a)ll, (s)kip, (q)uit\n */\nexport class InteractiveApprover {\n  private edgeRepo: EdgeRepository;\n  private sourceNodeId: string;\n  private rl: readline.Interface | null = null;\n\n  constructor(options: InteractiveApproverOptions) {\n    this.edgeRepo = options.edgeRepository;\n    this.sourceNodeId = options.sourceNodeId;\n  }\n\n  /**\n   * Check if running in a TTY environment\n   */\n  isTTY(): boolean {\n    return process.stdin.isTTY === true && process.stdout.isTTY === true;\n  }\n\n  /**\n   * Approve a single mention interactively\n   */\n  async approveMention(mention: RankedMention): Promise<ApprovalAction> {\n    if (!this.isTTY()) {\n      console.warn('Not running in interactive mode (non-TTY). Use --batch flag instead.');\n      return 'skip';\n    }\n\n    // Display mention info\n    console.log(`\\n  \"${mention.surfaceText}\" -> ${mention.targetTitle}`);\n    console.log(`  Confidence: ${(mention.confidence * 100).toFixed(0)}%`);\n    if (mention.reasons && mention.reasons.length > 0) {\n      console.log(`  Reasons: ${mention.reasons.join(', ')}`);\n    }\n\n    const action = await this.promptAction();\n    return action;\n  }\n\n  /**\n   * Approve multiple mentions interactively\n   */\n  async approveAll(mentions: RankedMention[]): Promise<ApprovalResult[]> {\n    const results: ApprovalResult[] = [];\n    let approveRemaining = false;\n\n    for (const mention of mentions) {\n      if (approveRemaining) {\n        // Auto-approve remaining\n        await this.createMentionEdge(mention);\n        results.push({ mention, action: 'approve' });\n        continue;\n      }\n\n      const action = await this.approveMention(mention);\n\n      switch (action) {\n        case 'approve':\n          await this.createMentionEdge(mention);\n          results.push({ mention, action: 'approve' });\n          break;\n\n        case 'approveAll':\n          await this.createMentionEdge(mention);\n          results.push({ mention, action: 'approve' });\n          approveRemaining = true;\n          break;\n\n        case 'reject':\n          results.push({ mention, action: 'reject' });\n          break;\n\n        case 'defer':\n          results.push({ mention, action: 'defer' });\n          break;\n\n        case 'skip':\n          results.push({ mention, action: 'skip' });\n          break;\n\n        case 'quit':\n          results.push({ mention, action: 'quit' });\n          this.close();\n          return results;\n      }\n    }\n\n    this.close();\n    return results;\n  }\n\n  /**\n   * Prompt user for action with retry limit\n   */\n  private async promptAction(): Promise<ApprovalAction> {\n    const maxRetries = 10;\n    let retries = 0;\n\n    while (retries < maxRetries) {\n      try {\n        const answer = await this.question('  Approve? (y)es/(n)o/(d)efer/(a)ll/(s)kip/(q)uit: ');\n        const action = this.parseAnswer(answer);\n        if (action) return action;\n        console.log('  Invalid input. Use y/n/d/a/s/q');\n        retries++;\n      } catch (error) {\n        this.close();\n        throw error;\n      }\n    }\n\n    // Default to skip after max retries\n    return 'skip';\n  }\n\n  /**\n   * Parse user answer into an action\n   */\n  private parseAnswer(answer: string): ApprovalAction | null {\n    const normalized = answer.toLowerCase().trim();\n\n    switch (normalized) {\n      case 'y':\n      case 'yes':\n        return 'approve';\n      case 'n':\n      case 'no':\n        return 'reject';\n      case 'd':\n      case 'defer':\n        return 'defer';\n      case 'a':\n      case 'all':\n        return 'approveAll';\n      case 's':\n      case 'skip':\n        return 'skip';\n      case 'q':\n      case 'quit':\n        return 'quit';\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Promisified readline question\n   */\n  private question(prompt: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n      if (!this.rl) {\n        this.rl = readline.createInterface({\n          input: process.stdin,\n          output: process.stdout,\n        });\n\n        this.rl.on('close', () => {\n          // Handle readline being closed externally\n        });\n\n        this.rl.on('error', (err) => {\n          reject(err);\n        });\n      }\n\n      this.rl.question(prompt, (answer) => {\n        resolve(answer);\n      });\n    });\n  }\n\n  /**\n   * Create a mention edge in the database\n   */\n  private async createMentionEdge(mention: RankedMention): Promise<void> {\n    try {\n      await this.edgeRepo.create({\n        sourceId: this.sourceNodeId,\n        targetId: mention.targetId,\n        edgeType: 'mention',\n        provenance: 'user_approved',\n        strength: mention.confidence,\n        attributes: {\n          surfaceText: mention.surfaceText,\n          spanStart: mention.spanStart,\n          spanEnd: mention.spanEnd,\n          approvedAt: new Date().toISOString(),\n        },\n      });\n    } catch (error) {\n      throw new DatabaseError(\n        `Failed to create mention edge: ${error instanceof Error ? error.message : String(error)}`,\n        {\n          sourceId: this.sourceNodeId,\n          targetId: mention.targetId,\n        }\n      );\n    }\n  }\n\n  /**\n   * Close the readline interface\n   */\n  close(): void {\n    if (this.rl) {\n      this.rl.close();\n      this.rl = null;\n    }\n  }\n}\n\n/**\n * Batch approve mentions without interaction\n */\nexport async function batchApproveMentions(\n  mentions: RankedMention[],\n  sourceNodeId: string,\n  edgeRepo: EdgeRepository,\n  action: 'approve' | 'reject' | 'defer'\n): Promise<ApprovalResult[]> {\n  const results: ApprovalResult[] = [];\n\n  for (const mention of mentions) {\n    if (action === 'approve') {\n      await edgeRepo.create({\n        sourceId: sourceNodeId,\n        targetId: mention.targetId,\n        edgeType: 'mention',\n        provenance: 'user_approved',\n        strength: mention.confidence,\n        attributes: {\n          surfaceText: mention.surfaceText,\n          spanStart: mention.spanStart,\n          spanEnd: mention.spanEnd,\n          approvedAt: new Date().toISOString(),\n        },\n      });\n    }\n\n    results.push({ mention, action });\n  }\n\n  return results;\n}\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { ContextAssembler } from '../../retrieval/context/assembler.js';\nimport type { RetrievalQuery } from '../../core/types/index.js';\n\nexport const retrieveCommand = new Command('retrieve')\n  .description('GraphRAG retrieval for a query')\n  .argument('<query>', 'The query to retrieve context for')\n  .option('-n, --max-results <n>', 'Maximum results', '10')\n  .option('-d, --depth <n>', 'Graph expansion depth', '2')\n  .option('-b, --budget <n>', 'Node expansion budget', '30')\n  .option('--no-semantic', 'Disable semantic search')\n  .option('--no-lexical', 'Disable lexical search')\n  .option('--no-graph', 'Disable graph expansion')\n  .option('-t, --type <types>', 'Filter by node types (comma-separated)')\n  .option('-v, --verbose', 'Show detailed provenance')\n  .action(async (queryText: string, options) => {\n    try {\n      const ctx = await initContext();\n\n      // Check if embeddings are configured\n      if (!ctx.config.embeddings.apiKey && ctx.config.embeddings.provider === 'openai') {\n        console.log('Note: OpenAI API key not configured. Semantic search disabled.');\n        console.log('Set OPENAI_API_KEY or configure in .zettelscript/config.yaml\\n');\n      }\n\n      const query: RetrievalQuery = {\n        text: queryText,\n        maxResults: parseInt(options.maxResults, 10),\n        expansion: {\n          maxDepth: parseInt(options.depth, 10),\n          budget: parseInt(options.budget, 10),\n        },\n      };\n\n      if (options.type) {\n        query.filters = {\n          nodeTypes: options.type.split(',').map((t: string) => t.trim()),\n        };\n      }\n\n      console.log(`Retrieving: \"${queryText}\"\\n`);\n\n      const assembler = new ContextAssembler({\n        nodeRepository: ctx.nodeRepository,\n        edgeRepository: ctx.edgeRepository,\n        chunkRepository: ctx.chunkRepository,\n        graphEngine: ctx.graphEngine,\n        config: ctx.config.retrieval,\n      });\n\n      const result = await assembler.retrieve(query);\n\n      if (result.chunks.length === 0) {\n        console.log('No relevant content found.');\n        console.log('\\nTips:');\n        console.log('  - Run \"zettel index\" to index your vault');\n        console.log('  - Try broader search terms');\n        console.log('  - Use \"zettel query stats\" to check indexed content');\n      } else {\n        // Show context\n        console.log('=== Retrieved Context ===\\n');\n        console.log(result.context);\n        console.log('\\n=== End Context ===\\n');\n\n        // Show provenance\n        if (options.verbose && result.provenance.length > 0) {\n          console.log('Sources:');\n          for (const p of result.provenance) {\n            const contribution = (p.contribution * 100).toFixed(0);\n            console.log(`  [${contribution}%] ${p.path}`);\n          }\n        } else {\n          console.log(`Sources: ${result.provenance.length} nodes`);\n        }\n\n        // Show match types\n        const matchTypes = new Map<string, number>();\n        for (const chunk of result.chunks) {\n          matchTypes.set(chunk.matchType, (matchTypes.get(chunk.matchType) || 0) + 1);\n        }\n\n        console.log('\\nMatch breakdown:');\n        for (const [type, count] of matchTypes) {\n          console.log(`  ${type}: ${count}`);\n        }\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Retrieval failed:', error);\n      process.exit(1);\n    }\n  });\n","import type { Edge, EdgeType, ZettelScriptConfig } from '../../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../../core/types/index.js';\nimport { EdgeRepository } from '../../storage/database/repositories/index.js';\n\nexport interface ExpansionOptions {\n  maxDepth: number;\n  budget: number;\n  edgeTypes: EdgeType[];\n  decayFactor: number;\n  includeIncoming: boolean;\n  scoreThreshold?: number;\n}\n\nexport interface ExpandedNode {\n  nodeId: string;\n  depth: number;\n  score: number;\n  path: string[];\n  edgeType: EdgeType | null;\n}\n\nexport interface GraphExpanderOptions {\n  edgeRepository: EdgeRepository;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Bounded graph expansion for GraphRAG retrieval\n *\n * Algorithm (from spec 7.3):\n * frontier = seed_nodes\n * for depth in 1..max_depth:\n *     if visited_count >= budget: break\n *     for node in frontier:\n *         for edge in outgoing_edges(node, allowed_types):\n *             score = current_score * edge_weight * decay^depth\n *             accumulated_scores[edge.target] = max(existing, score)\n *     frontier = newly_discovered_nodes\n */\nexport class GraphExpander {\n  private edgeRepo: EdgeRepository;\n  private config: ZettelScriptConfig;\n\n  constructor(options: GraphExpanderOptions | EdgeRepository) {\n    // Support both old and new constructor signature for backwards compatibility\n    if ('edgeRepository' in options) {\n      this.edgeRepo = options.edgeRepository;\n      this.config = options.config ?? DEFAULT_CONFIG;\n    } else {\n      this.edgeRepo = options;\n      this.config = DEFAULT_CONFIG;\n    }\n  }\n\n  /**\n   * Expand from seed nodes with bounded traversal\n   */\n  async expand(\n    seeds: Array<{ nodeId: string; score: number }>,\n    options: ExpansionOptions\n  ): Promise<ExpandedNode[]> {\n    const {\n      maxDepth,\n      budget,\n      edgeTypes,\n      decayFactor,\n      includeIncoming,\n      scoreThreshold = this.config.graph.scoreThreshold,\n    } = options;\n\n    if (seeds.length === 0) return [];\n\n    // Track accumulated scores and paths\n    const accumulated = new Map<string, ExpandedNode>();\n\n    // Initialize with seeds\n    let frontier = new Set<string>();\n    for (const seed of seeds) {\n      accumulated.set(seed.nodeId, {\n        nodeId: seed.nodeId,\n        depth: 0,\n        score: seed.score,\n        path: [seed.nodeId],\n        edgeType: null,\n      });\n      frontier.add(seed.nodeId);\n    }\n\n    // BFS with decay\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (accumulated.size >= budget) break;\n      if (frontier.size === 0) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (accumulated.size >= budget) break;\n\n        const current = accumulated.get(nodeId);\n        if (!current) continue;\n\n        // Get edges\n        const edges = await this.getEdges(nodeId, edgeTypes, includeIncoming);\n\n        for (const edge of edges) {\n          if (accumulated.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Calculate score with decay\n          const edgeWeight = edge.strength ?? 1.0;\n          const newScore = current.score * edgeWeight * Math.pow(decayFactor, depth);\n\n          // Skip if below threshold\n          if (newScore < scoreThreshold) continue;\n\n          const existing = accumulated.get(targetId);\n\n          if (!existing || newScore > existing.score) {\n            accumulated.set(targetId, {\n              nodeId: targetId,\n              depth,\n              score: newScore,\n              path: [...current.path, targetId],\n              edgeType: edge.edgeType as EdgeType,\n            });\n\n            if (!existing) {\n              newFrontier.add(targetId);\n            }\n          }\n        }\n      }\n\n      frontier = newFrontier;\n    }\n\n    // Convert to array and sort by score\n    return Array.from(accumulated.values())\n      .sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Get edges for a node\n   */\n  private async getEdges(\n    nodeId: string,\n    edgeTypes: EdgeType[],\n    includeIncoming: boolean\n  ): Promise<Edge[]> {\n    const outgoing = await this.edgeRepo.findOutgoing(nodeId, edgeTypes);\n\n    if (!includeIncoming) {\n      return outgoing;\n    }\n\n    const incoming = await this.edgeRepo.findIncoming(nodeId, edgeTypes);\n    return [...outgoing, ...incoming];\n  }\n\n  /**\n   * Expand with prioritized edge types\n   * Some edge types are more valuable for retrieval\n   */\n  async expandPrioritized(\n    seeds: Array<{ nodeId: string; score: number }>,\n    options: ExpansionOptions,\n    edgeWeights: Partial<Record<EdgeType, number>>\n  ): Promise<ExpandedNode[]> {\n    const {\n      maxDepth,\n      budget,\n      edgeTypes,\n      decayFactor,\n      includeIncoming,\n      scoreThreshold = this.config.graph.scoreThreshold,\n    } = options;\n\n    if (seeds.length === 0) return [];\n\n    const accumulated = new Map<string, ExpandedNode>();\n\n    let frontier = new Set<string>();\n    for (const seed of seeds) {\n      accumulated.set(seed.nodeId, {\n        nodeId: seed.nodeId,\n        depth: 0,\n        score: seed.score,\n        path: [seed.nodeId],\n        edgeType: null,\n      });\n      frontier.add(seed.nodeId);\n    }\n\n    for (let depth = 1; depth <= maxDepth; depth++) {\n      if (accumulated.size >= budget) break;\n      if (frontier.size === 0) break;\n\n      const newFrontier = new Set<string>();\n\n      for (const nodeId of frontier) {\n        if (accumulated.size >= budget) break;\n\n        const current = accumulated.get(nodeId);\n        if (!current) continue;\n\n        const edges = await this.getEdges(nodeId, edgeTypes, includeIncoming);\n\n        for (const edge of edges) {\n          if (accumulated.size >= budget) break;\n\n          const targetId = edge.sourceId === nodeId ? edge.targetId : edge.sourceId;\n\n          // Apply edge type weight\n          const typeWeight = edgeWeights[edge.edgeType as EdgeType] ?? 1.0;\n          const edgeWeight = (edge.strength ?? 1.0) * typeWeight;\n          const newScore = current.score * edgeWeight * Math.pow(decayFactor, depth);\n\n          if (newScore < scoreThreshold) continue;\n\n          const existing = accumulated.get(targetId);\n\n          if (!existing || newScore > existing.score) {\n            accumulated.set(targetId, {\n              nodeId: targetId,\n              depth,\n              score: newScore,\n              path: [...current.path, targetId],\n              edgeType: edge.edgeType as EdgeType,\n            });\n\n            if (!existing) {\n              newFrontier.add(targetId);\n            }\n          }\n        }\n      }\n\n      frontier = newFrontier;\n    }\n\n    return Array.from(accumulated.values())\n      .sort((a, b) => b.score - a.score);\n  }\n\n  /**\n   * Get expansion statistics\n   */\n  getExpansionStats(results: ExpandedNode[]): {\n    totalNodes: number;\n    maxDepth: number;\n    avgScore: number;\n    edgeTypeCounts: Record<string, number>;\n  } {\n    if (results.length === 0) {\n      return {\n        totalNodes: 0,\n        maxDepth: 0,\n        avgScore: 0,\n        edgeTypeCounts: {},\n      };\n    }\n\n    const edgeTypeCounts: Record<string, number> = {};\n    let totalScore = 0;\n    let maxDepth = 0;\n\n    for (const result of results) {\n      totalScore += result.score;\n      maxDepth = Math.max(maxDepth, result.depth);\n\n      if (result.edgeType) {\n        edgeTypeCounts[result.edgeType] = (edgeTypeCounts[result.edgeType] || 0) + 1;\n      }\n    }\n\n    return {\n      totalNodes: results.length,\n      maxDepth,\n      avgScore: totalScore / results.length,\n      edgeTypeCounts,\n    };\n  }\n}\n","/**\n * Reciprocal Rank Fusion (RRF) implementation\n *\n * Algorithm:\n * for each result in semantic_results:\n *     rrf_score += semantic_weight * (1 / (k + rank))\n * for each result in lexical_results:\n *     rrf_score += lexical_weight * (1 / (k + rank))\n * sort by rrf_score descending\n */\n\nexport interface RankedItem {\n  id: string;\n  score: number;\n  source: string;\n}\n\nexport interface FusionResult {\n  id: string;\n  score: number;\n  sources: string[];\n  ranks: Map<string, number>;\n}\n\nexport interface RRFOptions {\n  k?: number; // RRF constant (default 60)\n  weights?: Record<string, number>; // Weights per source\n}\n\n/**\n * Perform Reciprocal Rank Fusion on multiple result lists\n */\nexport function reciprocalRankFusion(\n  resultLists: Map<string, RankedItem[]>,\n  options: RRFOptions = {}\n): FusionResult[] {\n  const k = options.k ?? 60;\n  const weights = options.weights ?? {};\n\n  // Collect scores for each item\n  const scores = new Map<string, {\n    score: number;\n    sources: Set<string>;\n    ranks: Map<string, number>;\n  }>();\n\n  for (const [source, items] of resultLists) {\n    const weight = weights[source] ?? 1.0;\n\n    for (let rank = 0; rank < items.length; rank++) {\n      const item = items[rank];\n      if (!item) continue;\n\n      const rrfScore = weight * (1 / (k + rank + 1)); // rank is 0-indexed, formula expects 1-indexed\n\n      const existing = scores.get(item.id);\n      if (existing) {\n        existing.score += rrfScore;\n        existing.sources.add(source);\n        existing.ranks.set(source, rank + 1);\n      } else {\n        scores.set(item.id, {\n          score: rrfScore,\n          sources: new Set([source]),\n          ranks: new Map([[source, rank + 1]]),\n        });\n      }\n    }\n  }\n\n  // Convert to results and sort\n  const results: FusionResult[] = [];\n  for (const [id, data] of scores) {\n    results.push({\n      id,\n      score: data.score,\n      sources: Array.from(data.sources),\n      ranks: data.ranks,\n    });\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Simple score combination (weighted average)\n */\nexport function weightedScoreFusion(\n  resultLists: Map<string, RankedItem[]>,\n  weights: Record<string, number>\n): FusionResult[] {\n  const scores = new Map<string, {\n    totalScore: number;\n    totalWeight: number;\n    sources: Set<string>;\n    ranks: Map<string, number>;\n  }>();\n\n  for (const [source, items] of resultLists) {\n    const weight = weights[source] ?? 1.0;\n\n    for (let rank = 0; rank < items.length; rank++) {\n      const item = items[rank];\n      if (!item) continue;\n\n      const existing = scores.get(item.id);\n      if (existing) {\n        existing.totalScore += item.score * weight;\n        existing.totalWeight += weight;\n        existing.sources.add(source);\n        existing.ranks.set(source, rank + 1);\n      } else {\n        scores.set(item.id, {\n          totalScore: item.score * weight,\n          totalWeight: weight,\n          sources: new Set([source]),\n          ranks: new Map([[source, rank + 1]]),\n        });\n      }\n    }\n  }\n\n  const results: FusionResult[] = [];\n  for (const [id, data] of scores) {\n    results.push({\n      id,\n      score: data.totalScore / data.totalWeight,\n      sources: Array.from(data.sources),\n      ranks: data.ranks,\n    });\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n\n/**\n * Interleave results from multiple sources\n */\nexport function interleave(\n  resultLists: Map<string, RankedItem[]>,\n  maxResults: number\n): FusionResult[] {\n  const seen = new Set<string>();\n  const results: FusionResult[] = [];\n  const sources = Array.from(resultLists.keys());\n  const indices = new Map(sources.map(s => [s, 0]));\n\n  while (results.length < maxResults) {\n    let added = false;\n\n    for (const source of sources) {\n      const items = resultLists.get(source) ?? [];\n      let idx = indices.get(source) ?? 0;\n\n      while (idx < items.length) {\n        const item = items[idx];\n        idx++;\n        indices.set(source, idx);\n\n        if (!item || seen.has(item.id)) continue;\n\n        seen.add(item.id);\n        results.push({\n          id: item.id,\n          score: item.score,\n          sources: [source],\n          ranks: new Map([[source, idx]]),\n        });\n        added = true;\n        break;\n      }\n\n      if (results.length >= maxResults) break;\n    }\n\n    if (!added) break;\n  }\n\n  return results;\n}\n\n/**\n * Combine fusion results with score boosting for items in multiple sources\n */\nexport function boostOverlap(\n  results: FusionResult[],\n  boostFactor: number = 1.2\n): FusionResult[] {\n  return results.map(r => ({\n    ...r,\n    score: r.score * Math.pow(boostFactor, r.sources.length - 1),\n  })).sort((a, b) => b.score - a.score);\n}\n","import type { Chunk, Node, RetrievalQuery, RetrievalResult, EdgeType } from '../../core/types/index.js';\nimport { NodeRepository, EdgeRepository, ChunkRepository } from '../../storage/database/repositories/index.js';\nimport type { GraphEngine } from '../../core/graph/engine.js';\nimport { GraphExpander, type ExpandedNode } from '../expansion/graph-expander.js';\nimport { reciprocalRankFusion, type RankedItem } from '../fusion/rrf.js';\n\nexport interface ContextAssemblerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  chunkRepository: ChunkRepository;\n  graphEngine: GraphEngine;\n  config: {\n    defaultMaxResults: number;\n    semanticWeight: number;\n    lexicalWeight: number;\n    graphWeight: number;\n    rrfK: number;\n    expansionMaxDepth: number;\n    expansionBudget: number;\n  };\n}\n\ninterface ScoredChunk {\n  chunk: Chunk;\n  node: Node;\n  score: number;\n  matchType: 'semantic' | 'lexical' | 'graph';\n}\n\n/**\n * Assembles context from multiple retrieval strategies\n */\nexport class ContextAssembler {\n  private nodeRepo: NodeRepository;\n  private chunkRepo: ChunkRepository;\n  private expander: GraphExpander;\n  private config: ContextAssemblerOptions['config'];\n\n  constructor(options: ContextAssemblerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.chunkRepo = options.chunkRepository;\n    this.expander = new GraphExpander(options.edgeRepository);\n    this.config = options.config;\n  }\n\n  /**\n   * Main retrieval function\n   */\n  async retrieve(query: RetrievalQuery): Promise<RetrievalResult> {\n    const maxResults = query.maxResults ?? this.config.defaultMaxResults;\n\n    // Step 1: Seed retrieval (lexical for now, semantic when embeddings available)\n    const lexicalResults = await this.lexicalSearch(query.text, maxResults * 2);\n\n    // Step 2: Apply filters\n    const filteredLexical = await this.applyFilters(lexicalResults, query.filters);\n\n    // Step 3: Extract seed nodes\n    const seedNodes = this.extractSeeds(filteredLexical);\n\n    // Step 4: Graph expansion\n    const expansionOptions = {\n      maxDepth: query.expansion?.maxDepth ?? this.config.expansionMaxDepth,\n      budget: query.expansion?.budget ?? this.config.expansionBudget,\n      edgeTypes: (query.expansion?.edgeTypes ?? ['explicit_link', 'sequence', 'hierarchy']) as EdgeType[],\n      decayFactor: query.expansion?.decayFactor ?? 0.7,\n      includeIncoming: true,\n    };\n\n    const expandedNodes = await this.expander.expand(seedNodes, expansionOptions);\n\n    // Step 5: Fetch chunks for expanded nodes\n    const graphChunks = await this.fetchChunksForNodes(expandedNodes);\n\n    // Step 6: Fuse results\n    const fusedChunks = this.fuseResults(filteredLexical, graphChunks, maxResults);\n\n    // Step 7: Assemble context\n    const context = await this.assembleContext(fusedChunks);\n\n    // Step 8: Build provenance\n    const provenance = this.buildProvenance(fusedChunks);\n\n    return {\n      chunks: fusedChunks.map(sc => ({\n        chunk: sc.chunk,\n        node: sc.node,\n        score: sc.score,\n        matchType: sc.matchType,\n      })),\n      context,\n      provenance,\n    };\n  }\n\n  /**\n   * Lexical search using FTS5\n   */\n  private async lexicalSearch(query: string, limit: number): Promise<ScoredChunk[]> {\n    const ftsResults = this.chunkRepo.searchBM25(query, limit);\n\n    if (ftsResults.length === 0) {\n      return [];\n    }\n\n    // Fetch full chunk and node data\n    const chunkIds = ftsResults.map(r => r.chunkId);\n    const chunks = await this.chunkRepo.findByIds(chunkIds);\n    const chunkMap = new Map(chunks.map(c => [c.chunkId, c]));\n\n    const nodeIds = [...new Set(ftsResults.map(r => r.nodeId))];\n    const nodes = await this.nodeRepo.findByIds(nodeIds);\n    const nodeMap = new Map(nodes.map(n => [n.nodeId, n]));\n\n    const results: ScoredChunk[] = [];\n\n    // Normalize scores\n    const maxScore = Math.max(...ftsResults.map(r => Math.abs(r.score)));\n\n    for (const fts of ftsResults) {\n      const chunk = chunkMap.get(fts.chunkId);\n      const node = nodeMap.get(fts.nodeId);\n\n      if (chunk && node) {\n        results.push({\n          chunk,\n          node,\n          score: maxScore > 0 ? Math.abs(fts.score) / maxScore : 0.5,\n          matchType: 'lexical',\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Apply query filters\n   */\n  private async applyFilters(\n    chunks: ScoredChunk[],\n    filters?: RetrievalQuery['filters']\n  ): Promise<ScoredChunk[]> {\n    if (!filters) return chunks;\n\n    return chunks.filter(sc => {\n      // Filter by node type\n      if (filters.nodeTypes && !filters.nodeTypes.includes(sc.node.type)) {\n        return false;\n      }\n\n      // Filter by excluded nodes\n      if (filters.excludeNodeIds?.includes(sc.node.nodeId)) {\n        return false;\n      }\n\n      // Filter by date range\n      if (filters.dateRange) {\n        const nodeDate = new Date(sc.node.updatedAt);\n        if (filters.dateRange.start && nodeDate < new Date(filters.dateRange.start)) {\n          return false;\n        }\n        if (filters.dateRange.end && nodeDate > new Date(filters.dateRange.end)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Extract seed nodes from initial results\n   */\n  private extractSeeds(chunks: ScoredChunk[]): Array<{ nodeId: string; score: number }> {\n    // Aggregate scores by node\n    const nodeScores = new Map<string, number>();\n\n    for (const sc of chunks) {\n      const current = nodeScores.get(sc.node.nodeId) ?? 0;\n      nodeScores.set(sc.node.nodeId, Math.max(current, sc.score));\n    }\n\n    return Array.from(nodeScores.entries())\n      .map(([nodeId, score]) => ({ nodeId, score }))\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 10); // Top 10 seeds\n  }\n\n  /**\n   * Fetch chunks for expanded nodes\n   */\n  private async fetchChunksForNodes(expanded: ExpandedNode[]): Promise<ScoredChunk[]> {\n    const results: ScoredChunk[] = [];\n\n    for (const exp of expanded) {\n      if (exp.depth === 0) continue; // Skip seeds, already have their chunks\n\n      const chunks = await this.chunkRepo.findByNodeId(exp.nodeId);\n      const node = await this.nodeRepo.findById(exp.nodeId);\n\n      if (!node) continue;\n\n      for (const chunk of chunks) {\n        results.push({\n          chunk,\n          node,\n          score: exp.score,\n          matchType: 'graph',\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Fuse lexical and graph results using RRF\n   */\n  private fuseResults(\n    lexical: ScoredChunk[],\n    graph: ScoredChunk[],\n    maxResults: number\n  ): ScoredChunk[] {\n    // Convert to ranked items\n    const lexicalItems: RankedItem[] = lexical.map(sc => ({\n      id: sc.chunk.chunkId,\n      score: sc.score,\n      source: 'lexical',\n    }));\n\n    const graphItems: RankedItem[] = graph.map(sc => ({\n      id: sc.chunk.chunkId,\n      score: sc.score,\n      source: 'graph',\n    }));\n\n    // Create chunk lookup\n    const chunkLookup = new Map<string, ScoredChunk>();\n    for (const sc of [...lexical, ...graph]) {\n      const existing = chunkLookup.get(sc.chunk.chunkId);\n      if (!existing || sc.score > existing.score) {\n        chunkLookup.set(sc.chunk.chunkId, sc);\n      }\n    }\n\n    // Perform RRF\n    const resultLists = new Map([\n      ['lexical', lexicalItems],\n      ['graph', graphItems],\n    ]);\n\n    const fused = reciprocalRankFusion(resultLists, {\n      k: this.config.rrfK,\n      weights: {\n        lexical: this.config.lexicalWeight,\n        graph: this.config.graphWeight,\n      },\n    });\n\n    // Map back to ScoredChunk\n    const results: ScoredChunk[] = [];\n    for (const f of fused.slice(0, maxResults)) {\n      const sc = chunkLookup.get(f.id);\n      if (sc) {\n        results.push({\n          ...sc,\n          score: f.score,\n          matchType: f.sources.length > 1 ? 'lexical' : (f.sources[0] as 'lexical' | 'graph'),\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Assemble context string from chunks\n   */\n  private async assembleContext(chunks: ScoredChunk[]): Promise<string> {\n    if (chunks.length === 0) {\n      return '';\n    }\n\n    // Group chunks by node for better organization\n    const nodeChunks = new Map<string, ScoredChunk[]>();\n    for (const sc of chunks) {\n      const existing = nodeChunks.get(sc.node.nodeId) ?? [];\n      existing.push(sc);\n      nodeChunks.set(sc.node.nodeId, existing);\n    }\n\n    const sections: string[] = [];\n\n    for (const [, nodeChunkList] of nodeChunks) {\n      const node = nodeChunkList[0]?.node;\n      if (!node) continue;\n\n      // Sort chunks by offset\n      nodeChunkList.sort((a, b) => a.chunk.offsetStart - b.chunk.offsetStart);\n\n      const chunkTexts = nodeChunkList.map(sc => sc.chunk.text);\n      const combinedText = chunkTexts.join('\\n\\n');\n\n      sections.push(`## ${node.title}\\n\\n${combinedText}`);\n    }\n\n    return sections.join('\\n\\n---\\n\\n');\n  }\n\n  /**\n   * Build provenance information\n   */\n  private buildProvenance(chunks: ScoredChunk[]): RetrievalResult['provenance'] {\n    // Aggregate contribution by node\n    const nodeContributions = new Map<string, { path: string; score: number }>();\n\n    for (const sc of chunks) {\n      const existing = nodeContributions.get(sc.node.nodeId);\n      if (existing) {\n        existing.score += sc.score;\n      } else {\n        nodeContributions.set(sc.node.nodeId, {\n          path: sc.node.path,\n          score: sc.score,\n        });\n      }\n    }\n\n    // Normalize contributions\n    const totalScore = Array.from(nodeContributions.values())\n      .reduce((sum, n) => sum + n.score, 0);\n\n    return Array.from(nodeContributions.entries())\n      .map(([nodeId, data]) => ({\n        nodeId,\n        path: data.path,\n        contribution: totalScore > 0 ? data.score / totalScore : 0,\n      }))\n      .sort((a, b) => b.contribution - a.contribution);\n  }\n}\n","import { Command } from 'commander';\nimport { initContext } from '../utils.js';\nimport { ImpactAnalyzer } from '../../engine/manuscript/impact-analyzer.js';\nimport { RewriteOrchestrator } from '../../engine/manuscript/rewrite-orchestrator.js';\nimport { createLLMProvider, buildRewritePrompt, type RewriteContext as LLMRewriteContext } from '../../llm/index.js';\n\nexport const rewriteCommand = new Command('rewrite')\n  .description('Analyze and orchestrate scene rewrites')\n  .argument('<scene>', 'The scene to rewrite (path or title)')\n  .option('-g, --goal <goal>', 'Rewrite goal description')\n  .option('--analyze-only', 'Only show impact analysis, do not generate rewrite')\n  .option('--dry-run', 'Show what would change without applying')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (sceneIdentifier: string, options) => {\n    try {\n      const ctx = await initContext();\n\n      if (!ctx.config.manuscript.enabled) {\n        console.log('Manuscript mode not enabled.');\n        console.log('Enable with: zettel init --manuscript');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Find the scene node\n      let scene = await ctx.nodeRepository.findByPath(sceneIdentifier);\n      if (!scene) {\n        const nodes = await ctx.nodeRepository.findByTitle(sceneIdentifier);\n        scene = nodes.find(n => n.type === 'scene') ?? nodes[0] ?? null;\n      }\n\n      if (!scene) {\n        console.log(`Scene not found: ${sceneIdentifier}`);\n        ctx.connectionManager.close();\n        return;\n      }\n\n      if (scene.type !== 'scene') {\n        console.log(`Warning: Node \"${scene.title}\" is type \"${scene.type}\", not \"scene\".`);\n      }\n\n      console.log(`Scene: ${scene.title} (${scene.path})\\n`);\n\n      // Impact analysis\n      const analyzer = new ImpactAnalyzer({\n        nodeRepository: ctx.nodeRepository,\n        edgeRepository: ctx.edgeRepository,\n        graphEngine: ctx.graphEngine,\n      });\n\n      console.log('Analyzing impact...\\n');\n      const impact = await analyzer.analyze(scene.nodeId);\n\n      // Display impact analysis\n      console.log('Impact Analysis:');\n      console.log(`  Direct dependencies:    ${impact.directImpact.length}`);\n      console.log(`  Transitive impact:      ${impact.transitiveImpact.length}`);\n      console.log(`  POV-related scenes:     ${impact.povImpact.length}`);\n      console.log(`  Timeline-adjacent:      ${impact.timelineImpact.length}`);\n      console.log(`  Affected characters:    ${impact.characterImpact.length}`);\n\n      if (options.verbose) {\n        if (impact.directImpact.length > 0) {\n          console.log('\\nDirect dependencies:');\n          const directNodes = await ctx.nodeRepository.findByIds(impact.directImpact);\n          for (const n of directNodes.slice(0, 10)) {\n            console.log(`  - ${n.title}`);\n          }\n        }\n\n        if (impact.povImpact.length > 0) {\n          console.log('\\nPOV-related scenes:');\n          const povNodes = await ctx.nodeRepository.findByIds(impact.povImpact);\n          for (const n of povNodes.slice(0, 10)) {\n            console.log(`  - ${n.title}`);\n          }\n        }\n\n        if (impact.characterImpact.length > 0) {\n          console.log('\\nAffected characters:');\n          for (const c of impact.characterImpact.slice(0, 10)) {\n            console.log(`  - ${c}`);\n          }\n        }\n      }\n\n      if (options.analyzeOnly) {\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Rewrite orchestration\n      if (!options.goal) {\n        console.log('\\nSpecify a rewrite goal with --goal \"<goal>\"');\n        console.log('Example: zettel rewrite \"Chapter 1\" --goal \"Add more tension\"');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`\\nRewrite goal: ${options.goal}\\n`);\n\n      const orchestrator = new RewriteOrchestrator({\n        nodeRepository: ctx.nodeRepository,\n        impact,\n      });\n\n      console.log('Gathering context for rewrite...\\n');\n      const context = await orchestrator.gatherContext(scene.nodeId, options.goal);\n\n      console.log('Context includes:');\n      console.log(`  - Scene content: ${context.sceneContent.length} chars`);\n      console.log(`  - Character context: ${context.characterContext.length} items`);\n      console.log(`  - Timeline context: ${context.timelineContext.length} items`);\n      console.log(`  - Related content: ${context.relatedContent.length} items`);\n\n      if (options.dryRun) {\n        console.log('\\n[Dry run] Would send to LLM for rewrite suggestions.');\n        console.log('Context would include the above information.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Try to create LLM provider\n      const llmProvider = createLLMProvider(ctx.config.llm);\n\n      if (!llmProvider) {\n        console.log('\\nLLM not configured. Add to config.yaml:');\n        console.log('  llm:');\n        console.log('    provider: openai  # or ollama');\n        console.log('    model: gpt-4');\n        console.log('    apiKey: your-api-key  # for openai');\n        console.log('\\nManual rewrite context has been gathered and displayed above.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      // Build rewrite context for LLM\n      const povChar = context.sceneMetadata?.pov;\n      const rewriteContext: LLMRewriteContext = {\n        sceneTitle: scene.title,\n        sceneContent: context.sceneContent,\n        goal: options.goal,\n        characterContext: context.characterContext.map(c => ({\n          name: c.name,\n          details: c.description,\n        })),\n        timelineContext: context.timelineContext.map(t => ({\n          title: t.title,\n          position: String(t.order),\n        })),\n        relatedContent: context.relatedContent.map(r => ({\n          title: r.title,\n          excerpt: r.excerpt,\n        })),\n        ...(povChar && { povCharacter: povChar }),\n      };\n\n      console.log('\\nGenerating rewrite suggestions...\\n');\n\n      try {\n        const prompt = buildRewritePrompt(rewriteContext);\n        const suggestions = await llmProvider.complete(prompt);\n\n        console.log('Rewrite Suggestions:');\n        console.log('='.repeat(50));\n        console.log(suggestions);\n        console.log('='.repeat(50));\n      } catch (error) {\n        console.error('LLM request failed:', error instanceof Error ? error.message : error);\n        console.log('\\nManual rewrite context has been gathered and displayed above.');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Rewrite failed:', error);\n      process.exit(1);\n    }\n  });\n","import type { ImpactAnalysis, Frontmatter, ZettelScriptConfig } from '../../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../../core/types/index.js';\nimport { NodeRepository, EdgeRepository } from '../../storage/database/repositories/index.js';\nimport { GraphEngine } from '../../core/graph/engine.js';\n\nexport interface ImpactAnalyzerOptions {\n  nodeRepository: NodeRepository;\n  edgeRepository: EdgeRepository;\n  graphEngine: GraphEngine;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Analyzes the impact of changes to a scene\n */\nexport class ImpactAnalyzer {\n  private nodeRepo: NodeRepository;\n  private edgeRepo: EdgeRepository;\n  private graphEngine: GraphEngine;\n  private config: ZettelScriptConfig;\n\n  constructor(options: ImpactAnalyzerOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.edgeRepo = options.edgeRepository;\n    this.graphEngine = options.graphEngine;\n    this.config = options.config ?? DEFAULT_CONFIG;\n  }\n\n  /**\n   * Analyze the impact of modifying a scene\n   */\n  async analyze(sceneNodeId: string): Promise<ImpactAnalysis> {\n    const scene = await this.nodeRepo.findById(sceneNodeId);\n    if (!scene) {\n      return {\n        directImpact: [],\n        transitiveImpact: [],\n        povImpact: [],\n        timelineImpact: [],\n        characterImpact: [],\n      };\n    }\n\n    const metadata = scene.metadata as Frontmatter | undefined;\n\n    // Direct impact: nodes directly linked to this scene\n    const directImpact = await this.getDirectImpact(sceneNodeId);\n\n    // Transitive impact: nodes reachable via graph expansion\n    const transitiveImpact = await this.getTransitiveImpact(sceneNodeId, directImpact);\n\n    // POV impact: other scenes with the same POV\n    const povImpact = metadata?.pov\n      ? await this.getPovImpact(metadata.pov, sceneNodeId)\n      : [];\n\n    // Timeline impact: adjacent scenes in timeline\n    const timelineImpact = metadata?.scene_order !== undefined\n      ? await this.getTimelineImpact(metadata.scene_order, sceneNodeId)\n      : [];\n\n    // Character impact: characters whose knowledge might change\n    const characterImpact = await this.getCharacterImpact(sceneNodeId, metadata);\n\n    return {\n      directImpact,\n      transitiveImpact,\n      povImpact,\n      timelineImpact,\n      characterImpact,\n    };\n  }\n\n  /**\n   * Get directly linked nodes\n   */\n  private async getDirectImpact(nodeId: string): Promise<string[]> {\n    const outgoing = await this.edgeRepo.findOutgoing(nodeId);\n    const incoming = await this.edgeRepo.findIncoming(nodeId);\n\n    const impacted = new Set<string>();\n\n    for (const edge of outgoing) {\n      impacted.add(edge.targetId);\n    }\n\n    for (const edge of incoming) {\n      impacted.add(edge.sourceId);\n    }\n\n    return Array.from(impacted);\n  }\n\n  /**\n   * Get transitively impacted nodes via graph expansion\n   */\n  private async getTransitiveImpact(\n    nodeId: string,\n    directImpact: string[]\n  ): Promise<string[]> {\n    const expansion = await this.graphEngine.expandGraph({\n      seedNodes: [{ nodeId, score: 1 }],\n      maxDepth: this.config.impact.maxTransitiveDepth,\n      budget: this.config.impact.maxTransitiveBudget,\n      includeIncoming: true,\n    });\n\n    const directSet = new Set(directImpact);\n    directSet.add(nodeId);\n\n    // Return nodes that are transitively reachable but not direct\n    return expansion\n      .filter(e => e.depth > 1 && !directSet.has(e.nodeId))\n      .map(e => e.nodeId);\n  }\n\n  /**\n   * Get scenes with the same POV character\n   */\n  private async getPovImpact(povCharacter: string, excludeNodeId: string): Promise<string[]> {\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    return scenes\n      .filter(s => {\n        const meta = s.metadata as Frontmatter | undefined;\n        return meta?.pov === povCharacter && s.nodeId !== excludeNodeId;\n      })\n      .map(s => s.nodeId);\n  }\n\n  /**\n   * Get adjacent scenes in the timeline\n   */\n  private async getTimelineImpact(sceneOrder: number, excludeNodeId: string): Promise<string[]> {\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    // Get scenes within configured range of the current scene order\n    const range = this.config.impact.timelineRange;\n    return scenes\n      .filter(s => {\n        const meta = s.metadata as Frontmatter | undefined;\n        const order = meta?.scene_order;\n        if (order === undefined || s.nodeId === excludeNodeId) return false;\n        return Math.abs(order - sceneOrder) <= range;\n      })\n      .map(s => s.nodeId);\n  }\n\n  /**\n   * Get characters whose knowledge might be affected\n   */\n  private async getCharacterImpact(\n    sceneNodeId: string,\n    metadata: Frontmatter | undefined\n  ): Promise<string[]> {\n    const characters = new Set<string>();\n\n    // POV character\n    if (metadata?.pov) {\n      characters.add(metadata.pov);\n    }\n\n    // Characters listed in scene\n    if (metadata?.characters) {\n      for (const char of metadata.characters) {\n        characters.add(char);\n      }\n    }\n\n    // Characters linked from the scene\n    const links = await this.edgeRepo.findOutgoing(sceneNodeId);\n    for (const link of links) {\n      const targetNode = await this.nodeRepo.findById(link.targetId);\n      if (targetNode?.type === 'character') {\n        characters.add(targetNode.title);\n      }\n    }\n\n    return Array.from(characters);\n  }\n\n  /**\n   * Get detailed impact report\n   */\n  async getDetailedReport(sceneNodeId: string): Promise<{\n    impact: ImpactAnalysis;\n    summary: {\n      totalAffected: number;\n      directCount: number;\n      transitiveCount: number;\n      characterCount: number;\n      riskLevel: 'low' | 'medium' | 'high';\n    };\n    recommendations: string[];\n  }> {\n    const impact = await this.analyze(sceneNodeId);\n\n    const totalAffected = new Set([\n      ...impact.directImpact,\n      ...impact.transitiveImpact,\n      ...impact.povImpact,\n      ...impact.timelineImpact,\n    ]).size;\n\n    // Calculate risk level\n    let riskLevel: 'low' | 'medium' | 'high' = 'low';\n    if (totalAffected > 20 || impact.characterImpact.length > 5) {\n      riskLevel = 'high';\n    } else if (totalAffected > 10 || impact.characterImpact.length > 3) {\n      riskLevel = 'medium';\n    }\n\n    // Generate recommendations\n    const recommendations: string[] = [];\n\n    if (impact.povImpact.length > 3) {\n      recommendations.push('Review other scenes with the same POV for consistency');\n    }\n\n    if (impact.timelineImpact.length > 5) {\n      recommendations.push('Check timeline continuity with adjacent scenes');\n    }\n\n    if (impact.characterImpact.length > 0) {\n      recommendations.push(`Verify character knowledge for: ${impact.characterImpact.slice(0, 3).join(', ')}`);\n    }\n\n    if (impact.transitiveImpact.length > 10) {\n      recommendations.push('Large transitive impact - consider breaking change into smaller edits');\n    }\n\n    return {\n      impact,\n      summary: {\n        totalAffected,\n        directCount: impact.directImpact.length,\n        transitiveCount: impact.transitiveImpact.length,\n        characterCount: impact.characterImpact.length,\n        riskLevel,\n      },\n      recommendations,\n    };\n  }\n}\n","import type { Node, ImpactAnalysis, Frontmatter, ZettelScriptConfig } from '../../core/types/index.js';\nimport { DEFAULT_CONFIG } from '../../core/types/index.js';\nimport { NodeRepository } from '../../storage/database/repositories/index.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport interface RewriteContext {\n  sceneContent: string;\n  sceneMetadata: Frontmatter | null;\n  goal: string;\n  characterContext: Array<{ name: string; description: string; role: string }>;\n  timelineContext: Array<{ title: string; order: number; summary: string }>;\n  relatedContent: Array<{ title: string; type: string; excerpt: string }>;\n  constraints: string[];\n}\n\nexport interface RewriteOrchestratorOptions {\n  nodeRepository: NodeRepository;\n  impact: ImpactAnalysis;\n  vaultPath?: string;\n  config?: ZettelScriptConfig;\n}\n\n/**\n * Orchestrates scene rewrites by gathering context and managing constraints\n */\nexport class RewriteOrchestrator {\n  private nodeRepo: NodeRepository;\n  private impact: ImpactAnalysis;\n  private vaultPath: string;\n  private config: ZettelScriptConfig;\n\n  constructor(options: RewriteOrchestratorOptions) {\n    this.nodeRepo = options.nodeRepository;\n    this.impact = options.impact;\n    this.vaultPath = options.vaultPath || process.cwd();\n    this.config = options.config ?? DEFAULT_CONFIG;\n  }\n\n  /**\n   * Gather all context needed for a rewrite\n   */\n  async gatherContext(sceneNodeId: string, goal: string): Promise<RewriteContext> {\n    const scene = await this.nodeRepo.findById(sceneNodeId);\n    if (!scene) {\n      throw new Error(`Scene not found: ${sceneNodeId}`);\n    }\n\n    // Read scene content\n    const sceneContent = await this.readNodeContent(scene);\n    const sceneMetadata = scene.metadata as Frontmatter | null;\n\n    // Gather character context\n    const characterContext = await this.gatherCharacterContext(sceneNodeId, sceneMetadata);\n\n    // Gather timeline context\n    const timelineContext = await this.gatherTimelineContext(sceneMetadata?.scene_order);\n\n    // Gather related content\n    const relatedContent = await this.gatherRelatedContent(sceneNodeId);\n\n    // Build constraints\n    const constraints = this.buildConstraints(sceneMetadata);\n\n    return {\n      sceneContent,\n      sceneMetadata,\n      goal,\n      characterContext,\n      timelineContext,\n      relatedContent,\n      constraints,\n    };\n  }\n\n  /**\n   * Read content from a node's file\n   */\n  private async readNodeContent(node: Node): Promise<string> {\n    const filePath = path.join(this.vaultPath, node.path);\n    try {\n      return fs.readFileSync(filePath, 'utf-8');\n    } catch {\n      return '';\n    }\n  }\n\n  /**\n   * Gather context about characters in the scene\n   */\n  private async gatherCharacterContext(\n    _sceneNodeId: string,\n    sceneMetadata: Frontmatter | null\n  ): Promise<RewriteContext['characterContext']> {\n    const context: RewriteContext['characterContext'] = [];\n    const characterNames = new Set<string>();\n\n    // POV character\n    if (sceneMetadata?.pov) {\n      characterNames.add(sceneMetadata.pov);\n    }\n\n    // Listed characters\n    if (sceneMetadata?.characters) {\n      for (const char of sceneMetadata.characters) {\n        characterNames.add(char);\n      }\n    }\n\n    // Characters from impact analysis\n    for (const charName of this.impact.characterImpact) {\n      characterNames.add(charName);\n    }\n\n    // Fetch character nodes\n    for (const charName of characterNames) {\n      const nodes = await this.nodeRepo.findByTitle(charName);\n      const charNode = nodes.find(n => n.type === 'character');\n\n      if (charNode) {\n        const charMeta = charNode.metadata as { description?: string } | undefined;\n        const content = await this.readNodeContent(charNode);\n\n        // Extract first paragraph as description\n        const firstPara = content.split('\\n\\n')[1]?.trim() || charMeta?.description || '';\n\n        context.push({\n          name: charNode.title,\n          description: firstPara.slice(0, 500),\n          role: sceneMetadata?.pov === charName ? 'POV' : 'present',\n        });\n      }\n    }\n\n    return context;\n  }\n\n  /**\n   * Gather context about adjacent scenes in timeline\n   */\n  private async gatherTimelineContext(\n    sceneOrder: number | undefined\n  ): Promise<RewriteContext['timelineContext']> {\n    if (sceneOrder === undefined) return [];\n\n    const context: RewriteContext['timelineContext'] = [];\n    const scenes = await this.nodeRepo.findByType('scene');\n\n    // Get scenes within configured range of current (use half of impact range for context)\n    const range = Math.ceil(this.config.impact.timelineRange / 2);\n    const adjacentScenes = scenes\n      .filter(s => {\n        const meta = s.metadata as Frontmatter | undefined;\n        const order = meta?.scene_order;\n        return order !== undefined && Math.abs(order - sceneOrder) <= range && order !== sceneOrder;\n      })\n      .sort((a, b) => {\n        const orderA = (a.metadata as Frontmatter | undefined)?.scene_order ?? 0;\n        const orderB = (b.metadata as Frontmatter | undefined)?.scene_order ?? 0;\n        return orderA - orderB;\n      });\n\n    for (const scene of adjacentScenes) {\n      const meta = scene.metadata as Frontmatter | undefined;\n      const content = await this.readNodeContent(scene);\n\n      // Extract summary (first paragraph after frontmatter)\n      const parts = content.split('---');\n      const body = parts.length > 2 ? parts.slice(2).join('---') : content;\n      const summary = body.trim().split('\\n\\n')[0]?.slice(0, 300) || '';\n\n      context.push({\n        title: scene.title,\n        order: meta?.scene_order ?? 0,\n        summary,\n      });\n    }\n\n    return context;\n  }\n\n  /**\n   * Gather related content from direct links\n   */\n  private async gatherRelatedContent(\n    _sceneNodeId: string\n  ): Promise<RewriteContext['relatedContent']> {\n    const content: RewriteContext['relatedContent'] = [];\n\n    // Get directly linked nodes (excluding characters, handled separately)\n    const directIds = this.impact.directImpact;\n    const nodes = await this.nodeRepo.findByIds(directIds);\n\n    for (const node of nodes.slice(0, 10)) { // Limit to 10\n      if (node.type === 'character') continue;\n\n      const nodeContent = await this.readNodeContent(node);\n      const excerpt = nodeContent.trim().slice(0, 300);\n\n      content.push({\n        title: node.title,\n        type: node.type,\n        excerpt,\n      });\n    }\n\n    return content;\n  }\n\n  /**\n   * Build constraints based on metadata and impact\n   */\n  private buildConstraints(sceneMetadata: Frontmatter | null): string[] {\n    const constraints: string[] = [];\n\n    if (sceneMetadata?.pov) {\n      constraints.push(`Maintain POV: ${sceneMetadata.pov} - only reveal information they would know`);\n    }\n\n    if (sceneMetadata?.scene_order !== undefined) {\n      constraints.push(`Timeline position: Scene ${sceneMetadata.scene_order} - maintain continuity with adjacent scenes`);\n    }\n\n    if (sceneMetadata?.locations?.length) {\n      constraints.push(`Location: ${sceneMetadata.locations.join(', ')}`);\n    }\n\n    if (this.impact.characterImpact.length > 0) {\n      constraints.push(`Characters to consider: ${this.impact.characterImpact.join(', ')}`);\n    }\n\n    if (this.impact.povImpact.length > 5) {\n      constraints.push('This POV appears in many scenes - maintain character voice consistency');\n    }\n\n    return constraints;\n  }\n\n  /**\n   * Format context for LLM prompt\n   */\n  formatContextForPrompt(context: RewriteContext): string {\n    const sections: string[] = [];\n\n    // Goal\n    sections.push(`## Rewrite Goal\\n\\n${context.goal}`);\n\n    // Constraints\n    if (context.constraints.length > 0) {\n      sections.push(`## Constraints\\n\\n${context.constraints.map(c => `- ${c}`).join('\\n')}`);\n    }\n\n    // Characters\n    if (context.characterContext.length > 0) {\n      const charSection = context.characterContext.map(c =>\n        `### ${c.name} (${c.role})\\n\\n${c.description}`\n      ).join('\\n\\n');\n      sections.push(`## Characters\\n\\n${charSection}`);\n    }\n\n    // Timeline\n    if (context.timelineContext.length > 0) {\n      const timelineSection = context.timelineContext.map(t =>\n        `### Scene ${t.order}: ${t.title}\\n\\n${t.summary}`\n      ).join('\\n\\n');\n      sections.push(`## Timeline Context\\n\\n${timelineSection}`);\n    }\n\n    // Related content\n    if (context.relatedContent.length > 0) {\n      const relatedSection = context.relatedContent.map(r =>\n        `### ${r.title} (${r.type})\\n\\n${r.excerpt}`\n      ).join('\\n\\n');\n      sections.push(`## Related Content\\n\\n${relatedSection}`);\n    }\n\n    // Current scene\n    sections.push(`## Current Scene Content\\n\\n${context.sceneContent}`);\n\n    return sections.join('\\n\\n---\\n\\n');\n  }\n\n  /**\n   * Get a summary of the rewrite context\n   */\n  getContextSummary(context: RewriteContext): {\n    characterCount: number;\n    timelineSceneCount: number;\n    relatedContentCount: number;\n    constraintCount: number;\n    totalContextLength: number;\n  } {\n    return {\n      characterCount: context.characterContext.length,\n      timelineSceneCount: context.timelineContext.length,\n      relatedContentCount: context.relatedContent.length,\n      constraintCount: context.constraints.length,\n      totalContextLength: JSON.stringify(context).length,\n    };\n  }\n}\n","/**\n * LLM Provider abstraction for rewrite suggestions\n */\n/* global fetch */\n\nimport type { ZettelScriptConfig } from '../core/types/index.js';\n\nexport interface LLMOptions {\n  maxTokens?: number;\n  temperature?: number;\n}\n\nexport interface LLMProvider {\n  name: string;\n  complete(prompt: string, options?: LLMOptions): Promise<string>;\n}\n\n/**\n * OpenAI-compatible LLM provider\n */\nexport class OpenAILLMProvider implements LLMProvider {\n  name = 'openai';\n  private apiKey: string;\n  private baseUrl: string;\n  private model: string;\n  private defaultMaxTokens: number;\n  private defaultTemperature: number;\n\n  constructor(config: ZettelScriptConfig['llm']) {\n    if (!config.apiKey) {\n      throw new Error('OpenAI API key is required');\n    }\n    this.apiKey = config.apiKey;\n    this.baseUrl = config.baseUrl ?? 'https://api.openai.com/v1';\n    this.model = config.model;\n    this.defaultMaxTokens = config.maxTokens ?? 2048;\n    this.defaultTemperature = config.temperature ?? 0.7;\n  }\n\n  async complete(prompt: string, options?: LLMOptions): Promise<string> {\n    const maxTokens = options?.maxTokens ?? this.defaultMaxTokens;\n    const temperature = options?.temperature ?? this.defaultTemperature;\n\n    const response = await fetch(`${this.baseUrl}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${this.apiKey}`,\n      },\n      body: JSON.stringify({\n        model: this.model,\n        messages: [\n          { role: 'user', content: prompt },\n        ],\n        max_tokens: maxTokens,\n        temperature,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`OpenAI API error: ${response.status} - ${error}`);\n    }\n\n    const data = await response.json() as {\n      choices?: Array<{ message?: { content?: string } }>;\n    };\n\n    return data.choices?.[0]?.message?.content ?? '';\n  }\n}\n\n/**\n * Ollama LLM provider\n */\nexport class OllamaLLMProvider implements LLMProvider {\n  name = 'ollama';\n  private baseUrl: string;\n  private model: string;\n  private defaultMaxTokens: number;\n  private defaultTemperature: number;\n\n  constructor(config: ZettelScriptConfig['llm']) {\n    this.baseUrl = config.baseUrl ?? 'http://localhost:11434';\n    this.model = config.model;\n    this.defaultMaxTokens = config.maxTokens ?? 2048;\n    this.defaultTemperature = config.temperature ?? 0.7;\n  }\n\n  async complete(prompt: string, options?: LLMOptions): Promise<string> {\n    const temperature = options?.temperature ?? this.defaultTemperature;\n\n    const response = await fetch(`${this.baseUrl}/api/generate`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model: this.model,\n        prompt,\n        stream: false,\n        options: {\n          temperature,\n          num_predict: options?.maxTokens ?? this.defaultMaxTokens,\n        },\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Ollama API error: ${response.status} - ${error}`);\n    }\n\n    const data = await response.json() as { response?: string };\n\n    return data.response ?? '';\n  }\n}\n\n/**\n * Create an LLM provider based on config\n * Returns null if provider is 'none' or not configured\n */\nexport function createLLMProvider(config: ZettelScriptConfig['llm']): LLMProvider | null {\n  if (config.provider === 'none') {\n    return null;\n  }\n\n  switch (config.provider) {\n    case 'openai':\n      if (!config.apiKey) {\n        return null;\n      }\n      return new OpenAILLMProvider(config);\n\n    case 'ollama':\n      return new OllamaLLMProvider(config);\n\n    default:\n      return null;\n  }\n}\n","/**\n * Prompt templates for LLM-assisted features\n */\n\nexport interface RewriteContext {\n  sceneTitle: string;\n  sceneContent: string;\n  goal: string;\n  characterContext: Array<{ name: string; details: string }>;\n  timelineContext: Array<{ title: string; position: string }>;\n  relatedContent: Array<{ title: string; excerpt: string }>;\n  povCharacter?: string;\n}\n\n/**\n * Build a prompt for scene rewrite suggestions\n */\nexport function buildRewritePrompt(context: RewriteContext): string {\n  const parts: string[] = [];\n\n  parts.push('You are a creative writing assistant helping to rewrite a scene from a manuscript.');\n  parts.push('');\n  parts.push('## Current Scene');\n  parts.push(`Title: ${context.sceneTitle}`);\n  if (context.povCharacter) {\n    parts.push(`POV Character: ${context.povCharacter}`);\n  }\n  parts.push('');\n  parts.push('Content:');\n  parts.push('```');\n  parts.push(context.sceneContent);\n  parts.push('```');\n  parts.push('');\n  parts.push(`## Rewrite Goal`);\n  parts.push(context.goal);\n  parts.push('');\n\n  if (context.characterContext.length > 0) {\n    parts.push('## Character Context');\n    for (const char of context.characterContext) {\n      parts.push(`### ${char.name}`);\n      parts.push(char.details);\n      parts.push('');\n    }\n  }\n\n  if (context.timelineContext.length > 0) {\n    parts.push('## Timeline Context');\n    for (const scene of context.timelineContext) {\n      parts.push(`- ${scene.title} (${scene.position})`);\n    }\n    parts.push('');\n  }\n\n  if (context.relatedContent.length > 0) {\n    parts.push('## Related Scenes');\n    for (const related of context.relatedContent.slice(0, 5)) {\n      parts.push(`### ${related.title}`);\n      parts.push(related.excerpt);\n      parts.push('');\n    }\n  }\n\n  parts.push('## Instructions');\n  parts.push('Based on the context above, provide specific suggestions for how to rewrite this scene to achieve the stated goal.');\n  parts.push('');\n  parts.push('Please provide:');\n  parts.push('1. A brief analysis of how the current scene could be improved');\n  parts.push('2. Specific suggestions for changes (what to add, remove, or modify)');\n  parts.push('3. An example of a rewritten opening paragraph or key section');\n  parts.push('');\n  parts.push('Maintain consistency with the established characters, timeline, and POV.');\n\n  return parts.join('\\n');\n}\n\n/**\n * Build a prompt for mention disambiguation\n */\nexport function buildDisambiguationPrompt(\n  surfaceText: string,\n  context: string,\n  candidates: Array<{ title: string; type: string; description?: string }>\n): string {\n  const parts: string[] = [];\n\n  parts.push('You are helping to identify which entity is being referenced in a piece of text.');\n  parts.push('');\n  parts.push('## Text containing the mention');\n  parts.push('```');\n  parts.push(context);\n  parts.push('```');\n  parts.push('');\n  parts.push(`The highlighted mention is: \"${surfaceText}\"`);\n  parts.push('');\n  parts.push('## Possible matches');\n  for (let i = 0; i < candidates.length; i++) {\n    const c = candidates[i];\n    if (c) {\n      parts.push(`${i + 1}. ${c.title} (${c.type})${c.description ? `: ${c.description}` : ''}`);\n    }\n  }\n  parts.push('');\n  parts.push('Which entity (1-' + candidates.length + ') is most likely being referenced? Respond with just the number.');\n\n  return parts.join('\\n');\n}\n\n/**\n * Build a prompt for continuity checking\n */\nexport function buildContinuityCheckPrompt(\n  scene1: { title: string; content: string; pov?: string },\n  scene2: { title: string; content: string; pov?: string }\n): string {\n  const parts: string[] = [];\n\n  parts.push('You are a continuity editor checking for consistency between two scenes in a manuscript.');\n  parts.push('');\n  parts.push('## Scene 1');\n  parts.push(`Title: ${scene1.title}`);\n  if (scene1.pov) parts.push(`POV: ${scene1.pov}`);\n  parts.push('```');\n  parts.push(scene1.content.slice(0, 2000));\n  if (scene1.content.length > 2000) parts.push('... [truncated]');\n  parts.push('```');\n  parts.push('');\n  parts.push('## Scene 2');\n  parts.push(`Title: ${scene2.title}`);\n  if (scene2.pov) parts.push(`POV: ${scene2.pov}`);\n  parts.push('```');\n  parts.push(scene2.content.slice(0, 2000));\n  if (scene2.content.length > 2000) parts.push('... [truncated]');\n  parts.push('```');\n  parts.push('');\n  parts.push('## Task');\n  parts.push('Identify any continuity issues between these scenes, such as:');\n  parts.push('- Character inconsistencies (different descriptions, abilities, or knowledge)');\n  parts.push('- Timeline problems');\n  parts.push('- Setting/location inconsistencies');\n  parts.push('- POV violations (character knowing things they shouldn\\'t)');\n  parts.push('');\n  parts.push('List each issue found with a brief explanation, or state \"No continuity issues found.\"');\n\n  return parts.join('\\n');\n}\n","import { Command } from 'commander';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { initContext, Spinner, printTable } from '../utils.js';\nimport { EntityExtractor, type ExtractedEntity } from '../../extraction/index.js';\nimport { OllamaLLMProvider } from '../../llm/provider.js';\nimport { nanoid } from 'nanoid';\nimport { stringify as stringifyYaml } from 'yaml';\n\nexport const extractCommand = new Command('extract')\n  .description('Extract entities (characters, locations, etc.) from prose')\n  .option('-f, --file <path>', 'Extract from specific file')\n  .option('--all', 'Extract from all markdown files')\n  .option('-m, --model <model>', 'Ollama model to use', 'llama3.2:3b')\n  .option('--dry-run', 'Show what would be extracted without creating files')\n  .option('-o, --output <dir>', 'Output directory for entity files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    try {\n      const ctx = await initContext();\n\n      // Determine files to process\n      let filesToProcess: string[] = [];\n\n      if (options.file) {\n        const filePath = path.isAbsolute(options.file)\n          ? options.file\n          : path.join(ctx.vaultPath, options.file);\n\n        if (!fs.existsSync(filePath)) {\n          console.error(`File not found: ${filePath}`);\n          process.exit(1);\n        }\n        filesToProcess = [filePath];\n      } else if (options.all) {\n        // Find all markdown files\n        const findMarkdown = (dir: string): string[] => {\n          const results: string[] = [];\n          const entries = fs.readdirSync(dir, { withFileTypes: true });\n\n          for (const entry of entries) {\n            const fullPath = path.join(dir, entry.name);\n\n            // Skip excluded patterns\n            if (ctx.config.vault.excludePatterns.some(p => {\n              const pattern = p.replace('**/', '').replace('/**', '');\n              return entry.name === pattern || fullPath.includes(pattern);\n            })) {\n              continue;\n            }\n\n            if (entry.isDirectory()) {\n              results.push(...findMarkdown(fullPath));\n            } else if (entry.name.endsWith('.md')) {\n              results.push(fullPath);\n            }\n          }\n          return results;\n        };\n\n        filesToProcess = findMarkdown(ctx.vaultPath);\n      } else {\n        console.log('Specify --file <path> or --all to extract entities.');\n        console.log('\\nExamples:');\n        console.log('  zettel extract --file book1.md');\n        console.log('  zettel extract --all');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      if (filesToProcess.length === 0) {\n        console.log('No markdown files found.');\n        ctx.connectionManager.close();\n        return;\n      }\n\n      console.log(`Processing ${filesToProcess.length} file(s)...\\n`);\n\n      // Create LLM provider\n      const llmProvider = new OllamaLLMProvider({\n        provider: 'ollama',\n        model: options.model,\n        baseUrl: 'http://localhost:11434',\n      });\n\n      const extractor = new EntityExtractor({\n        llmProvider,\n        chunkSize: 6000, // Smaller chunks for 3b model\n      });\n\n      const allEntities = new Map<string, ExtractedEntity>();\n      const entityToFiles = new Map<string, Set<string>>();\n\n      for (const filePath of filesToProcess) {\n        const relativePath = path.relative(ctx.vaultPath, filePath);\n        console.log(`\\nExtracting from: ${relativePath}`);\n\n        const content = fs.readFileSync(filePath, 'utf-8');\n\n        // Skip very small files\n        if (content.length < 100) {\n          console.log('  Skipped (too small)');\n          continue;\n        }\n\n        const spinner = new Spinner('Analyzing...');\n        spinner.start();\n\n        const result = await extractor.extractFromText(content, (current, total) => {\n          spinner.update(`Chunk ${current}/${total}`);\n        });\n\n        spinner.stop();\n\n        // Merge entities\n        for (const entity of result.entities) {\n          const key = entity.name.toLowerCase();\n          const existing = allEntities.get(key);\n\n          if (existing) {\n            existing.mentions += entity.mentions;\n            existing.aliases = [...new Set([...existing.aliases, ...entity.aliases])];\n            if (entity.description.length > existing.description.length) {\n              existing.description = entity.description;\n            }\n          } else {\n            allEntities.set(key, { ...entity });\n          }\n\n          // Track which files reference this entity\n          if (!entityToFiles.has(key)) {\n            entityToFiles.set(key, new Set());\n          }\n          entityToFiles.get(key)!.add(relativePath);\n        }\n\n        if (options.verbose) {\n          console.log(`  Found ${result.entities.length} entities`);\n          for (const e of result.entities.slice(0, 10)) {\n            console.log(`    - ${e.name} (${e.type})`);\n          }\n          if (result.entities.length > 10) {\n            console.log(`    ... and ${result.entities.length - 10} more`);\n          }\n        }\n      }\n\n      // Sort by mentions\n      const sortedEntities = Array.from(allEntities.values())\n        .sort((a, b) => b.mentions - a.mentions);\n\n      // Display results\n      console.log('\\n' + '='.repeat(50));\n      console.log('Extracted Entities');\n      console.log('='.repeat(50) + '\\n');\n\n      // Group by type\n      const byType = new Map<string, ExtractedEntity[]>();\n      for (const entity of sortedEntities) {\n        const list = byType.get(entity.type) || [];\n        list.push(entity);\n        byType.set(entity.type, list);\n      }\n\n      for (const [type, entities] of byType) {\n        console.log(`\\n${type.toUpperCase()}S (${entities.length}):`);\n        const rows = entities.slice(0, 15).map(e => [\n          e.name,\n          e.aliases.slice(0, 3).join(', ') || '-',\n          e.mentions.toString(),\n          e.description.slice(0, 50) + (e.description.length > 50 ? '...' : ''),\n        ]);\n        printTable(['Name', 'Aliases', 'Refs', 'Description'], rows);\n\n        if (entities.length > 15) {\n          console.log(`  ... and ${entities.length - 15} more`);\n        }\n      }\n\n      console.log(`\\nTotal: ${sortedEntities.length} entities`);\n\n      // Create files if not dry run\n      if (!options.dryRun && sortedEntities.length > 0) {\n        const outputDir = options.output\n          ? path.isAbsolute(options.output)\n            ? options.output\n            : path.join(ctx.vaultPath, options.output)\n          : path.join(ctx.vaultPath, 'entities');\n\n        console.log(`\\nCreating entity files in: ${path.relative(ctx.vaultPath, outputDir)}/`);\n\n        // Create directories\n        const dirs = ['characters', 'locations', 'objects', 'events'];\n        for (const dir of dirs) {\n          fs.mkdirSync(path.join(outputDir, dir), { recursive: true });\n        }\n\n        let created = 0;\n        for (const entity of sortedEntities) {\n          // Skip low-mention entities\n          if (entity.mentions < 2) continue;\n\n          const typeDir = entity.type === 'character' ? 'characters'\n            : entity.type === 'location' ? 'locations'\n            : entity.type === 'object' ? 'objects'\n            : 'events';\n\n          const fileName = entity.name\n            .toLowerCase()\n            .replace(/[^a-z0-9]+/g, '-')\n            .replace(/^-|-$/g, '') + '.md';\n\n          const filePath = path.join(outputDir, typeDir, fileName);\n\n          // Skip if file already exists\n          if (fs.existsSync(filePath)) {\n            if (options.verbose) {\n              console.log(`  Skipped (exists): ${typeDir}/${fileName}`);\n            }\n            continue;\n          }\n\n          // Create frontmatter\n          const frontmatter: Record<string, unknown> = {\n            id: nanoid(),\n            title: entity.name,\n            type: entity.type,\n          };\n\n          if (entity.aliases.length > 0) {\n            frontmatter.aliases = entity.aliases;\n          }\n\n          // Create file content\n          const content = `---\n${stringifyYaml(frontmatter).trim()}\n---\n\n# ${entity.name}\n\n${entity.description}\n\n## Appearances\n\n${Array.from(entityToFiles.get(entity.name.toLowerCase()) || [])\n  .map(f => `- [[${path.basename(f, '.md')}]]`)\n  .join('\\n')}\n`;\n\n          fs.writeFileSync(filePath, content, 'utf-8');\n          created++;\n\n          if (options.verbose) {\n            console.log(`  Created: ${typeDir}/${fileName}`);\n          }\n        }\n\n        console.log(`\\nCreated ${created} entity files.`);\n        console.log('\\nNext steps:');\n        console.log('  zettel index     # Re-index to include new entities');\n        console.log('  zettel discover --all  # Find unlinked mentions');\n      }\n\n      ctx.connectionManager.close();\n    } catch (error) {\n      console.error('Extraction failed:', error);\n      process.exit(1);\n    }\n  });\n","/**\n * Entity extraction from prose using LLM\n */\n\nimport type { LLMProvider } from '../llm/provider.js';\nimport type { NodeType } from '../core/types/index.js';\n\nexport interface ExtractedEntity {\n  name: string;\n  type: NodeType;\n  aliases: string[];\n  description: string;\n  mentions: number;\n}\n\nexport interface ExtractionResult {\n  entities: ExtractedEntity[];\n  scenes: Array<{\n    title: string;\n    summary: string;\n    startOffset: number;\n    endOffset: number;\n    entities: string[]; // Entity names referenced in this scene\n  }>;\n}\n\nexport interface EntityExtractorOptions {\n  llmProvider: LLMProvider;\n  chunkSize?: number; // Max characters per chunk\n  overlapSize?: number; // Overlap between chunks\n}\n\nconst EXTRACTION_PROMPT = `You are an entity extractor for fiction manuscripts. Analyze the following text and extract all named entities.\n\nReturn ONLY valid JSON in this exact format (no markdown, no explanation):\n{\n  \"characters\": [\n    {\"name\": \"Full Name\", \"aliases\": [\"nickname\", \"title\"], \"description\": \"brief description\"}\n  ],\n  \"locations\": [\n    {\"name\": \"Location Name\", \"aliases\": [], \"description\": \"brief description\"}\n  ],\n  \"objects\": [\n    {\"name\": \"Object Name\", \"aliases\": [], \"description\": \"why it's significant\"}\n  ],\n  \"events\": [\n    {\"name\": \"Event Name\", \"aliases\": [], \"description\": \"what happened\"}\n  ]\n}\n\nRules:\n- Characters include people, animals, personified objects (like stuffed animals with names)\n- Locations include rooms, buildings, cities, any named place\n- Objects include significant items mentioned multiple times or plot-relevant\n- For aliases, include nicknames, titles, pronouns-as-names (\"Mom\" vs \"mother\")\n- Keep descriptions to one sentence\n- Only include entities that are NAMED or clearly identifiable\n- Do NOT include generic references (\"the door\" unless it's \"the basement door\" as a specific thing)\n\nTEXT TO ANALYZE:\n`;\n\n// Reserved for future LLM-based scene detection (see extractScenes TODO)\nexport const SCENE_EXTRACTION_PROMPT = `Analyze this text and identify distinct scenes or chapters. A scene is a continuous unit of action in one location/time.\n\nReturn ONLY valid JSON (no markdown):\n{\n  \"scenes\": [\n    {\n      \"title\": \"Brief scene title\",\n      \"summary\": \"One sentence summary\",\n      \"characters\": [\"Character names present\"],\n      \"locations\": [\"Location names\"],\n      \"startMarker\": \"First few words of scene\",\n      \"endMarker\": \"Last few words of scene\"\n    }\n  ]\n}\n\nTEXT:\n`;\n\nexport class EntityExtractor {\n  private llm: LLMProvider;\n  private chunkSize: number;\n  private overlapSize: number;\n\n  constructor(options: EntityExtractorOptions) {\n    this.llm = options.llmProvider;\n    this.chunkSize = options.chunkSize ?? 8000; // ~2000 tokens\n    this.overlapSize = options.overlapSize ?? 500;\n  }\n\n  /**\n   * Extract entities from a full manuscript\n   */\n  async extractFromText(text: string, onProgress?: (current: number, total: number) => void): Promise<ExtractionResult> {\n    const chunks = this.chunkText(text);\n    const allEntities = new Map<string, ExtractedEntity>();\n\n    // Extract entities from each chunk\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      if (!chunk) continue;\n      if (onProgress) onProgress(i + 1, chunks.length);\n\n      const chunkEntities = await this.extractEntitiesFromChunk(chunk.text);\n\n      // Merge entities\n      for (const entity of chunkEntities) {\n        const key = this.normalizeEntityKey(entity.name);\n        const existing = allEntities.get(key);\n\n        if (existing) {\n          // Merge: combine aliases, increment mentions\n          existing.aliases = [...new Set([...existing.aliases, ...entity.aliases])];\n          existing.mentions += 1;\n          // Keep longer description\n          if (entity.description.length > existing.description.length) {\n            existing.description = entity.description;\n          }\n        } else {\n          allEntities.set(key, { ...entity, mentions: 1 });\n        }\n      }\n    }\n\n    // Extract scene structure\n    const scenes = await this.extractScenes(text, chunks);\n\n    return {\n      entities: Array.from(allEntities.values()).sort((a, b) => b.mentions - a.mentions),\n      scenes,\n    };\n  }\n\n  private chunkText(text: string): Array<{ text: string; start: number; end: number }> {\n    const chunks: Array<{ text: string; start: number; end: number }> = [];\n    let start = 0;\n\n    while (start < text.length) {\n      let end = start + this.chunkSize;\n\n      // Try to break at paragraph boundary\n      if (end < text.length) {\n        const breakPoint = text.lastIndexOf('\\n\\n', end);\n        if (breakPoint > start + this.chunkSize / 2) {\n          end = breakPoint;\n        }\n      } else {\n        end = text.length;\n      }\n\n      chunks.push({\n        text: text.slice(start, end),\n        start,\n        end,\n      });\n\n      start = end - this.overlapSize;\n      if (start < 0) start = 0;\n      if (end >= text.length) break;\n    }\n\n    return chunks;\n  }\n\n  private async extractEntitiesFromChunk(text: string): Promise<ExtractedEntity[]> {\n    const prompt = EXTRACTION_PROMPT + text;\n\n    try {\n      const response = await this.llm.complete(prompt, { temperature: 0.1 });\n      const parsed = this.parseJSON(response);\n\n      const entities: ExtractedEntity[] = [];\n\n      // Process characters\n      if (Array.isArray(parsed.characters)) {\n        for (const c of parsed.characters) {\n          if (c.name) {\n            entities.push({\n              name: c.name,\n              type: 'character',\n              aliases: Array.isArray(c.aliases) ? c.aliases : [],\n              description: c.description || '',\n              mentions: 1,\n            });\n          }\n        }\n      }\n\n      // Process locations\n      if (Array.isArray(parsed.locations)) {\n        for (const l of parsed.locations) {\n          if (l.name) {\n            entities.push({\n              name: l.name,\n              type: 'location',\n              aliases: Array.isArray(l.aliases) ? l.aliases : [],\n              description: l.description || '',\n              mentions: 1,\n            });\n          }\n        }\n      }\n\n      // Process objects\n      if (Array.isArray(parsed.objects)) {\n        for (const o of parsed.objects) {\n          if (o.name) {\n            entities.push({\n              name: o.name,\n              type: 'object',\n              aliases: Array.isArray(o.aliases) ? o.aliases : [],\n              description: o.description || '',\n              mentions: 1,\n            });\n          }\n        }\n      }\n\n      // Process events\n      if (Array.isArray(parsed.events)) {\n        for (const e of parsed.events) {\n          if (e.name) {\n            entities.push({\n              name: e.name,\n              type: 'event',\n              aliases: Array.isArray(e.aliases) ? e.aliases : [],\n              description: e.description || '',\n              mentions: 1,\n            });\n          }\n        }\n      }\n\n      return entities;\n    } catch (error) {\n      console.error('Entity extraction failed for chunk:', error);\n      return [];\n    }\n  }\n\n  private async extractScenes(\n    _fullText: string,\n    chunks: Array<{ text: string; start: number; end: number }>\n  ): Promise<ExtractionResult['scenes']> {\n    // For now, use chapter markers or chunk boundaries\n    // A more sophisticated approach would use the LLM to identify scene breaks\n    const scenes: ExtractionResult['scenes'] = [];\n\n    // Try to find chapter markers\n    const chapterRegex = /^#+\\s*(Chapter|Scene|Part)\\s*\\d*[:\\s]*.*/gmi;\n\n    for (const chunk of chunks) {\n      const matches = chunk.text.matchAll(chapterRegex);\n      for (const match of matches) {\n        if (match.index !== undefined) {\n          scenes.push({\n            title: match[0].replace(/^#+\\s*/, '').trim(),\n            summary: '',\n            startOffset: chunk.start + match.index,\n            endOffset: chunk.start + match.index + 1000, // Approximate\n            entities: [],\n          });\n        }\n      }\n    }\n\n    return scenes;\n  }\n\n  private normalizeEntityKey(name: string): string {\n    return name.toLowerCase().replace(/[^a-z0-9]/g, '');\n  }\n\n  private parseJSON(text: string): Record<string, unknown> {\n    // Try to extract JSON from response\n    let jsonText = text.trim();\n\n    // Remove markdown code blocks if present\n    if (jsonText.startsWith('```')) {\n      jsonText = jsonText.replace(/^```(?:json)?\\n?/, '').replace(/\\n?```$/, '');\n    }\n\n    // Find JSON object boundaries\n    const start = jsonText.indexOf('{');\n    const end = jsonText.lastIndexOf('}');\n\n    if (start !== -1 && end !== -1 && end > start) {\n      jsonText = jsonText.slice(start, end + 1);\n    }\n\n    try {\n      return JSON.parse(jsonText);\n    } catch {\n      console.error('Failed to parse JSON:', jsonText.slice(0, 200));\n      return {};\n    }\n  }\n}\n","import { Command } from 'commander';\nimport * as path from 'node:path';\nimport { findVaultRoot, Spinner } from '../utils.js';\nimport {\n  generateCharacters,\n  generateChapters,\n  generateLocations,\n  generateObjects,\n  generateLore,\n  generateTimeline,\n  generateArcs,\n  findKBFiles,\n  type GeneratorOptions,\n  type ChapterGeneratorOptions,\n  type GeneratorResult,\n} from '../../generators/index.js';\n\n/**\n * Resolve common options for generators\n */\nfunction resolveOptions(options: {\n  output?: string;\n  kb?: string;\n  arcLedger?: string;\n  worldRules?: string;\n  force?: boolean;\n  dryRun?: boolean;\n  verbose?: boolean;\n}): GeneratorOptions {\n  // Find vault root or use current directory\n  const vaultPath = findVaultRoot() || process.cwd();\n  const outputDir = options.output ? path.resolve(options.output) : vaultPath;\n\n  // Find KB files if not specified\n  const kbFiles = findKBFiles(vaultPath);\n\n  return {\n    outputDir,\n    kbPath: options.kb ? path.resolve(options.kb) : kbFiles.kb,\n    arcLedgerPath: options.arcLedger ? path.resolve(options.arcLedger) : kbFiles.arcLedger,\n    worldRulesPath: options.worldRules ? path.resolve(options.worldRules) : kbFiles.worldRules,\n    force: options.force || false,\n    dryRun: options.dryRun || false,\n    verbose: options.verbose || false,\n  };\n}\n\n/**\n * Print generator result\n */\nfunction printResult(result: GeneratorResult): void {\n  console.log(`\\n${result.summary}`);\n\n  if (result.errors.length > 0) {\n    console.log('\\nErrors:');\n    for (const err of result.errors.slice(0, 10)) {\n      console.log(`  ${err.file}: ${err.error}`);\n    }\n    if (result.errors.length > 10) {\n      console.log(`  ... and ${result.errors.length - 10} more`);\n    }\n  }\n}\n\n// Create the parent generate command\nexport const generateCommand = new Command('generate')\n  .description('Generate vault notes from knowledge base data')\n  .addHelpText('after', `\nExamples:\n  zettel generate characters         Generate character notes\n  zettel generate all                Generate all note types\n  zettel generate chapters -m book.md  Split manuscript into chapters\n`);\n\n// Characters subcommand\ngenerateCommand\n  .command('characters')\n  .description('Generate character notes from KB data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating character notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath) {\n        spinner.stop('Error: No KB file found. Specify with --kb option.');\n        process.exit(1);\n      }\n\n      const result = await generateCharacters(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Chapters subcommand\ngenerateCommand\n  .command('chapters')\n  .description('Split manuscript into chapter notes')\n  .requiredOption('-m, --manuscript <path>', 'Path to manuscript file')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-d, --chapters-dir <dir>', 'Subdirectory for chapters (default: Chapters)')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Splitting manuscript into chapters...');\n    spinner.start();\n\n    try {\n      const baseOpts = resolveOptions(options);\n      const chapterOpts: ChapterGeneratorOptions = {\n        ...baseOpts,\n        manuscriptPath: path.resolve(options.manuscript),\n        chaptersDir: options.chaptersDir,\n      };\n\n      const result = await generateChapters(chapterOpts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Locations subcommand\ngenerateCommand\n  .command('locations')\n  .description('Generate location notes from KB data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating location notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath) {\n        spinner.stop('Error: No KB file found. Specify with --kb option.');\n        process.exit(1);\n      }\n\n      const result = await generateLocations(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Objects subcommand\ngenerateCommand\n  .command('objects')\n  .description('Generate object/artifact notes from KB data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating object notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath) {\n        spinner.stop('Error: No KB file found. Specify with --kb option.');\n        process.exit(1);\n      }\n\n      const result = await generateObjects(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Lore subcommand\ngenerateCommand\n  .command('lore')\n  .description('Generate lore/world rules notes from KB and world-rules data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-w, --world-rules <path>', 'Path to world-rules.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating lore notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath && !opts.worldRulesPath) {\n        spinner.stop('Error: No KB or world-rules file found. Specify with --kb or --world-rules option.');\n        process.exit(1);\n      }\n\n      const result = await generateLore(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Timeline subcommand\ngenerateCommand\n  .command('timeline')\n  .description('Generate timeline event notes from KB data')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating timeline notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.kbPath) {\n        spinner.stop('Error: No KB file found. Specify with --kb option.');\n        process.exit(1);\n      }\n\n      const result = await generateTimeline(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// Arcs subcommand\ngenerateCommand\n  .command('arcs')\n  .description('Generate plot thread and character arc notes from arc-ledger')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-a, --arc-ledger <path>', 'Path to arc-ledger.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Generating arc notes...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n\n      if (!opts.arcLedgerPath) {\n        spinner.stop('Error: No arc-ledger file found. Specify with --arc-ledger option.');\n        process.exit(1);\n      }\n\n      const result = await generateArcs(opts);\n      spinner.stop();\n      printResult(result);\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n\n// All subcommand - runs all generators\ngenerateCommand\n  .command('all')\n  .description('Run all generators in sequence')\n  .option('-o, --output <dir>', 'Output directory')\n  .option('-k, --kb <path>', 'Path to kb.json file')\n  .option('-a, --arc-ledger <path>', 'Path to arc-ledger.json file')\n  .option('-w, --world-rules <path>', 'Path to world-rules.json file')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-n, --dry-run', 'Show what would be created without writing files')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    const spinner = new Spinner('Running all generators...');\n    spinner.start();\n\n    try {\n      const opts = resolveOptions(options);\n      const results: GeneratorResult[] = [];\n\n      // Characters\n      if (opts.kbPath) {\n        spinner.update('Generating characters...');\n        results.push(await generateCharacters(opts));\n      }\n\n      // Locations\n      if (opts.kbPath) {\n        spinner.update('Generating locations...');\n        results.push(await generateLocations(opts));\n      }\n\n      // Objects\n      if (opts.kbPath) {\n        spinner.update('Generating objects...');\n        results.push(await generateObjects(opts));\n      }\n\n      // Timeline\n      if (opts.kbPath) {\n        spinner.update('Generating timeline...');\n        results.push(await generateTimeline(opts));\n      }\n\n      // Lore\n      if (opts.kbPath || opts.worldRulesPath) {\n        spinner.update('Generating lore...');\n        results.push(await generateLore(opts));\n      }\n\n      // Arcs\n      if (opts.arcLedgerPath) {\n        spinner.update('Generating arcs...');\n        results.push(await generateArcs(opts));\n      }\n\n      spinner.stop();\n\n      // Print summary\n      console.log('\\nGeneration complete:\\n');\n      for (const result of results) {\n        console.log(`  ${result.summary}`);\n      }\n\n      // Total errors\n      const totalErrors = results.reduce((sum, r) => sum + r.errors.length, 0);\n      if (totalErrors > 0) {\n        console.log(`\\nTotal errors: ${totalErrors}`);\n      }\n    } catch (error) {\n      spinner.stop(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n","/**\n * Types for vault generators\n * These types define the structure of knowledge base data used to generate vault notes\n */\n\n// ============================================================================\n// KB Data Types - Generic versions without manuscript-specific content\n// ============================================================================\n\nexport interface KBCharacter {\n  id: string;\n  canonical_name: string;\n  aliases?: string[];\n  role: string;\n  chapters_present?: number[];\n  first_appearance?: number;\n  last_appearance?: number;\n  age?: number;\n  physical?: Record<string, unknown>;\n  personality?: string[];\n  abilities?: Record<string, unknown>;\n  equipment?: string[];\n  backstory?: Record<string, unknown>;\n  arc?: CharacterArc;\n  entry_state?: Record<string, unknown>;\n  exit_state?: Record<string, unknown>;\n  key_quote?: string;\n  final_words?: string;\n  coping_mechanism?: Record<string, unknown>;\n  relationship_to_protagonist?: string;\n}\n\nexport interface CharacterArc {\n  type: string;\n  description: string;\n  key_moments?: Array<{\n    chapter: number;\n    beat: string;\n    description: string;\n  }>;\n  resolution?: {\n    status: string;\n    chapter?: number;\n    key_line?: string;\n    mechanism?: string;\n  };\n}\n\nexport interface KBLocation {\n  id: string;\n  name: string;\n  type: string;\n  description?: string;\n  features?: string[];\n  chapters_seen?: number[];\n  first_appearance?: number;\n  realm?: 'real_world' | 'dimensional' | 'liminal' | 'unknown';\n}\n\nexport interface KBObject {\n  id: string;\n  name: string;\n  type: string;\n  description?: string;\n  properties?: string[];\n  significance?: string;\n  locked?: boolean;\n  holder?: string | null;\n  holders?: string[];\n  status?: string | null;\n}\n\nexport interface KBTimelineEvent {\n  id: string;\n  description: string;\n  chapter: number;\n  locked?: boolean;\n  significance?: string;\n}\n\nexport interface KBPlotThread {\n  id: string;\n  name: string;\n  type: string;\n  status: string;\n  chapters_touched?: number[];\n  expected_resolution?: string;\n  resolution_chapter?: number;\n  resolution_description?: string;\n}\n\nexport interface KBFact {\n  id: string;\n  fact: string;\n  source: string;\n  locked?: boolean;\n}\n\nexport interface KBNameNormalization {\n  canonical: string;\n  variants: string[];\n}\n\nexport interface KBData {\n  schema_version: string;\n  book_id: string;\n  series_id?: string;\n  kb_version?: string;\n  created_at?: string;\n  last_updated?: string;\n  source?: string;\n  characters: KBCharacter[];\n  locations: KBLocation[];\n  objects: KBObject[];\n  timeline: KBTimelineEvent[];\n  plot_threads?: KBPlotThread[];\n  facts?: KBFact[];\n  relationships?: unknown[];\n  contradictions?: unknown[];\n  name_normalization?: KBNameNormalization[];\n  cross_reference?: Record<string, unknown>;\n}\n\n// ============================================================================\n// Arc Ledger Types\n// ============================================================================\n\nexport interface ArcLedgerCharacter {\n  character_id: string;\n  canonical_name: string;\n  entry_state?: Record<string, unknown>;\n  arc?: CharacterArc;\n  exit_state?: Record<string, unknown>;\n}\n\nexport interface ArcLedgerThread {\n  thread_id: string;\n  name: string;\n  type: string;\n  status: string;\n  chapters_touched?: number[];\n  resolution_chapter?: number;\n  resolution_description?: string;\n  expected_resolution?: string;\n  description?: string;\n}\n\nexport interface ArcLedger {\n  schema_version: string;\n  book_id: string;\n  series_id?: string;\n  last_updated?: string;\n  characters: ArcLedgerCharacter[];\n  threads: ArcLedgerThread[];\n  series_arc_tracking?: Record<string, unknown>;\n  locked_element_compliance?: Record<string, unknown>;\n}\n\n// ============================================================================\n// World Rules Types\n// ============================================================================\n\nexport interface WorldRule {\n  id: string;\n  name: string;\n  category: string;\n  description: string;\n  locked?: boolean;\n  examples?: string[];\n  exceptions?: string[];\n  source?: string;\n}\n\nexport interface WorldRulesData {\n  schema_version: string;\n  rules?: WorldRule[];\n  mechanics?: WorldRule[];\n  constraints?: WorldRule[];\n}\n\n// ============================================================================\n// Generator Options\n// ============================================================================\n\nexport interface GeneratorOptions {\n  /** Path to the output vault directory */\n  outputDir: string;\n  /** Path to the KB JSON file */\n  kbPath?: string | undefined;\n  /** Path to the arc-ledger JSON file */\n  arcLedgerPath?: string | undefined;\n  /** Path to the world-rules JSON file */\n  worldRulesPath?: string | undefined;\n  /** Whether to use database as source instead of JSON files */\n  fromDb?: boolean | undefined;\n  /** Dry run - don't write files, just show what would be created */\n  dryRun?: boolean | undefined;\n  /** Overwrite existing files */\n  force?: boolean | undefined;\n  /** Verbose output */\n  verbose?: boolean | undefined;\n}\n\nexport interface ChapterGeneratorOptions extends GeneratorOptions {\n  /** Path to the manuscript file */\n  manuscriptPath: string;\n  /** Output subdirectory for chapters */\n  chaptersDir?: string | undefined;\n}\n\nexport interface InjectLinksOptions {\n  /** Path to the vault directory */\n  vaultPath: string;\n  /** Dry run - show changes without modifying files */\n  dryRun?: boolean | undefined;\n  /** Entity names to create wikilinks for */\n  entities?: string[] | undefined;\n  /** Pattern to match files (glob) */\n  pattern?: string | undefined;\n  /** Verbose output */\n  verbose?: boolean | undefined;\n}\n\n// ============================================================================\n// Generator Results\n// ============================================================================\n\nexport interface GeneratorResult {\n  /** Files that were created */\n  created: string[];\n  /** Files that were skipped (already exist) */\n  skipped: string[];\n  /** Errors encountered */\n  errors: Array<{ file: string; error: string }>;\n  /** Summary message */\n  summary: string;\n}\n\nexport interface InjectLinksResult {\n  /** Files that were modified */\n  modified: string[];\n  /** Total links injected */\n  linksInjected: number;\n  /** Files that were skipped */\n  skipped: string[];\n  /** Errors encountered */\n  errors: Array<{ file: string; error: string }>;\n}\n\n// ============================================================================\n// Lock Level System\n// ============================================================================\n\nexport type LockLevel = 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';\n\nexport function getLockLevel(entity: { locked?: boolean; significance?: string }): LockLevel {\n  if (entity.locked) {\n    return 'CRITICAL';\n  }\n\n  const sig = entity.significance?.toLowerCase() || '';\n  if (sig.includes('critical') || sig.includes('essential')) {\n    return 'HIGH';\n  }\n  if (sig.includes('important') || sig.includes('significant')) {\n    return 'MEDIUM';\n  }\n  return 'LOW';\n}\n\n// ============================================================================\n// Realm Classification\n// ============================================================================\n\nexport type RealmType = 'real_world' | 'dimensional' | 'liminal' | 'unknown';\n\nconst DIMENSIONAL_KEYWORDS = ['dimension', 'portal', 'void', 'realm', 'prison', 'core', 'barrier'];\nconst LIMINAL_KEYWORDS = ['threshold', 'between', 'transition', 'edge', 'boundary'];\nconst REAL_WORLD_KEYWORDS = ['house', 'basement', 'bedroom', 'hospital', 'street', 'school', 'lab'];\n\nexport function classifyRealm(location: KBLocation): RealmType {\n  // Explicit type takes precedence\n  if (location.realm) {\n    return location.realm;\n  }\n\n  // Check type field\n  const locType = location.type?.toLowerCase() || '';\n  if (locType.includes('dimensional') || locType === 'dimensional_location') {\n    return 'dimensional';\n  }\n  if (locType.includes('real') || locType === 'real_world_location') {\n    return 'real_world';\n  }\n\n  // Heuristic keyword detection\n  const name = location.name.toLowerCase();\n  const desc = (location.description || '').toLowerCase();\n  const combined = `${name} ${desc}`;\n\n  for (const keyword of DIMENSIONAL_KEYWORDS) {\n    if (combined.includes(keyword)) {\n      return 'dimensional';\n    }\n  }\n\n  for (const keyword of LIMINAL_KEYWORDS) {\n    if (combined.includes(keyword)) {\n      return 'liminal';\n    }\n  }\n\n  for (const keyword of REAL_WORLD_KEYWORDS) {\n    if (combined.includes(keyword)) {\n      return 'real_world';\n    }\n  }\n\n  return 'unknown';\n}\n","/**\n * Shared utilities for vault generators\n */\n\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { stringify as stringifyYaml } from 'yaml';\nimport type { KBData, ArcLedger, WorldRulesData } from './types.js';\n\n// ============================================================================\n// Filename Sanitization\n// ============================================================================\n\n/**\n * Sanitize a string for use as a filename\n * Removes or replaces characters that are unsafe in filenames\n */\nexport function sanitizeFilename(name: string): string {\n  return name\n    // Replace Windows/Unix unsafe characters\n    .replace(/[<>:\"/\\\\|?*]/g, '')\n    // Replace multiple spaces with single space\n    .replace(/\\s+/g, ' ')\n    // Trim whitespace\n    .trim()\n    // Replace spaces with hyphens for cleaner URLs\n    .replace(/\\s/g, '-')\n    // Remove any remaining problematic characters\n    .replace(/[^\\w\\-().]/g, '')\n    // Collapse multiple hyphens\n    .replace(/-+/g, '-')\n    // Remove leading/trailing hyphens\n    .replace(/^-+|-+$/g, '');\n}\n\n/**\n * Generate a safe path for a note file\n */\nexport function generateNotePath(\n  outputDir: string,\n  subdir: string,\n  name: string,\n  extension: string = '.md'\n): string {\n  const safeFilename = sanitizeFilename(name);\n  return path.join(outputDir, subdir, `${safeFilename}${extension}`);\n}\n\n// ============================================================================\n// Frontmatter Building\n// ============================================================================\n\n/**\n * Build frontmatter YAML string from data\n */\nexport function buildFrontmatter(data: Record<string, unknown>): string {\n  // Filter out undefined/null values\n  const cleaned = Object.fromEntries(\n    Object.entries(data).filter(([, v]) => v !== undefined && v !== null)\n  );\n\n  if (Object.keys(cleaned).length === 0) {\n    return '';\n  }\n\n  return `---\\n${stringifyYaml(cleaned)}---\\n\\n`;\n}\n\n/**\n * Build a complete note with frontmatter and content\n */\nexport function buildNote(\n  frontmatter: Record<string, unknown>,\n  content: string\n): string {\n  const fm = buildFrontmatter(frontmatter);\n  return `${fm}${content}`;\n}\n\n// ============================================================================\n// KB Data Loading\n// ============================================================================\n\n/**\n * Load and parse a JSON file\n */\nexport function loadJson<T>(filePath: string): T {\n  const content = fs.readFileSync(filePath, 'utf-8');\n  return JSON.parse(content) as T;\n}\n\n/**\n * Load KB data from JSON file\n */\nexport function parseKBJson(kbPath: string): KBData {\n  return loadJson<KBData>(kbPath);\n}\n\n/**\n * Load arc ledger from JSON file\n */\nexport function parseArcLedger(arcLedgerPath: string): ArcLedger {\n  return loadJson<ArcLedger>(arcLedgerPath);\n}\n\n/**\n * Load world rules from JSON file\n */\nexport function parseWorldRules(worldRulesPath: string): WorldRulesData {\n  return loadJson<WorldRulesData>(worldRulesPath);\n}\n\n/**\n * Find KB files in a project directory\n */\nexport function findKBFiles(projectDir: string): {\n  kb?: string;\n  arcLedger?: string;\n  worldRules?: string;\n} {\n  const result: { kb?: string; arcLedger?: string; worldRules?: string } = {};\n\n  // Common paths for KB files\n  const kbPaths = [\n    path.join(projectDir, '.narrative-project', 'kb', 'kb.json'),\n    path.join(projectDir, 'kb', 'kb.json'),\n    path.join(projectDir, 'kb.json'),\n  ];\n\n  const arcLedgerPaths = [\n    path.join(projectDir, '.narrative-project', 'kb', 'arc-ledger.json'),\n    path.join(projectDir, 'kb', 'arc-ledger.json'),\n    path.join(projectDir, 'arc-ledger.json'),\n  ];\n\n  const worldRulesPaths = [\n    path.join(projectDir, '.narrative-project', 'kb', 'world-rules.json'),\n    path.join(projectDir, 'kb', 'world-rules.json'),\n    path.join(projectDir, 'world-rules.json'),\n  ];\n\n  for (const p of kbPaths) {\n    if (fs.existsSync(p)) {\n      result.kb = p;\n      break;\n    }\n  }\n\n  for (const p of arcLedgerPaths) {\n    if (fs.existsSync(p)) {\n      result.arcLedger = p;\n      break;\n    }\n  }\n\n  for (const p of worldRulesPaths) {\n    if (fs.existsSync(p)) {\n      result.worldRules = p;\n      break;\n    }\n  }\n\n  return result;\n}\n\n// ============================================================================\n// Entity Deduplication\n// ============================================================================\n\n/**\n * Case-insensitive entity tracker for deduplication\n */\nexport class EntityTracker {\n  private seen = new Map<string, string>(); // lowercase -> canonical\n\n  /**\n   * Check if an entity has been seen\n   */\n  has(name: string): boolean {\n    return this.seen.has(name.toLowerCase());\n  }\n\n  /**\n   * Add an entity to the tracker\n   * Returns false if already present\n   */\n  add(name: string): boolean {\n    const lower = name.toLowerCase();\n    if (this.seen.has(lower)) {\n      return false;\n    }\n    this.seen.set(lower, name);\n    return true;\n  }\n\n  /**\n   * Get the canonical name for an entity\n   */\n  getCanonical(name: string): string | undefined {\n    return this.seen.get(name.toLowerCase());\n  }\n\n  /**\n   * Get all tracked entities\n   */\n  getAll(): string[] {\n    return Array.from(this.seen.values());\n  }\n}\n\n// ============================================================================\n// File Writing Helpers\n// ============================================================================\n\n/**\n * Write a file, creating directories as needed\n * Returns true if file was written, false if skipped\n */\nexport async function writeNoteFile(\n  filePath: string,\n  content: string,\n  options: { force?: boolean | undefined; dryRun?: boolean | undefined } = {}\n): Promise<boolean> {\n  if (options.dryRun) {\n    console.log(`[DRY RUN] Would create: ${filePath}`);\n    return true;\n  }\n\n  // Check if file exists\n  if (!options.force && fs.existsSync(filePath)) {\n    return false;\n  }\n\n  // Create directory\n  const dir = path.dirname(filePath);\n  await fs.promises.mkdir(dir, { recursive: true });\n\n  // Write file\n  await fs.promises.writeFile(filePath, content, 'utf-8');\n  return true;\n}\n\n// ============================================================================\n// Markdown Helpers\n// ============================================================================\n\n/**\n * Create a wikilink\n */\nexport function wikilink(target: string, display?: string): string {\n  if (display && display !== target) {\n    return `[[${target}|${display}]]`;\n  }\n  return `[[${target}]]`;\n}\n\n/**\n * Create a list of wikilinks\n */\nexport function wikilinkList(items: string[]): string {\n  return items.map(item => `- ${wikilink(item)}`).join('\\n');\n}\n\n/**\n * Format an array as a YAML-compatible list in frontmatter\n */\nexport function formatList(items: string[] | undefined): string[] | undefined {\n  if (!items || items.length === 0) {\n    return undefined;\n  }\n  return items;\n}\n\n/**\n * Format chapters as a readable string\n */\nexport function formatChapters(chapters: number[] | undefined): string {\n  if (!chapters || chapters.length === 0) {\n    return 'Unknown';\n  }\n  return chapters.join(', ');\n}\n\n/**\n * Create a section header\n */\nexport function section(title: string, level: number = 2): string {\n  const hashes = '#'.repeat(level);\n  return `${hashes} ${title}\\n\\n`;\n}\n\n/**\n * Create a blockquote\n */\nexport function blockquote(text: string): string {\n  return text.split('\\n').map(line => `> ${line}`).join('\\n');\n}\n\n/**\n * Format a key-value pair for display\n */\nexport function kvPair(key: string, value: unknown): string {\n  if (value === undefined || value === null) {\n    return '';\n  }\n  if (Array.isArray(value)) {\n    return `**${key}:** ${value.join(', ')}`;\n  }\n  return `**${key}:** ${value}`;\n}\n","/**\n * Character Generator\n * Extracts character metadata from KB and creates character notes\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  KBCharacter,\n  KBData,\n  CharacterArc,\n} from './types.js';\nimport {\n  parseKBJson,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  wikilink,\n  section,\n  blockquote,\n  formatChapters,\n  formatList,\n  kvPair,\n} from './utils.js';\n\nconst CHARACTERS_SUBDIR = 'Characters';\n\n/**\n * Build frontmatter for a character note\n */\nfunction buildCharacterFrontmatter(char: KBCharacter): Record<string, unknown> {\n  return {\n    id: char.id,\n    type: 'character',\n    title: char.canonical_name,\n    aliases: formatList(char.aliases),\n    role: char.role,\n    tags: buildTags(char),\n    first_appearance: char.first_appearance,\n    last_appearance: char.last_appearance,\n    chapters: formatList(char.chapters_present?.map(String)),\n    age: char.age,\n    arc_type: char.arc?.type,\n    arc_status: char.arc?.resolution?.status,\n  };\n}\n\n/**\n * Build tags based on character properties\n */\nfunction buildTags(char: KBCharacter): string[] {\n  const tags: string[] = ['character'];\n\n  // Role-based tags\n  const role = char.role.toLowerCase();\n  if (role.includes('protagonist')) {\n    tags.push('protagonist');\n  } else if (role.includes('antagonist')) {\n    tags.push('antagonist');\n  } else if (role.includes('supporting')) {\n    tags.push('supporting-character');\n  } else if (role.includes('mentor')) {\n    tags.push('mentor');\n  } else if (role.includes('minor')) {\n    tags.push('minor-character');\n  }\n\n  // Arc status tags\n  if (char.arc?.resolution?.status) {\n    const status = char.arc.resolution.status.toLowerCase();\n    if (status === 'resolved') {\n      tags.push('arc-resolved');\n    } else if (status === 'destroyed') {\n      tags.push('arc-destroyed');\n    } else if (status === 'setup') {\n      tags.push('arc-setup');\n    }\n  }\n\n  return tags;\n}\n\n/**\n * Build the content body for a character note\n */\nfunction buildCharacterContent(char: KBCharacter): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${char.canonical_name}\\n\\n`);\n\n  // Quick reference\n  parts.push(section('Overview'));\n  const overview: string[] = [];\n  overview.push(kvPair('Role', char.role));\n  if (char.age) {\n    overview.push(kvPair('Age', char.age));\n  }\n  if (char.chapters_present) {\n    overview.push(kvPair('Chapters', formatChapters(char.chapters_present)));\n  }\n  if (char.relationship_to_protagonist) {\n    overview.push(kvPair('Relationship', char.relationship_to_protagonist));\n  }\n  parts.push(overview.filter(Boolean).join('\\n') + '\\n\\n');\n\n  // Aliases\n  if (char.aliases && char.aliases.length > 0) {\n    parts.push(section('Aliases', 3));\n    parts.push(char.aliases.map(a => `- ${a}`).join('\\n') + '\\n\\n');\n  }\n\n  // Physical description\n  if (char.physical && Object.keys(char.physical).length > 0) {\n    parts.push(section('Physical Description'));\n    for (const [key, value] of Object.entries(char.physical)) {\n      if (Array.isArray(value)) {\n        parts.push(`**${key}:**\\n`);\n        parts.push(value.map((v: unknown) => `- ${v}`).join('\\n') + '\\n\\n');\n      } else if (value) {\n        parts.push(`- **${key}:** ${value}\\n`);\n      }\n    }\n    parts.push('\\n');\n  }\n\n  // Personality\n  if (char.personality && char.personality.length > 0) {\n    parts.push(section('Personality'));\n    parts.push(char.personality.map(p => `- ${p}`).join('\\n') + '\\n\\n');\n  }\n\n  // Abilities\n  if (char.abilities && Object.keys(char.abilities).length > 0) {\n    parts.push(section('Abilities'));\n    for (const [name, details] of Object.entries(char.abilities)) {\n      if (typeof details === 'object' && details !== null) {\n        const d = details as Record<string, unknown>;\n        parts.push(`### ${name}\\n`);\n        if (d.status) {\n          parts.push(`- **Status:** ${d.status}\\n`);\n        }\n        if (d.notes) {\n          parts.push(`- **Notes:** ${d.notes}\\n`);\n        }\n        parts.push('\\n');\n      } else {\n        parts.push(`- **${name}:** ${details}\\n`);\n      }\n    }\n    parts.push('\\n');\n  }\n\n  // Equipment\n  if (char.equipment && char.equipment.length > 0) {\n    parts.push(section('Equipment'));\n    parts.push(char.equipment.map(e => `- ${wikilink(e)}`).join('\\n') + '\\n\\n');\n  }\n\n  // Coping mechanism\n  if (char.coping_mechanism) {\n    parts.push(section('Coping Mechanism'));\n    const cm = char.coping_mechanism;\n    if (typeof cm === 'object') {\n      for (const [key, value] of Object.entries(cm)) {\n        parts.push(`- **${key}:** ${value}\\n`);\n      }\n    } else {\n      parts.push(`${cm}\\n`);\n    }\n    parts.push('\\n');\n  }\n\n  // Character arc\n  if (char.arc) {\n    parts.push(buildArcSection(char.arc));\n  }\n\n  // Key quote\n  if (char.key_quote) {\n    parts.push(section('Key Quote'));\n    parts.push(blockquote(char.key_quote) + '\\n\\n');\n  }\n\n  // Final words\n  if (char.final_words) {\n    parts.push(section('Final Words'));\n    parts.push(blockquote(char.final_words) + '\\n\\n');\n  }\n\n  // Backstory\n  if (char.backstory && Object.keys(char.backstory).length > 0) {\n    parts.push(section('Backstory'));\n    for (const [key, value] of Object.entries(char.backstory)) {\n      parts.push(`- **${key}:** ${value}\\n`);\n    }\n    parts.push('\\n');\n  }\n\n  // Entry state\n  if (char.entry_state && Object.keys(char.entry_state).length > 0) {\n    parts.push(section('Entry State'));\n    parts.push(formatStateObject(char.entry_state));\n  }\n\n  // Exit state\n  if (char.exit_state && Object.keys(char.exit_state).length > 0) {\n    parts.push(section('Exit State'));\n    parts.push(formatStateObject(char.exit_state));\n  }\n\n  return parts.join('');\n}\n\n/**\n * Build the arc section\n */\nfunction buildArcSection(arc: CharacterArc): string {\n  const parts: string[] = [];\n\n  parts.push(section('Character Arc'));\n  parts.push(`**Type:** ${arc.type}\\n\\n`);\n  parts.push(`${arc.description}\\n\\n`);\n\n  // Key moments\n  if (arc.key_moments && arc.key_moments.length > 0) {\n    parts.push(section('Key Moments', 3));\n    for (const moment of arc.key_moments) {\n      parts.push(`- **Chapter ${moment.chapter} - ${moment.beat}:** ${moment.description}\\n`);\n    }\n    parts.push('\\n');\n  }\n\n  // Resolution\n  if (arc.resolution) {\n    parts.push(section('Resolution', 3));\n    parts.push(`**Status:** ${arc.resolution.status}\\n\\n`);\n    if (arc.resolution.chapter) {\n      parts.push(`**Chapter:** ${arc.resolution.chapter}\\n\\n`);\n    }\n    if (arc.resolution.key_line) {\n      parts.push(blockquote(arc.resolution.key_line) + '\\n\\n');\n    }\n    if (arc.resolution.mechanism) {\n      parts.push(`*${arc.resolution.mechanism}*\\n\\n`);\n    }\n  }\n\n  return parts.join('');\n}\n\n/**\n * Format a state object (entry_state or exit_state)\n */\nfunction formatStateObject(state: Record<string, unknown>): string {\n  const lines: string[] = [];\n\n  for (const [key, value] of Object.entries(state)) {\n    if (value === undefined || value === null) continue;\n\n    if (Array.isArray(value)) {\n      lines.push(`- **${key}:**`);\n      for (const item of value) {\n        lines.push(`  - ${item}`);\n      }\n    } else if (typeof value === 'object') {\n      lines.push(`- **${key}:**`);\n      for (const [k, v] of Object.entries(value as Record<string, unknown>)) {\n        lines.push(`  - ${k}: ${v}`);\n      }\n    } else {\n      lines.push(`- **${key}:** ${value}`);\n    }\n  }\n\n  return lines.join('\\n') + '\\n\\n';\n}\n\n/**\n * Generate character notes from KB data\n */\nexport async function generateCharacters(\n  options: GeneratorOptions\n): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.kbPath || 'unknown',\n      error: `Failed to load KB: ${error}`,\n    });\n    result.summary = 'Failed to load KB data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Process each character\n  for (const char of kb.characters) {\n    const name = char.canonical_name;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate character: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, CHARACTERS_SUBDIR, name);\n      const frontmatter = buildCharacterFrontmatter(char);\n      const content = buildCharacterContent(char);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Characters: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n","/**\n * Chapter Generator\n * Splits a manuscript into individual chapter notes\n */\n\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport type {\n  ChapterGeneratorOptions,\n  GeneratorResult,\n} from './types.js';\nimport {\n  buildNote,\n  writeNoteFile,\n  sanitizeFilename,\n} from './utils.js';\n\nconst CHAPTERS_SUBDIR = 'Chapters';\n\n// Chapter heading patterns\n// Matches: ## Chapter 1, ## Chapter 1: Title, ## Chapter 01, etc.\nconst CHAPTER_REGEX = /^##\\s*Chapter\\s+(\\d+)(?:\\s*[:\\-]\\s*(.+))?$/im;\n\n// Alternative patterns for different manuscript styles\nconst ALT_CHAPTER_PATTERNS = [\n  /^#\\s*Chapter\\s+(\\d+)(?:\\s*[:\\-]\\s*(.+))?$/im,  // Single hash\n  /^###\\s*Chapter\\s+(\\d+)(?:\\s*[:\\-]\\s*(.+))?$/im, // Triple hash\n  /^Chapter\\s+(\\d+)(?:\\s*[:\\-]\\s*(.+))?$/im,       // No hash\n  /^##\\s+(\\d+)\\.?\\s+(.+)$/im,                         // ## 1. Title\n];\n\ninterface ChapterData {\n  number: number;\n  title: string | null;\n  content: string;\n  startLine: number;\n  endLine: number;\n}\n\n/**\n * Parse manuscript content into chapters\n */\nfunction parseChapters(content: string): ChapterData[] {\n  const lines = content.split('\\n');\n  const chapters: ChapterData[] = [];\n  let currentChapter: ChapterData | null = null;\n  let contentLines: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i] ?? '';\n\n    // Try to match chapter heading\n    let match = line.match(CHAPTER_REGEX);\n\n    // Try alternative patterns if primary doesn't match\n    if (!match) {\n      for (const pattern of ALT_CHAPTER_PATTERNS) {\n        match = line.match(pattern);\n        if (match) break;\n      }\n    }\n\n    if (match) {\n      // Save previous chapter\n      if (currentChapter) {\n        currentChapter.content = contentLines.join('\\n').trim();\n        currentChapter.endLine = i - 1;\n        chapters.push(currentChapter);\n      }\n\n      // Start new chapter\n      const chapterNum = parseInt(match[1] ?? '0', 10);\n      const chapterTitle = match[2]?.trim() ?? null;\n\n      currentChapter = {\n        number: chapterNum,\n        title: chapterTitle,\n        content: '',\n        startLine: i,\n        endLine: i,\n      };\n      contentLines = [];\n    } else if (currentChapter) {\n      contentLines.push(line);\n    }\n  }\n\n  // Save last chapter\n  if (currentChapter) {\n    currentChapter.content = contentLines.join('\\n').trim();\n    currentChapter.endLine = lines.length - 1;\n    chapters.push(currentChapter);\n  }\n\n  return chapters;\n}\n\n/**\n * Build frontmatter for a chapter note\n */\nfunction buildChapterFrontmatter(chapter: ChapterData): Record<string, unknown> {\n  return {\n    type: 'scene',\n    title: chapter.title || `Chapter ${chapter.number}`,\n    chapter: chapter.number,\n    scene_order: chapter.number,\n    tags: ['chapter'],\n  };\n}\n\n/**\n * Build the content for a chapter note\n */\nfunction buildChapterContent(chapter: ChapterData): string {\n  const parts: string[] = [];\n\n  // Title\n  const title = chapter.title\n    ? `# Chapter ${chapter.number}: ${chapter.title}`\n    : `# Chapter ${chapter.number}`;\n  parts.push(title + '\\n\\n');\n\n  // Chapter content\n  parts.push(chapter.content);\n\n  return parts.join('');\n}\n\n/**\n * Generate a filename for a chapter\n */\nfunction getChapterFilename(chapter: ChapterData): string {\n  const numStr = chapter.number.toString().padStart(2, '0');\n  if (chapter.title) {\n    const safeTitle = sanitizeFilename(chapter.title);\n    return `Chapter-${numStr}-${safeTitle}`;\n  }\n  return `Chapter-${numStr}`;\n}\n\n/**\n * Generate chapter notes from a manuscript file\n */\nexport async function generateChapters(\n  options: ChapterGeneratorOptions\n): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load manuscript\n  let manuscript: string;\n  try {\n    manuscript = fs.readFileSync(options.manuscriptPath, 'utf-8');\n  } catch (error) {\n    result.errors.push({\n      file: options.manuscriptPath,\n      error: `Failed to read manuscript: ${error}`,\n    });\n    result.summary = 'Failed to read manuscript';\n    return result;\n  }\n\n  // Parse chapters\n  const chapters = parseChapters(manuscript);\n\n  if (chapters.length === 0) {\n    result.summary = 'No chapters found in manuscript';\n    return result;\n  }\n\n  if (options.verbose) {\n    console.log(`Found ${chapters.length} chapters in manuscript`);\n  }\n\n  // Output directory for chapters\n  const chaptersDir = options.chaptersDir || CHAPTERS_SUBDIR;\n\n  // Process each chapter\n  for (const chapter of chapters) {\n    try {\n      const filename = getChapterFilename(chapter);\n      const filePath = path.join(options.outputDir, chaptersDir, `${filename}.md`);\n\n      const frontmatter = buildChapterFrontmatter(chapter);\n      const content = buildChapterContent(chapter);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: `Chapter ${chapter.number}`,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Chapters: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n\n/**\n * Analyze a manuscript and return chapter info without generating files\n */\nexport function analyzeManuscript(manuscriptPath: string): {\n  chapters: Array<{ number: number; title: string | null; lines: number }>;\n  totalLines: number;\n} {\n  const content = fs.readFileSync(manuscriptPath, 'utf-8');\n  const chapters = parseChapters(content);\n  const totalLines = content.split('\\n').length;\n\n  return {\n    chapters: chapters.map(ch => ({\n      number: ch.number,\n      title: ch.title,\n      lines: ch.endLine - ch.startLine + 1,\n    })),\n    totalLines,\n  };\n}\n","/**\n * Location Generator\n * Creates location notes from KB data with realm classification\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  KBLocation,\n  KBData,\n  RealmType,\n} from './types.js';\nimport {\n  parseKBJson,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n  formatChapters,\n  formatList,\n  kvPair,\n} from './utils.js';\nimport { classifyRealm } from './types.js';\n\nconst LOCATIONS_SUBDIR = 'Locations';\n\n/**\n * Build frontmatter for a location note\n */\nfunction buildLocationFrontmatter(loc: KBLocation): Record<string, unknown> {\n  const realm = classifyRealm(loc);\n\n  return {\n    id: loc.id,\n    type: 'location',\n    title: loc.name,\n    location_type: loc.type,\n    realm: realm,\n    tags: buildTags(loc, realm),\n    first_appearance: loc.first_appearance,\n    chapters: formatList(loc.chapters_seen?.map(String)),\n  };\n}\n\n/**\n * Build tags based on location properties\n */\nfunction buildTags(loc: KBLocation, realm: RealmType): string[] {\n  const tags: string[] = ['location'];\n\n  // Realm-based tags\n  switch (realm) {\n    case 'dimensional':\n      tags.push('dimensional');\n      break;\n    case 'real_world':\n      tags.push('real-world');\n      break;\n    case 'liminal':\n      tags.push('liminal');\n      break;\n  }\n\n  // Type-based tags\n  const locType = loc.type.toLowerCase().replace(/[_\\s]+/g, '-');\n  if (locType && !tags.includes(locType)) {\n    tags.push(locType);\n  }\n\n  return tags;\n}\n\n/**\n * Build the content body for a location note\n */\nfunction buildLocationContent(loc: KBLocation): string {\n  const parts: string[] = [];\n  const realm = classifyRealm(loc);\n\n  // Title\n  parts.push(`# ${loc.name}\\n\\n`);\n\n  // Overview section\n  parts.push(section('Overview'));\n  const overview: string[] = [];\n  overview.push(kvPair('Type', loc.type.replace(/_/g, ' ')));\n  overview.push(kvPair('Realm', formatRealmName(realm)));\n  if (loc.first_appearance) {\n    overview.push(kvPair('First Appearance', `Chapter ${loc.first_appearance}`));\n  }\n  if (loc.chapters_seen) {\n    overview.push(kvPair('Chapters', formatChapters(loc.chapters_seen)));\n  }\n  parts.push(overview.filter(Boolean).join('\\n') + '\\n\\n');\n\n  // Description\n  if (loc.description) {\n    parts.push(section('Description'));\n    parts.push(loc.description + '\\n\\n');\n  }\n\n  // Features\n  if (loc.features && loc.features.length > 0) {\n    parts.push(section('Features'));\n    parts.push(loc.features.map(f => `- ${f}`).join('\\n') + '\\n\\n');\n  }\n\n  // Realm-specific sections\n  if (realm === 'dimensional') {\n    parts.push(section('Dimensional Properties'));\n    parts.push('*This location exists in a dimensional space.*\\n\\n');\n    parts.push('- [ ] Portal access documented\\n');\n    parts.push('- [ ] Time dilation effects noted\\n');\n    parts.push('- [ ] Environmental hazards catalogued\\n\\n');\n  }\n\n  // Connections placeholder\n  parts.push(section('Connections'));\n  parts.push('*Characters and events associated with this location:*\\n\\n');\n  parts.push('```dataview\\n');\n  parts.push(`LIST FROM \"\"\\n`);\n  parts.push(`WHERE contains(locations, \"${loc.name}\")\\n`);\n  parts.push('```\\n\\n');\n\n  return parts.join('');\n}\n\n/**\n * Format realm name for display\n */\nfunction formatRealmName(realm: RealmType): string {\n  switch (realm) {\n    case 'real_world':\n      return 'Real World';\n    case 'dimensional':\n      return 'Dimensional';\n    case 'liminal':\n      return 'Liminal Space';\n    case 'unknown':\n      return 'Unknown';\n  }\n}\n\n/**\n * Generate location notes from KB data\n */\nexport async function generateLocations(\n  options: GeneratorOptions\n): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.kbPath || 'unknown',\n      error: `Failed to load KB: ${error}`,\n    });\n    result.summary = 'Failed to load KB data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Process each location\n  for (const loc of kb.locations) {\n    const name = loc.name;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate location: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, LOCATIONS_SUBDIR, name);\n      const frontmatter = buildLocationFrontmatter(loc);\n      const content = buildLocationContent(loc);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Locations: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n","/**\n * Object Generator\n * Creates object/artifact notes from KB data with lock level system\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  KBObject,\n  KBData,\n  LockLevel,\n} from './types.js';\nimport {\n  parseKBJson,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n  wikilink,\n  kvPair,\n} from './utils.js';\nimport { getLockLevel } from './types.js';\n\nconst OBJECTS_SUBDIR = 'Objects';\n\n/**\n * Build frontmatter for an object note\n */\nfunction buildObjectFrontmatter(obj: KBObject): Record<string, unknown> {\n  const lockLevel = getLockLevel(obj);\n\n  return {\n    id: obj.id,\n    type: 'object',\n    title: obj.name,\n    object_type: obj.type,\n    lock_level: lockLevel,\n    locked: obj.locked || false,\n    tags: buildTags(obj, lockLevel),\n    holder: obj.holder || undefined,\n    status: obj.status || undefined,\n  };\n}\n\n/**\n * Build tags based on object properties\n */\nfunction buildTags(obj: KBObject, lockLevel: LockLevel): string[] {\n  const tags: string[] = ['object'];\n\n  // Type-based tags\n  const objType = obj.type.toLowerCase().replace(/[_\\s]+/g, '-');\n  if (objType && !tags.includes(objType)) {\n    tags.push(objType);\n  }\n\n  // Lock level tags\n  if (lockLevel === 'CRITICAL') {\n    tags.push('critical-item');\n  } else if (lockLevel === 'HIGH') {\n    tags.push('important-item');\n  }\n\n  // Locked status\n  if (obj.locked) {\n    tags.push('locked');\n  }\n\n  return tags;\n}\n\n/**\n * Get lock level icon\n */\nfunction getLockIcon(lockLevel: LockLevel): string {\n  switch (lockLevel) {\n    case 'CRITICAL':\n      return '';\n    case 'HIGH':\n      return '';\n    case 'MEDIUM':\n      return '';\n    case 'LOW':\n      return '';\n  }\n}\n\n/**\n * Build the content body for an object note\n */\nfunction buildObjectContent(obj: KBObject): string {\n  const parts: string[] = [];\n  const lockLevel = getLockLevel(obj);\n  const lockIcon = getLockIcon(lockLevel);\n\n  // Title with lock indicator\n  parts.push(`# ${obj.name} ${obj.locked ? lockIcon : ''}\\n\\n`);\n\n  // Overview section\n  parts.push(section('Overview'));\n  const overview: string[] = [];\n  overview.push(kvPair('Type', obj.type.replace(/_/g, ' ')));\n  overview.push(kvPair('Lock Level', `${lockLevel} ${lockIcon}`));\n  if (obj.holder) {\n    overview.push(kvPair('Current Holder', wikilink(obj.holder)));\n  }\n  if (obj.holders && obj.holders.length > 0) {\n    const holderLinks = obj.holders.map(h => wikilink(h)).join(', ');\n    overview.push(kvPair('Holders', holderLinks));\n  }\n  if (obj.status) {\n    overview.push(kvPair('Status', obj.status));\n  }\n  parts.push(overview.filter(Boolean).join('\\n') + '\\n\\n');\n\n  // Description\n  if (obj.description) {\n    parts.push(section('Description'));\n    parts.push(obj.description + '\\n\\n');\n  }\n\n  // Properties\n  if (obj.properties && obj.properties.length > 0) {\n    parts.push(section('Properties'));\n    parts.push(obj.properties.map(p => `- ${p}`).join('\\n') + '\\n\\n');\n  }\n\n  // Significance\n  if (obj.significance) {\n    parts.push(section('Significance'));\n    parts.push(obj.significance + '\\n\\n');\n  }\n\n  // Lock warning for critical items\n  if (lockLevel === 'CRITICAL') {\n    parts.push(section('Continuity Lock', 3));\n    parts.push('>  **This item is locked for continuity.**\\n');\n    parts.push('> Any changes to this item may affect established story elements.\\n\\n');\n  }\n\n  // Connections placeholder\n  parts.push(section('Appearances'));\n  parts.push('*Scenes and events involving this object:*\\n\\n');\n  parts.push('```dataview\\n');\n  parts.push(`LIST FROM \"\"\\n`);\n  parts.push(`WHERE contains(file.outlinks, this.file.link)\\n`);\n  parts.push('```\\n\\n');\n\n  return parts.join('');\n}\n\n/**\n * Generate object notes from KB data\n */\nexport async function generateObjects(\n  options: GeneratorOptions\n): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.kbPath || 'unknown',\n      error: `Failed to load KB: ${error}`,\n    });\n    result.summary = 'Failed to load KB data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Process each object\n  for (const obj of kb.objects) {\n    const name = obj.name;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate object: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, OBJECTS_SUBDIR, name);\n      const frontmatter = buildObjectFrontmatter(obj);\n      const content = buildObjectContent(obj);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Objects: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n","/**\n * Lore Generator\n * Creates world rules and mechanics notes from KB data\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  KBData,\n  KBFact,\n  WorldRulesData,\n  WorldRule,\n} from './types.js';\nimport {\n  parseKBJson,\n  parseWorldRules,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n  blockquote,\n} from './utils.js';\n\nconst LORE_SUBDIR = 'Lore';\n\n/**\n * Build frontmatter for a lore note (world rule)\n */\nfunction buildRuleFrontmatter(rule: WorldRule): Record<string, unknown> {\n  return {\n    id: rule.id,\n    type: 'concept',\n    title: rule.name,\n    category: rule.category,\n    locked: rule.locked || false,\n    tags: buildRuleTags(rule),\n  };\n}\n\n/**\n * Build tags for a world rule\n */\nfunction buildRuleTags(rule: WorldRule): string[] {\n  const tags: string[] = ['lore', 'world-rule'];\n\n  // Category tag\n  const category = rule.category.toLowerCase().replace(/[_\\s]+/g, '-');\n  if (category && !tags.includes(category)) {\n    tags.push(category);\n  }\n\n  // Locked status\n  if (rule.locked) {\n    tags.push('locked');\n  }\n\n  return tags;\n}\n\n/**\n * Build content for a world rule note\n */\nfunction buildRuleContent(rule: WorldRule): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${rule.name}\\n\\n`);\n\n  // Category badge\n  parts.push(`**Category:** ${rule.category}\\n\\n`);\n\n  // Locked indicator\n  if (rule.locked) {\n    parts.push('>  **This rule is locked for continuity.**\\n\\n');\n  }\n\n  // Description\n  parts.push(section('Description'));\n  parts.push(rule.description + '\\n\\n');\n\n  // Examples\n  if (rule.examples && rule.examples.length > 0) {\n    parts.push(section('Examples'));\n    parts.push(rule.examples.map(e => `- ${e}`).join('\\n') + '\\n\\n');\n  }\n\n  // Exceptions\n  if (rule.exceptions && rule.exceptions.length > 0) {\n    parts.push(section('Exceptions'));\n    parts.push(rule.exceptions.map(e => `- ${e}`).join('\\n') + '\\n\\n');\n  }\n\n  // Source\n  if (rule.source) {\n    parts.push(section('Source', 3));\n    parts.push(`*${rule.source}*\\n\\n`);\n  }\n\n  return parts.join('');\n}\n\n/**\n * Build frontmatter for a fact note\n */\nfunction buildFactFrontmatter(fact: KBFact): Record<string, unknown> {\n  return {\n    id: fact.id,\n    type: 'concept',\n    title: extractFactTitle(fact.fact),\n    source: fact.source,\n    locked: fact.locked || false,\n    tags: ['lore', 'fact', fact.locked ? 'locked' : undefined].filter(Boolean),\n  };\n}\n\n/**\n * Extract a short title from a fact\n */\nfunction extractFactTitle(fact: string): string {\n  // Take first 50 chars or up to first period\n  const firstSentence = fact.split('.')[0];\n  if (firstSentence && firstSentence.length <= 60) {\n    return firstSentence;\n  }\n  return fact.slice(0, 50) + '...';\n}\n\n/**\n * Build content for a fact note\n */\nfunction buildFactContent(fact: KBFact): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${extractFactTitle(fact.fact)}\\n\\n`);\n\n  // Locked indicator\n  if (fact.locked) {\n    parts.push('>  **This fact is locked for continuity.**\\n\\n');\n  }\n\n  // The fact\n  parts.push(section('Fact'));\n  parts.push(blockquote(fact.fact) + '\\n\\n');\n\n  // Source\n  parts.push(section('Source', 3));\n  parts.push(`*${fact.source}*\\n\\n`);\n\n  return parts.join('');\n}\n\n/**\n * Generate lore notes from KB and world rules data\n */\nexport async function generateLore(\n  options: GeneratorOptions\n): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Load world rules if available\n  if (options.worldRulesPath) {\n    try {\n      const worldRules = parseWorldRules(options.worldRulesPath);\n      await processWorldRules(worldRules, options, result, tracker);\n    } catch (error) {\n      result.errors.push({\n        file: options.worldRulesPath,\n        error: `Failed to load world rules: ${error}`,\n      });\n    }\n  }\n\n  // Load KB data for facts\n  if (options.kbPath) {\n    try {\n      const kb = parseKBJson(options.kbPath);\n      await processKBFacts(kb, options, result, tracker);\n    } catch (error) {\n      result.errors.push({\n        file: options.kbPath,\n        error: `Failed to load KB: ${error}`,\n      });\n    }\n  }\n\n  if (!options.kbPath && !options.worldRulesPath) {\n    result.summary = 'No KB or world rules path provided';\n    return result;\n  }\n\n  result.summary = `Lore: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n\n/**\n * Process world rules and generate notes\n */\nasync function processWorldRules(\n  worldRules: WorldRulesData,\n  options: GeneratorOptions,\n  result: GeneratorResult,\n  tracker: EntityTracker\n): Promise<void> {\n  const allRules: WorldRule[] = [\n    ...(worldRules.rules || []),\n    ...(worldRules.mechanics || []),\n    ...(worldRules.constraints || []),\n  ];\n\n  for (const rule of allRules) {\n    const name = rule.name;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate rule: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, LORE_SUBDIR, name);\n      const frontmatter = buildRuleFrontmatter(rule);\n      const content = buildRuleContent(rule);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n}\n\n/**\n * Process KB facts and generate notes\n */\nasync function processKBFacts(\n  kb: KBData,\n  options: GeneratorOptions,\n  result: GeneratorResult,\n  tracker: EntityTracker\n): Promise<void> {\n  const facts = kb.facts || [];\n\n  for (const fact of facts) {\n    const name = fact.id;\n\n    // Skip duplicates\n    if (!tracker.add(name)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate fact: ${name}`);\n      }\n      continue;\n    }\n\n    try {\n      const filePath = generateNotePath(options.outputDir, `${LORE_SUBDIR}/Facts`, name);\n      const frontmatter = buildFactFrontmatter(fact);\n      const content = buildFactContent(fact);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: name,\n        error: `${error}`,\n      });\n    }\n  }\n}\n","/**\n * Timeline Generator\n * Creates timeline event notes from KB data\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  KBTimelineEvent,\n  KBData,\n} from './types.js';\nimport {\n  parseKBJson,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n} from './utils.js';\n\nconst TIMELINE_SUBDIR = 'Timeline';\n\n/**\n * Build frontmatter for a timeline event note\n */\nfunction buildEventFrontmatter(event: KBTimelineEvent): Record<string, unknown> {\n  return {\n    id: event.id,\n    type: 'event',\n    title: formatEventTitle(event),\n    chapter: event.chapter,\n    locked: event.locked || false,\n    tags: buildTags(event),\n    timeline_position: `chapter-${event.chapter}`,\n  };\n}\n\n/**\n * Format a title for the event\n */\nfunction formatEventTitle(event: KBTimelineEvent): string {\n  // Create a title from the description\n  const desc = event.description;\n\n  // If short enough, use directly\n  if (desc.length <= 60) {\n    return desc;\n  }\n\n  // Otherwise truncate\n  return desc.slice(0, 57) + '...';\n}\n\n/**\n * Build tags based on event properties\n */\nfunction buildTags(event: KBTimelineEvent): string[] {\n  const tags: string[] = ['event', 'timeline'];\n\n  // Chapter tag\n  tags.push(`chapter-${event.chapter}`);\n\n  // Locked status\n  if (event.locked) {\n    tags.push('locked');\n  }\n\n  // Significance-based tags\n  const sig = event.significance?.toLowerCase() || '';\n  if (sig.includes('critical')) {\n    tags.push('critical-event');\n  }\n\n  return tags;\n}\n\n/**\n * Build the content body for a timeline event note\n */\nfunction buildEventContent(event: KBTimelineEvent): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${event.description}\\n\\n`);\n\n  // Locked indicator\n  if (event.locked) {\n    parts.push('>  **This event is locked for continuity.**\\n\\n');\n  }\n\n  // Event details\n  parts.push(section('Event Details'));\n  parts.push(`**Chapter:** ${event.chapter}\\n\\n`);\n\n  if (event.significance) {\n    parts.push(`**Significance:** ${event.significance}\\n\\n`);\n  }\n\n  // Description (expanded)\n  parts.push(section('Description'));\n  parts.push(event.description + '\\n\\n');\n\n  // Connections placeholder\n  parts.push(section('Related Notes'));\n  parts.push('*Characters, locations, and objects involved in this event:*\\n\\n');\n  parts.push('```dataview\\n');\n  parts.push(`LIST FROM \"\"\\n`);\n  parts.push(`WHERE contains(file.outlinks, this.file.link)\\n`);\n  parts.push('```\\n\\n');\n\n  // Timeline context\n  parts.push(section('Timeline Context'));\n  parts.push('```dataview\\n');\n  parts.push('TABLE chapter as \"Chapter\", description as \"Event\"\\n');\n  parts.push('FROM #timeline\\n');\n  parts.push(`WHERE chapter >= ${Math.max(1, event.chapter - 1)} AND chapter <= ${event.chapter + 1}\\n`);\n  parts.push('SORT chapter ASC\\n');\n  parts.push('```\\n\\n');\n\n  return parts.join('');\n}\n\n/**\n * Generate a filename for a timeline event\n */\nfunction getEventFilename(event: KBTimelineEvent): string {\n  const chapterStr = event.chapter.toString().padStart(2, '0');\n  const eventNum = event.id.replace(/[^0-9]/g, '').padStart(3, '0');\n  return `Event-${chapterStr}-${eventNum}`;\n}\n\n/**\n * Generate timeline event notes from KB data\n */\nexport async function generateTimeline(\n  options: GeneratorOptions\n): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.kbPath || 'unknown',\n      error: `Failed to load KB: ${error}`,\n    });\n    result.summary = 'Failed to load KB data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Sort events by chapter\n  const sortedEvents = [...kb.timeline].sort((a, b) => a.chapter - b.chapter);\n\n  // Process each event\n  for (const event of sortedEvents) {\n    const eventId = event.id;\n\n    // Skip duplicates\n    if (!tracker.add(eventId)) {\n      if (options.verbose) {\n        console.log(`Skipping duplicate event: ${eventId}`);\n      }\n      continue;\n    }\n\n    try {\n      const filename = getEventFilename(event);\n      const filePath = generateNotePath(options.outputDir, TIMELINE_SUBDIR, filename);\n      const frontmatter = buildEventFrontmatter(event);\n      const content = buildEventContent(event);\n      const note = buildNote(frontmatter, content);\n\n      const written = await writeNoteFile(filePath, note, {\n        force: options.force,\n        dryRun: options.dryRun,\n      });\n\n      if (written) {\n        result.created.push(filePath);\n        if (options.verbose) {\n          console.log(`Created: ${filePath}`);\n        }\n      } else {\n        result.skipped.push(filePath);\n        if (options.verbose) {\n          console.log(`Skipped (exists): ${filePath}`);\n        }\n      }\n    } catch (error) {\n      result.errors.push({\n        file: eventId,\n        error: `${error}`,\n      });\n    }\n  }\n\n  result.summary = `Timeline: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n\n/**\n * Generate a timeline index MOC\n */\nexport async function generateTimelineIndex(\n  options: GeneratorOptions\n): Promise<string | null> {\n  // Load KB data\n  let kb: KBData;\n  try {\n    if (!options.kbPath) {\n      throw new Error('KB path is required');\n    }\n    kb = parseKBJson(options.kbPath);\n  } catch {\n    return null;\n  }\n\n  const parts: string[] = [];\n\n  parts.push('# Timeline Index\\n\\n');\n  parts.push('A chronological view of events.\\n\\n');\n\n  // Group events by chapter\n  const eventsByChapter = new Map<number, KBTimelineEvent[]>();\n  for (const event of kb.timeline) {\n    const chapter = event.chapter;\n    if (!eventsByChapter.has(chapter)) {\n      eventsByChapter.set(chapter, []);\n    }\n    eventsByChapter.get(chapter)!.push(event);\n  }\n\n  // Sort chapters\n  const sortedChapters = Array.from(eventsByChapter.keys()).sort((a, b) => a - b);\n\n  for (const chapter of sortedChapters) {\n    const events = eventsByChapter.get(chapter)!;\n    parts.push(`## Chapter ${chapter}\\n\\n`);\n\n    for (const event of events) {\n      const lockIcon = event.locked ? ' ' : '';\n      parts.push(`- ${event.description}${lockIcon}\\n`);\n    }\n    parts.push('\\n');\n  }\n\n  return parts.join('');\n}\n","/**\n * Arc Generator\n * Converts arc-ledger data into plot structure notes\n */\n\nimport type {\n  GeneratorOptions,\n  GeneratorResult,\n  ArcLedger,\n  ArcLedgerThread,\n  ArcLedgerCharacter,\n} from './types.js';\nimport {\n  parseArcLedger,\n  buildNote,\n  generateNotePath,\n  writeNoteFile,\n  EntityTracker,\n  section,\n  wikilink,\n  formatChapters,\n} from './utils.js';\n\nconst ARCS_SUBDIR = 'Arcs';\n\n/**\n * Build frontmatter for a plot thread note\n */\nfunction buildThreadFrontmatter(thread: ArcLedgerThread): Record<string, unknown> {\n  return {\n    id: thread.thread_id,\n    type: 'concept',\n    title: thread.name,\n    thread_type: thread.type,\n    status: thread.status,\n    tags: buildThreadTags(thread),\n    chapters: thread.chapters_touched,\n    resolution_chapter: thread.resolution_chapter,\n  };\n}\n\n/**\n * Build tags for a plot thread\n */\nfunction buildThreadTags(thread: ArcLedgerThread): string[] {\n  const tags: string[] = ['arc', 'plot-thread'];\n\n  // Type tag\n  const threadType = thread.type.toLowerCase().replace(/[_\\s]+/g, '-');\n  if (threadType && !tags.includes(threadType)) {\n    tags.push(threadType);\n  }\n\n  // Status tag\n  const status = thread.status.toLowerCase();\n  tags.push(`status-${status}`);\n\n  return tags;\n}\n\n/**\n * Build content for a plot thread note\n */\nfunction buildThreadContent(thread: ArcLedgerThread): string {\n  const parts: string[] = [];\n\n  // Title\n  parts.push(`# ${thread.name}\\n\\n`);\n\n  // Status banner\n  const statusIcon = getStatusIcon(thread.status);\n  parts.push(`> ${statusIcon} **Status:** ${thread.status.toUpperCase()}\\n\\n`);\n\n  // Overview\n  parts.push(section('Overview'));\n  parts.push(`**Type:** ${thread.type.replace(/_/g, ' ')}\\n\\n`);\n\n  if (thread.description) {\n    parts.push(thread.description + '\\n\\n');\n  }\n\n  // Chapters\n  if (thread.chapters_touched && thread.chapters_touched.length > 0) {\n    parts.push(section('Chapters'));\n    parts.push(`**Chapters Touched:** ${formatChapters(thread.chapters_touched)}\\n\\n`);\n  }\n\n  // Resolution\n  if (thread.resolution_chapter || thread.resolution_description) {\n    parts.push(section('Resolution'));\n    if (thread.resolution_chapter) {\n      parts.push(`**Chapter:** ${thread.resolution_chapter}\\n\\n`);\n    }\n    if (thread.resolution_description) {\n      parts.push(thread.resolution_description + '\\n\\n');\n    }\n  }\n\n  // Expected resolution (for unresolved threads)\n  if (thread.expected_resolution && thread.status !== 'resolved') {\n    parts.push(section('Expected Resolution'));\n    parts.push(`*Expected in: ${thread.expected_resolution}*\\n\\n`);\n  }\n\n  // Related content\n  parts.push(section('Related Notes'));\n  parts.push('```dataview\\n');\n  parts.push('LIST FROM #arc\\n');\n  parts.push(`WHERE contains(file.outlinks, this.file.link) OR contains(tags, \"${thread.thread_id}\")\\n`);\n  parts.push('```\\n\\n');\n\n  return parts.join('');\n}\n\n/**\n * Build frontmatter for a character arc note\n */\nfunction buildCharacterArcFrontmatter(char: ArcLedgerCharacter): Record<string, unknown> {\n  const arc = char.arc;\n  return {\n    id: `arc-${char.character_id}`,\n    type: 'concept',\n    title: `${char.canonical_name}'s Arc`,\n    character: char.canonical_name,\n    arc_type: arc?.type,\n    status: arc?.resolution?.status || 'in_progress',\n    tags: ['arc', 'character-arc', `character-${char.character_id.replace(/_/g, '-')}`],\n    resolution_chapter: arc?.resolution?.chapter,\n  };\n}\n\n/**\n * Build content for a character arc note\n */\nfunction buildCharacterArcContent(char: ArcLedgerCharacter): string {\n  const parts: string[] = [];\n  const arc = char.arc;\n\n  // Title\n  parts.push(`# ${char.canonical_name}'s Arc\\n\\n`);\n\n  // Link to character\n  parts.push(`**Character:** ${wikilink(char.canonical_name)}\\n\\n`);\n\n  // Arc type and description\n  if (arc) {\n    parts.push(section('Arc Overview'));\n    parts.push(`**Type:** ${arc.type.replace(/_/g, ' ')}\\n\\n`);\n    if (arc.description) {\n      parts.push(arc.description + '\\n\\n');\n    }\n  }\n\n  // Entry state\n  if (char.entry_state && Object.keys(char.entry_state).length > 0) {\n    parts.push(section('Entry State'));\n    parts.push(formatStateForArc(char.entry_state));\n  }\n\n  // Key moments\n  if (arc?.key_moments && arc.key_moments.length > 0) {\n    parts.push(section('Key Moments'));\n    for (const moment of arc.key_moments) {\n      parts.push(`### Chapter ${moment.chapter}: ${moment.beat.replace(/_/g, ' ')}\\n`);\n      parts.push(`${moment.description}\\n\\n`);\n    }\n  }\n\n  // Resolution\n  if (arc?.resolution) {\n    parts.push(section('Resolution'));\n    const res = arc.resolution;\n    const statusIcon = getStatusIcon(res.status);\n    parts.push(`${statusIcon} **Status:** ${res.status}\\n\\n`);\n    if (res.chapter) {\n      parts.push(`**Chapter:** ${res.chapter}\\n\\n`);\n    }\n    if (res.key_line) {\n      parts.push(`> \"${res.key_line}\"\\n\\n`);\n    }\n    if (res.mechanism) {\n      parts.push(`*${res.mechanism}*\\n\\n`);\n    }\n  }\n\n  // Exit state\n  if (char.exit_state && Object.keys(char.exit_state).length > 0) {\n    parts.push(section('Exit State'));\n    parts.push(formatStateForArc(char.exit_state));\n  }\n\n  return parts.join('');\n}\n\n/**\n * Format a state object for arc display\n */\nfunction formatStateForArc(state: Record<string, unknown>): string {\n  const lines: string[] = [];\n\n  for (const [key, value] of Object.entries(state)) {\n    if (value === undefined || value === null) continue;\n    if (key === 'locked' || key === 'lock_reference' || key === 'source') continue;\n\n    if (Array.isArray(value)) {\n      lines.push(`**${key}:**`);\n      for (const item of value) {\n        lines.push(`- ${item}`);\n      }\n    } else {\n      lines.push(`**${key}:** ${value}`);\n    }\n  }\n\n  return lines.join('\\n') + '\\n\\n';\n}\n\n/**\n * Get status icon\n */\nfunction getStatusIcon(status: string): string {\n  const s = status.toLowerCase();\n  if (s === 'resolved' || s === 'compliant' || s === 'fulfilled') {\n    return '';\n  }\n  if (s === 'destroyed') {\n    return '';\n  }\n  if (s === 'setup' || s === 'unresolved') {\n    return '';\n  }\n  if (s === 'in_progress') {\n    return '';\n  }\n  return '';\n}\n\n/**\n * Generate arc notes from arc-ledger data\n */\nexport async function generateArcs(\n  options: GeneratorOptions\n): Promise<GeneratorResult> {\n  const result: GeneratorResult = {\n    created: [],\n    skipped: [],\n    errors: [],\n    summary: '',\n  };\n\n  // Load arc ledger\n  let arcLedger: ArcLedger;\n  try {\n    if (!options.arcLedgerPath) {\n      throw new Error('Arc ledger path is required');\n    }\n    arcLedger = parseArcLedger(options.arcLedgerPath);\n  } catch (error) {\n    result.errors.push({\n      file: options.arcLedgerPath || 'unknown',\n      error: `Failed to load arc ledger: ${error}`,\n    });\n    result.summary = 'Failed to load arc ledger data';\n    return result;\n  }\n\n  // Track entities to avoid duplicates\n  const tracker = new EntityTracker();\n\n  // Process plot threads\n  if (arcLedger.threads) {\n    for (const thread of arcLedger.threads) {\n      const name = thread.name;\n\n      if (!tracker.add(name)) {\n        if (options.verbose) {\n          console.log(`Skipping duplicate thread: ${name}`);\n        }\n        continue;\n      }\n\n      try {\n        const filePath = generateNotePath(options.outputDir, `${ARCS_SUBDIR}/Threads`, name);\n        const frontmatter = buildThreadFrontmatter(thread);\n        const content = buildThreadContent(thread);\n        const note = buildNote(frontmatter, content);\n\n        const written = await writeNoteFile(filePath, note, {\n          force: options.force,\n          dryRun: options.dryRun,\n        });\n\n        if (written) {\n          result.created.push(filePath);\n          if (options.verbose) {\n            console.log(`Created: ${filePath}`);\n          }\n        } else {\n          result.skipped.push(filePath);\n          if (options.verbose) {\n            console.log(`Skipped (exists): ${filePath}`);\n          }\n        }\n      } catch (error) {\n        result.errors.push({\n          file: name,\n          error: `${error}`,\n        });\n      }\n    }\n  }\n\n  // Process character arcs\n  if (arcLedger.characters) {\n    for (const char of arcLedger.characters) {\n      // Only process characters with arcs\n      if (!char.arc) continue;\n\n      const arcName = `${char.canonical_name}'s Arc`;\n\n      if (!tracker.add(arcName)) {\n        if (options.verbose) {\n          console.log(`Skipping duplicate character arc: ${arcName}`);\n        }\n        continue;\n      }\n\n      try {\n        const filePath = generateNotePath(options.outputDir, `${ARCS_SUBDIR}/Characters`, arcName);\n        const frontmatter = buildCharacterArcFrontmatter(char);\n        const content = buildCharacterArcContent(char);\n        const note = buildNote(frontmatter, content);\n\n        const written = await writeNoteFile(filePath, note, {\n          force: options.force,\n          dryRun: options.dryRun,\n        });\n\n        if (written) {\n          result.created.push(filePath);\n          if (options.verbose) {\n            console.log(`Created: ${filePath}`);\n          }\n        } else {\n          result.skipped.push(filePath);\n          if (options.verbose) {\n            console.log(`Skipped (exists): ${filePath}`);\n          }\n        }\n      } catch (error) {\n        result.errors.push({\n          file: arcName,\n          error: `${error}`,\n        });\n      }\n    }\n  }\n\n  result.summary = `Arcs: ${result.created.length} created, ${result.skipped.length} skipped, ${result.errors.length} errors`;\n  return result;\n}\n","/**\n * Link Injection\n * Post-processor that adds wikilinks to notes based on entity names\n * Carefully avoids frontmatter, code blocks, existing links, and headers\n */\n\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport type { InjectLinksOptions, InjectLinksResult, KBData } from './types.js';\nimport { parseKBJson } from './utils.js';\n\n// ============================================================================\n// Simple Glob Implementation\n// ============================================================================\n\ninterface GlobOptions {\n  ignore?: string[];\n}\n\n/**\n * Simple glob pattern matching for file discovery\n */\nasync function glob(basePath: string, pattern: string, options: GlobOptions = {}): Promise<string[]> {\n  const results: string[] = [];\n  const ignore = options.ignore || [];\n\n  // Convert glob pattern to regex\n  // Handle **/*.md to match both root files and nested files\n  let regexPattern = pattern\n    .replace(/\\*\\*/g, '{{GLOBSTAR}}')\n    .replace(/\\*/g, '[^/]*')\n    .replace(/\\?/g, '.')\n    .replace(/{{GLOBSTAR}}\\//g, '(?:.*\\\\/)?')  // **/ matches zero or more dirs\n    .replace(/{{GLOBSTAR}}/g, '.*');\n  const regex = new RegExp(`^${regexPattern}$`);\n\n  async function walk(dir: string): Promise<void> {\n    let entries;\n    try {\n      entries = await fs.promises.readdir(dir, { withFileTypes: true });\n    } catch {\n      return;\n    }\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      const relativePath = path.relative(basePath, fullPath).replace(/\\\\/g, '/');\n\n      // Check ignore patterns\n      let shouldIgnore = false;\n      for (const ignorePattern of ignore) {\n        const ignoreRegex = ignorePattern\n          .replace(/\\*\\*/g, '{{GLOBSTAR}}')\n          .replace(/\\*/g, '[^/]*')\n          .replace(/{{GLOBSTAR}}/g, '.*');\n        if (new RegExp(`^${ignoreRegex}$`).test(relativePath)) {\n          shouldIgnore = true;\n          break;\n        }\n      }\n\n      if (shouldIgnore) continue;\n\n      if (entry.isDirectory()) {\n        await walk(fullPath);\n      } else if (entry.isFile()) {\n        if (regex.test(relativePath)) {\n          results.push(fullPath);\n        }\n      }\n    }\n  }\n\n  await walk(basePath);\n  return results;\n}\n\n// ============================================================================\n// Protected Regions\n// ============================================================================\n\n// Regions to avoid when injecting links\ninterface ProtectedRegion {\n  start: number;\n  end: number;\n  type: 'frontmatter' | 'code_block' | 'inline_code' | 'existing_link' | 'header';\n}\n\n/**\n * Find all protected regions in a document where we shouldn't inject links\n */\nfunction findProtectedRegions(content: string): ProtectedRegion[] {\n  const regions: ProtectedRegion[] = [];\n\n  // Frontmatter (must be at start of document)\n  const frontmatterMatch = content.match(/^---\\r?\\n[\\s\\S]*?\\r?\\n---\\r?\\n?/);\n  if (frontmatterMatch) {\n    regions.push({\n      start: 0,\n      end: frontmatterMatch[0].length,\n      type: 'frontmatter',\n    });\n  }\n\n  // Code blocks (fenced with ``` or ~~~)\n  const codeBlockRegex = /```[\\s\\S]*?```|~~~[\\s\\S]*?~~~/g;\n  let match;\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'code_block',\n    });\n  }\n\n  // Inline code\n  const inlineCodeRegex = /`[^`\\n]+`/g;\n  while ((match = inlineCodeRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'inline_code',\n    });\n  }\n\n  // Existing wikilinks\n  const wikilinkRegex = /\\[\\[[^\\]]+\\]\\]/g;\n  while ((match = wikilinkRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'existing_link',\n    });\n  }\n\n  // Markdown links\n  const markdownLinkRegex = /\\[([^\\]]+)\\]\\([^)]+\\)/g;\n  while ((match = markdownLinkRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'existing_link',\n    });\n  }\n\n  // Headers (don't link inside headers)\n  const headerRegex = /^#{1,6}\\s+.+$/gm;\n  while ((match = headerRegex.exec(content)) !== null) {\n    regions.push({\n      start: match.index,\n      end: match.index + match[0].length,\n      type: 'header',\n    });\n  }\n\n  return regions.sort((a, b) => a.start - b.start);\n}\n\n/**\n * Check if a position is within any protected region\n */\nfunction isProtected(position: number, length: number, regions: ProtectedRegion[]): boolean {\n  const end = position + length;\n  for (const region of regions) {\n    // Check if our range overlaps with the protected region\n    if (position < region.end && end > region.start) {\n      return true;\n    }\n    // Early exit if we've passed all relevant regions\n    if (region.start > end) {\n      break;\n    }\n  }\n  return false;\n}\n\n/**\n * Create a case-insensitive regex for an entity name\n * Handles word boundaries properly\n */\nfunction createEntityRegex(name: string): RegExp {\n  // Escape special regex characters\n  const escaped = name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Match whole words only, case insensitive\n  return new RegExp(`\\\\b(${escaped})\\\\b`, 'gi');\n}\n\ninterface Replacement {\n  start: number;\n  end: number;\n  original: string;\n  replacement: string;\n}\n\n/**\n * Find all positions where an entity should be linked\n */\nfunction findEntityMatches(\n  content: string,\n  entityName: string,\n  protectedRegions: ProtectedRegion[]\n): Replacement[] {\n  const replacements: Replacement[] = [];\n  const regex = createEntityRegex(entityName);\n  let match;\n\n  while ((match = regex.exec(content)) !== null) {\n    const start = match.index;\n    const original = match[0];\n    const length = original.length;\n\n    // Skip if in protected region\n    if (isProtected(start, length, protectedRegions)) {\n      continue;\n    }\n\n    replacements.push({\n      start,\n      end: start + length,\n      original,\n      replacement: `[[${entityName}|${original}]]`,\n    });\n  }\n\n  return replacements;\n}\n\n/**\n * Apply replacements to content, working from end to start to maintain positions\n */\nfunction applyReplacements(content: string, replacements: Replacement[]): string {\n  // Sort by position descending so we can replace from end to start\n  const sorted = [...replacements].sort((a, b) => b.start - a.start);\n\n  let result = content;\n  for (const rep of sorted) {\n    result = result.slice(0, rep.start) + rep.replacement + result.slice(rep.end);\n  }\n\n  return result;\n}\n\n/**\n * Inject wikilinks into a single file\n */\nfunction injectLinksInFile(\n  content: string,\n  entities: Map<string, string[]> // canonical name -> aliases\n): { content: string; linksInjected: number } {\n  const protectedRegions = findProtectedRegions(content);\n  const allReplacements: Replacement[] = [];\n  const linkedPositions = new Set<string>(); // Track positions we've already linked\n\n  // Process each entity and its aliases\n  for (const [canonical, aliases] of entities) {\n    // Process canonical name first\n    const canonicalMatches = findEntityMatches(content, canonical, protectedRegions);\n    for (const match of canonicalMatches) {\n      const posKey = `${match.start}-${match.end}`;\n      if (!linkedPositions.has(posKey)) {\n        // For canonical name, use simple link\n        match.replacement = `[[${canonical}]]`;\n        allReplacements.push(match);\n        linkedPositions.add(posKey);\n      }\n    }\n\n    // Process aliases\n    for (const alias of aliases) {\n      if (alias.toLowerCase() === canonical.toLowerCase()) continue;\n\n      const aliasMatches = findEntityMatches(content, alias, protectedRegions);\n      for (const match of aliasMatches) {\n        const posKey = `${match.start}-${match.end}`;\n        if (!linkedPositions.has(posKey)) {\n          // Check if this position overlaps with any existing replacement\n          const overlaps = allReplacements.some(\n            r => (match.start < r.end && match.end > r.start)\n          );\n          if (!overlaps) {\n            // For alias, link to canonical with display text\n            match.replacement = `[[${canonical}|${match.original}]]`;\n            allReplacements.push(match);\n            linkedPositions.add(posKey);\n          }\n        }\n      }\n    }\n  }\n\n  // Remove overlapping replacements (keep first occurrence)\n  const nonOverlapping = removeOverlaps(allReplacements);\n\n  const newContent = applyReplacements(content, nonOverlapping);\n  return {\n    content: newContent,\n    linksInjected: nonOverlapping.length,\n  };\n}\n\n/**\n * Remove overlapping replacements, keeping the first one found\n */\nfunction removeOverlaps(replacements: Replacement[]): Replacement[] {\n  if (replacements.length <= 1) return replacements;\n\n  // Sort by start position\n  const sorted = [...replacements].sort((a, b) => a.start - b.start);\n  const first = sorted[0];\n  if (!first) return [];\n\n  const result: Replacement[] = [first];\n\n  for (let i = 1; i < sorted.length; i++) {\n    const current = sorted[i];\n    const last = result[result.length - 1];\n\n    // If current doesn't overlap with last kept replacement, keep it\n    if (current && last && current.start >= last.end) {\n      result.push(current);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Build entity map from KB data\n */\nfunction buildEntityMap(kb: KBData): Map<string, string[]> {\n  const entities = new Map<string, string[]>();\n\n  // Add characters\n  for (const char of kb.characters) {\n    entities.set(char.canonical_name, char.aliases || []);\n  }\n\n  // Add locations\n  for (const loc of kb.locations) {\n    entities.set(loc.name, []);\n  }\n\n  // Add objects\n  for (const obj of kb.objects) {\n    entities.set(obj.name, []);\n  }\n\n  // Add name normalization if available\n  if (kb.name_normalization) {\n    for (const norm of kb.name_normalization) {\n      if (entities.has(norm.canonical)) {\n        const existing = entities.get(norm.canonical)!;\n        const combined = [...new Set([...existing, ...norm.variants])];\n        entities.set(norm.canonical, combined);\n      } else {\n        entities.set(norm.canonical, norm.variants);\n      }\n    }\n  }\n\n  return entities;\n}\n\n/**\n * Inject wikilinks into all matching files in a vault\n */\nexport async function injectLinks(\n  options: InjectLinksOptions\n): Promise<InjectLinksResult> {\n  const result: InjectLinksResult = {\n    modified: [],\n    linksInjected: 0,\n    skipped: [],\n    errors: [],\n  };\n\n  // Build entity map\n  let entities: Map<string, string[]>;\n\n  if (options.entities) {\n    // Use provided entity list\n    entities = new Map();\n    for (const entity of options.entities) {\n      entities.set(entity, []);\n    }\n  } else {\n    // Try to find KB file\n    const kbPaths = [\n      path.join(options.vaultPath, '.narrative-project', 'kb', 'kb.json'),\n      path.join(options.vaultPath, 'kb', 'kb.json'),\n      path.join(options.vaultPath, 'kb.json'),\n    ];\n\n    let kbPath: string | null = null;\n    for (const p of kbPaths) {\n      if (fs.existsSync(p)) {\n        kbPath = p;\n        break;\n      }\n    }\n\n    if (kbPath) {\n      try {\n        const kb = parseKBJson(kbPath);\n        entities = buildEntityMap(kb);\n      } catch (error) {\n        result.errors.push({\n          file: kbPath,\n          error: `Failed to load KB: ${error}`,\n        });\n        return result;\n      }\n    } else {\n      result.errors.push({\n        file: options.vaultPath,\n        error: 'No entity list provided and no KB file found',\n      });\n      return result;\n    }\n  }\n\n  if (entities.size === 0) {\n    return result;\n  }\n\n  // Find files to process\n  const pattern = options.pattern || '**/*.md';\n  const files = await glob(options.vaultPath, pattern, {\n    ignore: ['**/node_modules/**', '**/.git/**', '**/.zettelscript/**'],\n  });\n\n  // Process each file\n  for (const file of files) {\n    try {\n      const content = fs.readFileSync(file, 'utf-8');\n      const { content: newContent, linksInjected } = injectLinksInFile(content, entities);\n\n      if (linksInjected > 0) {\n        if (options.dryRun) {\n          console.log(`[DRY RUN] Would modify: ${file} (+${linksInjected} links)`);\n          result.modified.push(file);\n          result.linksInjected += linksInjected;\n        } else {\n          await fs.promises.writeFile(file, newContent, 'utf-8');\n          result.modified.push(file);\n          result.linksInjected += linksInjected;\n          if (options.verbose) {\n            console.log(`Modified: ${file} (+${linksInjected} links)`);\n          }\n        }\n      } else {\n        result.skipped.push(file);\n      }\n    } catch (error) {\n      result.errors.push({\n        file,\n        error: `${error}`,\n      });\n    }\n  }\n\n  return result;\n}\n\n/**\n * Preview link injection without modifying files\n */\nexport async function previewLinkInjection(\n  options: InjectLinksOptions\n): Promise<Map<string, Array<{ original: string; linked: string; position: number }>>> {\n  const previews = new Map<string, Array<{ original: string; linked: string; position: number }>>();\n\n  // Build entity map (same logic as injectLinks)\n  let entities: Map<string, string[]>;\n\n  if (options.entities) {\n    entities = new Map();\n    for (const entity of options.entities) {\n      entities.set(entity, []);\n    }\n  } else {\n    const kbPaths = [\n      path.join(options.vaultPath, '.narrative-project', 'kb', 'kb.json'),\n      path.join(options.vaultPath, 'kb', 'kb.json'),\n      path.join(options.vaultPath, 'kb.json'),\n    ];\n\n    let kbPath: string | null = null;\n    for (const p of kbPaths) {\n      if (fs.existsSync(p)) {\n        kbPath = p;\n        break;\n      }\n    }\n\n    if (kbPath) {\n      const kb = parseKBJson(kbPath);\n      entities = buildEntityMap(kb);\n    } else {\n      return previews;\n    }\n  }\n\n  // Find files\n  const pattern = options.pattern || '**/*.md';\n  const files = await glob(options.vaultPath, pattern, {\n    ignore: ['**/node_modules/**', '**/.git/**', '**/.zettelscript/**'],\n  });\n\n  // Collect preview info for each file\n  for (const file of files) {\n    const content = fs.readFileSync(file, 'utf-8');\n    const protectedRegions = findProtectedRegions(content);\n    const filePreview: Array<{ original: string; linked: string; position: number }> = [];\n\n    for (const [canonical, aliases] of entities) {\n      const allNames = [canonical, ...aliases];\n      for (const name of allNames) {\n        const matches = findEntityMatches(content, name, protectedRegions);\n        for (const match of matches) {\n          const linked = name.toLowerCase() === canonical.toLowerCase()\n            ? `[[${canonical}]]`\n            : `[[${canonical}|${match.original}]]`;\n          filePreview.push({\n            original: match.original,\n            linked,\n            position: match.start,\n          });\n        }\n      }\n    }\n\n    if (filePreview.length > 0) {\n      previews.set(file, filePreview.sort((a, b) => a.position - b.position));\n    }\n  }\n\n  return previews;\n}\n","import { Command } from 'commander';\nimport * as path from 'node:path';\nimport { findVaultRoot, Spinner } from '../utils.js';\nimport { injectLinks, previewLinkInjection, type InjectLinksOptions } from '../../generators/index.js';\n\nexport const injectLinksCommand = new Command('inject-links')\n  .description('Add wikilinks to notes based on entity names from KB')\n  .option('-p, --path <dir>', 'Vault path (default: current vault)')\n  .option('-g, --pattern <glob>', 'File pattern to process (default: **/*.md)')\n  .option('-e, --entities <names...>', 'Specific entity names to link')\n  .option('-n, --dry-run', 'Show changes without modifying files')\n  .option('--preview', 'Show detailed preview of all changes')\n  .option('-v, --verbose', 'Show detailed output')\n  .addHelpText('after', `\nExamples:\n  zettel inject-links                    # Process all .md files using KB entities\n  zettel inject-links -n                 # Dry run to see what would change\n  zettel inject-links --preview          # Show detailed preview of all changes\n  zettel inject-links -e \"Ryan\" \"Kevin\"  # Only link specific entities\n  zettel inject-links -g \"Chapters/*.md\" # Only process chapter files\n`)\n  .action(async (options) => {\n    try {\n      // Resolve vault path\n      const vaultPath = options.path\n        ? path.resolve(options.path)\n        : findVaultRoot() || process.cwd();\n\n      const opts: InjectLinksOptions = {\n        vaultPath,\n        pattern: options.pattern,\n        entities: options.entities,\n        dryRun: options.dryRun || options.preview,\n        verbose: options.verbose,\n      };\n\n      // Preview mode shows detailed changes\n      if (options.preview) {\n        console.log('Previewing link injection...\\n');\n\n        const previews = await previewLinkInjection(opts);\n\n        if (previews.size === 0) {\n          console.log('No links to inject.');\n          return;\n        }\n\n        for (const [file, changes] of previews) {\n          const relativePath = path.relative(vaultPath, file);\n          console.log(`\\n${relativePath} (${changes.length} links):`);\n\n          for (const change of changes.slice(0, 10)) {\n            console.log(`  ${change.original}  ${change.linked}`);\n          }\n\n          if (changes.length > 10) {\n            console.log(`  ... and ${changes.length - 10} more`);\n          }\n        }\n\n        console.log(`\\nTotal: ${previews.size} files, ${Array.from(previews.values()).reduce((sum, c) => sum + c.length, 0)} links`);\n        console.log('\\nRun without --preview to apply changes.');\n        return;\n      }\n\n      // Normal operation\n      const spinner = new Spinner('Injecting links...');\n      spinner.start();\n\n      const result = await injectLinks(opts);\n\n      spinner.stop();\n\n      // Print results\n      if (opts.dryRun) {\n        console.log('\\n[DRY RUN] Would modify:');\n      } else {\n        console.log('\\nLink injection complete:');\n      }\n\n      console.log(`  Files modified: ${result.modified.length}`);\n      console.log(`  Links injected: ${result.linksInjected}`);\n      console.log(`  Files skipped:  ${result.skipped.length}`);\n\n      if (result.errors.length > 0) {\n        console.log(`\\nErrors (${result.errors.length}):`);\n        for (const err of result.errors.slice(0, 5)) {\n          console.log(`  ${err.file}: ${err.error}`);\n        }\n        if (result.errors.length > 5) {\n          console.log(`  ... and ${result.errors.length - 5} more`);\n        }\n      }\n\n      if (opts.verbose && result.modified.length > 0) {\n        console.log('\\nModified files:');\n        for (const file of result.modified) {\n          const relativePath = path.relative(vaultPath, file);\n          console.log(`  ${relativePath}`);\n        }\n      }\n    } catch (error) {\n      console.error(`Error: ${error}`);\n      process.exit(1);\n    }\n  });\n"],"mappings":"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","names":["Command","fs","path","stringifyYaml","fs","path","parseYaml","stringifyYaml","path","text","eq","and","inArray","sql","nanoid","nanoid","eq","and","inArray","sql","eq","and","sql","nanoid","nanoid","eq","and","sql","eq","sql","inArray","nanoid","nanoid","eq","inArray","sql","eq","and","sql","nanoid","nanoid","eq","and","sql","aliases","text","edges","wikilink","path","path","edges","nodes","parseYaml","stringifyYaml","Command","fs","path","Command","path","Command","EventEmitter","path","DEFAULT_EXTENSIONS","DEFAULT_EXCLUDE","EventEmitter","Command","edges","Command","Command","nodes","path","Command","nodes","edges","Type","nodes","edges","Command","Command","fs","path","nodes","aliases","text","resolve","Command","nodes","path","Command","edges","chunks","nodes","Command","Command","fs","path","nodes","Command","nodes","Command","fs","path","text","chunks","nanoid","stringifyYaml","Command","Command","path","desc","fs","path","stringifyYaml","text","fs","path","buildTags","buildTags","buildTags","desc","fs","path","aliases","Command","Command","path","Command","Command"]}